/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./style.css":
/*!*********************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./style.css ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `body {\r\n  display: flex;\r\n  margin: 0;\r\n  padding: 20px;\r\n  height: 100vh;\r\n  box-sizing: border-box;\r\n  font-family: Arial, sans-serif;\r\n}\r\n.editor-area {\r\n  flex: 2;\r\n  display: flex;\r\n  flex-direction: column;\r\n  margin-right: 20px;\r\n}\r\n#editor {\r\n  flex-grow: 1;\r\n  min-height: 400px;\r\n}\r\n#insertBtn {\r\n  margin-bottom: 10px;\r\n  padding: 8px 12px;\r\n}\r\n.templates-panel {\r\n  flex: 1;\r\n  display: flex;\r\n  flex-direction: column;\r\n  border: 1px solid #ccc;\r\n  padding: 10px;\r\n  max-width: 300px;\r\n}\r\n#templatesList {\r\n  list-style: none;\r\n  padding: 0;\r\n  margin: 0 0 10px 0;\r\n  flex-grow: 1;\r\n  overflow-y: auto;\r\n  border: 1px solid #ddd;\r\n}\r\n#templatesList li {\r\n  padding: 5px 10px;\r\n  cursor: pointer;\r\n}\r\n#templatesList li.selected {\r\n  background-color: #007acc;\r\n  color: white;\r\n}\r\n#addTemplateBtn,\r\n#removeTemplateBtn {\r\n  padding: 5px 10px;\r\n  margin-right: 5px;\r\n}\r\n#editTemplateInput {\r\n  margin-top: 10px;\r\n  padding: 6px 10px;\r\n  font-size: 14px;\r\n}\r\n.buttons-row {\r\n  margin-bottom: 10px;\r\n}\r\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://test/./style.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("{\r\n\r\n/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function (cssWithMappingToString) {\r\n  var list = [];\r\n\r\n  // return the list of modules as css string\r\n  list.toString = function toString() {\r\n    return this.map(function (item) {\r\n      var content = \"\";\r\n      var needLayer = typeof item[5] !== \"undefined\";\r\n      if (item[4]) {\r\n        content += \"@supports (\".concat(item[4], \") {\");\r\n      }\r\n      if (item[2]) {\r\n        content += \"@media \".concat(item[2], \" {\");\r\n      }\r\n      if (needLayer) {\r\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\r\n      }\r\n      content += cssWithMappingToString(item);\r\n      if (needLayer) {\r\n        content += \"}\";\r\n      }\r\n      if (item[2]) {\r\n        content += \"}\";\r\n      }\r\n      if (item[4]) {\r\n        content += \"}\";\r\n      }\r\n      return content;\r\n    }).join(\"\");\r\n  };\r\n\r\n  // import a list of modules into the list\r\n  list.i = function i(modules, media, dedupe, supports, layer) {\r\n    if (typeof modules === \"string\") {\r\n      modules = [[null, modules, undefined]];\r\n    }\r\n    var alreadyImportedModules = {};\r\n    if (dedupe) {\r\n      for (var k = 0; k < this.length; k++) {\r\n        var id = this[k][0];\r\n        if (id != null) {\r\n          alreadyImportedModules[id] = true;\r\n        }\r\n      }\r\n    }\r\n    for (var _k = 0; _k < modules.length; _k++) {\r\n      var item = [].concat(modules[_k]);\r\n      if (dedupe && alreadyImportedModules[item[0]]) {\r\n        continue;\r\n      }\r\n      if (typeof layer !== \"undefined\") {\r\n        if (typeof item[5] === \"undefined\") {\r\n          item[5] = layer;\r\n        } else {\r\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\r\n          item[5] = layer;\r\n        }\r\n      }\r\n      if (media) {\r\n        if (!item[2]) {\r\n          item[2] = media;\r\n        } else {\r\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\r\n          item[2] = media;\r\n        }\r\n      }\r\n      if (supports) {\r\n        if (!item[4]) {\r\n          item[4] = \"\".concat(supports);\r\n        } else {\r\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\r\n          item[4] = supports;\r\n        }\r\n      }\r\n      list.push(item);\r\n    }\r\n  };\r\n  return list;\r\n};\n\n//# sourceURL=webpack://test/./node_modules/css-loader/dist/runtime/api.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("{\r\n\r\nmodule.exports = function (i) {\r\n  return i[1];\r\n};\n\n//# sourceURL=webpack://test/./node_modules/css-loader/dist/runtime/noSourceMaps.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("{\r\n\r\nvar stylesInDOM = [];\r\nfunction getIndexByIdentifier(identifier) {\r\n  var result = -1;\r\n  for (var i = 0; i < stylesInDOM.length; i++) {\r\n    if (stylesInDOM[i].identifier === identifier) {\r\n      result = i;\r\n      break;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction modulesToDom(list, options) {\r\n  var idCountMap = {};\r\n  var identifiers = [];\r\n  for (var i = 0; i < list.length; i++) {\r\n    var item = list[i];\r\n    var id = options.base ? item[0] + options.base : item[0];\r\n    var count = idCountMap[id] || 0;\r\n    var identifier = \"\".concat(id, \" \").concat(count);\r\n    idCountMap[id] = count + 1;\r\n    var indexByIdentifier = getIndexByIdentifier(identifier);\r\n    var obj = {\r\n      css: item[1],\r\n      media: item[2],\r\n      sourceMap: item[3],\r\n      supports: item[4],\r\n      layer: item[5]\r\n    };\r\n    if (indexByIdentifier !== -1) {\r\n      stylesInDOM[indexByIdentifier].references++;\r\n      stylesInDOM[indexByIdentifier].updater(obj);\r\n    } else {\r\n      var updater = addElementStyle(obj, options);\r\n      options.byIndex = i;\r\n      stylesInDOM.splice(i, 0, {\r\n        identifier: identifier,\r\n        updater: updater,\r\n        references: 1\r\n      });\r\n    }\r\n    identifiers.push(identifier);\r\n  }\r\n  return identifiers;\r\n}\r\nfunction addElementStyle(obj, options) {\r\n  var api = options.domAPI(options);\r\n  api.update(obj);\r\n  var updater = function updater(newObj) {\r\n    if (newObj) {\r\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\r\n        return;\r\n      }\r\n      api.update(obj = newObj);\r\n    } else {\r\n      api.remove();\r\n    }\r\n  };\r\n  return updater;\r\n}\r\nmodule.exports = function (list, options) {\r\n  options = options || {};\r\n  list = list || [];\r\n  var lastIdentifiers = modulesToDom(list, options);\r\n  return function update(newList) {\r\n    newList = newList || [];\r\n    for (var i = 0; i < lastIdentifiers.length; i++) {\r\n      var identifier = lastIdentifiers[i];\r\n      var index = getIndexByIdentifier(identifier);\r\n      stylesInDOM[index].references--;\r\n    }\r\n    var newLastIdentifiers = modulesToDom(newList, options);\r\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\r\n      var _identifier = lastIdentifiers[_i];\r\n      var _index = getIndexByIdentifier(_identifier);\r\n      if (stylesInDOM[_index].references === 0) {\r\n        stylesInDOM[_index].updater();\r\n        stylesInDOM.splice(_index, 1);\r\n      }\r\n    }\r\n    lastIdentifiers = newLastIdentifiers;\r\n  };\r\n};\n\n//# sourceURL=webpack://test/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\r\n\r\nvar memo = {};\r\n\r\n/* istanbul ignore next  */\r\nfunction getTarget(target) {\r\n  if (typeof memo[target] === \"undefined\") {\r\n    var styleTarget = document.querySelector(target);\r\n\r\n    // Special case to return head of iframe instead of iframe itself\r\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\r\n      try {\r\n        // This will throw an exception if access to iframe is blocked\r\n        // due to cross-origin restrictions\r\n        styleTarget = styleTarget.contentDocument.head;\r\n      } catch (e) {\r\n        // istanbul ignore next\r\n        styleTarget = null;\r\n      }\r\n    }\r\n    memo[target] = styleTarget;\r\n  }\r\n  return memo[target];\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction insertBySelector(insert, style) {\r\n  var target = getTarget(insert);\r\n  if (!target) {\r\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\r\n  }\r\n  target.appendChild(style);\r\n}\r\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://test/./node_modules/style-loader/dist/runtime/insertBySelector.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\r\n\r\n/* istanbul ignore next  */\r\nfunction insertStyleElement(options) {\r\n  var element = document.createElement(\"style\");\r\n  options.setAttributes(element, options.attributes);\r\n  options.insert(element, options.options);\r\n  return element;\r\n}\r\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://test/./node_modules/style-loader/dist/runtime/insertStyleElement.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\r\n\r\n/* istanbul ignore next  */\r\nfunction setAttributesWithoutAttributes(styleElement) {\r\n  var nonce =  true ? __webpack_require__.nc : 0;\r\n  if (nonce) {\r\n    styleElement.setAttribute(\"nonce\", nonce);\r\n  }\r\n}\r\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://test/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("{\r\n\r\n/* istanbul ignore next  */\r\nfunction apply(styleElement, options, obj) {\r\n  var css = \"\";\r\n  if (obj.supports) {\r\n    css += \"@supports (\".concat(obj.supports, \") {\");\r\n  }\r\n  if (obj.media) {\r\n    css += \"@media \".concat(obj.media, \" {\");\r\n  }\r\n  var needLayer = typeof obj.layer !== \"undefined\";\r\n  if (needLayer) {\r\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\r\n  }\r\n  css += obj.css;\r\n  if (needLayer) {\r\n    css += \"}\";\r\n  }\r\n  if (obj.media) {\r\n    css += \"}\";\r\n  }\r\n  if (obj.supports) {\r\n    css += \"}\";\r\n  }\r\n  var sourceMap = obj.sourceMap;\r\n  if (sourceMap && typeof btoa !== \"undefined\") {\r\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\r\n  }\r\n\r\n  // For old IE\r\n  /* istanbul ignore if  */\r\n  options.styleTagTransform(css, styleElement, options.options);\r\n}\r\nfunction removeStyleElement(styleElement) {\r\n  // istanbul ignore if\r\n  if (styleElement.parentNode === null) {\r\n    return false;\r\n  }\r\n  styleElement.parentNode.removeChild(styleElement);\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction domAPI(options) {\r\n  if (typeof document === \"undefined\") {\r\n    return {\r\n      update: function update() {},\r\n      remove: function remove() {}\r\n    };\r\n  }\r\n  var styleElement = options.insertStyleElement(options);\r\n  return {\r\n    update: function update(obj) {\r\n      apply(styleElement, options, obj);\r\n    },\r\n    remove: function remove() {\r\n      removeStyleElement(styleElement);\r\n    }\r\n  };\r\n}\r\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://test/./node_modules/style-loader/dist/runtime/styleDomAPI.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\r\n\r\n/* istanbul ignore next  */\r\nfunction styleTagTransform(css, styleElement) {\r\n  if (styleElement.styleSheet) {\r\n    styleElement.styleSheet.cssText = css;\r\n  } else {\r\n    while (styleElement.firstChild) {\r\n      styleElement.removeChild(styleElement.firstChild);\r\n    }\r\n    styleElement.appendChild(document.createTextNode(css));\r\n  }\r\n}\r\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://test/./node_modules/style-loader/dist/runtime/styleTagTransform.js?\n}");

/***/ }),

/***/ "./node_modules/tinymce/icons/default/icons.js":
/*!*****************************************************!*\
  !*** ./node_modules/tinymce/icons/default/icons.js ***!
  \*****************************************************/
/***/ (() => {

eval("{tinymce.IconManager.add('default', {\r\n  icons: {\r\n    'accessibility-check': '<svg width=\"24\" height=\"24\"><path d=\"M12 2a2 2 0 012 2 2 2 0 01-2 2 2 2 0 01-2-2c0-1.1.9-2 2-2zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 01-1-1v-5c0-.6-.4-1-1-1a1 1 0 00-1 1v5c0 .6-.4 1-1 1a1 1 0 01-1-1V9H4a1 1 0 110-2h16c.6 0 1 .4 1 1s-.4 1-1 1z\" fill-rule=\"nonzero\"/></svg>',\r\n    'action-next': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M5.7 7.3a1 1 0 00-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 10-1.4-1.4L12 13.6 5.7 7.3z\"/></svg>',\r\n    'action-prev': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M18.3 15.7a1 1 0 001.4-1.4L12 6.6l-7.7 7.7a1 1 0 001.4 1.4L12 9.4l6.3 6.3z\"/></svg>',\r\n    'align-center': '<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 110-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'align-justify': '<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'align-left': '<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'align-none': '<svg width=\"24\" height=\"24\"><path d=\"M14.2 5L13 7H5a1 1 0 110-2h9.2zm4 0h.8a1 1 0 010 2h-2l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 010-2h6.8zm4 0H19a1 1 0 010 2h-4.4l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 010-2h4.4zm4 0H19a1 1 0 010 2h-6.8l1.2-2zM7 17l-1.2 2H5a1 1 0 010-2h2zm4 0h8a1 1 0 010 2H9.8l1.2-2zm5.2-13.5l1.3.7-9.7 16.3-1.3-.7 9.7-16.3z\" fill-rule=\"evenodd\"/></svg>',\r\n    'align-right': '<svg width=\"24\" height=\"24\"><path d=\"M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'arrow-left': '<svg width=\"24\" height=\"24\"><path d=\"M5.6 13l12 6a1 1 0 001.4-1V6a1 1 0 00-1.4-.9l-12 6a1 1 0 000 1.8z\" fill-rule=\"evenodd\"/></svg>',\r\n    'arrow-right': '<svg width=\"24\" height=\"24\"><path d=\"M18.5 13l-12 6A1 1 0 015 18V6a1 1 0 011.4-.9l12 6a1 1 0 010 1.8z\" fill-rule=\"evenodd\"/></svg>',\r\n    'bold': '<svg width=\"24\" height=\"24\"><path d=\"M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 01-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4z\" fill-rule=\"evenodd\"/></svg>',\r\n    'bookmark': '<svg width=\"24\" height=\"24\"><path d=\"M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 00-1 1z\" fill-rule=\"nonzero\"/></svg>',\r\n    'border-style': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><rect width=\"18\" height=\"2\" x=\"3\" y=\"6\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"3\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"6.8\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"10.6\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"14.4\" y=\"16\" rx=\"1\"/><rect width=\"2.8\" height=\"2\" x=\"18.2\" y=\"16\" rx=\"1\"/><rect width=\"8\" height=\"2\" x=\"3\" y=\"11\" rx=\"1\"/><rect width=\"8\" height=\"2\" x=\"13\" y=\"11\" rx=\"1\"/></g></svg>',\r\n    'border-width': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><rect width=\"18\" height=\"5\" x=\"3\" y=\"5\" rx=\"1\"/><rect width=\"18\" height=\"3.5\" x=\"3\" y=\"11.5\" rx=\"1\"/><rect width=\"18\" height=\"2\" x=\"3\" y=\"17\" rx=\"1\"/></g></svg>',\r\n    'brightness': '<svg width=\"24\" height=\"24\"><path d=\"M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.7-.3 1 1 0 01-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3zm0-10a1 1 0 01-.7-.3A1 1 0 0111 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 01-.7.3zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 01-.7.3h-1a1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1zM7 12c0 .3-.1.5-.3.7a1 1 0 01-.7.3H5a1 1 0 01-.7-.3A1 1 0 014 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7zm10 3.5l.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 01-.8.3 1 1 0 01-.6-.3l-.8-.7a1 1 0 01-.3-.8c0-.2.1-.5.3-.7a1 1 0 011.4 0zm-10-7l-.7-.8a1 1 0 01-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.8-.3zm10 0a1 1 0 01-.8.3 1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 010 1.4l-.8.8a1 1 0 01-.6.3 1 1 0 01-.8-.3 1 1 0 01-.3-.8c0-.2.1-.5.3-.6l.7-.8zM12 8a4 4 0 013.7 2.4 4 4 0 010 3.2A4 4 0 0112 16a4 4 0 01-3.7-2.4 4 4 0 010-3.2A4 4 0 0112 8zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7z\" fill-rule=\"evenodd\"/></svg>',\r\n    'browse': '<svg width=\"24\" height=\"24\"><path d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9.4l-2.3 2.3a1 1 0 11-1.4-1.4l4-4a1 1 0 011.4 0l4 4a1 1 0 01-1.4 1.4L13 13.4V20a1 1 0 01-2 0v-6.6z\" fill-rule=\"nonzero\"/></svg>',\r\n    'cancel': '<svg width=\"24\" height=\"24\"><path d=\"M12 4.6a7.4 7.4 0 110 14.8 7.4 7.4 0 010-14.8zM12 3a9 9 0 100 18 9 9 0 000-18zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7z\" fill-rule=\"nonzero\"/></svg>',\r\n    'cell-background-color': '<svg width=\"24\" height=\"24\"><path d=\"M15.7 2l1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 01-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2zM18 12l-4.5-4L9 12h9zM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16z\"/></svg>',\r\n    'cell-border-color': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M5 13v5h2v2H5a2 2 0 01-2-2v-5h2zm8-7V4h6a2 2 0 012 2h-8z\" opacity=\".2\"/><path fill-rule=\"nonzero\" d=\"M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1l.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z\"/><path d=\"M13 11l-2 2H5v-2h6V6h2z\"/><path fill-rule=\"nonzero\" d=\"M18.4 8l1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 01-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8zm1.6 7l-3-3-3 3h6z\"/></g></svg>',\r\n    'change-case': '<svg width=\"24\" height=\"24\"><path d=\"M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 01-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 01-1 .7h-.2a.7.7 0 01-.7-1l4-12a1 1 0 012 0l4 12a.7.7 0 01-.8 1h-.2a1 1 0 01-1-.7l-.8-2.6zm-.3-1.5l-2-6.5-1.9 6.5h3.9z\" fill-rule=\"evenodd\"/></svg>',\r\n    'character-count': '<svg width=\"24\" height=\"24\"><path d=\"M4 11.5h16v1H4v-1zm4.8-6.8V10H7.7V5.8h-1v-1h2zM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1zM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2v-.1-.2l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 01-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 00-.5-.1 1 1 0 00-.4 0l-.3.4h-1zm2.3.8h-.2l-.2.1-.4.1a1 1 0 00-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 001.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 00-.6-.3l-.6.3-.2.8zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 00-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 01-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 01-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1z\" fill-rule=\"evenodd\"/></svg>',\r\n    'checklist-rtl': '<svg width=\"24\" height=\"24\"><path d=\"M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 110-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z\" fill-rule=\"evenodd\"/></svg>',\r\n    'checklist': '<svg width=\"24\" height=\"24\"><path d=\"M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8a1 1 0 010 2h-8a1 1 0 010-2zM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 010-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z\" fill-rule=\"evenodd\"/></svg>',\r\n    'checkmark': '<svg width=\"24\" height=\"24\"><path d=\"M18.2 5.4a1 1 0 011.6 1.2l-8 12a1 1 0 01-1.5.1l-5-5a1 1 0 111.4-1.4l4.1 4.1 7.4-11z\" fill-rule=\"nonzero\"/></svg>',\r\n    'chevron-down': '<svg width=\"10\" height=\"10\"><path d=\"M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 010-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8z\" fill-rule=\"nonzero\"/></svg>',\r\n    'chevron-left': '<svg width=\"10\" height=\"10\"><path d=\"M7.8 1.3L4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 010-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1z\" fill-rule=\"nonzero\"/></svg>',\r\n    'chevron-right': '<svg width=\"10\" height=\"10\"><path d=\"M2.2 1.3a.8.8 0 010-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 010-1.1L6 5 2.2 1.3z\" fill-rule=\"nonzero\"/></svg>',\r\n    'chevron-up': '<svg width=\"10\" height=\"10\"><path d=\"M8.7 7.8L5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 010-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0z\" fill-rule=\"nonzero\"/></svg>',\r\n    'close': '<svg width=\"24\" height=\"24\"><path d=\"M17.3 8.2L13.4 12l3.9 3.8a1 1 0 01-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 01-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 011.5-1.5l3.8 3.9 3.8-3.9a1 1 0 011.5 1.5z\" fill-rule=\"evenodd\"/></svg>',\r\n    'code-sample': '<svg width=\"24\" height=\"26\"><path d=\"M7.1 11a2.8 2.8 0 01-.8 2 2.8 2.8 0 01.8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 01-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 01-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 01-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 01.8-2 2.8 2.8 0 01-.8-2zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2zM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 01-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 01-.5-.5V17a3 3 0 001-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5z\" fill-rule=\"evenodd\"/></svg>',\r\n    'color-levels': '<svg width=\"24\" height=\"24\"><path d=\"M17.5 11.4A9 9 0 0118 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 01-3.7 3 5.7 5.7 0 01-3.2 0A5.9 5.9 0 017.6 18a6.2 6.2 0 01-1.4-2.6 6.7 6.7 0 010-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 012.3-4A20 20 0 0112 4a26.4 26.4 0 013.2 3.4 18.2 18.2 0 012.3 4zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 00-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 01-1.3 3 5.3 5.3 0 01-2.3 1.5 4.9 4.9 0 01-2 .1 4.3 4.3 0 002.4.8 4 4 0 002-.6 4 4 0 001.5-1.5z\" fill-rule=\"evenodd\"/></svg>',\r\n    'color-picker': '<svg width=\"24\" height=\"24\"><path d=\"M12 3a9 9 0 000 18 1.5 1.5 0 001.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 005-5c0-4.4-4-8-9-8zm-5.5 9a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm3-4a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm5 0a1.5 1.5 0 110-3 1.5 1.5 0 010 3zm3 4a1.5 1.5 0 110-3 1.5 1.5 0 010 3z\" fill-rule=\"nonzero\"/></svg>',\r\n    'color-swatch-remove-color': '<svg width=\"24\" height=\"24\"><path stroke=\"#000\" stroke-width=\"2\" d=\"M21 3L3 21\" fill-rule=\"evenodd\"/></svg>',\r\n    'color-swatch': '<svg width=\"24\" height=\"24\"><rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"1\" fill-rule=\"evenodd\"/></svg>',\r\n    'comment-add': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 00-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 01-3-3V6a3 3 0 013-3h14a3 3 0 013 3v10a3 3 0 01-3 3h-6.4L7 23z\"/><path d=\"M13 10h2a1 1 0 010 2h-2v2a1 1 0 01-2 0v-2H9a1 1 0 010-2h2V8a1 1 0 012 0v2z\"/></g></svg>',\r\n    'comment': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 00-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 01-3-3V6a3 3 0 013-3h14a3 3 0 013 3v10a3 3 0 01-3 3h-6.4L7 23z\"/></svg>',\r\n    'contrast': '<svg width=\"24\" height=\"24\"><path d=\"M12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4zm-6 8a6 6 0 006 6V6a6 6 0 00-6 6z\" fill-rule=\"evenodd\"/></svg>',\r\n    'copy': '<svg width=\"24\" height=\"24\"><path d=\"M16 3H6a2 2 0 00-2 2v11h2V5h10V3zm1 4a2 2 0 012 2v10a2 2 0 01-2 2h-7a2 2 0 01-2-2V9c0-1.2.9-2 2-2h7zm0 12V9h-7v10h7z\" fill-rule=\"nonzero\"/></svg>',\r\n    'crop': '<svg width=\"24\" height=\"24\"><path d=\"M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 01-1-1v-2H7V9H5a1 1 0 110-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3zM9 9v5l5-5H9zm1 6h5v-5l-5 5z\" fill-rule=\"evenodd\"/></svg>',\r\n    'cut-column': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0110.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 012 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 017 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7zm12.3 5h-3v10h3v-10zM8 13.8h-.3l-.4.2a2.8 2.8 0 00-.7.4v.1a2.8 2.8 0 00-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 00.8-.3 2.4 2.4 0 00.7-.7 2.5 2.5 0 00.3-.8 1.5 1.5 0 000-.8 1 1 0 00-.2-.4 1 1 0 00-.5-.2H8zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4zM7 5.8h-.4a1 1 0 00-.5.3 1 1 0 00-.2.5v.7a2.5 2.5 0 00.3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 000-.8 2.6 2.6 0 00-.3-.8A2.5 2.5 0 007.7 6l-.4-.1H7z\"/></svg>',\r\n    'cut-row': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 01-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 018.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 010-2c0-.4.3-.7.5-1l2 2V3h14zM8.5 15.3h-.3a2.6 2.6 0 00-.8.4 2.5 2.5 0 00-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 00.8-.3L9 18V18l.4-.4.2-.4.1-.4v-.3-.4a1 1 0 00-.2-.5 1 1 0 00-.4-.2h-.5zm7 0H15a1 1 0 00-.4.3 1 1 0 00-.2.5 1.5 1.5 0 000 .7v.4a2.8 2.8 0 00.5.7h.1a2.8 2.8 0 00.8.6l.4.1h.7l.5-.2.2-.5v-.4-.3a2.6 2.6 0 00-.3-.8 2.4 2.4 0 00-.7-.7 2.5 2.5 0 00-.8-.3h-.3zM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4zm8.5-7.1h-11v2h11v-2z\"/></svg>',\r\n    'cut': '<svg width=\"24\" height=\"24\"><path d=\"M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 01-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 018.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 010-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 010 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8zm-8.5 2.2l.1-.4v-.3-.4a1 1 0 00-.2-.5 1 1 0 00-.4-.2 1.6 1.6 0 00-.8 0 2.6 2.6 0 00-.8.3 2.5 2.5 0 00-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 00.8-.3 2.8 2.8 0 001-1zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4zm5.4 4l.2-.5v-.4-.3a2.6 2.6 0 00-.3-.8 2.4 2.4 0 00-.7-.7 2.5 2.5 0 00-.8-.3 1.5 1.5 0 00-.8 0 1 1 0 00-.4.2 1 1 0 00-.2.5 1.5 1.5 0 000 .7v.4l.3.4.3.4a2.8 2.8 0 00.8.5l.4.1h.7l.5-.2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'document-properties': '<svg width=\"24\" height=\"24\"><path d=\"M14.4 3H7a2 2 0 00-2 2v14c0 1.1.9 2 2 2h10a2 2 0 002-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z\" fill-rule=\"nonzero\"/></svg>',\r\n    'drag': '<svg width=\"24\" height=\"24\"><path d=\"M13 5h2v2h-2V5zm0 4h2v2h-2V9zM9 9h2v2H9V9zm4 4h2v2h-2v-2zm-4 0h2v2H9v-2zm0 4h2v2H9v-2zm4 0h2v2h-2v-2zM9 5h2v2H9V5z\" fill-rule=\"evenodd\"/></svg>',\r\n    'duplicate-column': '<svg width=\"24\" height=\"24\"><path d=\"M17 6v16h-7V6h7zm-2 2h-3v12h3V8zm-2-6v2H8v15H6V2h7z\"/></svg>',\r\n    'duplicate-row': '<svg width=\"24\" height=\"24\"><path d=\"M22 11v7H6v-7h16zm-2 2H8v3h12v-3zm-1-6v2H4v5H2V7h17z\"/></svg>',\r\n    'duplicate': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10zm3 8h-2V9h-7v10h9a2 2 0 01-2 2h-7a2 2 0 01-2-2V9c0-1.2.9-2 2-2h7a2 2 0 012 2v2z\"/><path d=\"M17 14h1a1 1 0 010 2h-1v1a1 1 0 01-2 0v-1h-1a1 1 0 010-2h1v-1a1 1 0 012 0v1z\"/></g></svg>',\r\n    'edit-block': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19.8 8.8l-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5zm-2-.2l1-.9v-.3l-2.2-2.2a.3.3 0 00-.3 0l-1 1L18 8.5zm-1 1l-2.5-2.4-6 6 2.5 2.5 6-6zm-7 7.1l-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5z\"/></svg>',\r\n    'edit-image': '<svg width=\"24\" height=\"24\"><path d=\"M18 16h2V7a2 2 0 00-2-2H7v2h11v9zM6 17h15a1 1 0 010 2h-1v1a1 1 0 01-2 0v-1H6a2 2 0 01-2-2V7H3a1 1 0 110-2h1V4a1 1 0 112 0v13zm3-5.3l1.3 2 3-4.7 3.7 6H7l2-3.3z\" fill-rule=\"nonzero\"/></svg>',\r\n    'embed-page': '<svg width=\"24\" height=\"24\"><path d=\"M19 6V5H5v14h2A13 13 0 0119 6zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 008 19h3zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 00-4 4.5h2.2zm-3.4 0a12 12 0 012.8-4 12 12 0 00-5 4h2.2z\" fill-rule=\"nonzero\"/></svg>',\r\n    'embed': '<svg width=\"24\" height=\"24\"><path d=\"M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm4.8 2.6l5.6 4a.5.5 0 010 .8l-5.6 4A.5.5 0 019 16V8a.5.5 0 01.8-.4z\" fill-rule=\"nonzero\"/></svg>',\r\n    'emoji': '<svg width=\"24\" height=\"24\"><path d=\"M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 00-1 1c0 .6.4 1 1 1zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 00-1 1c0 .6.4 1 1 1zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5zM12 4a8 8 0 100 16 8 8 0 000-16zm0 14.5a6.5 6.5 0 110-13 6.5 6.5 0 010 13z\" fill-rule=\"nonzero\"/></svg>',\r\n    'export': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M14.4 3L18 7v1h-5V5H7v14h9a1 1 0 012 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5z\"/><path d=\"M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3z\"/><path d=\"M16.4 9.2a1 1 0 011.4.2l2.4 3.6-2.4 3.6a1 1 0 01-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 01.2-1.4z\"/></g></svg>',\r\n    'fill': '<svg width=\"24\" height=\"26\"><path d=\"M16.6 12l-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 002.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2zM5.2 13L10 8.2l4.8 4.8H5.2zM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 002-2c0-1.3-2-3.5-2-3.5z\" fill-rule=\"nonzero\"/></svg>',\r\n    'flip-horizontally': '<svg width=\"24\" height=\"24\"><path d=\"M14 19h2v-2h-2v2zm4-8h2V9h-2v2zM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 00-2 2zm14-2v2h2a2 2 0 00-2-2zm-7 16h2V3h-2v18zm7-6h2v-2h-2v2zm-4-8h2V5h-2v2zm4 12a2 2 0 002-2h-2v2z\" fill-rule=\"nonzero\"/></svg>',\r\n    'flip-vertically': '<svg width=\"24\" height=\"24\"><path d=\"M5 14v2h2v-2H5zm8 4v2h2v-2h-2zm4-14H7a2 2 0 00-2 2v3h2V6h10v3h2V6a2 2 0 00-2-2zm2 14h-2v2a2 2 0 002-2zM3 11v2h18v-2H3zm6 7v2h2v-2H9zm8-4v2h2v-2h-2zM5 18c0 1.1.9 2 2 2v-2H5z\" fill-rule=\"nonzero\"/></svg>',\r\n    'format-painter': '<svg width=\"24\" height=\"24\"><path d=\"M18 5V4c0-.5-.4-1-1-1H5a1 1 0 00-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3z\" fill-rule=\"nonzero\"/></svg>',\r\n    'format': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M17 5a1 1 0 010 2h-4v11a1 1 0 01-2 0V7H7a1 1 0 110-2h10z\"/></svg>',\r\n    'fullscreen': '<svg width=\"24\" height=\"24\"><path d=\"M15.3 10l-1.2-1.3 2.9-3h-2.3a.9.9 0 110-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 11-1.8 0V7l-2.9 3zm0 4l3 3v-2.3a.9.9 0 111.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 110-1.8H17l-3-2.9 1.3-1.2zM10 15.4l-2.9 3h2.3a.9.9 0 110 1.7H5a.9.9 0 01-.9-.9v-4.4a.9.9 0 111.8 0V17l2.9-3 1.2 1.3zM8.7 10L5.7 7v2.3a.9.9 0 01-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 010 1.8H7l3 2.9-1.3 1.2z\" fill-rule=\"nonzero\"/></svg>',\r\n    'gallery': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M5 15.7l2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7zM5 18V19h3l1.8-1.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 01-1-1V7c0-.6.4-1 1-1zm6 7a2 2 0 110-4 2 2 0 010 4zM4.5 4h15a.5.5 0 110 1h-15a.5.5 0 010-1zm2-2h11a.5.5 0 110 1h-11a.5.5 0 010-1z\"/></svg>',\r\n    'gamma': '<svg width=\"24\" height=\"24\"><path d=\"M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 00-.4-.8l-.1-.2H8 8v-1l.3-.1.3-.1h.7a1 1 0 01.6.5l.1.3a8.5 8.5 0 01.3.6l1.9 4.6 2-5.2a1 1 0 011-.6.5.5 0 01.5.6L13 14v2.8a.7.7 0 01-1.4 0z\" fill-rule=\"nonzero\"/></svg>',\r\n    'help': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M12 5.5a6.5 6.5 0 00-6 9 6.3 6.3 0 001.4 2l1 1a6.3 6.3 0 003.6 1 6.5 6.5 0 006-9 6.3 6.3 0 00-1.4-2l-1-1a6.3 6.3 0 00-3.6-1zM12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4z\"/><path d=\"M9.6 9.7a.7.7 0 01-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 00-.8.8.8.8 0 01-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8z\" fill-rule=\"nonzero\"/><circle cx=\"12\" cy=\"16\" r=\"1\"/></g></svg>',\r\n    'highlight-bg-color': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path id=\"tox-icon-highlight-bg-color__color\" d=\"M3 18h18v3H3z\"/><path fill-rule=\"nonzero\" d=\"M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 012.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6\"/></g></svg>',\r\n    'home': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z\"/></svg>',\r\n    'horizontal-rule': '<svg width=\"24\" height=\"24\"><path d=\"M4 11h16v2H4z\" fill-rule=\"evenodd\"/></svg>',\r\n    'image-options': '<svg width=\"24\" height=\"24\"><path d=\"M6 10a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm12 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm-6 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2z\" fill-rule=\"nonzero\"/></svg>',\r\n    'image': '<svg width=\"24\" height=\"24\"><path d=\"M5 15.7l3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7zM5 18V19h3l2.8-2.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 01-1-1V4c0-.6.4-1 1-1zm6 8a2 2 0 100-4 2 2 0 000 4z\" fill-rule=\"nonzero\"/></svg>',\r\n    'indent': '<svg width=\"24\" height=\"24\"><path d=\"M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 110-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm-5 4h12a1 1 0 010 2H7a1 1 0 010-2zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 011.2-1.6l3 2a1 1 0 010 1.6l-3 2a1 1 0 11-1.2-1.6z\" fill-rule=\"evenodd\"/></svg>',\r\n    'info': '<svg width=\"24\" height=\"24\"><path d=\"M12 4a7.8 7.8 0 015.7 2.3A8 8 0 1112 4zm-1 3v2h2V7h-2zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4z\" fill-rule=\"evenodd\"/></svg>',\r\n    'insert-character': '<svg width=\"24\" height=\"24\"><path d=\"M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 001.8-2.9 6.3 6.3 0 00-.1-4.1 5.8 5.8 0 00-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 00-3.9 1.8 6.3 6.3 0 00-1.3 6 6.2 6.2 0 001.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 014 11c0-1 .2-1.9.6-2.7A7 7 0 016.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 015.7 2 7 7 0 011.7 2.3 6 6 0 01.2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 01-3.6 2.5v.5z\" fill-rule=\"evenodd\"/></svg>',\r\n    'insert-time': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M12 19a7 7 0 100-14 7 7 0 000 14zm0 2a9 9 0 110-18 9 9 0 010 18z\"/><path d=\"M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 00-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1z\"/></g></svg>',\r\n    'invert': '<svg width=\"24\" height=\"24\"><path d=\"M18 19.3L16.5 18a5.8 5.8 0 01-3.1 1.9 6.1 6.1 0 01-5.5-1.6A5.8 5.8 0 016 14v-.3l.1-1.2A13.9 13.9 0 017.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 00.2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 00-3-4.2L12 6a26.1 26.1 0 00-2.2 2.5l-1-1a20.9 20.9 0 012.9-3.3L12 4l1 .8a22.2 22.2 0 014 5.4c.6 1.2 1 2.4 1 3.6z\" fill-rule=\"evenodd\"/></svg>',\r\n    'italic': '<svg width=\"24\" height=\"24\"><path d=\"M16.7 4.7l-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8z\" fill-rule=\"evenodd\"/></svg>',\r\n    'language': '<svg width=\"24\" height=\"24\"><path d=\"M12 3a9 9 0 110 18 9 9 0 010-18zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 003.2-2.1l-.2-.2a6 6 0 00-1-.6zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 01-2-2.8zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 01-.3-2zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1zm3-1.4l-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 00-1.3-3.5zm-9 0l2 .2V5.5a9 9 0 00-2 2.2zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 00-2-2.3zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 011.9-2.5zm4.4 0l.1.1a10 10 0 011.8 2.4l1.1-.7a7.5 7.5 0 00-3-1.8z\"/></svg>',\r\n    'line-height': '<svg width=\"24\" height=\"24\"><path d=\"M21 5a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zm0 4a1 1 0 01.1 2H13a1 1 0 01-.1-2H21zM7 3.6l3.7 3.7a1 1 0 01-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 011.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 011.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 01-1.3 0h-.1a1 1 0 010-1.3v-.1L7 3.6z\"/></svg>',\r\n    'line': '<svg width=\"24\" height=\"24\"><path d=\"M15 9l-8 8H4v-3l8-8 3 3zm1-1l-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1zM4 18h16v2H4v-2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'link': '<svg width=\"24\" height=\"24\"><path d=\"M6.2 12.3a1 1 0 011.4 1.4l-2.1 2a2 2 0 102.7 2.8l4.8-4.8a1 1 0 000-1.4 1 1 0 111.4-1.3 2.9 2.9 0 010 4L9.6 20a3.9 3.9 0 01-5.5-5.5l2-2zm11.6-.6a1 1 0 01-1.4-1.4l2-2a2 2 0 10-2.6-2.8L11 10.3a1 1 0 000 1.4A1 1 0 119.6 13a2.9 2.9 0 010-4L14.4 4a3.9 3.9 0 015.5 5.5l-2 2z\" fill-rule=\"nonzero\"/></svg>',\r\n    'list-bull-circle': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path d=\"M11 16a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6zM11 26a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6zM11 36a2 2 0 100-4 2 2 0 000 4zm0 1a3 3 0 110-6 3 3 0 010 6z\" fill-rule=\"nonzero\"/><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/></g></svg>',\r\n    'list-bull-default': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><circle cx=\"11\" cy=\"14\" r=\"3\"/><circle cx=\"11\" cy=\"24\" r=\"3\"/><circle cx=\"11\" cy=\"34\" r=\"3\"/><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/></g></svg>',\r\n    'list-bull-square': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path d=\"M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z\"/><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/></g></svg>',\r\n    'list-num-default-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M37.4 17v-4.8l-1.6 1v-1.1l1.6-1h1.2V17zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z\"/></g></svg>',\r\n    'list-num-default': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z\"/></g></svg>',\r\n    'list-num-lower-alpha-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6zM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3zM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z\"/></g></svg>',\r\n    'list-num-lower-alpha': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z\"/></g></svg>',\r\n    'list-num-lower-greek-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4zM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3zM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM37.1 34.6L34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 00-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z\"/></g></svg>',\r\n    'list-num-lower-greek': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3zM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 00-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z\"/></g></svg>',\r\n    'list-num-lower-roman-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M32.9 16v-1.2h-1.3V16H33zm0 10v-1.2h-1.3V26H33zm0 10v-1.2h-1.3V36H33z\"/><path fill-rule=\"nonzero\" d=\"M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z\"/></g></svg>',\r\n    'list-num-lower-roman': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M15.1 16v-1.2h1.3V16H15zm0 10v-1.2h1.3V26H15zm0 10v-1.2h1.3V36H15z\"/><path fill-rule=\"nonzero\" d=\"M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z\"/></g></svg>',\r\n    'list-num-upper-alpha-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M39.3 17l-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3zm-1.6-4.7l-.7 2.3h1.6l-.8-2.3zM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26zM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z\"/></g></svg>',\r\n    'list-num-upper-alpha': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M12.6 17l-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3zM11 12.3l-.7 2.3h1.6l-.8-2.3zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z\"/></g></svg>',\r\n    'list-num-upper-roman-rtl': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z\"/><path d=\"M31.6 17v-1.2H33V17h-1.3zm0 10v-1.2H33V27h-1.3zm0 10v-1.2H33V37h-1.3z\"/><path fill-rule=\"nonzero\" d=\"M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z\"/></g></svg>',\r\n    'list-num-upper-roman': '<svg width=\"48\" height=\"48\"><g fill-rule=\"evenodd\"><path opacity=\".2\" d=\"M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z\"/><path d=\"M15.1 17v-1.2h1.3V17H15zm0 10v-1.2h1.3V27H15zm0 10v-1.2h1.3V37H15z\"/><path fill-rule=\"nonzero\" d=\"M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z\"/></g></svg>',\r\n    'lock': '<svg width=\"24\" height=\"24\"><path d=\"M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3zM10 8v3h4V8a1 1 0 00-.3-.7A1 1 0 0013 7h-2a1 1 0 00-.7.3 1 1 0 00-.3.7z\" fill-rule=\"evenodd\"/></svg>',\r\n    'ltr': '<svg width=\"24\" height=\"24\"><path d=\"M11 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 017.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L11 5zM4.4 16.2L6.2 15l-1.8-1.2a1 1 0 011.2-1.6l3 2a1 1 0 010 1.6l-3 2a1 1 0 11-1.2-1.6z\" fill-rule=\"evenodd\"/></svg>',\r\n    'more-drawer': '<svg width=\"24\" height=\"24\"><path d=\"M6 10a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm12 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2zm-6 0a2 2 0 00-2 2c0 1.1.9 2 2 2a2 2 0 002-2 2 2 0 00-2-2z\" fill-rule=\"nonzero\"/></svg>',\r\n    'new-document': '<svg width=\"24\" height=\"24\"><path d=\"M14.4 3H7a2 2 0 00-2 2v14c0 1.1.9 2 2 2h10a2 2 0 002-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z\" fill-rule=\"nonzero\"/></svg>',\r\n    'new-tab': '<svg width=\"24\" height=\"24\"><path d=\"M15 13l2-2v8H5V7h8l-2 2H7v8h8v-4zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19z\" fill-rule=\"evenodd\"/></svg>',\r\n    'non-breaking': '<svg width=\"24\" height=\"24\"><path d=\"M11 11H8a1 1 0 110-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 01-1-1v-3zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1z\" fill-rule=\"evenodd\"/></svg>',\r\n    'notice': '<svg width=\"24\" height=\"24\"><path d=\"M17.8 9.8L15.4 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7l2.3 5.8zm0 0l2.2 5.7-2.3-5.8zM13 17v-2h-2v2h2zm0-4V7h-2v6h2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'ordered-list-rtl': '<svg width=\"24\" height=\"24\"><path d=\"M6 17h8a1 1 0 010 2H6a1 1 0 010-2zm0-6h8a1 1 0 010 2H6a1 1 0 010-2zm0-6h8a1 1 0 010 2H6a1 1 0 110-2zm13-1v3.5a.5.5 0 11-1 0V5h-.5a.5.5 0 110-1H19zm-1 8.8l.2.2h1.3a.5.5 0 110 1h-1.6a1 1 0 01-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 00-.2-.2h-1.3a.5.5 0 01-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 010-1h1.2a.3.3 0 100-.6h-1.3a.4.4 0 110-.8h1.3a.3.3 0 000-.6h-1.2a.5.5 0 110-1H19c.6 0 1 .4 1 1z\" fill-rule=\"evenodd\"/></svg>',\r\n    'ordered-list': '<svg width=\"24\" height=\"24\"><path d=\"M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 110-2zM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 01-.5-.5V5h-.5a.5.5 0 010-1H6zm-1 8.8l.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 01-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 00-.2-.2H4.5a.5.5 0 01-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 010-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 110-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 110-1H6c.6 0 1 .4 1 1z\" fill-rule=\"evenodd\"/></svg>',\r\n    'orientation': '<svg width=\"24\" height=\"24\"><path d=\"M7.3 6.4L1 13l6.4 6.5 6.5-6.5-6.5-6.5zM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7zM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 010-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 11-4.3 16.9l1.5-1.5A7 7 0 1013 6h-1z\" fill-rule=\"nonzero\"/></svg>',\r\n    'outdent': '<svg width=\"24\" height=\"24\"><path d=\"M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 110-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 010-2zm-5 4h12a1 1 0 010 2H7a1 1 0 010-2zm1.6-3.8a1 1 0 01-1.2 1.6l-3-2a1 1 0 010-1.6l3-2a1 1 0 011.2 1.6L6.8 12l1.8 1.2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'page-break': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 010-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1zM6 22a1 1 0 01-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 01-1-1v-5H7v5c0 .6-.4 1-1 1z\"/></g></svg>',\r\n    'paragraph': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M10 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 016.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L10 5z\"/></svg>',\r\n    'paste-column-after': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm8 7v12h-6V8h6zm-1.5 1.5h-3v9h3v-9zM12 3a1 1 0 100 2 1 1 0 000-2z\"/></svg>',\r\n    'paste-column-before': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm-2 7v12H4V8h6zM8.5 9.5h-3v9h3v-9zM12 3a1 1 0 100 2 1 1 0 000-2z\"/></svg>',\r\n    'paste-row-after': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm10 11v5H8v-5h14zm-1.5 1.5h-11v2h11v-2zM12 3a1 1 0 100 2 1 1 0 000-2z\"/></svg>',\r\n    'paste-row-before': '<svg width=\"24\" height=\"24\"><path fill-rule=\"evenodd\" d=\"M12 1a3 3 0 012.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0112 1zm10 7v5H8V8h14zm-1.5 1.5h-11v2h11v-2zM12 3a1 1 0 100 2 1 1 0 000-2z\"/></svg>',\r\n    'paste-text': '<svg width=\"24\" height=\"24\"><path d=\"M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 01-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0112 1a3 3 0 012.8 2H18a2 2 0 012 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 00-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2z\" fill-rule=\"nonzero\"/></svg>',\r\n    'paste': '<svg width=\"24\" height=\"24\"><path d=\"M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 01-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 01-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0112 1a3 3 0 012.8 2H18a2 2 0 012 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 00-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1z\" fill-rule=\"nonzero\"/></svg>',\r\n    'permanent-pen': '<svg width=\"24\" height=\"24\"><path d=\"M10.5 17.5L8 20H3v-3l3.5-3.5a2 2 0 010-3L14 3l1 1-7.3 7.3a1 1 0 000 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 01-2.8 0l-.1-.1z\" fill-rule=\"nonzero\"/></svg>',\r\n    'plus': '<svg width=\"24\" height=\"24\"><path d=\"M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 01.1 2H13v6a1 1 0 01-2 .1V13H5a1 1 0 01-.1-2H11V5c0-.6.4-1 1-1z\"/></svg>',\r\n    'preferences': '<svg width=\"24\" height=\"24\"><path d=\"M20.1 13.5l-1.9.2a5.8 5.8 0 01-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 01-1.4 0l-1.5-1.2a6.2 6.2 0 01-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 01-1-.9l-.2-1.9a5.8 5.8 0 01-1.5-.6l-1.5 1.2a1 1 0 01-1.4 0l-.7-.7a1 1 0 010-1.4l1.2-1.5a6.2 6.2 0 01-.6-1.5l-1.9-.2a1 1 0 01-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 01.6-1.5L5.2 7.3a1 1 0 010-1.4l.7-.7a1 1 0 011.4 0l1.5 1.2a6.2 6.2 0 011.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 011.5.6l1.5-1.2a1 1 0 011.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 01.6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1zM12 15a3 3 0 100-6 3 3 0 000 6z\" fill-rule=\"evenodd\"/></svg>',\r\n    'preview': '<svg width=\"24\" height=\"24\"><path d=\"M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 002.1-2.8 15.7 15.7 0 00-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 00-6.7 3.2A16.2 16.2 0 003.2 12c0 .2.2.3.3.5zm-2.4-1l.7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 012.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 01-2.8-3.7 1 1 0 010-1zm12-3.3a2 2 0 102.7 2.6 4 4 0 11-2.6-2.6z\" fill-rule=\"nonzero\"/></svg>',\r\n    'print': '<svg width=\"24\" height=\"24\"><path d=\"M18 8H6a3 3 0 00-3 3v6h2v3h14v-3h2v-6a3 3 0 00-3-3zm-1 10H7v-4h10v4zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5zm.5-8H6v2h12V5z\" fill-rule=\"nonzero\"/></svg>',\r\n    'quote': '<svg width=\"24\" height=\"24\"><path d=\"M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 00-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 00.8 1.3zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 00-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 00.8 1.3z\" fill-rule=\"nonzero\"/></svg>',\r\n    'redo': '<svg width=\"24\" height=\"24\"><path d=\"M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 11-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 111.4-1.4l5 5a1 1 0 010 1.4l-5 5a1 1 0 01-1.4-1.4l3.3-3.3z\" fill-rule=\"nonzero\"/></svg>',\r\n    'reload': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M5 22.1l-1.2-4.7v-.2a1 1 0 011-1l5 .4a1 1 0 11-.2 2l-2.2-.2a7.8 7.8 0 008.4.2 7.5 7.5 0 003.5-6.4 1 1 0 112 0 9.5 9.5 0 01-4.5 8 9.9 9.9 0 01-10.2 0l.4 1.4a1 1 0 11-2 .5zM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 00-9.5-1 7.5 7.5 0 00-3.6 7 1 1 0 01-2 0 9.5 9.5 0 014.5-8.6 10 10 0 0110.9.3l-.3-1a1 1 0 012-.5l1.1 4.8a1 1 0 01-1 1.2l-5-.4a1 1 0 01-.9-1z\"/></g></svg>',\r\n    'remove-formatting': '<svg width=\"24\" height=\"24\"><path d=\"M13.2 6a1 1 0 010 .2l-2.6 10a1 1 0 01-1 .8h-.2a.8.8 0 01-.8-1l2.6-10H8a1 1 0 110-2h9a1 1 0 010 2h-3.8zM5 18h7a1 1 0 010 2H5a1 1 0 010-2zm13 1.5L16.5 18 15 19.5a.7.7 0 01-1-1l1.5-1.5-1.5-1.5a.7.7 0 011-1l1.5 1.5 1.5-1.5a.7.7 0 011 1L17.5 17l1.5 1.5a.7.7 0 01-1 1z\" fill-rule=\"evenodd\"/></svg>',\r\n    'remove': '<svg width=\"24\" height=\"24\"><path d=\"M16 7h3a1 1 0 010 2h-1v9a3 3 0 01-3 3H9a3 3 0 01-3-3V9H5a1 1 0 110-2h3V6a3 3 0 013-3h2a3 3 0 013 3v1zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 00-1 1v1h4zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9zm-7 3a1 1 0 012 0v4a1 1 0 01-2 0v-4zm4 0a1 1 0 012 0v4a1 1 0 01-2 0v-4z\" fill-rule=\"nonzero\"/></svg>',\r\n    'resize-handle': '<svg width=\"10\" height=\"10\"><g fill-rule=\"nonzero\"><path d=\"M8.1 1.1A.5.5 0 119 2l-7 7A.5.5 0 111 8l7-7zM8.1 5.1A.5.5 0 119 6l-3 3A.5.5 0 115 8l3-3z\"/></g></svg>',\r\n    'resize': '<svg width=\"24\" height=\"24\"><path d=\"M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 01-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 01-.7.3h-6a1 1 0 01-.7-.3 1 1 0 01-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 01-.7.3 1 1 0 01-.7-.3A1 1 0 014 11V5z\" fill-rule=\"evenodd\"/></svg>',\r\n    'restore-draft': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1z\"/><path d=\"M4.7 10H9a1 1 0 010 2H3a1 1 0 01-1-1V5a1 1 0 112 0v3l2.5-2.4a9.2 9.2 0 0110.8-1.5A9 9 0 0113.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 111.3-1.5 7.2 7.2 0 0011.6-3.7 7 7 0 00-3.5-7.7A7.2 7.2 0 008 7L4.7 10z\" fill-rule=\"nonzero\"/></g></svg>',\r\n    'rotate-left': '<svg width=\"24\" height=\"24\"><path d=\"M4.7 10H9a1 1 0 010 2H3a1 1 0 01-1-1V5a1 1 0 112 0v3l2.5-2.4a9.2 9.2 0 0110.8-1.5A9 9 0 0113.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 111.3-1.5 7.2 7.2 0 0011.6-3.7 7 7 0 00-3.5-7.7A7.2 7.2 0 008 7L4.7 10z\" fill-rule=\"nonzero\"/></svg>',\r\n    'rotate-right': '<svg width=\"24\" height=\"24\"><path d=\"M20 8V5a1 1 0 012 0v6c0 .6-.4 1-1 1h-6a1 1 0 010-2h4.3L16 7A7.2 7.2 0 007.7 6a7 7 0 003 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 011.4 1.5A9.2 9.2 0 012.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8z\" fill-rule=\"nonzero\"/></svg>',\r\n    'rtl': '<svg width=\"24\" height=\"24\"><path d=\"M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 014.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L8 5zm12 11.2a1 1 0 11-1 1.6l-3-2a1 1 0 010-1.6l3-2a1 1 0 111 1.6L18.4 15l1.8 1.2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'save': '<svg width=\"24\" height=\"24\"><path d=\"M5 16h14a2 2 0 012 2v2a2 2 0 01-2 2H5a2 2 0 01-2-2v-2c0-1.1.9-2 2-2zm0 2v2h14v-2H5zm10 0h2v2h-2v-2zm-4-6.4L8.7 9.3a1 1 0 10-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 10-1.4-1.4L13 11.6V4a1 1 0 00-2 0v7.6z\" fill-rule=\"nonzero\"/></svg>',\r\n    'search': '<svg width=\"24\" height=\"24\"><path d=\"M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12z\" fill-rule=\"nonzero\"/></svg>',\r\n    'select-all': '<svg width=\"24\" height=\"24\"><path d=\"M3 5h2V3a2 2 0 00-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2a2 2 0 00-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8a2 2 0 002-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z\" fill-rule=\"nonzero\"/></svg>',\r\n    'selected': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2zm3.6 10.9L7 12.3a.7.7 0 00-1 1L9.6 17 18 8.6a.7.7 0 000-1 .7.7 0 00-1 0l-7.4 7.3z\"/></svg>',\r\n    'settings': '<svg width=\"24\" height=\"24\"><path d=\"M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V8H5a1 1 0 110-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6zM8 8h2V6H8v2zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V13H5a1 1 0 010-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6zM14 13h2v-2h-2v2zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6V18H5a1 1 0 010-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6zM8 18h2v-2H8v2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'sharpen': '<svg width=\"24\" height=\"24\"><path d=\"M16 6l4 4-8 9-8-9 4-4h8zm-4 10.2l5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'sourcecode': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 010-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7zM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 00-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7z\"/></g></svg>',\r\n    'spell-check': '<svg width=\"24\" height=\"24\"><path d=\"M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6zm0-3v2h2V5H6zm13 0h-3v5h3v1h-3a1 1 0 01-.7-.3 1 1 0 01-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1zm-5 1.5l-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 01-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5zM13 10V8h-2v2h2zm0-3V5h-2v2h2zm3 5l1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12z\" fill-rule=\"evenodd\"/></svg>',\r\n    'strike-through': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 017 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1z\"/><path d=\"M5 11h14a1 1 0 010 2H5a1 1 0 010-2z\" fill-rule=\"nonzero\"/></g></svg>',\r\n    'subscript': '<svg width=\"24\" height=\"24\"><path d=\"M10.4 10l4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10zM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 00-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 01-1.3 1.3l-.6.6h2.6V19z\" fill-rule=\"nonzero\"/></svg>',\r\n    'superscript': '<svg width=\"24\" height=\"24\"><path d=\"M15 9.4L10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11z\" fill-rule=\"nonzero\"/></svg>',\r\n    'table-caption': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><rect width=\"12\" height=\"2\" x=\"3\" y=\"4\" rx=\"1\"/><path d=\"M19 8a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2v-8c0-1.1.9-2 2-2h14zM5 15v3h6v-3H5zm14 0h-6v3h6v-3zm0-5h-6v3h6v-3zM5 13h6v-3H5v3z\"/></g></svg>',\r\n    'table-cell-classes': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M13 4v9H3V6c0-1.1.9-2 2-2h8zm-2 2H5v5h6V6z\"/><path fill-rule=\"nonzero\" d=\"M13 4h6a2 2 0 012 2v7h-8v-2h6V6h-6V4z\" opacity=\".2\"/><path d=\"M18 20l-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3 .2-2.3 2 .7 3z\"/><path fill-rule=\"nonzero\" d=\"M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3z\" opacity=\".2\"/></g></svg>',\r\n    'table-cell-properties': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9H5v5h6v-5zm8 0h-6v5h6v-5zm-8-7H5v5h6V6z\"/></svg>',\r\n    'table-cell-select-all': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z\"/><path d=\"M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z\" opacity=\".2\"/></g></svg>',\r\n    'table-cell-select-inner': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z\" opacity=\".2\"/><path d=\"M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z\"/></g></svg>',\r\n    'table-classes': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v7h-8v7H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 9H5v5h6v-5zm8-7h-6v5h6V6zm-8 0H5v5h6V6z\"/><path d=\"M18 20l-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3 .2-2.3 2 .7 3z\"/></g></svg>',\r\n    'table-delete-column': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2zm.3.5l1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5z\"/></svg>',\r\n    'table-delete-row': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6zm-4.7 1.8l1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3z\"/></svg>',\r\n    'table-delete-table': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><path d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 6v12h14V6H5z\"/><path d=\"M14.4 8.6l1 1-2.3 2.4 2.3 2.4-1 1-2.4-2.3-2.4 2.3-1-1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z\"/></g></svg>',\r\n    'table-insert-column-after': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M20 4c.6 0 1 .4 1 1v2a1 1 0 01-2 0V6h-8v12h8v-1a1 1 0 012 0v2c0 .5-.4 1-.9 1H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h15zM9 13H5v5h4v-5zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 01.1 2H17v2a1 1 0 01-2 .1V13h-2a1 1 0 01-.1-2H15V9c0-.6.4-1 1-1zM9 6H5v5h4V6z\"/></svg>',\r\n    'table-insert-column-before': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H4a1 1 0 01-1-1v-2a1 1 0 012 0v1h8V6H5v1a1 1 0 11-2 0V5c0-.6.4-1 1-1h15zm0 9h-4v5h4v-5zM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 01.1 2H9v2a1 1 0 01-2 .1V13H5a1 1 0 01-.1-2H7V9c0-.6.4-1 1-1zm11-2h-4v5h4V6z\"/></svg>',\r\n    'table-insert-row-above': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M6 4a1 1 0 110 2H5v6h14V6h-1a1 1 0 010-2h2c.6 0 1 .4 1 1v13a2 2 0 01-2 2H5a2 2 0 01-2-2V5c0-.6.4-1 1-1h2zm5 10H5v4h6v-4zm8 0h-6v4h6v-4zM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 010 2h-2v2a1 1 0 01-2 .1V8H9a1 1 0 010-2h2V4c0-.6.4-1 1-1z\"/></svg>',\r\n    'table-insert-row-after': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 01.1 2H13v2a1 1 0 01-2 .1V18H9a1 1 0 01-.1-2H11v-2c0-.6.4-1 1-1zm6 7a1 1 0 010-2h1v-6H5v6h1a1 1 0 010 2H4a1 1 0 01-1-1V6c0-1.1.9-2 2-2h14a2 2 0 012 2v13c0 .5-.4 1-.9 1H18zM11 6H5v4h6V6zm8 0h-6v4h6V6z\"/></svg>',\r\n    'table-left-header': '<svg width=\"24\" height=\"24\"><path d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm0 9h-4v5h4v-5zm-6 0H9v5h4v-5zm0-7H9v5h4V6zm6 0h-4v5h4V6z\"/></svg>',\r\n    'table-merge-cells': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 15.5V18h3v-2.5H5zm14-5h-9V18h9v-7.5zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6zm-8 7.5h3v-3H5v3z\"/></svg>',\r\n    'table-row-numbering-rtl': '<svg width=\"24\" height=\"24\"><path d=\"M6 4a2 2 0 00-2 2v13c0 1.1.9 2 2 2h12a2 2 0 002-2V6a2 2 0 00-2-2H6zm0 12h8v3H6v-3zm11 0c.6 0 1 .4 1 1v1a1 1 0 01-2 0v-1c0-.6.4-1 1-1zM6 11h8v3H6v-3zm11 0c.6 0 1 .4 1 1v1a1 1 0 01-2 0v-1c0-.6.4-1 1-1zM6 6h8v3H6V6zm11 0c.6 0 1 .4 1 1v1a1 1 0 11-2 0V7c0-.6.4-1 1-1z\"/></svg>',\r\n    'table-row-numbering': '<svg width=\"24\" height=\"24\"><path d=\"M18 4a2 2 0 012 2v13a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2h12zm0 12h-8v3h8v-3zM7 16a1 1 0 00-1 1v1a1 1 0 002 0v-1c0-.6-.4-1-1-1zm11-5h-8v3h8v-3zM7 11a1 1 0 00-1 1v1a1 1 0 002 0v-1c0-.6-.4-1-1-1zm11-5h-8v3h8V6zM7 6a1 1 0 00-1 1v1a1 1 0 102 0V7c0-.6-.4-1-1-1z\"/></svg>',\r\n    'table-row-properties': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 15v3h6v-3H5zm14 0h-6v3h6v-3zm0-9h-6v3h6V6zM5 9h6V6H5v3z\"/></svg>',\r\n    'table-split-cells': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM8 15.5H5V18h3v-2.5zm11-5h-9V18h9v-7.5zm-2.5 1l1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2zm-8.5-1H5v3h3v-3zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6z\"/></svg>',\r\n    'table-top-header': '<svg width=\"24\" height=\"24\"><path d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zm-8 11H5v3h6v-3zm8 0h-6v3h6v-3zm0-5h-6v3h6v-3zM5 13h6v-3H5v3z\"/></svg>',\r\n    'table': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M19 4a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6c0-1.1.9-2 2-2h14zM5 14v4h6v-4H5zm14 0h-6v4h6v-4zm0-6h-6v4h6V8zM5 12h6V8H5v4z\"/></svg>',\r\n    'template': '<svg width=\"24\" height=\"24\"><path d=\"M19 19v-1H5v1h14zM9 16v-4a5 5 0 116 0v4h4a2 2 0 012 2v3H3v-3c0-1.1.9-2 2-2h4zm4 0v-5l.8-.6a3 3 0 10-3.6 0l.8.6v5h2z\" fill-rule=\"nonzero\"/></svg>',\r\n    'temporary-placeholder': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path d=\"M9 7.6V6h2.5V4.5a.5.5 0 111 0V6H15v1.6a8 8 0 11-6 0zm-2.6 5.3a.5.5 0 00.3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 013.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 00-4.1 3.7z\"/><circle cx=\"14\" cy=\"4\" r=\"1\"/><circle cx=\"12\" cy=\"2\" r=\"1\"/><circle cx=\"10\" cy=\"4\" r=\"1\"/></g></svg>',\r\n    'text-color': '<svg width=\"24\" height=\"24\"><g fill-rule=\"evenodd\"><path id=\"tox-icon-text-color__color\" d=\"M3 18h18v3H3z\"/><path d=\"M8.7 16h-.8a.5.5 0 01-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 01-.5.6h-.8a.5.5 0 01-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4zm2.6-7.6l-.6 2a.5.5 0 00.5.6h1.6a.5.5 0 00.5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4z\"/></g></svg>',\r\n    'toc': '<svg width=\"24\" height=\"24\"><path d=\"M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 110-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 110-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 110-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 010-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'translate': '<svg width=\"24\" height=\"24\"><path d=\"M12.7 14.3l-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 010-1l3.1-3A12.4 12.4 0 016.7 9H8a10.1 10.1 0 001.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 110-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 01-1 2.4 13.5 13.5 0 01-1.7 2.3l1.9 1.8zm4.3-3l2.7 7.3a.5.5 0 01-.4.7 1 1 0 01-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 01-1 .7.5.5 0 01-.4-.7l2.7-7.4a1 1 0 012 0zm-2.2 4.4h2.4L16 12.5l-1.2 3.2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'underline': '<svg width=\"24\" height=\"24\"><path d=\"M16 5c.6 0 1 .4 1 1v5.5a4 4 0 01-.4 1.8l-1 1.4a5.3 5.3 0 01-5.5 1 5 5 0 01-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 01-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 002.2.8 3.4 3.4 0 002.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1zM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 010-2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'undo': '<svg width=\"24\" height=\"24\"><path d=\"M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 01-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 11-1.4 1.4l-5-5a1 1 0 010-1.4l5-5a1 1 0 011.4 1.4L6.4 8z\" fill-rule=\"nonzero\"/></svg>',\r\n    'unlink': '<svg width=\"24\" height=\"24\"><path d=\"M6.2 12.3a1 1 0 011.4 1.4l-2 2a2 2 0 102.6 2.8l4.8-4.8a1 1 0 000-1.4 1 1 0 111.4-1.3 2.9 2.9 0 010 4L9.6 20a3.9 3.9 0 01-5.5-5.5l2-2zm11.6-.6a1 1 0 01-1.4-1.4l2.1-2a2 2 0 10-2.7-2.8L11 10.3a1 1 0 000 1.4A1 1 0 119.6 13a2.9 2.9 0 010-4L14.4 4a3.9 3.9 0 015.5 5.5l-2 2zM7.6 6.3a.8.8 0 01-1 1.1L3.3 4.2a.7.7 0 111-1l3.2 3.1zM5.1 8.6a.8.8 0 010 1.5H3a.8.8 0 010-1.5H5zm5-3.5a.8.8 0 01-1.5 0V3a.8.8 0 011.5 0V5zm6 11.8a.8.8 0 011-1l3.2 3.2a.8.8 0 01-1 1L16 17zm-2.2 2a.8.8 0 011.5 0V21a.8.8 0 01-1.5 0V19zm5-3.5a.7.7 0 110-1.5H21a.8.8 0 010 1.5H19z\" fill-rule=\"nonzero\"/></svg>',\r\n    'unlock': '<svg width=\"24\" height=\"24\"><path d=\"M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 00-.3-.7A1 1 0 0016 7h-2a1 1 0 00-.7.3 1 1 0 00-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 01-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'unordered-list': '<svg width=\"24\" height=\"24\"><path d=\"M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 010-2zM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1z\" fill-rule=\"evenodd\"/></svg>',\r\n    'unselected': '<svg width=\"24\" height=\"24\"><path fill-rule=\"nonzero\" d=\"M6 4h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6c0-1.1.9-2 2-2zm0 1a1 1 0 00-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6z\"/></svg>',\r\n    'upload': '<svg width=\"24\" height=\"24\"><path d=\"M18 19v-2a1 1 0 012 0v3c0 .6-.4 1-1 1H5a1 1 0 01-1-1v-3a1 1 0 012 0v2h12zM11 6.4L8.7 8.7a1 1 0 01-1.4-1.4l4-4a1 1 0 011.4 0l4 4a1 1 0 11-1.4 1.4L13 6.4V16a1 1 0 01-2 0V6.4z\" fill-rule=\"nonzero\"/></svg>',\r\n    'user': '<svg width=\"24\" height=\"24\"><path d=\"M12 24a12 12 0 110-24 12 12 0 010 24zm-8.7-5.3a11 11 0 0017.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7zM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13z\" fill-rule=\"nonzero\"/></svg>',\r\n    'vertical-align': '<svg width=\"24\" height=\"24\"><g fill-rule=\"nonzero\"><rect width=\"18\" height=\"2\" x=\"3\" y=\"11\" rx=\"1\"/><path d=\"M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 011.2 1.5l-.1.1-4.1 3-4-3a1 1 0 011-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8l4 2.9a1 1 0 01-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 01-1-1v-4l-2 1.3a1 1 0 01-1.2-.1l-.1-.1a1 1 0 01.1-1.3l.1-.1 4.1-3z\"/></g></svg>',\r\n    'visualblocks': '<svg width=\"24\" height=\"24\"><path d=\"M9 19v2H7v-2h2zm-4 0v2a2 2 0 01-2-2h2zm8 0v2h-2v-2h2zm8 0a2 2 0 01-2 2v-2h2zm-4 0v2h-2v-2h2zM15 7a1 1 0 010 2v7a1 1 0 01-2 0V9h-1v7a1 1 0 01-2 0v-4a2.5 2.5 0 01-.2-5H15zM5 15v2H3v-2h2zm16 0v2h-2v-2h2zM5 11v2H3v-2h2zm16 0v2h-2v-2h2zM5 7v2H3V7h2zm16 0v2h-2V7h2zM5 3v2H3c0-1.1.9-2 2-2zm8 0v2h-2V3h2zm6 0a2 2 0 012 2h-2V3zM9 3v2H7V3h2zm8 0v2h-2V3h2z\" fill-rule=\"evenodd\"/></svg>',\r\n    'visualchars': '<svg width=\"24\" height=\"24\"><path d=\"M10 5h7a1 1 0 010 2h-1v11a1 1 0 01-2 0V7h-2v11a1 1 0 01-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 016.8 10a3.3 3.3 0 010-2.8 3.4 3.4 0 011.8-1.8L10 5z\" fill-rule=\"evenodd\"/></svg>',\r\n    'warning': '<svg width=\"24\" height=\"24\"><path d=\"M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6zM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 00-.3-.7 1 1 0 00-.7-.3 1 1 0 00-.7.3 1 1 0 00-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3zm.7-3l.3-4a1 1 0 00-.3-.7 1 1 0 00-.7-.3 1 1 0 00-.7.3 1 1 0 00-.3.7l.3 4h1.4z\" fill-rule=\"evenodd\"/></svg>',\r\n    'zoom-in': '<svg width=\"24\" height=\"24\"><path d=\"M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12zm-1-9a1 1 0 012 0v6a1 1 0 01-2 0V8zm-2 4a1 1 0 010-2h6a1 1 0 010 2H8z\" fill-rule=\"nonzero\"/></svg>',\r\n    'zoom-out': '<svg width=\"24\" height=\"24\"><path d=\"M16 17.3a8 8 0 111.4-1.4l4.3 4.4a1 1 0 01-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 100-12 6 6 0 000 12zm-3-5a1 1 0 010-2h6a1 1 0 010 2H8z\" fill-rule=\"nonzero\"/></svg>',\r\n  }\r\n});\n\n//# sourceURL=webpack://test/./node_modules/tinymce/icons/default/icons.js?\n}");

/***/ }),

/***/ "./node_modules/tinymce/icons/default/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/tinymce/icons/default/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("{// Exports the \"default\" icons for usage with module loaders\r\n// Usage:\r\n//   CommonJS:\r\n//     require('tinymce/icons/default')\r\n//   ES2015:\r\n//     import 'tinymce/icons/default'\r\n__webpack_require__(/*! ./icons.js */ \"./node_modules/tinymce/icons/default/icons.js\");\n\n//# sourceURL=webpack://test/./node_modules/tinymce/icons/default/index.js?\n}");

/***/ }),

/***/ "./node_modules/tinymce/plugins/lists/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/tinymce/plugins/lists/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("{// Exports the \"lists\" plugin for usage with module loaders\r\n// Usage:\r\n//   CommonJS:\r\n//     require('tinymce/plugins/lists')\r\n//   ES2015:\r\n//     import 'tinymce/plugins/lists'\r\n__webpack_require__(/*! ./plugin.js */ \"./node_modules/tinymce/plugins/lists/plugin.js\");\n\n//# sourceURL=webpack://test/./node_modules/tinymce/plugins/lists/index.js?\n}");

/***/ }),

/***/ "./node_modules/tinymce/plugins/lists/plugin.js":
/*!******************************************************!*\
  !*** ./node_modules/tinymce/plugins/lists/plugin.js ***!
  \******************************************************/
/***/ (() => {

eval("{/**\r\n * Copyright (c) Tiny Technologies, Inc. All rights reserved.\r\n * Licensed under the LGPL or a commercial license.\r\n * For LGPL see License.txt in the project root for license information.\r\n * For commercial licenses see https://www.tiny.cloud/\r\n *\r\n * Version: 5.10.8 (2023-10-19)\r\n */\r\n(function () {\r\n    'use strict';\r\n\r\n    var global$7 = tinymce.util.Tools.resolve('tinymce.PluginManager');\r\n\r\n    var typeOf = function (x) {\r\n      var t = typeof x;\r\n      if (x === null) {\r\n        return 'null';\r\n      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\r\n        return 'array';\r\n      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\r\n        return 'string';\r\n      } else {\r\n        return t;\r\n      }\r\n    };\r\n    var isType$1 = function (type) {\r\n      return function (value) {\r\n        return typeOf(value) === type;\r\n      };\r\n    };\r\n    var isSimpleType = function (type) {\r\n      return function (value) {\r\n        return typeof value === type;\r\n      };\r\n    };\r\n    var isString = isType$1('string');\r\n    var isObject = isType$1('object');\r\n    var isArray = isType$1('array');\r\n    var isBoolean = isSimpleType('boolean');\r\n    var isFunction = isSimpleType('function');\r\n    var isNumber = isSimpleType('number');\r\n\r\n    var noop = function () {\r\n    };\r\n    var constant = function (value) {\r\n      return function () {\r\n        return value;\r\n      };\r\n    };\r\n    var identity = function (x) {\r\n      return x;\r\n    };\r\n    var tripleEquals = function (a, b) {\r\n      return a === b;\r\n    };\r\n    var not = function (f) {\r\n      return function (t) {\r\n        return !f(t);\r\n      };\r\n    };\r\n    var never = constant(false);\r\n    var always = constant(true);\r\n\r\n    var none = function () {\r\n      return NONE;\r\n    };\r\n    var NONE = function () {\r\n      var call = function (thunk) {\r\n        return thunk();\r\n      };\r\n      var id = identity;\r\n      var me = {\r\n        fold: function (n, _s) {\r\n          return n();\r\n        },\r\n        isSome: never,\r\n        isNone: always,\r\n        getOr: id,\r\n        getOrThunk: call,\r\n        getOrDie: function (msg) {\r\n          throw new Error(msg || 'error: getOrDie called on none.');\r\n        },\r\n        getOrNull: constant(null),\r\n        getOrUndefined: constant(undefined),\r\n        or: id,\r\n        orThunk: call,\r\n        map: none,\r\n        each: noop,\r\n        bind: none,\r\n        exists: never,\r\n        forall: always,\r\n        filter: function () {\r\n          return none();\r\n        },\r\n        toArray: function () {\r\n          return [];\r\n        },\r\n        toString: constant('none()')\r\n      };\r\n      return me;\r\n    }();\r\n    var some = function (a) {\r\n      var constant_a = constant(a);\r\n      var self = function () {\r\n        return me;\r\n      };\r\n      var bind = function (f) {\r\n        return f(a);\r\n      };\r\n      var me = {\r\n        fold: function (n, s) {\r\n          return s(a);\r\n        },\r\n        isSome: always,\r\n        isNone: never,\r\n        getOr: constant_a,\r\n        getOrThunk: constant_a,\r\n        getOrDie: constant_a,\r\n        getOrNull: constant_a,\r\n        getOrUndefined: constant_a,\r\n        or: self,\r\n        orThunk: self,\r\n        map: function (f) {\r\n          return some(f(a));\r\n        },\r\n        each: function (f) {\r\n          f(a);\r\n        },\r\n        bind: bind,\r\n        exists: bind,\r\n        forall: bind,\r\n        filter: function (f) {\r\n          return f(a) ? me : NONE;\r\n        },\r\n        toArray: function () {\r\n          return [a];\r\n        },\r\n        toString: function () {\r\n          return 'some(' + a + ')';\r\n        }\r\n      };\r\n      return me;\r\n    };\r\n    var from = function (value) {\r\n      return value === null || value === undefined ? NONE : some(value);\r\n    };\r\n    var Optional = {\r\n      some: some,\r\n      none: none,\r\n      from: from\r\n    };\r\n\r\n    var nativeSlice = Array.prototype.slice;\r\n    var nativePush = Array.prototype.push;\r\n    var map = function (xs, f) {\r\n      var len = xs.length;\r\n      var r = new Array(len);\r\n      for (var i = 0; i < len; i++) {\r\n        var x = xs[i];\r\n        r[i] = f(x, i);\r\n      }\r\n      return r;\r\n    };\r\n    var each$1 = function (xs, f) {\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    var filter$1 = function (xs, pred) {\r\n      var r = [];\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        if (pred(x, i)) {\r\n          r.push(x);\r\n        }\r\n      }\r\n      return r;\r\n    };\r\n    var groupBy = function (xs, f) {\r\n      if (xs.length === 0) {\r\n        return [];\r\n      } else {\r\n        var wasType = f(xs[0]);\r\n        var r = [];\r\n        var group = [];\r\n        for (var i = 0, len = xs.length; i < len; i++) {\r\n          var x = xs[i];\r\n          var type = f(x);\r\n          if (type !== wasType) {\r\n            r.push(group);\r\n            group = [];\r\n          }\r\n          wasType = type;\r\n          group.push(x);\r\n        }\r\n        if (group.length !== 0) {\r\n          r.push(group);\r\n        }\r\n        return r;\r\n      }\r\n    };\r\n    var foldl = function (xs, f, acc) {\r\n      each$1(xs, function (x, i) {\r\n        acc = f(acc, x, i);\r\n      });\r\n      return acc;\r\n    };\r\n    var findUntil = function (xs, pred, until) {\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        if (pred(x, i)) {\r\n          return Optional.some(x);\r\n        } else if (until(x, i)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var find$1 = function (xs, pred) {\r\n      return findUntil(xs, pred, never);\r\n    };\r\n    var flatten = function (xs) {\r\n      var r = [];\r\n      for (var i = 0, len = xs.length; i < len; ++i) {\r\n        if (!isArray(xs[i])) {\r\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\r\n        }\r\n        nativePush.apply(r, xs[i]);\r\n      }\r\n      return r;\r\n    };\r\n    var bind = function (xs, f) {\r\n      return flatten(map(xs, f));\r\n    };\r\n    var reverse = function (xs) {\r\n      var r = nativeSlice.call(xs, 0);\r\n      r.reverse();\r\n      return r;\r\n    };\r\n    var get$1 = function (xs, i) {\r\n      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\r\n    };\r\n    var head = function (xs) {\r\n      return get$1(xs, 0);\r\n    };\r\n    var last = function (xs) {\r\n      return get$1(xs, xs.length - 1);\r\n    };\r\n    var findMap = function (arr, f) {\r\n      for (var i = 0; i < arr.length; i++) {\r\n        var r = f(arr[i], i);\r\n        if (r.isSome()) {\r\n          return r;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n\r\n    var __assign = function () {\r\n      __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n          s = arguments[i];\r\n          for (var p in s)\r\n            if (Object.prototype.hasOwnProperty.call(s, p))\r\n              t[p] = s[p];\r\n        }\r\n        return t;\r\n      };\r\n      return __assign.apply(this, arguments);\r\n    };\r\n    function __spreadArray(to, from, pack) {\r\n      if (pack || arguments.length === 2)\r\n        for (var i = 0, l = from.length, ar; i < l; i++) {\r\n          if (ar || !(i in from)) {\r\n            if (!ar)\r\n              ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n          }\r\n        }\r\n      return to.concat(ar || Array.prototype.slice.call(from));\r\n    }\r\n\r\n    var cached = function (f) {\r\n      var called = false;\r\n      var r;\r\n      return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        if (!called) {\r\n          called = true;\r\n          r = f.apply(null, args);\r\n        }\r\n        return r;\r\n      };\r\n    };\r\n\r\n    var DeviceType = function (os, browser, userAgent, mediaMatch) {\r\n      var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\r\n      var isiPhone = os.isiOS() && !isiPad;\r\n      var isMobile = os.isiOS() || os.isAndroid();\r\n      var isTouch = isMobile || mediaMatch('(pointer:coarse)');\r\n      var isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\r\n      var isPhone = isiPhone || isMobile && !isTablet;\r\n      var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\r\n      var isDesktop = !isPhone && !isTablet && !iOSwebview;\r\n      return {\r\n        isiPad: constant(isiPad),\r\n        isiPhone: constant(isiPhone),\r\n        isTablet: constant(isTablet),\r\n        isPhone: constant(isPhone),\r\n        isTouch: constant(isTouch),\r\n        isAndroid: os.isAndroid,\r\n        isiOS: os.isiOS,\r\n        isWebView: constant(iOSwebview),\r\n        isDesktop: constant(isDesktop)\r\n      };\r\n    };\r\n\r\n    var firstMatch = function (regexes, s) {\r\n      for (var i = 0; i < regexes.length; i++) {\r\n        var x = regexes[i];\r\n        if (x.test(s)) {\r\n          return x;\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n    var find = function (regexes, agent) {\r\n      var r = firstMatch(regexes, agent);\r\n      if (!r) {\r\n        return {\r\n          major: 0,\r\n          minor: 0\r\n        };\r\n      }\r\n      var group = function (i) {\r\n        return Number(agent.replace(r, '$' + i));\r\n      };\r\n      return nu$2(group(1), group(2));\r\n    };\r\n    var detect$3 = function (versionRegexes, agent) {\r\n      var cleanedAgent = String(agent).toLowerCase();\r\n      if (versionRegexes.length === 0) {\r\n        return unknown$2();\r\n      }\r\n      return find(versionRegexes, cleanedAgent);\r\n    };\r\n    var unknown$2 = function () {\r\n      return nu$2(0, 0);\r\n    };\r\n    var nu$2 = function (major, minor) {\r\n      return {\r\n        major: major,\r\n        minor: minor\r\n      };\r\n    };\r\n    var Version = {\r\n      nu: nu$2,\r\n      detect: detect$3,\r\n      unknown: unknown$2\r\n    };\r\n\r\n    var detectBrowser$1 = function (browsers, userAgentData) {\r\n      return findMap(userAgentData.brands, function (uaBrand) {\r\n        var lcBrand = uaBrand.brand.toLowerCase();\r\n        return find$1(browsers, function (browser) {\r\n          var _a;\r\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\r\n        }).map(function (info) {\r\n          return {\r\n            current: info.name,\r\n            version: Version.nu(parseInt(uaBrand.version, 10), 0)\r\n          };\r\n        });\r\n      });\r\n    };\r\n\r\n    var detect$2 = function (candidates, userAgent) {\r\n      var agent = String(userAgent).toLowerCase();\r\n      return find$1(candidates, function (candidate) {\r\n        return candidate.search(agent);\r\n      });\r\n    };\r\n    var detectBrowser = function (browsers, userAgent) {\r\n      return detect$2(browsers, userAgent).map(function (browser) {\r\n        var version = Version.detect(browser.versionRegexes, userAgent);\r\n        return {\r\n          current: browser.name,\r\n          version: version\r\n        };\r\n      });\r\n    };\r\n    var detectOs = function (oses, userAgent) {\r\n      return detect$2(oses, userAgent).map(function (os) {\r\n        var version = Version.detect(os.versionRegexes, userAgent);\r\n        return {\r\n          current: os.name,\r\n          version: version\r\n        };\r\n      });\r\n    };\r\n\r\n    var contains$1 = function (str, substr) {\r\n      return str.indexOf(substr) !== -1;\r\n    };\r\n    var blank = function (r) {\r\n      return function (s) {\r\n        return s.replace(r, '');\r\n      };\r\n    };\r\n    var trim = blank(/^\\s+|\\s+$/g);\r\n    var isNotEmpty = function (s) {\r\n      return s.length > 0;\r\n    };\r\n    var isEmpty$1 = function (s) {\r\n      return !isNotEmpty(s);\r\n    };\r\n\r\n    var normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\r\n    var checkContains = function (target) {\r\n      return function (uastring) {\r\n        return contains$1(uastring, target);\r\n      };\r\n    };\r\n    var browsers = [\r\n      {\r\n        name: 'Edge',\r\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\r\n        search: function (uastring) {\r\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\r\n        }\r\n      },\r\n      {\r\n        name: 'Chrome',\r\n        brand: 'Chromium',\r\n        versionRegexes: [\r\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\r\n          normalVersionRegex\r\n        ],\r\n        search: function (uastring) {\r\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\r\n        }\r\n      },\r\n      {\r\n        name: 'IE',\r\n        versionRegexes: [\r\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\r\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\r\n        ],\r\n        search: function (uastring) {\r\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\r\n        }\r\n      },\r\n      {\r\n        name: 'Opera',\r\n        versionRegexes: [\r\n          normalVersionRegex,\r\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\r\n        ],\r\n        search: checkContains('opera')\r\n      },\r\n      {\r\n        name: 'Firefox',\r\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\r\n        search: checkContains('firefox')\r\n      },\r\n      {\r\n        name: 'Safari',\r\n        versionRegexes: [\r\n          normalVersionRegex,\r\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\r\n        ],\r\n        search: function (uastring) {\r\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\r\n        }\r\n      }\r\n    ];\r\n    var oses = [\r\n      {\r\n        name: 'Windows',\r\n        search: checkContains('win'),\r\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'iOS',\r\n        search: function (uastring) {\r\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\r\n        },\r\n        versionRegexes: [\r\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\r\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\r\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\r\n        ]\r\n      },\r\n      {\r\n        name: 'Android',\r\n        search: checkContains('android'),\r\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'OSX',\r\n        search: checkContains('mac os x'),\r\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'Linux',\r\n        search: checkContains('linux'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'Solaris',\r\n        search: checkContains('sunos'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'FreeBSD',\r\n        search: checkContains('freebsd'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'ChromeOS',\r\n        search: checkContains('cros'),\r\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\r\n      }\r\n    ];\r\n    var PlatformInfo = {\r\n      browsers: constant(browsers),\r\n      oses: constant(oses)\r\n    };\r\n\r\n    var edge = 'Edge';\r\n    var chrome = 'Chrome';\r\n    var ie = 'IE';\r\n    var opera = 'Opera';\r\n    var firefox = 'Firefox';\r\n    var safari = 'Safari';\r\n    var unknown$1 = function () {\r\n      return nu$1({\r\n        current: undefined,\r\n        version: Version.unknown()\r\n      });\r\n    };\r\n    var nu$1 = function (info) {\r\n      var current = info.current;\r\n      var version = info.version;\r\n      var isBrowser = function (name) {\r\n        return function () {\r\n          return current === name;\r\n        };\r\n      };\r\n      return {\r\n        current: current,\r\n        version: version,\r\n        isEdge: isBrowser(edge),\r\n        isChrome: isBrowser(chrome),\r\n        isIE: isBrowser(ie),\r\n        isOpera: isBrowser(opera),\r\n        isFirefox: isBrowser(firefox),\r\n        isSafari: isBrowser(safari)\r\n      };\r\n    };\r\n    var Browser = {\r\n      unknown: unknown$1,\r\n      nu: nu$1,\r\n      edge: constant(edge),\r\n      chrome: constant(chrome),\r\n      ie: constant(ie),\r\n      opera: constant(opera),\r\n      firefox: constant(firefox),\r\n      safari: constant(safari)\r\n    };\r\n\r\n    var windows = 'Windows';\r\n    var ios = 'iOS';\r\n    var android = 'Android';\r\n    var linux = 'Linux';\r\n    var osx = 'OSX';\r\n    var solaris = 'Solaris';\r\n    var freebsd = 'FreeBSD';\r\n    var chromeos = 'ChromeOS';\r\n    var unknown = function () {\r\n      return nu({\r\n        current: undefined,\r\n        version: Version.unknown()\r\n      });\r\n    };\r\n    var nu = function (info) {\r\n      var current = info.current;\r\n      var version = info.version;\r\n      var isOS = function (name) {\r\n        return function () {\r\n          return current === name;\r\n        };\r\n      };\r\n      return {\r\n        current: current,\r\n        version: version,\r\n        isWindows: isOS(windows),\r\n        isiOS: isOS(ios),\r\n        isAndroid: isOS(android),\r\n        isOSX: isOS(osx),\r\n        isLinux: isOS(linux),\r\n        isSolaris: isOS(solaris),\r\n        isFreeBSD: isOS(freebsd),\r\n        isChromeOS: isOS(chromeos)\r\n      };\r\n    };\r\n    var OperatingSystem = {\r\n      unknown: unknown,\r\n      nu: nu,\r\n      windows: constant(windows),\r\n      ios: constant(ios),\r\n      android: constant(android),\r\n      linux: constant(linux),\r\n      osx: constant(osx),\r\n      solaris: constant(solaris),\r\n      freebsd: constant(freebsd),\r\n      chromeos: constant(chromeos)\r\n    };\r\n\r\n    var detect$1 = function (userAgent, userAgentDataOpt, mediaMatch) {\r\n      var browsers = PlatformInfo.browsers();\r\n      var oses = PlatformInfo.oses();\r\n      var browser = userAgentDataOpt.bind(function (userAgentData) {\r\n        return detectBrowser$1(browsers, userAgentData);\r\n      }).orThunk(function () {\r\n        return detectBrowser(browsers, userAgent);\r\n      }).fold(Browser.unknown, Browser.nu);\r\n      var os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\r\n      var deviceType = DeviceType(os, browser, userAgent, mediaMatch);\r\n      return {\r\n        browser: browser,\r\n        os: os,\r\n        deviceType: deviceType\r\n      };\r\n    };\r\n    var PlatformDetection = { detect: detect$1 };\r\n\r\n    var mediaMatch = function (query) {\r\n      return window.matchMedia(query).matches;\r\n    };\r\n    var platform = cached(function () {\r\n      return PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch);\r\n    });\r\n    var detect = function () {\r\n      return platform();\r\n    };\r\n\r\n    var compareDocumentPosition = function (a, b, match) {\r\n      return (a.compareDocumentPosition(b) & match) !== 0;\r\n    };\r\n    var documentPositionContainedBy = function (a, b) {\r\n      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_CONTAINED_BY);\r\n    };\r\n\r\n    var ELEMENT = 1;\r\n\r\n    var fromHtml = function (html, scope) {\r\n      var doc = scope || document;\r\n      var div = doc.createElement('div');\r\n      div.innerHTML = html;\r\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\r\n        console.error('HTML does not have a single root node', html);\r\n        throw new Error('HTML must have a single root node');\r\n      }\r\n      return fromDom(div.childNodes[0]);\r\n    };\r\n    var fromTag = function (tag, scope) {\r\n      var doc = scope || document;\r\n      var node = doc.createElement(tag);\r\n      return fromDom(node);\r\n    };\r\n    var fromText = function (text, scope) {\r\n      var doc = scope || document;\r\n      var node = doc.createTextNode(text);\r\n      return fromDom(node);\r\n    };\r\n    var fromDom = function (node) {\r\n      if (node === null || node === undefined) {\r\n        throw new Error('Node cannot be null or undefined');\r\n      }\r\n      return { dom: node };\r\n    };\r\n    var fromPoint = function (docElm, x, y) {\r\n      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\r\n    };\r\n    var SugarElement = {\r\n      fromHtml: fromHtml,\r\n      fromTag: fromTag,\r\n      fromText: fromText,\r\n      fromDom: fromDom,\r\n      fromPoint: fromPoint\r\n    };\r\n\r\n    var is$2 = function (element, selector) {\r\n      var dom = element.dom;\r\n      if (dom.nodeType !== ELEMENT) {\r\n        return false;\r\n      } else {\r\n        var elem = dom;\r\n        if (elem.matches !== undefined) {\r\n          return elem.matches(selector);\r\n        } else if (elem.msMatchesSelector !== undefined) {\r\n          return elem.msMatchesSelector(selector);\r\n        } else if (elem.webkitMatchesSelector !== undefined) {\r\n          return elem.webkitMatchesSelector(selector);\r\n        } else if (elem.mozMatchesSelector !== undefined) {\r\n          return elem.mozMatchesSelector(selector);\r\n        } else {\r\n          throw new Error('Browser lacks native selectors');\r\n        }\r\n      }\r\n    };\r\n\r\n    var eq = function (e1, e2) {\r\n      return e1.dom === e2.dom;\r\n    };\r\n    var regularContains = function (e1, e2) {\r\n      var d1 = e1.dom;\r\n      var d2 = e2.dom;\r\n      return d1 === d2 ? false : d1.contains(d2);\r\n    };\r\n    var ieContains = function (e1, e2) {\r\n      return documentPositionContainedBy(e1.dom, e2.dom);\r\n    };\r\n    var contains = function (e1, e2) {\r\n      return detect().browser.isIE() ? ieContains(e1, e2) : regularContains(e1, e2);\r\n    };\r\n    var is$1 = is$2;\r\n\r\n    var global$6 = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils');\r\n\r\n    var global$5 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\r\n\r\n    var global$4 = tinymce.util.Tools.resolve('tinymce.util.VK');\r\n\r\n    var keys = Object.keys;\r\n    var each = function (obj, f) {\r\n      var props = keys(obj);\r\n      for (var k = 0, len = props.length; k < len; k++) {\r\n        var i = props[k];\r\n        var x = obj[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    var objAcc = function (r) {\r\n      return function (x, i) {\r\n        r[i] = x;\r\n      };\r\n    };\r\n    var internalFilter = function (obj, pred, onTrue, onFalse) {\r\n      var r = {};\r\n      each(obj, function (x, i) {\r\n        (pred(x, i) ? onTrue : onFalse)(x, i);\r\n      });\r\n      return r;\r\n    };\r\n    var filter = function (obj, pred) {\r\n      var t = {};\r\n      internalFilter(obj, pred, objAcc(t), noop);\r\n      return t;\r\n    };\r\n\r\n    typeof window !== 'undefined' ? window : Function('return this;')();\r\n\r\n    var name = function (element) {\r\n      var r = element.dom.nodeName;\r\n      return r.toLowerCase();\r\n    };\r\n    var type = function (element) {\r\n      return element.dom.nodeType;\r\n    };\r\n    var isType = function (t) {\r\n      return function (element) {\r\n        return type(element) === t;\r\n      };\r\n    };\r\n    var isElement = isType(ELEMENT);\r\n    var isTag = function (tag) {\r\n      return function (e) {\r\n        return isElement(e) && name(e) === tag;\r\n      };\r\n    };\r\n\r\n    var rawSet = function (dom, key, value) {\r\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\r\n        dom.setAttribute(key, value + '');\r\n      } else {\r\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\r\n        throw new Error('Attribute value was not simple');\r\n      }\r\n    };\r\n    var setAll = function (element, attrs) {\r\n      var dom = element.dom;\r\n      each(attrs, function (v, k) {\r\n        rawSet(dom, k, v);\r\n      });\r\n    };\r\n    var clone$1 = function (element) {\r\n      return foldl(element.dom.attributes, function (acc, attr) {\r\n        acc[attr.name] = attr.value;\r\n        return acc;\r\n      }, {});\r\n    };\r\n\r\n    var parent = function (element) {\r\n      return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\r\n    };\r\n    var children = function (element) {\r\n      return map(element.dom.childNodes, SugarElement.fromDom);\r\n    };\r\n    var child = function (element, index) {\r\n      var cs = element.dom.childNodes;\r\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\r\n    };\r\n    var firstChild = function (element) {\r\n      return child(element, 0);\r\n    };\r\n    var lastChild = function (element) {\r\n      return child(element, element.dom.childNodes.length - 1);\r\n    };\r\n\r\n    var before$1 = function (marker, element) {\r\n      var parent$1 = parent(marker);\r\n      parent$1.each(function (v) {\r\n        v.dom.insertBefore(element.dom, marker.dom);\r\n      });\r\n    };\r\n    var append$1 = function (parent, element) {\r\n      parent.dom.appendChild(element.dom);\r\n    };\r\n\r\n    var before = function (marker, elements) {\r\n      each$1(elements, function (x) {\r\n        before$1(marker, x);\r\n      });\r\n    };\r\n    var append = function (parent, elements) {\r\n      each$1(elements, function (x) {\r\n        append$1(parent, x);\r\n      });\r\n    };\r\n\r\n    var remove = function (element) {\r\n      var dom = element.dom;\r\n      if (dom.parentNode !== null) {\r\n        dom.parentNode.removeChild(dom);\r\n      }\r\n    };\r\n\r\n    var clone = function (original, isDeep) {\r\n      return SugarElement.fromDom(original.dom.cloneNode(isDeep));\r\n    };\r\n    var deep = function (original) {\r\n      return clone(original, true);\r\n    };\r\n    var shallowAs = function (original, tag) {\r\n      var nu = SugarElement.fromTag(tag);\r\n      var attributes = clone$1(original);\r\n      setAll(nu, attributes);\r\n      return nu;\r\n    };\r\n    var mutate = function (original, tag) {\r\n      var nu = shallowAs(original, tag);\r\n      before$1(original, nu);\r\n      var children$1 = children(original);\r\n      append(nu, children$1);\r\n      remove(original);\r\n      return nu;\r\n    };\r\n\r\n    var global$3 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\r\n\r\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');\r\n\r\n    var matchNodeName = function (name) {\r\n      return function (node) {\r\n        return node && node.nodeName.toLowerCase() === name;\r\n      };\r\n    };\r\n    var matchNodeNames = function (regex) {\r\n      return function (node) {\r\n        return node && regex.test(node.nodeName);\r\n      };\r\n    };\r\n    var isTextNode = function (node) {\r\n      return node && node.nodeType === 3;\r\n    };\r\n    var isListNode = matchNodeNames(/^(OL|UL|DL)$/);\r\n    var isOlUlNode = matchNodeNames(/^(OL|UL)$/);\r\n    var isOlNode = matchNodeName('ol');\r\n    var isListItemNode = matchNodeNames(/^(LI|DT|DD)$/);\r\n    var isDlItemNode = matchNodeNames(/^(DT|DD)$/);\r\n    var isTableCellNode = matchNodeNames(/^(TH|TD)$/);\r\n    var isBr = matchNodeName('br');\r\n    var isFirstChild = function (node) {\r\n      return node.parentNode.firstChild === node;\r\n    };\r\n    var isTextBlock = function (editor, node) {\r\n      return node && !!editor.schema.getTextBlockElements()[node.nodeName];\r\n    };\r\n    var isBlock = function (node, blockElements) {\r\n      return node && node.nodeName in blockElements;\r\n    };\r\n    var isBogusBr = function (dom, node) {\r\n      if (!isBr(node)) {\r\n        return false;\r\n      }\r\n      return dom.isBlock(node.nextSibling) && !isBr(node.previousSibling);\r\n    };\r\n    var isEmpty = function (dom, elm, keepBookmarks) {\r\n      var empty = dom.isEmpty(elm);\r\n      if (keepBookmarks && dom.select('span[data-mce-type=bookmark]', elm).length > 0) {\r\n        return false;\r\n      }\r\n      return empty;\r\n    };\r\n    var isChildOfBody = function (dom, elm) {\r\n      return dom.isChildOf(elm, dom.getRoot());\r\n    };\r\n\r\n    var shouldIndentOnTab = function (editor) {\r\n      return editor.getParam('lists_indent_on_tab', true);\r\n    };\r\n    var getForcedRootBlock = function (editor) {\r\n      var block = editor.getParam('forced_root_block', 'p');\r\n      if (block === false) {\r\n        return '';\r\n      } else if (block === true) {\r\n        return 'p';\r\n      } else {\r\n        return block;\r\n      }\r\n    };\r\n    var getForcedRootBlockAttrs = function (editor) {\r\n      return editor.getParam('forced_root_block_attrs', {});\r\n    };\r\n\r\n    var createTextBlock = function (editor, contentNode) {\r\n      var dom = editor.dom;\r\n      var blockElements = editor.schema.getBlockElements();\r\n      var fragment = dom.createFragment();\r\n      var blockName = getForcedRootBlock(editor);\r\n      var node, textBlock, hasContentNode;\r\n      if (blockName) {\r\n        textBlock = dom.create(blockName);\r\n        if (textBlock.tagName === blockName.toUpperCase()) {\r\n          dom.setAttribs(textBlock, getForcedRootBlockAttrs(editor));\r\n        }\r\n        if (!isBlock(contentNode.firstChild, blockElements)) {\r\n          fragment.appendChild(textBlock);\r\n        }\r\n      }\r\n      if (contentNode) {\r\n        while (node = contentNode.firstChild) {\r\n          var nodeName = node.nodeName;\r\n          if (!hasContentNode && (nodeName !== 'SPAN' || node.getAttribute('data-mce-type') !== 'bookmark')) {\r\n            hasContentNode = true;\r\n          }\r\n          if (isBlock(node, blockElements)) {\r\n            fragment.appendChild(node);\r\n            textBlock = null;\r\n          } else {\r\n            if (blockName) {\r\n              if (!textBlock) {\r\n                textBlock = dom.create(blockName);\r\n                fragment.appendChild(textBlock);\r\n              }\r\n              textBlock.appendChild(node);\r\n            } else {\r\n              fragment.appendChild(node);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (!blockName) {\r\n        fragment.appendChild(dom.create('br'));\r\n      } else {\r\n        if (!hasContentNode) {\r\n          textBlock.appendChild(dom.create('br', { 'data-mce-bogus': '1' }));\r\n        }\r\n      }\r\n      return fragment;\r\n    };\r\n\r\n    var DOM$2 = global$3.DOM;\r\n    var splitList = function (editor, list, li) {\r\n      var removeAndKeepBookmarks = function (targetNode) {\r\n        global$2.each(bookmarks, function (node) {\r\n          targetNode.parentNode.insertBefore(node, li.parentNode);\r\n        });\r\n        DOM$2.remove(targetNode);\r\n      };\r\n      var bookmarks = DOM$2.select('span[data-mce-type=\"bookmark\"]', list);\r\n      var newBlock = createTextBlock(editor, li);\r\n      var tmpRng = DOM$2.createRng();\r\n      tmpRng.setStartAfter(li);\r\n      tmpRng.setEndAfter(list);\r\n      var fragment = tmpRng.extractContents();\r\n      for (var node = fragment.firstChild; node; node = node.firstChild) {\r\n        if (node.nodeName === 'LI' && editor.dom.isEmpty(node)) {\r\n          DOM$2.remove(node);\r\n          break;\r\n        }\r\n      }\r\n      if (!editor.dom.isEmpty(fragment)) {\r\n        DOM$2.insertAfter(fragment, list);\r\n      }\r\n      DOM$2.insertAfter(newBlock, list);\r\n      if (isEmpty(editor.dom, li.parentNode)) {\r\n        removeAndKeepBookmarks(li.parentNode);\r\n      }\r\n      DOM$2.remove(li);\r\n      if (isEmpty(editor.dom, list)) {\r\n        DOM$2.remove(list);\r\n      }\r\n    };\r\n\r\n    var isDescriptionDetail = isTag('dd');\r\n    var isDescriptionTerm = isTag('dt');\r\n    var outdentDlItem = function (editor, item) {\r\n      if (isDescriptionDetail(item)) {\r\n        mutate(item, 'dt');\r\n      } else if (isDescriptionTerm(item)) {\r\n        parent(item).each(function (dl) {\r\n          return splitList(editor, dl.dom, item.dom);\r\n        });\r\n      }\r\n    };\r\n    var indentDlItem = function (item) {\r\n      if (isDescriptionTerm(item)) {\r\n        mutate(item, 'dd');\r\n      }\r\n    };\r\n    var dlIndentation = function (editor, indentation, dlItems) {\r\n      if (indentation === 'Indent') {\r\n        each$1(dlItems, indentDlItem);\r\n      } else {\r\n        each$1(dlItems, function (item) {\r\n          return outdentDlItem(editor, item);\r\n        });\r\n      }\r\n    };\r\n\r\n    var getNormalizedPoint = function (container, offset) {\r\n      if (isTextNode(container)) {\r\n        return {\r\n          container: container,\r\n          offset: offset\r\n        };\r\n      }\r\n      var node = global$6.getNode(container, offset);\r\n      if (isTextNode(node)) {\r\n        return {\r\n          container: node,\r\n          offset: offset >= container.childNodes.length ? node.data.length : 0\r\n        };\r\n      } else if (node.previousSibling && isTextNode(node.previousSibling)) {\r\n        return {\r\n          container: node.previousSibling,\r\n          offset: node.previousSibling.data.length\r\n        };\r\n      } else if (node.nextSibling && isTextNode(node.nextSibling)) {\r\n        return {\r\n          container: node.nextSibling,\r\n          offset: 0\r\n        };\r\n      }\r\n      return {\r\n        container: container,\r\n        offset: offset\r\n      };\r\n    };\r\n    var normalizeRange = function (rng) {\r\n      var outRng = rng.cloneRange();\r\n      var rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);\r\n      outRng.setStart(rangeStart.container, rangeStart.offset);\r\n      var rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);\r\n      outRng.setEnd(rangeEnd.container, rangeEnd.offset);\r\n      return outRng;\r\n    };\r\n\r\n    var global$1 = tinymce.util.Tools.resolve('tinymce.dom.DomQuery');\r\n\r\n    var getParentList = function (editor, node) {\r\n      var selectionStart = node || editor.selection.getStart(true);\r\n      return editor.dom.getParent(selectionStart, 'OL,UL,DL', getClosestListRootElm(editor, selectionStart));\r\n    };\r\n    var isParentListSelected = function (parentList, selectedBlocks) {\r\n      return parentList && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;\r\n    };\r\n    var findSubLists = function (parentList) {\r\n      return filter$1(parentList.querySelectorAll('ol,ul,dl'), isListNode);\r\n    };\r\n    var getSelectedSubLists = function (editor) {\r\n      var parentList = getParentList(editor);\r\n      var selectedBlocks = editor.selection.getSelectedBlocks();\r\n      if (isParentListSelected(parentList, selectedBlocks)) {\r\n        return findSubLists(parentList);\r\n      } else {\r\n        return filter$1(selectedBlocks, function (elm) {\r\n          return isListNode(elm) && parentList !== elm;\r\n        });\r\n      }\r\n    };\r\n    var findParentListItemsNodes = function (editor, elms) {\r\n      var listItemsElms = global$2.map(elms, function (elm) {\r\n        var parentLi = editor.dom.getParent(elm, 'li,dd,dt', getClosestListRootElm(editor, elm));\r\n        return parentLi ? parentLi : elm;\r\n      });\r\n      return global$1.unique(listItemsElms);\r\n    };\r\n    var getSelectedListItems = function (editor) {\r\n      var selectedBlocks = editor.selection.getSelectedBlocks();\r\n      return filter$1(findParentListItemsNodes(editor, selectedBlocks), isListItemNode);\r\n    };\r\n    var getSelectedDlItems = function (editor) {\r\n      return filter$1(getSelectedListItems(editor), isDlItemNode);\r\n    };\r\n    var getClosestListRootElm = function (editor, elm) {\r\n      var parentTableCell = editor.dom.getParents(elm, 'TD,TH');\r\n      return parentTableCell.length > 0 ? parentTableCell[0] : editor.getBody();\r\n    };\r\n    var findLastParentListNode = function (editor, elm) {\r\n      var parentLists = editor.dom.getParents(elm, 'ol,ul', getClosestListRootElm(editor, elm));\r\n      return last(parentLists);\r\n    };\r\n    var getSelectedLists = function (editor) {\r\n      var firstList = findLastParentListNode(editor, editor.selection.getStart());\r\n      var subsequentLists = filter$1(editor.selection.getSelectedBlocks(), isOlUlNode);\r\n      return firstList.toArray().concat(subsequentLists);\r\n    };\r\n    var getSelectedListRoots = function (editor) {\r\n      var selectedLists = getSelectedLists(editor);\r\n      return getUniqueListRoots(editor, selectedLists);\r\n    };\r\n    var getUniqueListRoots = function (editor, lists) {\r\n      var listRoots = map(lists, function (list) {\r\n        return findLastParentListNode(editor, list).getOr(list);\r\n      });\r\n      return global$1.unique(listRoots);\r\n    };\r\n\r\n    var is = function (lhs, rhs, comparator) {\r\n      if (comparator === void 0) {\r\n        comparator = tripleEquals;\r\n      }\r\n      return lhs.exists(function (left) {\r\n        return comparator(left, rhs);\r\n      });\r\n    };\r\n    var lift2 = function (oa, ob, f) {\r\n      return oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\r\n    };\r\n\r\n    var fromElements = function (elements, scope) {\r\n      var doc = scope || document;\r\n      var fragment = doc.createDocumentFragment();\r\n      each$1(elements, function (element) {\r\n        fragment.appendChild(element.dom);\r\n      });\r\n      return SugarElement.fromDom(fragment);\r\n    };\r\n\r\n    var fireListEvent = function (editor, action, element) {\r\n      return editor.fire('ListMutation', {\r\n        action: action,\r\n        element: element\r\n      });\r\n    };\r\n\r\n    var isSupported = function (dom) {\r\n      return dom.style !== undefined && isFunction(dom.style.getPropertyValue);\r\n    };\r\n\r\n    var internalSet = function (dom, property, value) {\r\n      if (!isString(value)) {\r\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\r\n        throw new Error('CSS value must be a string: ' + value);\r\n      }\r\n      if (isSupported(dom)) {\r\n        dom.style.setProperty(property, value);\r\n      }\r\n    };\r\n    var set = function (element, property, value) {\r\n      var dom = element.dom;\r\n      internalSet(dom, property, value);\r\n    };\r\n\r\n    var joinSegment = function (parent, child) {\r\n      append$1(parent.item, child.list);\r\n    };\r\n    var joinSegments = function (segments) {\r\n      for (var i = 1; i < segments.length; i++) {\r\n        joinSegment(segments[i - 1], segments[i]);\r\n      }\r\n    };\r\n    var appendSegments = function (head$1, tail) {\r\n      lift2(last(head$1), head(tail), joinSegment);\r\n    };\r\n    var createSegment = function (scope, listType) {\r\n      var segment = {\r\n        list: SugarElement.fromTag(listType, scope),\r\n        item: SugarElement.fromTag('li', scope)\r\n      };\r\n      append$1(segment.list, segment.item);\r\n      return segment;\r\n    };\r\n    var createSegments = function (scope, entry, size) {\r\n      var segments = [];\r\n      for (var i = 0; i < size; i++) {\r\n        segments.push(createSegment(scope, entry.listType));\r\n      }\r\n      return segments;\r\n    };\r\n    var populateSegments = function (segments, entry) {\r\n      for (var i = 0; i < segments.length - 1; i++) {\r\n        set(segments[i].item, 'list-style-type', 'none');\r\n      }\r\n      last(segments).each(function (segment) {\r\n        setAll(segment.list, entry.listAttributes);\r\n        setAll(segment.item, entry.itemAttributes);\r\n        append(segment.item, entry.content);\r\n      });\r\n    };\r\n    var normalizeSegment = function (segment, entry) {\r\n      if (name(segment.list) !== entry.listType) {\r\n        segment.list = mutate(segment.list, entry.listType);\r\n      }\r\n      setAll(segment.list, entry.listAttributes);\r\n    };\r\n    var createItem = function (scope, attr, content) {\r\n      var item = SugarElement.fromTag('li', scope);\r\n      setAll(item, attr);\r\n      append(item, content);\r\n      return item;\r\n    };\r\n    var appendItem = function (segment, item) {\r\n      append$1(segment.list, item);\r\n      segment.item = item;\r\n    };\r\n    var writeShallow = function (scope, cast, entry) {\r\n      var newCast = cast.slice(0, entry.depth);\r\n      last(newCast).each(function (segment) {\r\n        var item = createItem(scope, entry.itemAttributes, entry.content);\r\n        appendItem(segment, item);\r\n        normalizeSegment(segment, entry);\r\n      });\r\n      return newCast;\r\n    };\r\n    var writeDeep = function (scope, cast, entry) {\r\n      var segments = createSegments(scope, entry, entry.depth - cast.length);\r\n      joinSegments(segments);\r\n      populateSegments(segments, entry);\r\n      appendSegments(cast, segments);\r\n      return cast.concat(segments);\r\n    };\r\n    var composeList = function (scope, entries) {\r\n      var cast = foldl(entries, function (cast, entry) {\r\n        return entry.depth > cast.length ? writeDeep(scope, cast, entry) : writeShallow(scope, cast, entry);\r\n      }, []);\r\n      return head(cast).map(function (segment) {\r\n        return segment.list;\r\n      });\r\n    };\r\n\r\n    var isList = function (el) {\r\n      return is$1(el, 'OL,UL');\r\n    };\r\n    var hasFirstChildList = function (el) {\r\n      return firstChild(el).exists(isList);\r\n    };\r\n    var hasLastChildList = function (el) {\r\n      return lastChild(el).exists(isList);\r\n    };\r\n\r\n    var isIndented = function (entry) {\r\n      return entry.depth > 0;\r\n    };\r\n    var isSelected = function (entry) {\r\n      return entry.isSelected;\r\n    };\r\n    var cloneItemContent = function (li) {\r\n      var children$1 = children(li);\r\n      var content = hasLastChildList(li) ? children$1.slice(0, -1) : children$1;\r\n      return map(content, deep);\r\n    };\r\n    var createEntry = function (li, depth, isSelected) {\r\n      return parent(li).filter(isElement).map(function (list) {\r\n        return {\r\n          depth: depth,\r\n          dirty: false,\r\n          isSelected: isSelected,\r\n          content: cloneItemContent(li),\r\n          itemAttributes: clone$1(li),\r\n          listAttributes: clone$1(list),\r\n          listType: name(list)\r\n        };\r\n      });\r\n    };\r\n\r\n    var indentEntry = function (indentation, entry) {\r\n      switch (indentation) {\r\n      case 'Indent':\r\n        entry.depth++;\r\n        break;\r\n      case 'Outdent':\r\n        entry.depth--;\r\n        break;\r\n      case 'Flatten':\r\n        entry.depth = 0;\r\n      }\r\n      entry.dirty = true;\r\n    };\r\n\r\n    var cloneListProperties = function (target, source) {\r\n      target.listType = source.listType;\r\n      target.listAttributes = __assign({}, source.listAttributes);\r\n    };\r\n    var cleanListProperties = function (entry) {\r\n      entry.listAttributes = filter(entry.listAttributes, function (_value, key) {\r\n        return key !== 'start';\r\n      });\r\n    };\r\n    var closestSiblingEntry = function (entries, start) {\r\n      var depth = entries[start].depth;\r\n      var matches = function (entry) {\r\n        return entry.depth === depth && !entry.dirty;\r\n      };\r\n      var until = function (entry) {\r\n        return entry.depth < depth;\r\n      };\r\n      return findUntil(reverse(entries.slice(0, start)), matches, until).orThunk(function () {\r\n        return findUntil(entries.slice(start + 1), matches, until);\r\n      });\r\n    };\r\n    var normalizeEntries = function (entries) {\r\n      each$1(entries, function (entry, i) {\r\n        closestSiblingEntry(entries, i).fold(function () {\r\n          if (entry.dirty) {\r\n            cleanListProperties(entry);\r\n          }\r\n        }, function (matchingEntry) {\r\n          return cloneListProperties(entry, matchingEntry);\r\n        });\r\n      });\r\n      return entries;\r\n    };\r\n\r\n    var Cell = function (initial) {\r\n      var value = initial;\r\n      var get = function () {\r\n        return value;\r\n      };\r\n      var set = function (v) {\r\n        value = v;\r\n      };\r\n      return {\r\n        get: get,\r\n        set: set\r\n      };\r\n    };\r\n\r\n    var parseItem = function (depth, itemSelection, selectionState, item) {\r\n      return firstChild(item).filter(isList).fold(function () {\r\n        itemSelection.each(function (selection) {\r\n          if (eq(selection.start, item)) {\r\n            selectionState.set(true);\r\n          }\r\n        });\r\n        var currentItemEntry = createEntry(item, depth, selectionState.get());\r\n        itemSelection.each(function (selection) {\r\n          if (eq(selection.end, item)) {\r\n            selectionState.set(false);\r\n          }\r\n        });\r\n        var childListEntries = lastChild(item).filter(isList).map(function (list) {\r\n          return parseList(depth, itemSelection, selectionState, list);\r\n        }).getOr([]);\r\n        return currentItemEntry.toArray().concat(childListEntries);\r\n      }, function (list) {\r\n        return parseList(depth, itemSelection, selectionState, list);\r\n      });\r\n    };\r\n    var parseList = function (depth, itemSelection, selectionState, list) {\r\n      return bind(children(list), function (element) {\r\n        var parser = isList(element) ? parseList : parseItem;\r\n        var newDepth = depth + 1;\r\n        return parser(newDepth, itemSelection, selectionState, element);\r\n      });\r\n    };\r\n    var parseLists = function (lists, itemSelection) {\r\n      var selectionState = Cell(false);\r\n      var initialDepth = 0;\r\n      return map(lists, function (list) {\r\n        return {\r\n          sourceList: list,\r\n          entries: parseList(initialDepth, itemSelection, selectionState, list)\r\n        };\r\n      });\r\n    };\r\n\r\n    var outdentedComposer = function (editor, entries) {\r\n      var normalizedEntries = normalizeEntries(entries);\r\n      return map(normalizedEntries, function (entry) {\r\n        var content = fromElements(entry.content);\r\n        return SugarElement.fromDom(createTextBlock(editor, content.dom));\r\n      });\r\n    };\r\n    var indentedComposer = function (editor, entries) {\r\n      var normalizedEntries = normalizeEntries(entries);\r\n      return composeList(editor.contentDocument, normalizedEntries).toArray();\r\n    };\r\n    var composeEntries = function (editor, entries) {\r\n      return bind(groupBy(entries, isIndented), function (entries) {\r\n        var groupIsIndented = head(entries).exists(isIndented);\r\n        return groupIsIndented ? indentedComposer(editor, entries) : outdentedComposer(editor, entries);\r\n      });\r\n    };\r\n    var indentSelectedEntries = function (entries, indentation) {\r\n      each$1(filter$1(entries, isSelected), function (entry) {\r\n        return indentEntry(indentation, entry);\r\n      });\r\n    };\r\n    var getItemSelection = function (editor) {\r\n      var selectedListItems = map(getSelectedListItems(editor), SugarElement.fromDom);\r\n      return lift2(find$1(selectedListItems, not(hasFirstChildList)), find$1(reverse(selectedListItems), not(hasFirstChildList)), function (start, end) {\r\n        return {\r\n          start: start,\r\n          end: end\r\n        };\r\n      });\r\n    };\r\n    var listIndentation = function (editor, lists, indentation) {\r\n      var entrySets = parseLists(lists, getItemSelection(editor));\r\n      each$1(entrySets, function (entrySet) {\r\n        indentSelectedEntries(entrySet.entries, indentation);\r\n        var composedLists = composeEntries(editor, entrySet.entries);\r\n        each$1(composedLists, function (composedList) {\r\n          fireListEvent(editor, indentation === 'Indent' ? 'IndentList' : 'OutdentList', composedList.dom);\r\n        });\r\n        before(entrySet.sourceList, composedLists);\r\n        remove(entrySet.sourceList);\r\n      });\r\n    };\r\n\r\n    var selectionIndentation = function (editor, indentation) {\r\n      var lists = map(getSelectedListRoots(editor), SugarElement.fromDom);\r\n      var dlItems = map(getSelectedDlItems(editor), SugarElement.fromDom);\r\n      var isHandled = false;\r\n      if (lists.length || dlItems.length) {\r\n        var bookmark = editor.selection.getBookmark();\r\n        listIndentation(editor, lists, indentation);\r\n        dlIndentation(editor, indentation, dlItems);\r\n        editor.selection.moveToBookmark(bookmark);\r\n        editor.selection.setRng(normalizeRange(editor.selection.getRng()));\r\n        editor.nodeChanged();\r\n        isHandled = true;\r\n      }\r\n      return isHandled;\r\n    };\r\n    var indentListSelection = function (editor) {\r\n      return selectionIndentation(editor, 'Indent');\r\n    };\r\n    var outdentListSelection = function (editor) {\r\n      return selectionIndentation(editor, 'Outdent');\r\n    };\r\n    var flattenListSelection = function (editor) {\r\n      return selectionIndentation(editor, 'Flatten');\r\n    };\r\n\r\n    var global = tinymce.util.Tools.resolve('tinymce.dom.BookmarkManager');\r\n\r\n    var DOM$1 = global$3.DOM;\r\n    var createBookmark = function (rng) {\r\n      var bookmark = {};\r\n      var setupEndPoint = function (start) {\r\n        var container = rng[start ? 'startContainer' : 'endContainer'];\r\n        var offset = rng[start ? 'startOffset' : 'endOffset'];\r\n        if (container.nodeType === 1) {\r\n          var offsetNode = DOM$1.create('span', { 'data-mce-type': 'bookmark' });\r\n          if (container.hasChildNodes()) {\r\n            offset = Math.min(offset, container.childNodes.length - 1);\r\n            if (start) {\r\n              container.insertBefore(offsetNode, container.childNodes[offset]);\r\n            } else {\r\n              DOM$1.insertAfter(offsetNode, container.childNodes[offset]);\r\n            }\r\n          } else {\r\n            container.appendChild(offsetNode);\r\n          }\r\n          container = offsetNode;\r\n          offset = 0;\r\n        }\r\n        bookmark[start ? 'startContainer' : 'endContainer'] = container;\r\n        bookmark[start ? 'startOffset' : 'endOffset'] = offset;\r\n      };\r\n      setupEndPoint(true);\r\n      if (!rng.collapsed) {\r\n        setupEndPoint();\r\n      }\r\n      return bookmark;\r\n    };\r\n    var resolveBookmark = function (bookmark) {\r\n      var restoreEndPoint = function (start) {\r\n        var node;\r\n        var nodeIndex = function (container) {\r\n          var node = container.parentNode.firstChild, idx = 0;\r\n          while (node) {\r\n            if (node === container) {\r\n              return idx;\r\n            }\r\n            if (node.nodeType !== 1 || node.getAttribute('data-mce-type') !== 'bookmark') {\r\n              idx++;\r\n            }\r\n            node = node.nextSibling;\r\n          }\r\n          return -1;\r\n        };\r\n        var container = node = bookmark[start ? 'startContainer' : 'endContainer'];\r\n        var offset = bookmark[start ? 'startOffset' : 'endOffset'];\r\n        if (!container) {\r\n          return;\r\n        }\r\n        if (container.nodeType === 1) {\r\n          offset = nodeIndex(container);\r\n          container = container.parentNode;\r\n          DOM$1.remove(node);\r\n          if (!container.hasChildNodes() && DOM$1.isBlock(container)) {\r\n            container.appendChild(DOM$1.create('br'));\r\n          }\r\n        }\r\n        bookmark[start ? 'startContainer' : 'endContainer'] = container;\r\n        bookmark[start ? 'startOffset' : 'endOffset'] = offset;\r\n      };\r\n      restoreEndPoint(true);\r\n      restoreEndPoint();\r\n      var rng = DOM$1.createRng();\r\n      rng.setStart(bookmark.startContainer, bookmark.startOffset);\r\n      if (bookmark.endContainer) {\r\n        rng.setEnd(bookmark.endContainer, bookmark.endOffset);\r\n      }\r\n      return normalizeRange(rng);\r\n    };\r\n\r\n    var listToggleActionFromListName = function (listName) {\r\n      switch (listName) {\r\n      case 'UL':\r\n        return 'ToggleUlList';\r\n      case 'OL':\r\n        return 'ToggleOlList';\r\n      case 'DL':\r\n        return 'ToggleDLList';\r\n      }\r\n    };\r\n\r\n    var isCustomList = function (list) {\r\n      return /\\btox\\-/.test(list.className);\r\n    };\r\n    var listState = function (editor, listName, activate) {\r\n      var nodeChangeHandler = function (e) {\r\n        var inList = findUntil(e.parents, isListNode, isTableCellNode).filter(function (list) {\r\n          return list.nodeName === listName && !isCustomList(list);\r\n        }).isSome();\r\n        activate(inList);\r\n      };\r\n      var parents = editor.dom.getParents(editor.selection.getNode());\r\n      nodeChangeHandler({ parents: parents });\r\n      editor.on('NodeChange', nodeChangeHandler);\r\n      return function () {\r\n        return editor.off('NodeChange', nodeChangeHandler);\r\n      };\r\n    };\r\n\r\n    var updateListStyle = function (dom, el, detail) {\r\n      var type = detail['list-style-type'] ? detail['list-style-type'] : null;\r\n      dom.setStyle(el, 'list-style-type', type);\r\n    };\r\n    var setAttribs = function (elm, attrs) {\r\n      global$2.each(attrs, function (value, key) {\r\n        elm.setAttribute(key, value);\r\n      });\r\n    };\r\n    var updateListAttrs = function (dom, el, detail) {\r\n      setAttribs(el, detail['list-attributes']);\r\n      global$2.each(dom.select('li', el), function (li) {\r\n        setAttribs(li, detail['list-item-attributes']);\r\n      });\r\n    };\r\n    var updateListWithDetails = function (dom, el, detail) {\r\n      updateListStyle(dom, el, detail);\r\n      updateListAttrs(dom, el, detail);\r\n    };\r\n    var removeStyles = function (dom, element, styles) {\r\n      global$2.each(styles, function (style) {\r\n        var _a;\r\n        return dom.setStyle(element, (_a = {}, _a[style] = '', _a));\r\n      });\r\n    };\r\n    var getEndPointNode = function (editor, rng, start, root) {\r\n      var container = rng[start ? 'startContainer' : 'endContainer'];\r\n      var offset = rng[start ? 'startOffset' : 'endOffset'];\r\n      if (container.nodeType === 1) {\r\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\r\n      }\r\n      if (!start && isBr(container.nextSibling)) {\r\n        container = container.nextSibling;\r\n      }\r\n      while (container.parentNode !== root) {\r\n        if (isTextBlock(editor, container)) {\r\n          return container;\r\n        }\r\n        if (/^(TD|TH)$/.test(container.parentNode.nodeName)) {\r\n          return container;\r\n        }\r\n        container = container.parentNode;\r\n      }\r\n      return container;\r\n    };\r\n    var getSelectedTextBlocks = function (editor, rng, root) {\r\n      var textBlocks = [];\r\n      var dom = editor.dom;\r\n      var startNode = getEndPointNode(editor, rng, true, root);\r\n      var endNode = getEndPointNode(editor, rng, false, root);\r\n      var block;\r\n      var siblings = [];\r\n      for (var node = startNode; node; node = node.nextSibling) {\r\n        siblings.push(node);\r\n        if (node === endNode) {\r\n          break;\r\n        }\r\n      }\r\n      global$2.each(siblings, function (node) {\r\n        if (isTextBlock(editor, node)) {\r\n          textBlocks.push(node);\r\n          block = null;\r\n          return;\r\n        }\r\n        if (dom.isBlock(node) || isBr(node)) {\r\n          if (isBr(node)) {\r\n            dom.remove(node);\r\n          }\r\n          block = null;\r\n          return;\r\n        }\r\n        var nextSibling = node.nextSibling;\r\n        if (global.isBookmarkNode(node)) {\r\n          if (isListNode(nextSibling) || isTextBlock(editor, nextSibling) || !nextSibling && node.parentNode === root) {\r\n            block = null;\r\n            return;\r\n          }\r\n        }\r\n        if (!block) {\r\n          block = dom.create('p');\r\n          node.parentNode.insertBefore(block, node);\r\n          textBlocks.push(block);\r\n        }\r\n        block.appendChild(node);\r\n      });\r\n      return textBlocks;\r\n    };\r\n    var hasCompatibleStyle = function (dom, sib, detail) {\r\n      var sibStyle = dom.getStyle(sib, 'list-style-type');\r\n      var detailStyle = detail ? detail['list-style-type'] : '';\r\n      detailStyle = detailStyle === null ? '' : detailStyle;\r\n      return sibStyle === detailStyle;\r\n    };\r\n    var applyList = function (editor, listName, detail) {\r\n      var rng = editor.selection.getRng();\r\n      var listItemName = 'LI';\r\n      var root = getClosestListRootElm(editor, editor.selection.getStart(true));\r\n      var dom = editor.dom;\r\n      if (dom.getContentEditable(editor.selection.getNode()) === 'false') {\r\n        return;\r\n      }\r\n      listName = listName.toUpperCase();\r\n      if (listName === 'DL') {\r\n        listItemName = 'DT';\r\n      }\r\n      var bookmark = createBookmark(rng);\r\n      var selectedTextBlocks = getSelectedTextBlocks(editor, rng, root);\r\n      global$2.each(selectedTextBlocks, function (block) {\r\n        var listBlock;\r\n        var sibling = block.previousSibling;\r\n        var parent = block.parentNode;\r\n        if (!isListItemNode(parent)) {\r\n          if (sibling && isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {\r\n            listBlock = sibling;\r\n            block = dom.rename(block, listItemName);\r\n            sibling.appendChild(block);\r\n          } else {\r\n            listBlock = dom.create(listName);\r\n            block.parentNode.insertBefore(listBlock, block);\r\n            listBlock.appendChild(block);\r\n            block = dom.rename(block, listItemName);\r\n          }\r\n          removeStyles(dom, block, [\r\n            'margin',\r\n            'margin-right',\r\n            'margin-bottom',\r\n            'margin-left',\r\n            'margin-top',\r\n            'padding',\r\n            'padding-right',\r\n            'padding-bottom',\r\n            'padding-left',\r\n            'padding-top'\r\n          ]);\r\n          updateListWithDetails(dom, listBlock, detail);\r\n          mergeWithAdjacentLists(editor.dom, listBlock);\r\n        }\r\n      });\r\n      editor.selection.setRng(resolveBookmark(bookmark));\r\n    };\r\n    var isValidLists = function (list1, list2) {\r\n      return list1 && list2 && isListNode(list1) && list1.nodeName === list2.nodeName;\r\n    };\r\n    var hasSameListStyle = function (dom, list1, list2) {\r\n      var targetStyle = dom.getStyle(list1, 'list-style-type', true);\r\n      var style = dom.getStyle(list2, 'list-style-type', true);\r\n      return targetStyle === style;\r\n    };\r\n    var hasSameClasses = function (elm1, elm2) {\r\n      return elm1.className === elm2.className;\r\n    };\r\n    var shouldMerge = function (dom, list1, list2) {\r\n      return isValidLists(list1, list2) && hasSameListStyle(dom, list1, list2) && hasSameClasses(list1, list2);\r\n    };\r\n    var mergeWithAdjacentLists = function (dom, listBlock) {\r\n      var sibling, node;\r\n      sibling = listBlock.nextSibling;\r\n      if (shouldMerge(dom, listBlock, sibling)) {\r\n        while (node = sibling.firstChild) {\r\n          listBlock.appendChild(node);\r\n        }\r\n        dom.remove(sibling);\r\n      }\r\n      sibling = listBlock.previousSibling;\r\n      if (shouldMerge(dom, listBlock, sibling)) {\r\n        while (node = sibling.lastChild) {\r\n          listBlock.insertBefore(node, listBlock.firstChild);\r\n        }\r\n        dom.remove(sibling);\r\n      }\r\n    };\r\n    var updateList$1 = function (editor, list, listName, detail) {\r\n      if (list.nodeName !== listName) {\r\n        var newList = editor.dom.rename(list, listName);\r\n        updateListWithDetails(editor.dom, newList, detail);\r\n        fireListEvent(editor, listToggleActionFromListName(listName), newList);\r\n      } else {\r\n        updateListWithDetails(editor.dom, list, detail);\r\n        fireListEvent(editor, listToggleActionFromListName(listName), list);\r\n      }\r\n    };\r\n    var toggleMultipleLists = function (editor, parentList, lists, listName, detail) {\r\n      var parentIsList = isListNode(parentList);\r\n      if (parentIsList && parentList.nodeName === listName && !hasListStyleDetail(detail)) {\r\n        flattenListSelection(editor);\r\n      } else {\r\n        applyList(editor, listName, detail);\r\n        var bookmark = createBookmark(editor.selection.getRng());\r\n        var allLists = parentIsList ? __spreadArray([parentList], lists, true) : lists;\r\n        global$2.each(allLists, function (elm) {\r\n          updateList$1(editor, elm, listName, detail);\r\n        });\r\n        editor.selection.setRng(resolveBookmark(bookmark));\r\n      }\r\n    };\r\n    var hasListStyleDetail = function (detail) {\r\n      return 'list-style-type' in detail;\r\n    };\r\n    var toggleSingleList = function (editor, parentList, listName, detail) {\r\n      if (parentList === editor.getBody()) {\r\n        return;\r\n      }\r\n      if (parentList) {\r\n        if (parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {\r\n          flattenListSelection(editor);\r\n        } else {\r\n          var bookmark = createBookmark(editor.selection.getRng());\r\n          updateListWithDetails(editor.dom, parentList, detail);\r\n          var newList = editor.dom.rename(parentList, listName);\r\n          mergeWithAdjacentLists(editor.dom, newList);\r\n          editor.selection.setRng(resolveBookmark(bookmark));\r\n          applyList(editor, listName, detail);\r\n          fireListEvent(editor, listToggleActionFromListName(listName), newList);\r\n        }\r\n      } else {\r\n        applyList(editor, listName, detail);\r\n        fireListEvent(editor, listToggleActionFromListName(listName), parentList);\r\n      }\r\n    };\r\n    var toggleList = function (editor, listName, _detail) {\r\n      var parentList = getParentList(editor);\r\n      var selectedSubLists = getSelectedSubLists(editor);\r\n      var detail = isObject(_detail) ? _detail : {};\r\n      if (selectedSubLists.length > 0) {\r\n        toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);\r\n      } else {\r\n        toggleSingleList(editor, parentList, listName, detail);\r\n      }\r\n    };\r\n\r\n    var DOM = global$3.DOM;\r\n    var normalizeList = function (dom, list) {\r\n      var parentNode = list.parentNode;\r\n      if (parentNode.nodeName === 'LI' && parentNode.firstChild === list) {\r\n        var sibling = parentNode.previousSibling;\r\n        if (sibling && sibling.nodeName === 'LI') {\r\n          sibling.appendChild(list);\r\n          if (isEmpty(dom, parentNode)) {\r\n            DOM.remove(parentNode);\r\n          }\r\n        } else {\r\n          DOM.setStyle(parentNode, 'listStyleType', 'none');\r\n        }\r\n      }\r\n      if (isListNode(parentNode)) {\r\n        var sibling = parentNode.previousSibling;\r\n        if (sibling && sibling.nodeName === 'LI') {\r\n          sibling.appendChild(list);\r\n        }\r\n      }\r\n    };\r\n    var normalizeLists = function (dom, element) {\r\n      var lists = global$2.grep(dom.select('ol,ul', element));\r\n      global$2.each(lists, function (list) {\r\n        normalizeList(dom, list);\r\n      });\r\n    };\r\n\r\n    var findNextCaretContainer = function (editor, rng, isForward, root) {\r\n      var node = rng.startContainer;\r\n      var offset = rng.startOffset;\r\n      if (isTextNode(node) && (isForward ? offset < node.data.length : offset > 0)) {\r\n        return node;\r\n      }\r\n      var nonEmptyBlocks = editor.schema.getNonEmptyElements();\r\n      if (node.nodeType === 1) {\r\n        node = global$6.getNode(node, offset);\r\n      }\r\n      var walker = new global$5(node, root);\r\n      if (isForward) {\r\n        if (isBogusBr(editor.dom, node)) {\r\n          walker.next();\r\n        }\r\n      }\r\n      while (node = walker[isForward ? 'next' : 'prev2']()) {\r\n        if (node.nodeName === 'LI' && !node.hasChildNodes()) {\r\n          return node;\r\n        }\r\n        if (nonEmptyBlocks[node.nodeName]) {\r\n          return node;\r\n        }\r\n        if (isTextNode(node) && node.data.length > 0) {\r\n          return node;\r\n        }\r\n      }\r\n    };\r\n    var hasOnlyOneBlockChild = function (dom, elm) {\r\n      var childNodes = elm.childNodes;\r\n      return childNodes.length === 1 && !isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);\r\n    };\r\n    var unwrapSingleBlockChild = function (dom, elm) {\r\n      if (hasOnlyOneBlockChild(dom, elm)) {\r\n        dom.remove(elm.firstChild, true);\r\n      }\r\n    };\r\n    var moveChildren = function (dom, fromElm, toElm) {\r\n      var node;\r\n      var targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;\r\n      unwrapSingleBlockChild(dom, fromElm);\r\n      if (!isEmpty(dom, fromElm, true)) {\r\n        while (node = fromElm.firstChild) {\r\n          targetElm.appendChild(node);\r\n        }\r\n      }\r\n    };\r\n    var mergeLiElements = function (dom, fromElm, toElm) {\r\n      var listNode;\r\n      var ul = fromElm.parentNode;\r\n      if (!isChildOfBody(dom, fromElm) || !isChildOfBody(dom, toElm)) {\r\n        return;\r\n      }\r\n      if (isListNode(toElm.lastChild)) {\r\n        listNode = toElm.lastChild;\r\n      }\r\n      if (ul === toElm.lastChild) {\r\n        if (isBr(ul.previousSibling)) {\r\n          dom.remove(ul.previousSibling);\r\n        }\r\n      }\r\n      var node = toElm.lastChild;\r\n      if (node && isBr(node) && fromElm.hasChildNodes()) {\r\n        dom.remove(node);\r\n      }\r\n      if (isEmpty(dom, toElm, true)) {\r\n        dom.$(toElm).empty();\r\n      }\r\n      moveChildren(dom, fromElm, toElm);\r\n      if (listNode) {\r\n        toElm.appendChild(listNode);\r\n      }\r\n      var contains$1 = contains(SugarElement.fromDom(toElm), SugarElement.fromDom(fromElm));\r\n      var nestedLists = contains$1 ? dom.getParents(fromElm, isListNode, toElm) : [];\r\n      dom.remove(fromElm);\r\n      each$1(nestedLists, function (list) {\r\n        if (isEmpty(dom, list) && list !== dom.getRoot()) {\r\n          dom.remove(list);\r\n        }\r\n      });\r\n    };\r\n    var mergeIntoEmptyLi = function (editor, fromLi, toLi) {\r\n      editor.dom.$(toLi).empty();\r\n      mergeLiElements(editor.dom, fromLi, toLi);\r\n      editor.selection.setCursorLocation(toLi, 0);\r\n    };\r\n    var mergeForward = function (editor, rng, fromLi, toLi) {\r\n      var dom = editor.dom;\r\n      if (dom.isEmpty(toLi)) {\r\n        mergeIntoEmptyLi(editor, fromLi, toLi);\r\n      } else {\r\n        var bookmark = createBookmark(rng);\r\n        mergeLiElements(dom, fromLi, toLi);\r\n        editor.selection.setRng(resolveBookmark(bookmark));\r\n      }\r\n    };\r\n    var mergeBackward = function (editor, rng, fromLi, toLi) {\r\n      var bookmark = createBookmark(rng);\r\n      mergeLiElements(editor.dom, fromLi, toLi);\r\n      var resolvedBookmark = resolveBookmark(bookmark);\r\n      editor.selection.setRng(resolvedBookmark);\r\n    };\r\n    var backspaceDeleteFromListToListCaret = function (editor, isForward) {\r\n      var dom = editor.dom, selection = editor.selection;\r\n      var selectionStartElm = selection.getStart();\r\n      var root = getClosestListRootElm(editor, selectionStartElm);\r\n      var li = dom.getParent(selection.getStart(), 'LI', root);\r\n      if (li) {\r\n        var ul = li.parentNode;\r\n        if (ul === editor.getBody() && isEmpty(dom, ul)) {\r\n          return true;\r\n        }\r\n        var rng_1 = normalizeRange(selection.getRng());\r\n        var otherLi_1 = dom.getParent(findNextCaretContainer(editor, rng_1, isForward, root), 'LI', root);\r\n        if (otherLi_1 && otherLi_1 !== li) {\r\n          editor.undoManager.transact(function () {\r\n            if (isForward) {\r\n              mergeForward(editor, rng_1, otherLi_1, li);\r\n            } else {\r\n              if (isFirstChild(li)) {\r\n                outdentListSelection(editor);\r\n              } else {\r\n                mergeBackward(editor, rng_1, li, otherLi_1);\r\n              }\r\n            }\r\n          });\r\n          return true;\r\n        } else if (!otherLi_1) {\r\n          if (!isForward && rng_1.startOffset === 0 && rng_1.endOffset === 0) {\r\n            editor.undoManager.transact(function () {\r\n              flattenListSelection(editor);\r\n            });\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var removeBlock = function (dom, block, root) {\r\n      var parentBlock = dom.getParent(block.parentNode, dom.isBlock, root);\r\n      dom.remove(block);\r\n      if (parentBlock && dom.isEmpty(parentBlock)) {\r\n        dom.remove(parentBlock);\r\n      }\r\n    };\r\n    var backspaceDeleteIntoListCaret = function (editor, isForward) {\r\n      var dom = editor.dom;\r\n      var selectionStartElm = editor.selection.getStart();\r\n      var root = getClosestListRootElm(editor, selectionStartElm);\r\n      var block = dom.getParent(selectionStartElm, dom.isBlock, root);\r\n      if (block && dom.isEmpty(block)) {\r\n        var rng = normalizeRange(editor.selection.getRng());\r\n        var otherLi_2 = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);\r\n        if (otherLi_2) {\r\n          editor.undoManager.transact(function () {\r\n            removeBlock(dom, block, root);\r\n            mergeWithAdjacentLists(dom, otherLi_2.parentNode);\r\n            editor.selection.select(otherLi_2, true);\r\n            editor.selection.collapse(isForward);\r\n          });\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var backspaceDeleteCaret = function (editor, isForward) {\r\n      return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);\r\n    };\r\n    var backspaceDeleteRange = function (editor) {\r\n      var selectionStartElm = editor.selection.getStart();\r\n      var root = getClosestListRootElm(editor, selectionStartElm);\r\n      var startListParent = editor.dom.getParent(selectionStartElm, 'LI,DT,DD', root);\r\n      if (startListParent || getSelectedListItems(editor).length > 0) {\r\n        editor.undoManager.transact(function () {\r\n          editor.execCommand('Delete');\r\n          normalizeLists(editor.dom, editor.getBody());\r\n        });\r\n        return true;\r\n      }\r\n      return false;\r\n    };\r\n    var backspaceDelete = function (editor, isForward) {\r\n      return editor.selection.isCollapsed() ? backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor);\r\n    };\r\n    var setup$1 = function (editor) {\r\n      editor.on('keydown', function (e) {\r\n        if (e.keyCode === global$4.BACKSPACE) {\r\n          if (backspaceDelete(editor, false)) {\r\n            e.preventDefault();\r\n          }\r\n        } else if (e.keyCode === global$4.DELETE) {\r\n          if (backspaceDelete(editor, true)) {\r\n            e.preventDefault();\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    var get = function (editor) {\r\n      return {\r\n        backspaceDelete: function (isForward) {\r\n          backspaceDelete(editor, isForward);\r\n        }\r\n      };\r\n    };\r\n\r\n    var updateList = function (editor, update) {\r\n      var parentList = getParentList(editor);\r\n      editor.undoManager.transact(function () {\r\n        if (isObject(update.styles)) {\r\n          editor.dom.setStyles(parentList, update.styles);\r\n        }\r\n        if (isObject(update.attrs)) {\r\n          each(update.attrs, function (v, k) {\r\n            return editor.dom.setAttrib(parentList, k, v);\r\n          });\r\n        }\r\n      });\r\n    };\r\n\r\n    var parseAlphabeticBase26 = function (str) {\r\n      var chars = reverse(trim(str).split(''));\r\n      var values = map(chars, function (char, i) {\r\n        var charValue = char.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0) + 1;\r\n        return Math.pow(26, i) * charValue;\r\n      });\r\n      return foldl(values, function (sum, v) {\r\n        return sum + v;\r\n      }, 0);\r\n    };\r\n    var composeAlphabeticBase26 = function (value) {\r\n      value--;\r\n      if (value < 0) {\r\n        return '';\r\n      } else {\r\n        var remainder = value % 26;\r\n        var quotient = Math.floor(value / 26);\r\n        var rest = composeAlphabeticBase26(quotient);\r\n        var char = String.fromCharCode('A'.charCodeAt(0) + remainder);\r\n        return rest + char;\r\n      }\r\n    };\r\n    var isUppercase = function (str) {\r\n      return /^[A-Z]+$/.test(str);\r\n    };\r\n    var isLowercase = function (str) {\r\n      return /^[a-z]+$/.test(str);\r\n    };\r\n    var isNumeric = function (str) {\r\n      return /^[0-9]+$/.test(str);\r\n    };\r\n    var deduceListType = function (start) {\r\n      if (isNumeric(start)) {\r\n        return 2;\r\n      } else if (isUppercase(start)) {\r\n        return 0;\r\n      } else if (isLowercase(start)) {\r\n        return 1;\r\n      } else if (isEmpty$1(start)) {\r\n        return 3;\r\n      } else {\r\n        return 4;\r\n      }\r\n    };\r\n    var parseStartValue = function (start) {\r\n      switch (deduceListType(start)) {\r\n      case 2:\r\n        return Optional.some({\r\n          listStyleType: Optional.none(),\r\n          start: start\r\n        });\r\n      case 0:\r\n        return Optional.some({\r\n          listStyleType: Optional.some('upper-alpha'),\r\n          start: parseAlphabeticBase26(start).toString()\r\n        });\r\n      case 1:\r\n        return Optional.some({\r\n          listStyleType: Optional.some('lower-alpha'),\r\n          start: parseAlphabeticBase26(start).toString()\r\n        });\r\n      case 3:\r\n        return Optional.some({\r\n          listStyleType: Optional.none(),\r\n          start: ''\r\n        });\r\n      case 4:\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var parseDetail = function (detail) {\r\n      var start = parseInt(detail.start, 10);\r\n      if (is(detail.listStyleType, 'upper-alpha')) {\r\n        return composeAlphabeticBase26(start);\r\n      } else if (is(detail.listStyleType, 'lower-alpha')) {\r\n        return composeAlphabeticBase26(start).toLowerCase();\r\n      } else {\r\n        return detail.start;\r\n      }\r\n    };\r\n\r\n    var open = function (editor) {\r\n      var currentList = getParentList(editor);\r\n      if (!isOlNode(currentList)) {\r\n        return;\r\n      }\r\n      editor.windowManager.open({\r\n        title: 'List Properties',\r\n        body: {\r\n          type: 'panel',\r\n          items: [{\r\n              type: 'input',\r\n              name: 'start',\r\n              label: 'Start list at number',\r\n              inputMode: 'numeric'\r\n            }]\r\n        },\r\n        initialData: {\r\n          start: parseDetail({\r\n            start: editor.dom.getAttrib(currentList, 'start', '1'),\r\n            listStyleType: Optional.some(editor.dom.getStyle(currentList, 'list-style-type'))\r\n          })\r\n        },\r\n        buttons: [\r\n          {\r\n            type: 'cancel',\r\n            name: 'cancel',\r\n            text: 'Cancel'\r\n          },\r\n          {\r\n            type: 'submit',\r\n            name: 'save',\r\n            text: 'Save',\r\n            primary: true\r\n          }\r\n        ],\r\n        onSubmit: function (api) {\r\n          var data = api.getData();\r\n          parseStartValue(data.start).each(function (detail) {\r\n            editor.execCommand('mceListUpdate', false, {\r\n              attrs: { start: detail.start === '1' ? '' : detail.start },\r\n              styles: { 'list-style-type': detail.listStyleType.getOr('') }\r\n            });\r\n          });\r\n          api.close();\r\n        }\r\n      });\r\n    };\r\n\r\n    var queryListCommandState = function (editor, listName) {\r\n      return function () {\r\n        var parentList = getParentList(editor);\r\n        return parentList && parentList.nodeName === listName;\r\n      };\r\n    };\r\n    var registerDialog = function (editor) {\r\n      editor.addCommand('mceListProps', function () {\r\n        open(editor);\r\n      });\r\n    };\r\n    var register$2 = function (editor) {\r\n      editor.on('BeforeExecCommand', function (e) {\r\n        var cmd = e.command.toLowerCase();\r\n        if (cmd === 'indent') {\r\n          indentListSelection(editor);\r\n        } else if (cmd === 'outdent') {\r\n          outdentListSelection(editor);\r\n        }\r\n      });\r\n      editor.addCommand('InsertUnorderedList', function (ui, detail) {\r\n        toggleList(editor, 'UL', detail);\r\n      });\r\n      editor.addCommand('InsertOrderedList', function (ui, detail) {\r\n        toggleList(editor, 'OL', detail);\r\n      });\r\n      editor.addCommand('InsertDefinitionList', function (ui, detail) {\r\n        toggleList(editor, 'DL', detail);\r\n      });\r\n      editor.addCommand('RemoveList', function () {\r\n        flattenListSelection(editor);\r\n      });\r\n      registerDialog(editor);\r\n      editor.addCommand('mceListUpdate', function (ui, detail) {\r\n        if (isObject(detail)) {\r\n          updateList(editor, detail);\r\n        }\r\n      });\r\n      editor.addQueryStateHandler('InsertUnorderedList', queryListCommandState(editor, 'UL'));\r\n      editor.addQueryStateHandler('InsertOrderedList', queryListCommandState(editor, 'OL'));\r\n      editor.addQueryStateHandler('InsertDefinitionList', queryListCommandState(editor, 'DL'));\r\n    };\r\n\r\n    var setupTabKey = function (editor) {\r\n      editor.on('keydown', function (e) {\r\n        if (e.keyCode !== global$4.TAB || global$4.metaKeyPressed(e)) {\r\n          return;\r\n        }\r\n        editor.undoManager.transact(function () {\r\n          if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) {\r\n            e.preventDefault();\r\n          }\r\n        });\r\n      });\r\n    };\r\n    var setup = function (editor) {\r\n      if (shouldIndentOnTab(editor)) {\r\n        setupTabKey(editor);\r\n      }\r\n      setup$1(editor);\r\n    };\r\n\r\n    var register$1 = function (editor) {\r\n      var exec = function (command) {\r\n        return function () {\r\n          return editor.execCommand(command);\r\n        };\r\n      };\r\n      if (!editor.hasPlugin('advlist')) {\r\n        editor.ui.registry.addToggleButton('numlist', {\r\n          icon: 'ordered-list',\r\n          active: false,\r\n          tooltip: 'Numbered list',\r\n          onAction: exec('InsertOrderedList'),\r\n          onSetup: function (api) {\r\n            return listState(editor, 'OL', api.setActive);\r\n          }\r\n        });\r\n        editor.ui.registry.addToggleButton('bullist', {\r\n          icon: 'unordered-list',\r\n          active: false,\r\n          tooltip: 'Bullet list',\r\n          onAction: exec('InsertUnorderedList'),\r\n          onSetup: function (api) {\r\n            return listState(editor, 'UL', api.setActive);\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    var register = function (editor) {\r\n      var listProperties = {\r\n        text: 'List properties...',\r\n        icon: 'ordered-list',\r\n        onAction: function () {\r\n          return editor.execCommand('mceListProps');\r\n        },\r\n        onSetup: function (api) {\r\n          return listState(editor, 'OL', function (active) {\r\n            return api.setDisabled(!active);\r\n          });\r\n        }\r\n      };\r\n      editor.ui.registry.addMenuItem('listprops', listProperties);\r\n      editor.ui.registry.addContextMenu('lists', {\r\n        update: function (node) {\r\n          var parentList = getParentList(editor, node);\r\n          return isOlNode(parentList) ? ['listprops'] : [];\r\n        }\r\n      });\r\n    };\r\n\r\n    function Plugin () {\r\n      global$7.add('lists', function (editor) {\r\n        if (editor.hasPlugin('rtc', true) === false) {\r\n          setup(editor);\r\n          register$2(editor);\r\n        } else {\r\n          registerDialog(editor);\r\n        }\r\n        register$1(editor);\r\n        register(editor);\r\n        return get(editor);\r\n      });\r\n    }\r\n\r\n    Plugin();\r\n\r\n}());\r\n\n\n//# sourceURL=webpack://test/./node_modules/tinymce/plugins/lists/plugin.js?\n}");

/***/ }),

/***/ "./node_modules/tinymce/themes/silver/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/tinymce/themes/silver/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("{// Exports the \"silver\" theme for usage with module loaders\r\n// Usage:\r\n//   CommonJS:\r\n//     require('tinymce/themes/silver')\r\n//   ES2015:\r\n//     import 'tinymce/themes/silver'\r\n__webpack_require__(/*! ./theme.js */ \"./node_modules/tinymce/themes/silver/theme.js\");\n\n//# sourceURL=webpack://test/./node_modules/tinymce/themes/silver/index.js?\n}");

/***/ }),

/***/ "./node_modules/tinymce/themes/silver/theme.js":
/*!*****************************************************!*\
  !*** ./node_modules/tinymce/themes/silver/theme.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("{/**\r\n * Copyright (c) Tiny Technologies, Inc. All rights reserved.\r\n * Licensed under the LGPL or a commercial license.\r\n * For LGPL see License.txt in the project root for license information.\r\n * For commercial licenses see https://www.tiny.cloud/\r\n *\r\n * Version: 5.10.8 (2023-10-19)\r\n */\r\n(function () {\r\n    'use strict';\r\n\r\n    var typeOf = function (x) {\r\n      var t = typeof x;\r\n      if (x === null) {\r\n        return 'null';\r\n      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\r\n        return 'array';\r\n      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\r\n        return 'string';\r\n      } else {\r\n        return t;\r\n      }\r\n    };\r\n    var isType$1 = function (type) {\r\n      return function (value) {\r\n        return typeOf(value) === type;\r\n      };\r\n    };\r\n    var isSimpleType = function (type) {\r\n      return function (value) {\r\n        return typeof value === type;\r\n      };\r\n    };\r\n    var eq$1 = function (t) {\r\n      return function (a) {\r\n        return t === a;\r\n      };\r\n    };\r\n    var isString = isType$1('string');\r\n    var isObject = isType$1('object');\r\n    var isArray = isType$1('array');\r\n    var isNull = eq$1(null);\r\n    var isBoolean = isSimpleType('boolean');\r\n    var isUndefined = eq$1(undefined);\r\n    var isNullable = function (a) {\r\n      return a === null || a === undefined;\r\n    };\r\n    var isNonNullable = function (a) {\r\n      return !isNullable(a);\r\n    };\r\n    var isFunction = isSimpleType('function');\r\n    var isNumber = isSimpleType('number');\r\n    var isArrayOf = function (value, pred) {\r\n      if (isArray(value)) {\r\n        for (var i = 0, len = value.length; i < len; ++i) {\r\n          if (!pred(value[i])) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      return false;\r\n    };\r\n\r\n    var noop = function () {\r\n    };\r\n    var noarg = function (f) {\r\n      return function () {\r\n        return f();\r\n      };\r\n    };\r\n    var compose = function (fa, fb) {\r\n      return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        return fa(fb.apply(null, args));\r\n      };\r\n    };\r\n    var compose1 = function (fbc, fab) {\r\n      return function (a) {\r\n        return fbc(fab(a));\r\n      };\r\n    };\r\n    var constant$1 = function (value) {\r\n      return function () {\r\n        return value;\r\n      };\r\n    };\r\n    var identity$1 = function (x) {\r\n      return x;\r\n    };\r\n    var tripleEquals = function (a, b) {\r\n      return a === b;\r\n    };\r\n    function curry(fn) {\r\n      var initialArgs = [];\r\n      for (var _i = 1; _i < arguments.length; _i++) {\r\n        initialArgs[_i - 1] = arguments[_i];\r\n      }\r\n      return function () {\r\n        var restArgs = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          restArgs[_i] = arguments[_i];\r\n        }\r\n        var all = initialArgs.concat(restArgs);\r\n        return fn.apply(null, all);\r\n      };\r\n    }\r\n    var not = function (f) {\r\n      return function (t) {\r\n        return !f(t);\r\n      };\r\n    };\r\n    var die = function (msg) {\r\n      return function () {\r\n        throw new Error(msg);\r\n      };\r\n    };\r\n    var never = constant$1(false);\r\n    var always = constant$1(true);\r\n\r\n    var global$g = tinymce.util.Tools.resolve('tinymce.ThemeManager');\r\n\r\n    var __assign = function () {\r\n      __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n          s = arguments[i];\r\n          for (var p in s)\r\n            if (Object.prototype.hasOwnProperty.call(s, p))\r\n              t[p] = s[p];\r\n        }\r\n        return t;\r\n      };\r\n      return __assign.apply(this, arguments);\r\n    };\r\n    function __rest(s, e) {\r\n      var t = {};\r\n      for (var p in s)\r\n        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n          t[p] = s[p];\r\n      if (s != null && typeof Object.getOwnPropertySymbols === 'function')\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n            t[p[i]] = s[p[i]];\r\n        }\r\n      return t;\r\n    }\r\n    function __spreadArray(to, from, pack) {\r\n      if (pack || arguments.length === 2)\r\n        for (var i = 0, l = from.length, ar; i < l; i++) {\r\n          if (ar || !(i in from)) {\r\n            if (!ar)\r\n              ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n          }\r\n        }\r\n      return to.concat(ar || Array.prototype.slice.call(from));\r\n    }\r\n\r\n    var none = function () {\r\n      return NONE;\r\n    };\r\n    var NONE = function () {\r\n      var call = function (thunk) {\r\n        return thunk();\r\n      };\r\n      var id = identity$1;\r\n      var me = {\r\n        fold: function (n, _s) {\r\n          return n();\r\n        },\r\n        isSome: never,\r\n        isNone: always,\r\n        getOr: id,\r\n        getOrThunk: call,\r\n        getOrDie: function (msg) {\r\n          throw new Error(msg || 'error: getOrDie called on none.');\r\n        },\r\n        getOrNull: constant$1(null),\r\n        getOrUndefined: constant$1(undefined),\r\n        or: id,\r\n        orThunk: call,\r\n        map: none,\r\n        each: noop,\r\n        bind: none,\r\n        exists: never,\r\n        forall: always,\r\n        filter: function () {\r\n          return none();\r\n        },\r\n        toArray: function () {\r\n          return [];\r\n        },\r\n        toString: constant$1('none()')\r\n      };\r\n      return me;\r\n    }();\r\n    var some = function (a) {\r\n      var constant_a = constant$1(a);\r\n      var self = function () {\r\n        return me;\r\n      };\r\n      var bind = function (f) {\r\n        return f(a);\r\n      };\r\n      var me = {\r\n        fold: function (n, s) {\r\n          return s(a);\r\n        },\r\n        isSome: always,\r\n        isNone: never,\r\n        getOr: constant_a,\r\n        getOrThunk: constant_a,\r\n        getOrDie: constant_a,\r\n        getOrNull: constant_a,\r\n        getOrUndefined: constant_a,\r\n        or: self,\r\n        orThunk: self,\r\n        map: function (f) {\r\n          return some(f(a));\r\n        },\r\n        each: function (f) {\r\n          f(a);\r\n        },\r\n        bind: bind,\r\n        exists: bind,\r\n        forall: bind,\r\n        filter: function (f) {\r\n          return f(a) ? me : NONE;\r\n        },\r\n        toArray: function () {\r\n          return [a];\r\n        },\r\n        toString: function () {\r\n          return 'some(' + a + ')';\r\n        }\r\n      };\r\n      return me;\r\n    };\r\n    var from$1 = function (value) {\r\n      return value === null || value === undefined ? NONE : some(value);\r\n    };\r\n    var Optional = {\r\n      some: some,\r\n      none: none,\r\n      from: from$1\r\n    };\r\n\r\n    var nativeSlice = Array.prototype.slice;\r\n    var nativeIndexOf = Array.prototype.indexOf;\r\n    var nativePush = Array.prototype.push;\r\n    var rawIndexOf = function (ts, t) {\r\n      return nativeIndexOf.call(ts, t);\r\n    };\r\n    var indexOf = function (xs, x) {\r\n      var r = rawIndexOf(xs, x);\r\n      return r === -1 ? Optional.none() : Optional.some(r);\r\n    };\r\n    var contains$2 = function (xs, x) {\r\n      return rawIndexOf(xs, x) > -1;\r\n    };\r\n    var exists = function (xs, pred) {\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        if (pred(x, i)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var range$2 = function (num, f) {\r\n      var r = [];\r\n      for (var i = 0; i < num; i++) {\r\n        r.push(f(i));\r\n      }\r\n      return r;\r\n    };\r\n    var chunk$1 = function (array, size) {\r\n      var r = [];\r\n      for (var i = 0; i < array.length; i += size) {\r\n        var s = nativeSlice.call(array, i, i + size);\r\n        r.push(s);\r\n      }\r\n      return r;\r\n    };\r\n    var map$2 = function (xs, f) {\r\n      var len = xs.length;\r\n      var r = new Array(len);\r\n      for (var i = 0; i < len; i++) {\r\n        var x = xs[i];\r\n        r[i] = f(x, i);\r\n      }\r\n      return r;\r\n    };\r\n    var each$1 = function (xs, f) {\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    var eachr = function (xs, f) {\r\n      for (var i = xs.length - 1; i >= 0; i--) {\r\n        var x = xs[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    var partition$3 = function (xs, pred) {\r\n      var pass = [];\r\n      var fail = [];\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        var arr = pred(x, i) ? pass : fail;\r\n        arr.push(x);\r\n      }\r\n      return {\r\n        pass: pass,\r\n        fail: fail\r\n      };\r\n    };\r\n    var filter$2 = function (xs, pred) {\r\n      var r = [];\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        if (pred(x, i)) {\r\n          r.push(x);\r\n        }\r\n      }\r\n      return r;\r\n    };\r\n    var foldr = function (xs, f, acc) {\r\n      eachr(xs, function (x, i) {\r\n        acc = f(acc, x, i);\r\n      });\r\n      return acc;\r\n    };\r\n    var foldl = function (xs, f, acc) {\r\n      each$1(xs, function (x, i) {\r\n        acc = f(acc, x, i);\r\n      });\r\n      return acc;\r\n    };\r\n    var findUntil = function (xs, pred, until) {\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        if (pred(x, i)) {\r\n          return Optional.some(x);\r\n        } else if (until(x, i)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var find$5 = function (xs, pred) {\r\n      return findUntil(xs, pred, never);\r\n    };\r\n    var findIndex$1 = function (xs, pred) {\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        if (pred(x, i)) {\r\n          return Optional.some(i);\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var flatten = function (xs) {\r\n      var r = [];\r\n      for (var i = 0, len = xs.length; i < len; ++i) {\r\n        if (!isArray(xs[i])) {\r\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\r\n        }\r\n        nativePush.apply(r, xs[i]);\r\n      }\r\n      return r;\r\n    };\r\n    var bind$3 = function (xs, f) {\r\n      return flatten(map$2(xs, f));\r\n    };\r\n    var forall = function (xs, pred) {\r\n      for (var i = 0, len = xs.length; i < len; ++i) {\r\n        var x = xs[i];\r\n        if (pred(x, i) !== true) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    var reverse = function (xs) {\r\n      var r = nativeSlice.call(xs, 0);\r\n      r.reverse();\r\n      return r;\r\n    };\r\n    var difference = function (a1, a2) {\r\n      return filter$2(a1, function (x) {\r\n        return !contains$2(a2, x);\r\n      });\r\n    };\r\n    var mapToObject = function (xs, f) {\r\n      var r = {};\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        r[String(x)] = f(x, i);\r\n      }\r\n      return r;\r\n    };\r\n    var pure$2 = function (x) {\r\n      return [x];\r\n    };\r\n    var sort = function (xs, comparator) {\r\n      var copy = nativeSlice.call(xs, 0);\r\n      copy.sort(comparator);\r\n      return copy;\r\n    };\r\n    var get$f = function (xs, i) {\r\n      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\r\n    };\r\n    var head = function (xs) {\r\n      return get$f(xs, 0);\r\n    };\r\n    var last$2 = function (xs) {\r\n      return get$f(xs, xs.length - 1);\r\n    };\r\n    var from = isFunction(Array.from) ? Array.from : function (x) {\r\n      return nativeSlice.call(x);\r\n    };\r\n    var findMap = function (arr, f) {\r\n      for (var i = 0; i < arr.length; i++) {\r\n        var r = f(arr[i], i);\r\n        if (r.isSome()) {\r\n          return r;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n\r\n    var keys = Object.keys;\r\n    var hasOwnProperty$1 = Object.hasOwnProperty;\r\n    var each = function (obj, f) {\r\n      var props = keys(obj);\r\n      for (var k = 0, len = props.length; k < len; k++) {\r\n        var i = props[k];\r\n        var x = obj[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    var map$1 = function (obj, f) {\r\n      return tupleMap(obj, function (x, i) {\r\n        return {\r\n          k: i,\r\n          v: f(x, i)\r\n        };\r\n      });\r\n    };\r\n    var tupleMap = function (obj, f) {\r\n      var r = {};\r\n      each(obj, function (x, i) {\r\n        var tuple = f(x, i);\r\n        r[tuple.k] = tuple.v;\r\n      });\r\n      return r;\r\n    };\r\n    var objAcc = function (r) {\r\n      return function (x, i) {\r\n        r[i] = x;\r\n      };\r\n    };\r\n    var internalFilter = function (obj, pred, onTrue, onFalse) {\r\n      var r = {};\r\n      each(obj, function (x, i) {\r\n        (pred(x, i) ? onTrue : onFalse)(x, i);\r\n      });\r\n      return r;\r\n    };\r\n    var filter$1 = function (obj, pred) {\r\n      var t = {};\r\n      internalFilter(obj, pred, objAcc(t), noop);\r\n      return t;\r\n    };\r\n    var mapToArray = function (obj, f) {\r\n      var r = [];\r\n      each(obj, function (value, name) {\r\n        r.push(f(value, name));\r\n      });\r\n      return r;\r\n    };\r\n    var find$4 = function (obj, pred) {\r\n      var props = keys(obj);\r\n      for (var k = 0, len = props.length; k < len; k++) {\r\n        var i = props[k];\r\n        var x = obj[i];\r\n        if (pred(x, i, obj)) {\r\n          return Optional.some(x);\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var values = function (obj) {\r\n      return mapToArray(obj, identity$1);\r\n    };\r\n    var get$e = function (obj, key) {\r\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\r\n    };\r\n    var has$2 = function (obj, key) {\r\n      return hasOwnProperty$1.call(obj, key);\r\n    };\r\n    var hasNonNullableKey = function (obj, key) {\r\n      return has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\r\n    };\r\n\r\n    var is$1 = function (lhs, rhs, comparator) {\r\n      if (comparator === void 0) {\r\n        comparator = tripleEquals;\r\n      }\r\n      return lhs.exists(function (left) {\r\n        return comparator(left, rhs);\r\n      });\r\n    };\r\n    var equals = function (lhs, rhs, comparator) {\r\n      if (comparator === void 0) {\r\n        comparator = tripleEquals;\r\n      }\r\n      return lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\r\n    };\r\n    var cat = function (arr) {\r\n      var r = [];\r\n      var push = function (x) {\r\n        r.push(x);\r\n      };\r\n      for (var i = 0; i < arr.length; i++) {\r\n        arr[i].each(push);\r\n      }\r\n      return r;\r\n    };\r\n    var sequence = function (arr) {\r\n      var r = [];\r\n      for (var i = 0; i < arr.length; i++) {\r\n        var x = arr[i];\r\n        if (x.isSome()) {\r\n          r.push(x.getOrDie());\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      }\r\n      return Optional.some(r);\r\n    };\r\n    var lift2 = function (oa, ob, f) {\r\n      return oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\r\n    };\r\n    var lift3 = function (oa, ob, oc, f) {\r\n      return oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\r\n    };\r\n    var mapFrom = function (a, f) {\r\n      return a !== undefined && a !== null ? Optional.some(f(a)) : Optional.none();\r\n    };\r\n    var someIf = function (b, a) {\r\n      return b ? Optional.some(a) : Optional.none();\r\n    };\r\n\r\n    var addToEnd = function (str, suffix) {\r\n      return str + suffix;\r\n    };\r\n    var removeFromStart = function (str, numChars) {\r\n      return str.substring(numChars);\r\n    };\r\n\r\n    var checkRange = function (str, substr, start) {\r\n      return substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\r\n    };\r\n    var removeLeading = function (str, prefix) {\r\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\r\n    };\r\n    var ensureTrailing = function (str, suffix) {\r\n      return endsWith(str, suffix) ? str : addToEnd(str, suffix);\r\n    };\r\n    var contains$1 = function (str, substr) {\r\n      return str.indexOf(substr) !== -1;\r\n    };\r\n    var startsWith = function (str, prefix) {\r\n      return checkRange(str, prefix, 0);\r\n    };\r\n    var endsWith = function (str, suffix) {\r\n      return checkRange(str, suffix, str.length - suffix.length);\r\n    };\r\n    var blank = function (r) {\r\n      return function (s) {\r\n        return s.replace(r, '');\r\n      };\r\n    };\r\n    var trim$1 = blank(/^\\s+|\\s+$/g);\r\n    var isNotEmpty = function (s) {\r\n      return s.length > 0;\r\n    };\r\n    var isEmpty = function (s) {\r\n      return !isNotEmpty(s);\r\n    };\r\n\r\n    var isSupported$1 = function (dom) {\r\n      return dom.style !== undefined && isFunction(dom.style.getPropertyValue);\r\n    };\r\n\r\n    var fromHtml$2 = function (html, scope) {\r\n      var doc = scope || document;\r\n      var div = doc.createElement('div');\r\n      div.innerHTML = html;\r\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\r\n        console.error('HTML does not have a single root node', html);\r\n        throw new Error('HTML must have a single root node');\r\n      }\r\n      return fromDom(div.childNodes[0]);\r\n    };\r\n    var fromTag = function (tag, scope) {\r\n      var doc = scope || document;\r\n      var node = doc.createElement(tag);\r\n      return fromDom(node);\r\n    };\r\n    var fromText = function (text, scope) {\r\n      var doc = scope || document;\r\n      var node = doc.createTextNode(text);\r\n      return fromDom(node);\r\n    };\r\n    var fromDom = function (node) {\r\n      if (node === null || node === undefined) {\r\n        throw new Error('Node cannot be null or undefined');\r\n      }\r\n      return { dom: node };\r\n    };\r\n    var fromPoint = function (docElm, x, y) {\r\n      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\r\n    };\r\n    var SugarElement = {\r\n      fromHtml: fromHtml$2,\r\n      fromTag: fromTag,\r\n      fromText: fromText,\r\n      fromDom: fromDom,\r\n      fromPoint: fromPoint\r\n    };\r\n\r\n    typeof window !== 'undefined' ? window : Function('return this;')();\r\n\r\n    var DOCUMENT = 9;\r\n    var DOCUMENT_FRAGMENT = 11;\r\n    var ELEMENT = 1;\r\n    var TEXT = 3;\r\n\r\n    var name$2 = function (element) {\r\n      var r = element.dom.nodeName;\r\n      return r.toLowerCase();\r\n    };\r\n    var type = function (element) {\r\n      return element.dom.nodeType;\r\n    };\r\n    var isType = function (t) {\r\n      return function (element) {\r\n        return type(element) === t;\r\n      };\r\n    };\r\n    var isElement$2 = isType(ELEMENT);\r\n    var isText$1 = isType(TEXT);\r\n    var isDocument = isType(DOCUMENT);\r\n    var isDocumentFragment = isType(DOCUMENT_FRAGMENT);\r\n\r\n    var cached = function (f) {\r\n      var called = false;\r\n      var r;\r\n      return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        if (!called) {\r\n          called = true;\r\n          r = f.apply(null, args);\r\n        }\r\n        return r;\r\n      };\r\n    };\r\n\r\n    var DeviceType = function (os, browser, userAgent, mediaMatch) {\r\n      var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\r\n      var isiPhone = os.isiOS() && !isiPad;\r\n      var isMobile = os.isiOS() || os.isAndroid();\r\n      var isTouch = isMobile || mediaMatch('(pointer:coarse)');\r\n      var isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\r\n      var isPhone = isiPhone || isMobile && !isTablet;\r\n      var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\r\n      var isDesktop = !isPhone && !isTablet && !iOSwebview;\r\n      return {\r\n        isiPad: constant$1(isiPad),\r\n        isiPhone: constant$1(isiPhone),\r\n        isTablet: constant$1(isTablet),\r\n        isPhone: constant$1(isPhone),\r\n        isTouch: constant$1(isTouch),\r\n        isAndroid: os.isAndroid,\r\n        isiOS: os.isiOS,\r\n        isWebView: constant$1(iOSwebview),\r\n        isDesktop: constant$1(isDesktop)\r\n      };\r\n    };\r\n\r\n    var firstMatch = function (regexes, s) {\r\n      for (var i = 0; i < regexes.length; i++) {\r\n        var x = regexes[i];\r\n        if (x.test(s)) {\r\n          return x;\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n    var find$3 = function (regexes, agent) {\r\n      var r = firstMatch(regexes, agent);\r\n      if (!r) {\r\n        return {\r\n          major: 0,\r\n          minor: 0\r\n        };\r\n      }\r\n      var group = function (i) {\r\n        return Number(agent.replace(r, '$' + i));\r\n      };\r\n      return nu$d(group(1), group(2));\r\n    };\r\n    var detect$4 = function (versionRegexes, agent) {\r\n      var cleanedAgent = String(agent).toLowerCase();\r\n      if (versionRegexes.length === 0) {\r\n        return unknown$3();\r\n      }\r\n      return find$3(versionRegexes, cleanedAgent);\r\n    };\r\n    var unknown$3 = function () {\r\n      return nu$d(0, 0);\r\n    };\r\n    var nu$d = function (major, minor) {\r\n      return {\r\n        major: major,\r\n        minor: minor\r\n      };\r\n    };\r\n    var Version = {\r\n      nu: nu$d,\r\n      detect: detect$4,\r\n      unknown: unknown$3\r\n    };\r\n\r\n    var detectBrowser$1 = function (browsers, userAgentData) {\r\n      return findMap(userAgentData.brands, function (uaBrand) {\r\n        var lcBrand = uaBrand.brand.toLowerCase();\r\n        return find$5(browsers, function (browser) {\r\n          var _a;\r\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\r\n        }).map(function (info) {\r\n          return {\r\n            current: info.name,\r\n            version: Version.nu(parseInt(uaBrand.version, 10), 0)\r\n          };\r\n        });\r\n      });\r\n    };\r\n\r\n    var detect$3 = function (candidates, userAgent) {\r\n      var agent = String(userAgent).toLowerCase();\r\n      return find$5(candidates, function (candidate) {\r\n        return candidate.search(agent);\r\n      });\r\n    };\r\n    var detectBrowser = function (browsers, userAgent) {\r\n      return detect$3(browsers, userAgent).map(function (browser) {\r\n        var version = Version.detect(browser.versionRegexes, userAgent);\r\n        return {\r\n          current: browser.name,\r\n          version: version\r\n        };\r\n      });\r\n    };\r\n    var detectOs = function (oses, userAgent) {\r\n      return detect$3(oses, userAgent).map(function (os) {\r\n        var version = Version.detect(os.versionRegexes, userAgent);\r\n        return {\r\n          current: os.name,\r\n          version: version\r\n        };\r\n      });\r\n    };\r\n\r\n    var normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\r\n    var checkContains = function (target) {\r\n      return function (uastring) {\r\n        return contains$1(uastring, target);\r\n      };\r\n    };\r\n    var browsers = [\r\n      {\r\n        name: 'Edge',\r\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\r\n        search: function (uastring) {\r\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\r\n        }\r\n      },\r\n      {\r\n        name: 'Chrome',\r\n        brand: 'Chromium',\r\n        versionRegexes: [\r\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\r\n          normalVersionRegex\r\n        ],\r\n        search: function (uastring) {\r\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\r\n        }\r\n      },\r\n      {\r\n        name: 'IE',\r\n        versionRegexes: [\r\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\r\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\r\n        ],\r\n        search: function (uastring) {\r\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\r\n        }\r\n      },\r\n      {\r\n        name: 'Opera',\r\n        versionRegexes: [\r\n          normalVersionRegex,\r\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\r\n        ],\r\n        search: checkContains('opera')\r\n      },\r\n      {\r\n        name: 'Firefox',\r\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\r\n        search: checkContains('firefox')\r\n      },\r\n      {\r\n        name: 'Safari',\r\n        versionRegexes: [\r\n          normalVersionRegex,\r\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\r\n        ],\r\n        search: function (uastring) {\r\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\r\n        }\r\n      }\r\n    ];\r\n    var oses = [\r\n      {\r\n        name: 'Windows',\r\n        search: checkContains('win'),\r\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'iOS',\r\n        search: function (uastring) {\r\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\r\n        },\r\n        versionRegexes: [\r\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\r\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\r\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\r\n        ]\r\n      },\r\n      {\r\n        name: 'Android',\r\n        search: checkContains('android'),\r\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'OSX',\r\n        search: checkContains('mac os x'),\r\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'Linux',\r\n        search: checkContains('linux'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'Solaris',\r\n        search: checkContains('sunos'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'FreeBSD',\r\n        search: checkContains('freebsd'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'ChromeOS',\r\n        search: checkContains('cros'),\r\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\r\n      }\r\n    ];\r\n    var PlatformInfo = {\r\n      browsers: constant$1(browsers),\r\n      oses: constant$1(oses)\r\n    };\r\n\r\n    var edge = 'Edge';\r\n    var chrome = 'Chrome';\r\n    var ie = 'IE';\r\n    var opera = 'Opera';\r\n    var firefox = 'Firefox';\r\n    var safari = 'Safari';\r\n    var unknown$2 = function () {\r\n      return nu$c({\r\n        current: undefined,\r\n        version: Version.unknown()\r\n      });\r\n    };\r\n    var nu$c = function (info) {\r\n      var current = info.current;\r\n      var version = info.version;\r\n      var isBrowser = function (name) {\r\n        return function () {\r\n          return current === name;\r\n        };\r\n      };\r\n      return {\r\n        current: current,\r\n        version: version,\r\n        isEdge: isBrowser(edge),\r\n        isChrome: isBrowser(chrome),\r\n        isIE: isBrowser(ie),\r\n        isOpera: isBrowser(opera),\r\n        isFirefox: isBrowser(firefox),\r\n        isSafari: isBrowser(safari)\r\n      };\r\n    };\r\n    var Browser = {\r\n      unknown: unknown$2,\r\n      nu: nu$c,\r\n      edge: constant$1(edge),\r\n      chrome: constant$1(chrome),\r\n      ie: constant$1(ie),\r\n      opera: constant$1(opera),\r\n      firefox: constant$1(firefox),\r\n      safari: constant$1(safari)\r\n    };\r\n\r\n    var windows = 'Windows';\r\n    var ios = 'iOS';\r\n    var android = 'Android';\r\n    var linux = 'Linux';\r\n    var osx = 'OSX';\r\n    var solaris = 'Solaris';\r\n    var freebsd = 'FreeBSD';\r\n    var chromeos = 'ChromeOS';\r\n    var unknown$1 = function () {\r\n      return nu$b({\r\n        current: undefined,\r\n        version: Version.unknown()\r\n      });\r\n    };\r\n    var nu$b = function (info) {\r\n      var current = info.current;\r\n      var version = info.version;\r\n      var isOS = function (name) {\r\n        return function () {\r\n          return current === name;\r\n        };\r\n      };\r\n      return {\r\n        current: current,\r\n        version: version,\r\n        isWindows: isOS(windows),\r\n        isiOS: isOS(ios),\r\n        isAndroid: isOS(android),\r\n        isOSX: isOS(osx),\r\n        isLinux: isOS(linux),\r\n        isSolaris: isOS(solaris),\r\n        isFreeBSD: isOS(freebsd),\r\n        isChromeOS: isOS(chromeos)\r\n      };\r\n    };\r\n    var OperatingSystem = {\r\n      unknown: unknown$1,\r\n      nu: nu$b,\r\n      windows: constant$1(windows),\r\n      ios: constant$1(ios),\r\n      android: constant$1(android),\r\n      linux: constant$1(linux),\r\n      osx: constant$1(osx),\r\n      solaris: constant$1(solaris),\r\n      freebsd: constant$1(freebsd),\r\n      chromeos: constant$1(chromeos)\r\n    };\r\n\r\n    var detect$2 = function (userAgent, userAgentDataOpt, mediaMatch) {\r\n      var browsers = PlatformInfo.browsers();\r\n      var oses = PlatformInfo.oses();\r\n      var browser = userAgentDataOpt.bind(function (userAgentData) {\r\n        return detectBrowser$1(browsers, userAgentData);\r\n      }).orThunk(function () {\r\n        return detectBrowser(browsers, userAgent);\r\n      }).fold(Browser.unknown, Browser.nu);\r\n      var os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\r\n      var deviceType = DeviceType(os, browser, userAgent, mediaMatch);\r\n      return {\r\n        browser: browser,\r\n        os: os,\r\n        deviceType: deviceType\r\n      };\r\n    };\r\n    var PlatformDetection = { detect: detect$2 };\r\n\r\n    var mediaMatch = function (query) {\r\n      return window.matchMedia(query).matches;\r\n    };\r\n    var platform = cached(function () {\r\n      return PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch);\r\n    });\r\n    var detect$1 = function () {\r\n      return platform();\r\n    };\r\n\r\n    var compareDocumentPosition = function (a, b, match) {\r\n      return (a.compareDocumentPosition(b) & match) !== 0;\r\n    };\r\n    var documentPositionContainedBy = function (a, b) {\r\n      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_CONTAINED_BY);\r\n    };\r\n\r\n    var is = function (element, selector) {\r\n      var dom = element.dom;\r\n      if (dom.nodeType !== ELEMENT) {\r\n        return false;\r\n      } else {\r\n        var elem = dom;\r\n        if (elem.matches !== undefined) {\r\n          return elem.matches(selector);\r\n        } else if (elem.msMatchesSelector !== undefined) {\r\n          return elem.msMatchesSelector(selector);\r\n        } else if (elem.webkitMatchesSelector !== undefined) {\r\n          return elem.webkitMatchesSelector(selector);\r\n        } else if (elem.mozMatchesSelector !== undefined) {\r\n          return elem.mozMatchesSelector(selector);\r\n        } else {\r\n          throw new Error('Browser lacks native selectors');\r\n        }\r\n      }\r\n    };\r\n    var bypassSelector = function (dom) {\r\n      return dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\r\n    };\r\n    var all$3 = function (selector, scope) {\r\n      var base = scope === undefined ? document : scope.dom;\r\n      return bypassSelector(base) ? [] : map$2(base.querySelectorAll(selector), SugarElement.fromDom);\r\n    };\r\n    var one = function (selector, scope) {\r\n      var base = scope === undefined ? document : scope.dom;\r\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\r\n    };\r\n\r\n    var eq = function (e1, e2) {\r\n      return e1.dom === e2.dom;\r\n    };\r\n    var regularContains = function (e1, e2) {\r\n      var d1 = e1.dom;\r\n      var d2 = e2.dom;\r\n      return d1 === d2 ? false : d1.contains(d2);\r\n    };\r\n    var ieContains = function (e1, e2) {\r\n      return documentPositionContainedBy(e1.dom, e2.dom);\r\n    };\r\n    var contains = function (e1, e2) {\r\n      return detect$1().browser.isIE() ? ieContains(e1, e2) : regularContains(e1, e2);\r\n    };\r\n\r\n    var owner$4 = function (element) {\r\n      return SugarElement.fromDom(element.dom.ownerDocument);\r\n    };\r\n    var documentOrOwner = function (dos) {\r\n      return isDocument(dos) ? dos : owner$4(dos);\r\n    };\r\n    var documentElement = function (element) {\r\n      return SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\r\n    };\r\n    var defaultView = function (element) {\r\n      return SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\r\n    };\r\n    var parent = function (element) {\r\n      return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\r\n    };\r\n    var parentNode = function (element) {\r\n      return parent(element);\r\n    };\r\n    var offsetParent = function (element) {\r\n      return Optional.from(element.dom.offsetParent).map(SugarElement.fromDom);\r\n    };\r\n    var nextSibling = function (element) {\r\n      return Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\r\n    };\r\n    var children = function (element) {\r\n      return map$2(element.dom.childNodes, SugarElement.fromDom);\r\n    };\r\n    var child$2 = function (element, index) {\r\n      var cs = element.dom.childNodes;\r\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\r\n    };\r\n    var firstChild = function (element) {\r\n      return child$2(element, 0);\r\n    };\r\n    var spot = function (element, offset) {\r\n      return {\r\n        element: element,\r\n        offset: offset\r\n      };\r\n    };\r\n    var leaf = function (element, offset) {\r\n      var cs = children(element);\r\n      return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);\r\n    };\r\n\r\n    var isShadowRoot = function (dos) {\r\n      return isDocumentFragment(dos) && isNonNullable(dos.dom.host);\r\n    };\r\n    var supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\r\n    var isSupported = constant$1(supported);\r\n    var getRootNode = supported ? function (e) {\r\n      return SugarElement.fromDom(e.dom.getRootNode());\r\n    } : documentOrOwner;\r\n    var getContentContainer = function (dos) {\r\n      return isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\r\n    };\r\n    var isInShadowRoot = function (e) {\r\n      return getShadowRoot(e).isSome();\r\n    };\r\n    var getShadowRoot = function (e) {\r\n      var r = getRootNode(e);\r\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\r\n    };\r\n    var getShadowHost = function (e) {\r\n      return SugarElement.fromDom(e.dom.host);\r\n    };\r\n    var getOriginalEventTarget = function (event) {\r\n      if (isSupported() && isNonNullable(event.target)) {\r\n        var el = SugarElement.fromDom(event.target);\r\n        if (isElement$2(el) && isOpenShadowHost(el)) {\r\n          if (event.composed && event.composedPath) {\r\n            var composedPath = event.composedPath();\r\n            if (composedPath) {\r\n              return head(composedPath);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return Optional.from(event.target);\r\n    };\r\n    var isOpenShadowHost = function (element) {\r\n      return isNonNullable(element.dom.shadowRoot);\r\n    };\r\n\r\n    var inBody = function (element) {\r\n      var dom = isText$1(element) ? element.dom.parentNode : element.dom;\r\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\r\n        return false;\r\n      }\r\n      var doc = dom.ownerDocument;\r\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(function () {\r\n        return doc.body.contains(dom);\r\n      }, compose1(inBody, getShadowHost));\r\n    };\r\n    var body = function () {\r\n      return getBody(SugarElement.fromDom(document));\r\n    };\r\n    var getBody = function (doc) {\r\n      var b = doc.dom.body;\r\n      if (b === null || b === undefined) {\r\n        throw new Error('Body is not available yet');\r\n      }\r\n      return SugarElement.fromDom(b);\r\n    };\r\n\r\n    var rawSet = function (dom, key, value) {\r\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\r\n        dom.setAttribute(key, value + '');\r\n      } else {\r\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\r\n        throw new Error('Attribute value was not simple');\r\n      }\r\n    };\r\n    var set$8 = function (element, key, value) {\r\n      rawSet(element.dom, key, value);\r\n    };\r\n    var setAll$1 = function (element, attrs) {\r\n      var dom = element.dom;\r\n      each(attrs, function (v, k) {\r\n        rawSet(dom, k, v);\r\n      });\r\n    };\r\n    var get$d = function (element, key) {\r\n      var v = element.dom.getAttribute(key);\r\n      return v === null ? undefined : v;\r\n    };\r\n    var getOpt = function (element, key) {\r\n      return Optional.from(get$d(element, key));\r\n    };\r\n    var has$1 = function (element, key) {\r\n      var dom = element.dom;\r\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\r\n    };\r\n    var remove$7 = function (element, key) {\r\n      element.dom.removeAttribute(key);\r\n    };\r\n\r\n    var internalSet = function (dom, property, value) {\r\n      if (!isString(value)) {\r\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\r\n        throw new Error('CSS value must be a string: ' + value);\r\n      }\r\n      if (isSupported$1(dom)) {\r\n        dom.style.setProperty(property, value);\r\n      }\r\n    };\r\n    var internalRemove = function (dom, property) {\r\n      if (isSupported$1(dom)) {\r\n        dom.style.removeProperty(property);\r\n      }\r\n    };\r\n    var set$7 = function (element, property, value) {\r\n      var dom = element.dom;\r\n      internalSet(dom, property, value);\r\n    };\r\n    var setAll = function (element, css) {\r\n      var dom = element.dom;\r\n      each(css, function (v, k) {\r\n        internalSet(dom, k, v);\r\n      });\r\n    };\r\n    var setOptions = function (element, css) {\r\n      var dom = element.dom;\r\n      each(css, function (v, k) {\r\n        v.fold(function () {\r\n          internalRemove(dom, k);\r\n        }, function (value) {\r\n          internalSet(dom, k, value);\r\n        });\r\n      });\r\n    };\r\n    var get$c = function (element, property) {\r\n      var dom = element.dom;\r\n      var styles = window.getComputedStyle(dom);\r\n      var r = styles.getPropertyValue(property);\r\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\r\n    };\r\n    var getUnsafeProperty = function (dom, property) {\r\n      return isSupported$1(dom) ? dom.style.getPropertyValue(property) : '';\r\n    };\r\n    var getRaw = function (element, property) {\r\n      var dom = element.dom;\r\n      var raw = getUnsafeProperty(dom, property);\r\n      return Optional.from(raw).filter(function (r) {\r\n        return r.length > 0;\r\n      });\r\n    };\r\n    var getAllRaw = function (element) {\r\n      var css = {};\r\n      var dom = element.dom;\r\n      if (isSupported$1(dom)) {\r\n        for (var i = 0; i < dom.style.length; i++) {\r\n          var ruleName = dom.style.item(i);\r\n          css[ruleName] = dom.style[ruleName];\r\n        }\r\n      }\r\n      return css;\r\n    };\r\n    var isValidValue = function (tag, property, value) {\r\n      var element = SugarElement.fromTag(tag);\r\n      set$7(element, property, value);\r\n      var style = getRaw(element, property);\r\n      return style.isSome();\r\n    };\r\n    var remove$6 = function (element, property) {\r\n      var dom = element.dom;\r\n      internalRemove(dom, property);\r\n      if (is$1(getOpt(element, 'style').map(trim$1), '')) {\r\n        remove$7(element, 'style');\r\n      }\r\n    };\r\n    var reflow = function (e) {\r\n      return e.dom.offsetWidth;\r\n    };\r\n\r\n    var Dimension = function (name, getOffset) {\r\n      var set = function (element, h) {\r\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\r\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\r\n        }\r\n        var dom = element.dom;\r\n        if (isSupported$1(dom)) {\r\n          dom.style[name] = h + 'px';\r\n        }\r\n      };\r\n      var get = function (element) {\r\n        var r = getOffset(element);\r\n        if (r <= 0 || r === null) {\r\n          var css = get$c(element, name);\r\n          return parseFloat(css) || 0;\r\n        }\r\n        return r;\r\n      };\r\n      var getOuter = get;\r\n      var aggregate = function (element, properties) {\r\n        return foldl(properties, function (acc, property) {\r\n          var val = get$c(element, property);\r\n          var value = val === undefined ? 0 : parseInt(val, 10);\r\n          return isNaN(value) ? acc : acc + value;\r\n        }, 0);\r\n      };\r\n      var max = function (element, value, properties) {\r\n        var cumulativeInclusions = aggregate(element, properties);\r\n        var absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\r\n        return absoluteMax;\r\n      };\r\n      return {\r\n        set: set,\r\n        get: get,\r\n        getOuter: getOuter,\r\n        aggregate: aggregate,\r\n        max: max\r\n      };\r\n    };\r\n\r\n    var api$3 = Dimension('height', function (element) {\r\n      var dom = element.dom;\r\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\r\n    });\r\n    var get$b = function (element) {\r\n      return api$3.get(element);\r\n    };\r\n    var getOuter$2 = function (element) {\r\n      return api$3.getOuter(element);\r\n    };\r\n    var setMax$1 = function (element, value) {\r\n      var inclusions = [\r\n        'margin-top',\r\n        'border-top-width',\r\n        'padding-top',\r\n        'padding-bottom',\r\n        'border-bottom-width',\r\n        'margin-bottom'\r\n      ];\r\n      var absMax = api$3.max(element, value, inclusions);\r\n      set$7(element, 'max-height', absMax + 'px');\r\n    };\r\n\r\n    var r$1 = function (left, top) {\r\n      var translate = function (x, y) {\r\n        return r$1(left + x, top + y);\r\n      };\r\n      return {\r\n        left: left,\r\n        top: top,\r\n        translate: translate\r\n      };\r\n    };\r\n    var SugarPosition = r$1;\r\n\r\n    var boxPosition = function (dom) {\r\n      var box = dom.getBoundingClientRect();\r\n      return SugarPosition(box.left, box.top);\r\n    };\r\n    var firstDefinedOrZero = function (a, b) {\r\n      if (a !== undefined) {\r\n        return a;\r\n      } else {\r\n        return b !== undefined ? b : 0;\r\n      }\r\n    };\r\n    var absolute$3 = function (element) {\r\n      var doc = element.dom.ownerDocument;\r\n      var body = doc.body;\r\n      var win = doc.defaultView;\r\n      var html = doc.documentElement;\r\n      if (body === element.dom) {\r\n        return SugarPosition(body.offsetLeft, body.offsetTop);\r\n      }\r\n      var scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\r\n      var scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\r\n      var clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\r\n      var clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\r\n      return viewport$1(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\r\n    };\r\n    var viewport$1 = function (element) {\r\n      var dom = element.dom;\r\n      var doc = dom.ownerDocument;\r\n      var body = doc.body;\r\n      if (body === dom) {\r\n        return SugarPosition(body.offsetLeft, body.offsetTop);\r\n      }\r\n      if (!inBody(element)) {\r\n        return SugarPosition(0, 0);\r\n      }\r\n      return boxPosition(dom);\r\n    };\r\n\r\n    var api$2 = Dimension('width', function (element) {\r\n      return element.dom.offsetWidth;\r\n    });\r\n    var set$6 = function (element, h) {\r\n      return api$2.set(element, h);\r\n    };\r\n    var get$a = function (element) {\r\n      return api$2.get(element);\r\n    };\r\n    var getOuter$1 = function (element) {\r\n      return api$2.getOuter(element);\r\n    };\r\n    var setMax = function (element, value) {\r\n      var inclusions = [\r\n        'margin-left',\r\n        'border-left-width',\r\n        'padding-left',\r\n        'padding-right',\r\n        'border-right-width',\r\n        'margin-right'\r\n      ];\r\n      var absMax = api$2.max(element, value, inclusions);\r\n      set$7(element, 'max-width', absMax + 'px');\r\n    };\r\n\r\n    var mkEvent = function (target, x, y, stop, prevent, kill, raw) {\r\n      return {\r\n        target: target,\r\n        x: x,\r\n        y: y,\r\n        stop: stop,\r\n        prevent: prevent,\r\n        kill: kill,\r\n        raw: raw\r\n      };\r\n    };\r\n    var fromRawEvent$1 = function (rawEvent) {\r\n      var target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\r\n      var stop = function () {\r\n        return rawEvent.stopPropagation();\r\n      };\r\n      var prevent = function () {\r\n        return rawEvent.preventDefault();\r\n      };\r\n      var kill = compose(prevent, stop);\r\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\r\n    };\r\n    var handle = function (filter, handler) {\r\n      return function (rawEvent) {\r\n        if (filter(rawEvent)) {\r\n          handler(fromRawEvent$1(rawEvent));\r\n        }\r\n      };\r\n    };\r\n    var binder = function (element, event, filter, handler, useCapture) {\r\n      var wrapped = handle(filter, handler);\r\n      element.dom.addEventListener(event, wrapped, useCapture);\r\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\r\n    };\r\n    var bind$2 = function (element, event, filter, handler) {\r\n      return binder(element, event, filter, handler, false);\r\n    };\r\n    var capture$1 = function (element, event, filter, handler) {\r\n      return binder(element, event, filter, handler, true);\r\n    };\r\n    var unbind = function (element, event, handler, useCapture) {\r\n      element.dom.removeEventListener(event, handler, useCapture);\r\n    };\r\n\r\n    var before$2 = function (marker, element) {\r\n      var parent$1 = parent(marker);\r\n      parent$1.each(function (v) {\r\n        v.dom.insertBefore(element.dom, marker.dom);\r\n      });\r\n    };\r\n    var after$2 = function (marker, element) {\r\n      var sibling = nextSibling(marker);\r\n      sibling.fold(function () {\r\n        var parent$1 = parent(marker);\r\n        parent$1.each(function (v) {\r\n          append$2(v, element);\r\n        });\r\n      }, function (v) {\r\n        before$2(v, element);\r\n      });\r\n    };\r\n    var prepend$1 = function (parent, element) {\r\n      var firstChild$1 = firstChild(parent);\r\n      firstChild$1.fold(function () {\r\n        append$2(parent, element);\r\n      }, function (v) {\r\n        parent.dom.insertBefore(element.dom, v.dom);\r\n      });\r\n    };\r\n    var append$2 = function (parent, element) {\r\n      parent.dom.appendChild(element.dom);\r\n    };\r\n    var appendAt = function (parent, element, index) {\r\n      child$2(parent, index).fold(function () {\r\n        append$2(parent, element);\r\n      }, function (v) {\r\n        before$2(v, element);\r\n      });\r\n    };\r\n\r\n    var before$1 = function (marker, elements) {\r\n      each$1(elements, function (x) {\r\n        before$2(marker, x);\r\n      });\r\n    };\r\n    var append$1 = function (parent, elements) {\r\n      each$1(elements, function (x) {\r\n        append$2(parent, x);\r\n      });\r\n    };\r\n\r\n    var empty = function (element) {\r\n      element.dom.textContent = '';\r\n      each$1(children(element), function (rogue) {\r\n        remove$5(rogue);\r\n      });\r\n    };\r\n    var remove$5 = function (element) {\r\n      var dom = element.dom;\r\n      if (dom.parentNode !== null) {\r\n        dom.parentNode.removeChild(dom);\r\n      }\r\n    };\r\n    var unwrap = function (wrapper) {\r\n      var children$1 = children(wrapper);\r\n      if (children$1.length > 0) {\r\n        before$1(wrapper, children$1);\r\n      }\r\n      remove$5(wrapper);\r\n    };\r\n\r\n    var get$9 = function (_DOC) {\r\n      var doc = _DOC !== undefined ? _DOC.dom : document;\r\n      var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\r\n      var y = doc.body.scrollTop || doc.documentElement.scrollTop;\r\n      return SugarPosition(x, y);\r\n    };\r\n    var to = function (x, y, _DOC) {\r\n      var doc = _DOC !== undefined ? _DOC.dom : document;\r\n      var win = doc.defaultView;\r\n      if (win) {\r\n        win.scrollTo(x, y);\r\n      }\r\n    };\r\n\r\n    var get$8 = function (_win) {\r\n      var win = _win === undefined ? window : _win;\r\n      if (detect$1().browser.isFirefox()) {\r\n        return Optional.none();\r\n      } else {\r\n        return Optional.from(win['visualViewport']);\r\n      }\r\n    };\r\n    var bounds$1 = function (x, y, width, height) {\r\n      return {\r\n        x: x,\r\n        y: y,\r\n        width: width,\r\n        height: height,\r\n        right: x + width,\r\n        bottom: y + height\r\n      };\r\n    };\r\n    var getBounds$3 = function (_win) {\r\n      var win = _win === undefined ? window : _win;\r\n      var doc = win.document;\r\n      var scroll = get$9(SugarElement.fromDom(doc));\r\n      return get$8(win).fold(function () {\r\n        var html = win.document.documentElement;\r\n        var width = html.clientWidth;\r\n        var height = html.clientHeight;\r\n        return bounds$1(scroll.left, scroll.top, width, height);\r\n      }, function (visualViewport) {\r\n        return bounds$1(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height);\r\n      });\r\n    };\r\n\r\n    var walkUp = function (navigation, doc) {\r\n      var frame = navigation.view(doc);\r\n      return frame.fold(constant$1([]), function (f) {\r\n        var parent = navigation.owner(f);\r\n        var rest = walkUp(navigation, parent);\r\n        return [f].concat(rest);\r\n      });\r\n    };\r\n    var pathTo = function (element, navigation) {\r\n      var d = navigation.owner(element);\r\n      var paths = walkUp(navigation, d);\r\n      return Optional.some(paths);\r\n    };\r\n\r\n    var view = function (doc) {\r\n      var _a;\r\n      var element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\r\n      return element.map(SugarElement.fromDom);\r\n    };\r\n    var owner$3 = function (element) {\r\n      return owner$4(element);\r\n    };\r\n\r\n    var Navigation = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        view: view,\r\n        owner: owner$3\r\n    });\r\n\r\n    var find$2 = function (element) {\r\n      var doc = SugarElement.fromDom(document);\r\n      var scroll = get$9(doc);\r\n      var path = pathTo(element, Navigation);\r\n      return path.fold(curry(absolute$3, element), function (frames) {\r\n        var offset = viewport$1(element);\r\n        var r = foldr(frames, function (b, a) {\r\n          var loc = viewport$1(a);\r\n          return {\r\n            left: b.left + loc.left,\r\n            top: b.top + loc.top\r\n          };\r\n        }, {\r\n          left: 0,\r\n          top: 0\r\n        });\r\n        return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\r\n      });\r\n    };\r\n\r\n    var pointed = function (point, width, height) {\r\n      return {\r\n        point: point,\r\n        width: width,\r\n        height: height\r\n      };\r\n    };\r\n    var rect = function (x, y, width, height) {\r\n      return {\r\n        x: x,\r\n        y: y,\r\n        width: width,\r\n        height: height\r\n      };\r\n    };\r\n    var bounds = function (x, y, width, height) {\r\n      return {\r\n        x: x,\r\n        y: y,\r\n        width: width,\r\n        height: height,\r\n        right: x + width,\r\n        bottom: y + height\r\n      };\r\n    };\r\n    var box$1 = function (element) {\r\n      var xy = absolute$3(element);\r\n      var w = getOuter$1(element);\r\n      var h = getOuter$2(element);\r\n      return bounds(xy.left, xy.top, w, h);\r\n    };\r\n    var absolute$2 = function (element) {\r\n      var position = find$2(element);\r\n      var width = getOuter$1(element);\r\n      var height = getOuter$2(element);\r\n      return bounds(position.left, position.top, width, height);\r\n    };\r\n    var win = function () {\r\n      return getBounds$3(window);\r\n    };\r\n\r\n    var value$3 = function (o) {\r\n      var or = function (_opt) {\r\n        return value$3(o);\r\n      };\r\n      var orThunk = function (_f) {\r\n        return value$3(o);\r\n      };\r\n      var map = function (f) {\r\n        return value$3(f(o));\r\n      };\r\n      var mapError = function (_f) {\r\n        return value$3(o);\r\n      };\r\n      var each = function (f) {\r\n        f(o);\r\n      };\r\n      var bind = function (f) {\r\n        return f(o);\r\n      };\r\n      var fold = function (_, onValue) {\r\n        return onValue(o);\r\n      };\r\n      var exists = function (f) {\r\n        return f(o);\r\n      };\r\n      var forall = function (f) {\r\n        return f(o);\r\n      };\r\n      var toOptional = function () {\r\n        return Optional.some(o);\r\n      };\r\n      return {\r\n        isValue: always,\r\n        isError: never,\r\n        getOr: constant$1(o),\r\n        getOrThunk: constant$1(o),\r\n        getOrDie: constant$1(o),\r\n        or: or,\r\n        orThunk: orThunk,\r\n        fold: fold,\r\n        map: map,\r\n        mapError: mapError,\r\n        each: each,\r\n        bind: bind,\r\n        exists: exists,\r\n        forall: forall,\r\n        toOptional: toOptional\r\n      };\r\n    };\r\n    var error$1 = function (message) {\r\n      var getOrThunk = function (f) {\r\n        return f();\r\n      };\r\n      var getOrDie = function () {\r\n        return die(String(message))();\r\n      };\r\n      var or = identity$1;\r\n      var orThunk = function (f) {\r\n        return f();\r\n      };\r\n      var map = function (_f) {\r\n        return error$1(message);\r\n      };\r\n      var mapError = function (f) {\r\n        return error$1(f(message));\r\n      };\r\n      var bind = function (_f) {\r\n        return error$1(message);\r\n      };\r\n      var fold = function (onError, _) {\r\n        return onError(message);\r\n      };\r\n      return {\r\n        isValue: never,\r\n        isError: always,\r\n        getOr: identity$1,\r\n        getOrThunk: getOrThunk,\r\n        getOrDie: getOrDie,\r\n        or: or,\r\n        orThunk: orThunk,\r\n        fold: fold,\r\n        map: map,\r\n        mapError: mapError,\r\n        each: noop,\r\n        bind: bind,\r\n        exists: never,\r\n        forall: always,\r\n        toOptional: Optional.none\r\n      };\r\n    };\r\n    var fromOption = function (opt, err) {\r\n      return opt.fold(function () {\r\n        return error$1(err);\r\n      }, value$3);\r\n    };\r\n    var Result = {\r\n      value: value$3,\r\n      error: error$1,\r\n      fromOption: fromOption\r\n    };\r\n\r\n    var SimpleResultType;\r\n    (function (SimpleResultType) {\r\n      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\r\n      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\r\n    }(SimpleResultType || (SimpleResultType = {})));\r\n    var fold$1 = function (res, onError, onValue) {\r\n      return res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\r\n    };\r\n    var partition$2 = function (results) {\r\n      var values = [];\r\n      var errors = [];\r\n      each$1(results, function (obj) {\r\n        fold$1(obj, function (err) {\r\n          return errors.push(err);\r\n        }, function (val) {\r\n          return values.push(val);\r\n        });\r\n      });\r\n      return {\r\n        values: values,\r\n        errors: errors\r\n      };\r\n    };\r\n    var mapError = function (res, f) {\r\n      if (res.stype === SimpleResultType.Error) {\r\n        return {\r\n          stype: SimpleResultType.Error,\r\n          serror: f(res.serror)\r\n        };\r\n      } else {\r\n        return res;\r\n      }\r\n    };\r\n    var map = function (res, f) {\r\n      if (res.stype === SimpleResultType.Value) {\r\n        return {\r\n          stype: SimpleResultType.Value,\r\n          svalue: f(res.svalue)\r\n        };\r\n      } else {\r\n        return res;\r\n      }\r\n    };\r\n    var bind$1 = function (res, f) {\r\n      if (res.stype === SimpleResultType.Value) {\r\n        return f(res.svalue);\r\n      } else {\r\n        return res;\r\n      }\r\n    };\r\n    var bindError = function (res, f) {\r\n      if (res.stype === SimpleResultType.Error) {\r\n        return f(res.serror);\r\n      } else {\r\n        return res;\r\n      }\r\n    };\r\n    var svalue = function (v) {\r\n      return {\r\n        stype: SimpleResultType.Value,\r\n        svalue: v\r\n      };\r\n    };\r\n    var serror = function (e) {\r\n      return {\r\n        stype: SimpleResultType.Error,\r\n        serror: e\r\n      };\r\n    };\r\n    var toResult$1 = function (res) {\r\n      return fold$1(res, Result.error, Result.value);\r\n    };\r\n    var fromResult$1 = function (res) {\r\n      return res.fold(serror, svalue);\r\n    };\r\n    var SimpleResult = {\r\n      fromResult: fromResult$1,\r\n      toResult: toResult$1,\r\n      svalue: svalue,\r\n      partition: partition$2,\r\n      serror: serror,\r\n      bind: bind$1,\r\n      bindError: bindError,\r\n      map: map,\r\n      mapError: mapError,\r\n      fold: fold$1\r\n    };\r\n\r\n    var field$2 = function (key, newKey, presence, prop) {\r\n      return {\r\n        tag: 'field',\r\n        key: key,\r\n        newKey: newKey,\r\n        presence: presence,\r\n        prop: prop\r\n      };\r\n    };\r\n    var customField$1 = function (newKey, instantiator) {\r\n      return {\r\n        tag: 'custom',\r\n        newKey: newKey,\r\n        instantiator: instantiator\r\n      };\r\n    };\r\n    var fold = function (value, ifField, ifCustom) {\r\n      switch (value.tag) {\r\n      case 'field':\r\n        return ifField(value.key, value.newKey, value.presence, value.prop);\r\n      case 'custom':\r\n        return ifCustom(value.newKey, value.instantiator);\r\n      }\r\n    };\r\n\r\n    var shallow$1 = function (old, nu) {\r\n      return nu;\r\n    };\r\n    var deep = function (old, nu) {\r\n      var bothObjects = isObject(old) && isObject(nu);\r\n      return bothObjects ? deepMerge(old, nu) : nu;\r\n    };\r\n    var baseMerge = function (merger) {\r\n      return function () {\r\n        var objects = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          objects[_i] = arguments[_i];\r\n        }\r\n        if (objects.length === 0) {\r\n          throw new Error('Can\\'t merge zero objects');\r\n        }\r\n        var ret = {};\r\n        for (var j = 0; j < objects.length; j++) {\r\n          var curObject = objects[j];\r\n          for (var key in curObject) {\r\n            if (has$2(curObject, key)) {\r\n              ret[key] = merger(ret[key], curObject[key]);\r\n            }\r\n          }\r\n        }\r\n        return ret;\r\n      };\r\n    };\r\n    var deepMerge = baseMerge(deep);\r\n    var merge$1 = baseMerge(shallow$1);\r\n\r\n    var required$2 = function () {\r\n      return {\r\n        tag: 'required',\r\n        process: {}\r\n      };\r\n    };\r\n    var defaultedThunk = function (fallbackThunk) {\r\n      return {\r\n        tag: 'defaultedThunk',\r\n        process: fallbackThunk\r\n      };\r\n    };\r\n    var defaulted$1 = function (fallback) {\r\n      return defaultedThunk(constant$1(fallback));\r\n    };\r\n    var asOption = function () {\r\n      return {\r\n        tag: 'option',\r\n        process: {}\r\n      };\r\n    };\r\n    var mergeWithThunk = function (baseThunk) {\r\n      return {\r\n        tag: 'mergeWithThunk',\r\n        process: baseThunk\r\n      };\r\n    };\r\n    var mergeWith = function (base) {\r\n      return mergeWithThunk(constant$1(base));\r\n    };\r\n\r\n    var mergeValues$1 = function (values, base) {\r\n      return values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge$1.apply(undefined, values))) : SimpleResult.svalue(base);\r\n    };\r\n    var mergeErrors$1 = function (errors) {\r\n      return compose(SimpleResult.serror, flatten)(errors);\r\n    };\r\n    var consolidateObj = function (objects, base) {\r\n      var partition = SimpleResult.partition(objects);\r\n      return partition.errors.length > 0 ? mergeErrors$1(partition.errors) : mergeValues$1(partition.values, base);\r\n    };\r\n    var consolidateArr = function (objects) {\r\n      var partitions = SimpleResult.partition(objects);\r\n      return partitions.errors.length > 0 ? mergeErrors$1(partitions.errors) : SimpleResult.svalue(partitions.values);\r\n    };\r\n    var ResultCombine = {\r\n      consolidateObj: consolidateObj,\r\n      consolidateArr: consolidateArr\r\n    };\r\n\r\n    var formatObj = function (input) {\r\n      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\r\n    };\r\n    var formatErrors = function (errors) {\r\n      var es = errors.length > 10 ? errors.slice(0, 10).concat([{\r\n          path: [],\r\n          getErrorInfo: constant$1('... (only showing first ten failures)')\r\n        }]) : errors;\r\n      return map$2(es, function (e) {\r\n        return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\r\n      });\r\n    };\r\n\r\n    var nu$a = function (path, getErrorInfo) {\r\n      return SimpleResult.serror([{\r\n          path: path,\r\n          getErrorInfo: getErrorInfo\r\n        }]);\r\n    };\r\n    var missingRequired = function (path, key, obj) {\r\n      return nu$a(path, function () {\r\n        return 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj);\r\n      });\r\n    };\r\n    var missingKey = function (path, key) {\r\n      return nu$a(path, function () {\r\n        return 'Choice schema did not contain choice key: \"' + key + '\"';\r\n      });\r\n    };\r\n    var missingBranch = function (path, branches, branch) {\r\n      return nu$a(path, function () {\r\n        return 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches);\r\n      });\r\n    };\r\n    var unsupportedFields = function (path, unsupported) {\r\n      return nu$a(path, function () {\r\n        return 'There are unsupported fields: [' + unsupported.join(', ') + '] specified';\r\n      });\r\n    };\r\n    var custom = function (path, err) {\r\n      return nu$a(path, constant$1(err));\r\n    };\r\n\r\n    var value$2 = function (validator) {\r\n      var extract = function (path, val) {\r\n        return SimpleResult.bindError(validator(val), function (err) {\r\n          return custom(path, err);\r\n        });\r\n      };\r\n      var toString = constant$1('val');\r\n      return {\r\n        extract: extract,\r\n        toString: toString\r\n      };\r\n    };\r\n    var anyValue$1 = value$2(SimpleResult.svalue);\r\n\r\n    var requiredAccess = function (path, obj, key, bundle) {\r\n      return get$e(obj, key).fold(function () {\r\n        return missingRequired(path, key, obj);\r\n      }, bundle);\r\n    };\r\n    var fallbackAccess = function (obj, key, fallback, bundle) {\r\n      var v = get$e(obj, key).getOrThunk(function () {\r\n        return fallback(obj);\r\n      });\r\n      return bundle(v);\r\n    };\r\n    var optionAccess = function (obj, key, bundle) {\r\n      return bundle(get$e(obj, key));\r\n    };\r\n    var optionDefaultedAccess = function (obj, key, fallback, bundle) {\r\n      var opt = get$e(obj, key).map(function (val) {\r\n        return val === true ? fallback(obj) : val;\r\n      });\r\n      return bundle(opt);\r\n    };\r\n    var extractField = function (field, path, obj, key, prop) {\r\n      var bundle = function (av) {\r\n        return prop.extract(path.concat([key]), av);\r\n      };\r\n      var bundleAsOption = function (optValue) {\r\n        return optValue.fold(function () {\r\n          return SimpleResult.svalue(Optional.none());\r\n        }, function (ov) {\r\n          var result = prop.extract(path.concat([key]), ov);\r\n          return SimpleResult.map(result, Optional.some);\r\n        });\r\n      };\r\n      switch (field.tag) {\r\n      case 'required':\r\n        return requiredAccess(path, obj, key, bundle);\r\n      case 'defaultedThunk':\r\n        return fallbackAccess(obj, key, field.process, bundle);\r\n      case 'option':\r\n        return optionAccess(obj, key, bundleAsOption);\r\n      case 'defaultedOptionThunk':\r\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\r\n      case 'mergeWithThunk': {\r\n          return fallbackAccess(obj, key, constant$1({}), function (v) {\r\n            var result = deepMerge(field.process(obj), v);\r\n            return bundle(result);\r\n          });\r\n        }\r\n      }\r\n    };\r\n    var extractFields = function (path, obj, fields) {\r\n      var success = {};\r\n      var errors = [];\r\n      for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {\r\n        var field = fields_1[_i];\r\n        fold(field, function (key, newKey, presence, prop) {\r\n          var result = extractField(presence, path, obj, key, prop);\r\n          SimpleResult.fold(result, function (err) {\r\n            errors.push.apply(errors, err);\r\n          }, function (res) {\r\n            success[newKey] = res;\r\n          });\r\n        }, function (newKey, instantiator) {\r\n          success[newKey] = instantiator(obj);\r\n        });\r\n      }\r\n      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\r\n    };\r\n    var valueThunk = function (getDelegate) {\r\n      var extract = function (path, val) {\r\n        return getDelegate().extract(path, val);\r\n      };\r\n      var toString = function () {\r\n        return getDelegate().toString();\r\n      };\r\n      return {\r\n        extract: extract,\r\n        toString: toString\r\n      };\r\n    };\r\n    var getSetKeys = function (obj) {\r\n      return keys(filter$1(obj, isNonNullable));\r\n    };\r\n    var objOfOnly = function (fields) {\r\n      var delegate = objOf(fields);\r\n      var fieldNames = foldr(fields, function (acc, value) {\r\n        return fold(value, function (key) {\r\n          var _a;\r\n          return deepMerge(acc, (_a = {}, _a[key] = true, _a));\r\n        }, constant$1(acc));\r\n      }, {});\r\n      var extract = function (path, o) {\r\n        var keys = isBoolean(o) ? [] : getSetKeys(o);\r\n        var extra = filter$2(keys, function (k) {\r\n          return !hasNonNullableKey(fieldNames, k);\r\n        });\r\n        return extra.length === 0 ? delegate.extract(path, o) : unsupportedFields(path, extra);\r\n      };\r\n      return {\r\n        extract: extract,\r\n        toString: delegate.toString\r\n      };\r\n    };\r\n    var objOf = function (values) {\r\n      var extract = function (path, o) {\r\n        return extractFields(path, o, values);\r\n      };\r\n      var toString = function () {\r\n        var fieldStrings = map$2(values, function (value) {\r\n          return fold(value, function (key, _okey, _presence, prop) {\r\n            return key + ' -> ' + prop.toString();\r\n          }, function (newKey, _instantiator) {\r\n            return 'state(' + newKey + ')';\r\n          });\r\n        });\r\n        return 'obj{\\n' + fieldStrings.join('\\n') + '}';\r\n      };\r\n      return {\r\n        extract: extract,\r\n        toString: toString\r\n      };\r\n    };\r\n    var arrOf = function (prop) {\r\n      var extract = function (path, array) {\r\n        var results = map$2(array, function (a, i) {\r\n          return prop.extract(path.concat(['[' + i + ']']), a);\r\n        });\r\n        return ResultCombine.consolidateArr(results);\r\n      };\r\n      var toString = function () {\r\n        return 'array(' + prop.toString() + ')';\r\n      };\r\n      return {\r\n        extract: extract,\r\n        toString: toString\r\n      };\r\n    };\r\n    var oneOf = function (props) {\r\n      var extract = function (path, val) {\r\n        var errors = [];\r\n        for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {\r\n          var prop = props_1[_i];\r\n          var res = prop.extract(path, val);\r\n          if (res.stype === SimpleResultType.Value) {\r\n            return res;\r\n          }\r\n          errors.push(res);\r\n        }\r\n        return ResultCombine.consolidateArr(errors);\r\n      };\r\n      var toString = function () {\r\n        return 'oneOf(' + map$2(props, function (prop) {\r\n          return prop.toString();\r\n        }).join(', ') + ')';\r\n      };\r\n      return {\r\n        extract: extract,\r\n        toString: toString\r\n      };\r\n    };\r\n    var setOf$1 = function (validator, prop) {\r\n      var validateKeys = function (path, keys) {\r\n        return arrOf(value$2(validator)).extract(path, keys);\r\n      };\r\n      var extract = function (path, o) {\r\n        var keys$1 = keys(o);\r\n        var validatedKeys = validateKeys(path, keys$1);\r\n        return SimpleResult.bind(validatedKeys, function (validKeys) {\r\n          var schema = map$2(validKeys, function (vk) {\r\n            return field$2(vk, vk, required$2(), prop);\r\n          });\r\n          return objOf(schema).extract(path, o);\r\n        });\r\n      };\r\n      var toString = function () {\r\n        return 'setOf(' + prop.toString() + ')';\r\n      };\r\n      return {\r\n        extract: extract,\r\n        toString: toString\r\n      };\r\n    };\r\n    var thunk = function (_desc, processor) {\r\n      var getP = cached(processor);\r\n      var extract = function (path, val) {\r\n        return getP().extract(path, val);\r\n      };\r\n      var toString = function () {\r\n        return getP().toString();\r\n      };\r\n      return {\r\n        extract: extract,\r\n        toString: toString\r\n      };\r\n    };\r\n    var arrOfObj = compose(arrOf, objOf);\r\n\r\n    var anyValue = constant$1(anyValue$1);\r\n    var typedValue = function (validator, expectedType) {\r\n      return value$2(function (a) {\r\n        var actualType = typeof a;\r\n        return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror('Expected type: ' + expectedType + ' but got: ' + actualType);\r\n      });\r\n    };\r\n    var number = typedValue(isNumber, 'number');\r\n    var string = typedValue(isString, 'string');\r\n    var boolean = typedValue(isBoolean, 'boolean');\r\n    var functionProcessor = typedValue(isFunction, 'function');\r\n    var isPostMessageable = function (val) {\r\n      if (Object(val) !== val) {\r\n        return true;\r\n      }\r\n      switch ({}.toString.call(val).slice(8, -1)) {\r\n      case 'Boolean':\r\n      case 'Number':\r\n      case 'String':\r\n      case 'Date':\r\n      case 'RegExp':\r\n      case 'Blob':\r\n      case 'FileList':\r\n      case 'ImageData':\r\n      case 'ImageBitmap':\r\n      case 'ArrayBuffer':\r\n        return true;\r\n      case 'Array':\r\n      case 'Object':\r\n        return Object.keys(val).every(function (prop) {\r\n          return isPostMessageable(val[prop]);\r\n        });\r\n      default:\r\n        return false;\r\n      }\r\n    };\r\n    var postMessageable = value$2(function (a) {\r\n      if (isPostMessageable(a)) {\r\n        return SimpleResult.svalue(a);\r\n      } else {\r\n        return SimpleResult.serror('Expected value to be acceptable for sending via postMessage');\r\n      }\r\n    });\r\n\r\n    var chooseFrom = function (path, input, branches, ch) {\r\n      var fields = get$e(branches, ch);\r\n      return fields.fold(function () {\r\n        return missingBranch(path, branches, ch);\r\n      }, function (vp) {\r\n        return vp.extract(path.concat(['branch: ' + ch]), input);\r\n      });\r\n    };\r\n    var choose$2 = function (key, branches) {\r\n      var extract = function (path, input) {\r\n        var choice = get$e(input, key);\r\n        return choice.fold(function () {\r\n          return missingKey(path, key);\r\n        }, function (chosen) {\r\n          return chooseFrom(path, input, branches, chosen);\r\n        });\r\n      };\r\n      var toString = function () {\r\n        return 'chooseOn(' + key + '). Possible values: ' + keys(branches);\r\n      };\r\n      return {\r\n        extract: extract,\r\n        toString: toString\r\n      };\r\n    };\r\n\r\n    var arrOfVal = function () {\r\n      return arrOf(anyValue$1);\r\n    };\r\n    var valueOf = function (validator) {\r\n      return value$2(function (v) {\r\n        return validator(v).fold(SimpleResult.serror, SimpleResult.svalue);\r\n      });\r\n    };\r\n    var setOf = function (validator, prop) {\r\n      return setOf$1(function (v) {\r\n        return SimpleResult.fromResult(validator(v));\r\n      }, prop);\r\n    };\r\n    var extractValue = function (label, prop, obj) {\r\n      var res = prop.extract([label], obj);\r\n      return SimpleResult.mapError(res, function (errs) {\r\n        return {\r\n          input: obj,\r\n          errors: errs\r\n        };\r\n      });\r\n    };\r\n    var asRaw = function (label, prop, obj) {\r\n      return SimpleResult.toResult(extractValue(label, prop, obj));\r\n    };\r\n    var getOrDie = function (extraction) {\r\n      return extraction.fold(function (errInfo) {\r\n        throw new Error(formatError(errInfo));\r\n      }, identity$1);\r\n    };\r\n    var asRawOrDie$1 = function (label, prop, obj) {\r\n      return getOrDie(asRaw(label, prop, obj));\r\n    };\r\n    var formatError = function (errInfo) {\r\n      return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\r\n    };\r\n    var choose$1 = function (key, branches) {\r\n      return choose$2(key, map$1(branches, objOf));\r\n    };\r\n    var thunkOf = function (desc, schema) {\r\n      return thunk(desc, schema);\r\n    };\r\n\r\n    var field$1 = field$2;\r\n    var customField = customField$1;\r\n    var validateEnum = function (values) {\r\n      return valueOf(function (value) {\r\n        return contains$2(values, value) ? Result.value(value) : Result.error('Unsupported value: \"' + value + '\", choose one of \"' + values.join(', ') + '\".');\r\n      });\r\n    };\r\n    var required$1 = function (key) {\r\n      return field$1(key, key, required$2(), anyValue());\r\n    };\r\n    var requiredOf = function (key, schema) {\r\n      return field$1(key, key, required$2(), schema);\r\n    };\r\n    var requiredNumber = function (key) {\r\n      return requiredOf(key, number);\r\n    };\r\n    var requiredString = function (key) {\r\n      return requiredOf(key, string);\r\n    };\r\n    var requiredStringEnum = function (key, values) {\r\n      return field$1(key, key, required$2(), validateEnum(values));\r\n    };\r\n    var requiredBoolean = function (key) {\r\n      return requiredOf(key, boolean);\r\n    };\r\n    var requiredFunction = function (key) {\r\n      return requiredOf(key, functionProcessor);\r\n    };\r\n    var forbid = function (key, message) {\r\n      return field$1(key, key, asOption(), value$2(function (_v) {\r\n        return SimpleResult.serror('The field: ' + key + ' is forbidden. ' + message);\r\n      }));\r\n    };\r\n    var requiredObjOf = function (key, objSchema) {\r\n      return field$1(key, key, required$2(), objOf(objSchema));\r\n    };\r\n    var requiredArrayOfObj = function (key, objFields) {\r\n      return field$1(key, key, required$2(), arrOfObj(objFields));\r\n    };\r\n    var requiredArrayOf = function (key, schema) {\r\n      return field$1(key, key, required$2(), arrOf(schema));\r\n    };\r\n    var option = function (key) {\r\n      return field$1(key, key, asOption(), anyValue());\r\n    };\r\n    var optionOf = function (key, schema) {\r\n      return field$1(key, key, asOption(), schema);\r\n    };\r\n    var optionNumber = function (key) {\r\n      return optionOf(key, number);\r\n    };\r\n    var optionString = function (key) {\r\n      return optionOf(key, string);\r\n    };\r\n    var optionFunction = function (key) {\r\n      return optionOf(key, functionProcessor);\r\n    };\r\n    var optionArrayOf = function (key, schema) {\r\n      return optionOf(key, arrOf(schema));\r\n    };\r\n    var optionObjOf = function (key, objSchema) {\r\n      return optionOf(key, objOf(objSchema));\r\n    };\r\n    var optionObjOfOnly = function (key, objSchema) {\r\n      return optionOf(key, objOfOnly(objSchema));\r\n    };\r\n    var defaulted = function (key, fallback) {\r\n      return field$1(key, key, defaulted$1(fallback), anyValue());\r\n    };\r\n    var defaultedOf = function (key, fallback, schema) {\r\n      return field$1(key, key, defaulted$1(fallback), schema);\r\n    };\r\n    var defaultedNumber = function (key, fallback) {\r\n      return defaultedOf(key, fallback, number);\r\n    };\r\n    var defaultedString = function (key, fallback) {\r\n      return defaultedOf(key, fallback, string);\r\n    };\r\n    var defaultedStringEnum = function (key, fallback, values) {\r\n      return defaultedOf(key, fallback, validateEnum(values));\r\n    };\r\n    var defaultedBoolean = function (key, fallback) {\r\n      return defaultedOf(key, fallback, boolean);\r\n    };\r\n    var defaultedFunction = function (key, fallback) {\r\n      return defaultedOf(key, fallback, functionProcessor);\r\n    };\r\n    var defaultedPostMsg = function (key, fallback) {\r\n      return defaultedOf(key, fallback, postMessageable);\r\n    };\r\n    var defaultedArrayOf = function (key, fallback, schema) {\r\n      return defaultedOf(key, fallback, arrOf(schema));\r\n    };\r\n    var defaultedObjOf = function (key, fallback, objSchema) {\r\n      return defaultedOf(key, fallback, objOf(objSchema));\r\n    };\r\n\r\n    var Cell = function (initial) {\r\n      var value = initial;\r\n      var get = function () {\r\n        return value;\r\n      };\r\n      var set = function (v) {\r\n        value = v;\r\n      };\r\n      return {\r\n        get: get,\r\n        set: set\r\n      };\r\n    };\r\n\r\n    var generate$7 = function (cases) {\r\n      if (!isArray(cases)) {\r\n        throw new Error('cases must be an array');\r\n      }\r\n      if (cases.length === 0) {\r\n        throw new Error('there must be at least one case');\r\n      }\r\n      var constructors = [];\r\n      var adt = {};\r\n      each$1(cases, function (acase, count) {\r\n        var keys$1 = keys(acase);\r\n        if (keys$1.length !== 1) {\r\n          throw new Error('one and only one name per case');\r\n        }\r\n        var key = keys$1[0];\r\n        var value = acase[key];\r\n        if (adt[key] !== undefined) {\r\n          throw new Error('duplicate key detected:' + key);\r\n        } else if (key === 'cata') {\r\n          throw new Error('cannot have a case named cata (sorry)');\r\n        } else if (!isArray(value)) {\r\n          throw new Error('case arguments must be an array');\r\n        }\r\n        constructors.push(key);\r\n        adt[key] = function () {\r\n          var args = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n          }\r\n          var argLength = args.length;\r\n          if (argLength !== value.length) {\r\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\r\n          }\r\n          var match = function (branches) {\r\n            var branchKeys = keys(branches);\r\n            if (constructors.length !== branchKeys.length) {\r\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\r\n            }\r\n            var allReqd = forall(constructors, function (reqKey) {\r\n              return contains$2(branchKeys, reqKey);\r\n            });\r\n            if (!allReqd) {\r\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\r\n            }\r\n            return branches[key].apply(null, args);\r\n          };\r\n          return {\r\n            fold: function () {\r\n              var foldArgs = [];\r\n              for (var _i = 0; _i < arguments.length; _i++) {\r\n                foldArgs[_i] = arguments[_i];\r\n              }\r\n              if (foldArgs.length !== cases.length) {\r\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\r\n              }\r\n              var target = foldArgs[count];\r\n              return target.apply(null, args);\r\n            },\r\n            match: match,\r\n            log: function (label) {\r\n              console.log(label, {\r\n                constructors: constructors,\r\n                constructor: key,\r\n                params: args\r\n              });\r\n            }\r\n          };\r\n        };\r\n      });\r\n      return adt;\r\n    };\r\n    var Adt = { generate: generate$7 };\r\n\r\n    Adt.generate([\r\n      {\r\n        bothErrors: [\r\n          'error1',\r\n          'error2'\r\n        ]\r\n      },\r\n      {\r\n        firstError: [\r\n          'error1',\r\n          'value2'\r\n        ]\r\n      },\r\n      {\r\n        secondError: [\r\n          'value1',\r\n          'error2'\r\n        ]\r\n      },\r\n      {\r\n        bothValues: [\r\n          'value1',\r\n          'value2'\r\n        ]\r\n      }\r\n    ]);\r\n    var partition$1 = function (results) {\r\n      var errors = [];\r\n      var values = [];\r\n      each$1(results, function (result) {\r\n        result.fold(function (err) {\r\n          errors.push(err);\r\n        }, function (value) {\r\n          values.push(value);\r\n        });\r\n      });\r\n      return {\r\n        errors: errors,\r\n        values: values\r\n      };\r\n    };\r\n\r\n    var exclude$1 = function (obj, fields) {\r\n      var r = {};\r\n      each(obj, function (v, k) {\r\n        if (!contains$2(fields, k)) {\r\n          r[k] = v;\r\n        }\r\n      });\r\n      return r;\r\n    };\r\n\r\n    var wrap$2 = function (key, value) {\r\n      var _a;\r\n      return _a = {}, _a[key] = value, _a;\r\n    };\r\n    var wrapAll$1 = function (keyvalues) {\r\n      var r = {};\r\n      each$1(keyvalues, function (kv) {\r\n        r[kv.key] = kv.value;\r\n      });\r\n      return r;\r\n    };\r\n\r\n    var exclude = function (obj, fields) {\r\n      return exclude$1(obj, fields);\r\n    };\r\n    var wrap$1 = function (key, value) {\r\n      return wrap$2(key, value);\r\n    };\r\n    var wrapAll = function (keyvalues) {\r\n      return wrapAll$1(keyvalues);\r\n    };\r\n    var mergeValues = function (values, base) {\r\n      return values.length === 0 ? Result.value(base) : Result.value(deepMerge(base, merge$1.apply(undefined, values)));\r\n    };\r\n    var mergeErrors = function (errors) {\r\n      return Result.error(flatten(errors));\r\n    };\r\n    var consolidate = function (objs, base) {\r\n      var partitions = partition$1(objs);\r\n      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : mergeValues(partitions.values, base);\r\n    };\r\n\r\n    var ensureIsRoot = function (isRoot) {\r\n      return isFunction(isRoot) ? isRoot : never;\r\n    };\r\n    var ancestor$2 = function (scope, transform, isRoot) {\r\n      var element = scope.dom;\r\n      var stop = ensureIsRoot(isRoot);\r\n      while (element.parentNode) {\r\n        element = element.parentNode;\r\n        var el = SugarElement.fromDom(element);\r\n        var transformed = transform(el);\r\n        if (transformed.isSome()) {\r\n          return transformed;\r\n        } else if (stop(el)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var closest$4 = function (scope, transform, isRoot) {\r\n      var current = transform(scope);\r\n      var stop = ensureIsRoot(isRoot);\r\n      return current.orThunk(function () {\r\n        return stop(scope) ? Optional.none() : ancestor$2(scope, transform, stop);\r\n      });\r\n    };\r\n\r\n    var isSource = function (component, simulatedEvent) {\r\n      return eq(component.element, simulatedEvent.event.target);\r\n    };\r\n\r\n    var defaultEventHandler = {\r\n      can: always,\r\n      abort: never,\r\n      run: noop\r\n    };\r\n    var nu$9 = function (parts) {\r\n      if (!hasNonNullableKey(parts, 'can') && !hasNonNullableKey(parts, 'abort') && !hasNonNullableKey(parts, 'run')) {\r\n        throw new Error('EventHandler defined by: ' + JSON.stringify(parts, null, 2) + ' does not have can, abort, or run!');\r\n      }\r\n      return __assign(__assign({}, defaultEventHandler), parts);\r\n    };\r\n    var all$2 = function (handlers, f) {\r\n      return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        return foldl(handlers, function (acc, handler) {\r\n          return acc && f(handler).apply(undefined, args);\r\n        }, true);\r\n      };\r\n    };\r\n    var any = function (handlers, f) {\r\n      return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        return foldl(handlers, function (acc, handler) {\r\n          return acc || f(handler).apply(undefined, args);\r\n        }, false);\r\n      };\r\n    };\r\n    var read$2 = function (handler) {\r\n      return isFunction(handler) ? {\r\n        can: always,\r\n        abort: never,\r\n        run: handler\r\n      } : handler;\r\n    };\r\n    var fuse$1 = function (handlers) {\r\n      var can = all$2(handlers, function (handler) {\r\n        return handler.can;\r\n      });\r\n      var abort = any(handlers, function (handler) {\r\n        return handler.abort;\r\n      });\r\n      var run = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        each$1(handlers, function (handler) {\r\n          handler.run.apply(undefined, args);\r\n        });\r\n      };\r\n      return {\r\n        can: can,\r\n        abort: abort,\r\n        run: run\r\n      };\r\n    };\r\n\r\n    var constant = constant$1;\r\n    var touchstart = constant('touchstart');\r\n    var touchmove = constant('touchmove');\r\n    var touchend = constant('touchend');\r\n    var touchcancel = constant('touchcancel');\r\n    var mousedown = constant('mousedown');\r\n    var mousemove = constant('mousemove');\r\n    var mouseout = constant('mouseout');\r\n    var mouseup = constant('mouseup');\r\n    var mouseover = constant('mouseover');\r\n    var focusin = constant('focusin');\r\n    var focusout = constant('focusout');\r\n    var keydown = constant('keydown');\r\n    var keyup = constant('keyup');\r\n    var input = constant('input');\r\n    var change = constant('change');\r\n    var click = constant('click');\r\n    var transitioncancel = constant('transitioncancel');\r\n    var transitionend = constant('transitionend');\r\n    var transitionstart = constant('transitionstart');\r\n    var selectstart = constant('selectstart');\r\n\r\n    var prefixName = function (name) {\r\n      return constant$1('alloy.' + name);\r\n    };\r\n    var alloy = { tap: prefixName('tap') };\r\n    var focus$4 = prefixName('focus');\r\n    var postBlur = prefixName('blur.post');\r\n    var postPaste = prefixName('paste.post');\r\n    var receive = prefixName('receive');\r\n    var execute$5 = prefixName('execute');\r\n    var focusItem = prefixName('focus.item');\r\n    var tap = alloy.tap;\r\n    var longpress = prefixName('longpress');\r\n    var sandboxClose = prefixName('sandbox.close');\r\n    var typeaheadCancel = prefixName('typeahead.cancel');\r\n    var systemInit = prefixName('system.init');\r\n    var documentTouchmove = prefixName('system.touchmove');\r\n    var documentTouchend = prefixName('system.touchend');\r\n    var windowScroll = prefixName('system.scroll');\r\n    var windowResize = prefixName('system.resize');\r\n    var attachedToDom = prefixName('system.attached');\r\n    var detachedFromDom = prefixName('system.detached');\r\n    var dismissRequested = prefixName('system.dismissRequested');\r\n    var repositionRequested = prefixName('system.repositionRequested');\r\n    var focusShifted = prefixName('focusmanager.shifted');\r\n    var slotVisibility = prefixName('slotcontainer.visibility');\r\n    var changeTab = prefixName('change.tab');\r\n    var dismissTab = prefixName('dismiss.tab');\r\n    var highlight$1 = prefixName('highlight');\r\n    var dehighlight$1 = prefixName('dehighlight');\r\n\r\n    var emit = function (component, event) {\r\n      dispatchWith(component, component.element, event, {});\r\n    };\r\n    var emitWith = function (component, event, properties) {\r\n      dispatchWith(component, component.element, event, properties);\r\n    };\r\n    var emitExecute = function (component) {\r\n      emit(component, execute$5());\r\n    };\r\n    var dispatch = function (component, target, event) {\r\n      dispatchWith(component, target, event, {});\r\n    };\r\n    var dispatchWith = function (component, target, event, properties) {\r\n      var data = __assign({ target: target }, properties);\r\n      component.getSystem().triggerEvent(event, target, data);\r\n    };\r\n    var dispatchEvent = function (component, target, event, simulatedEvent) {\r\n      component.getSystem().triggerEvent(event, target, simulatedEvent.event);\r\n    };\r\n\r\n    var derive$2 = function (configs) {\r\n      return wrapAll(configs);\r\n    };\r\n    var abort = function (name, predicate) {\r\n      return {\r\n        key: name,\r\n        value: nu$9({ abort: predicate })\r\n      };\r\n    };\r\n    var can = function (name, predicate) {\r\n      return {\r\n        key: name,\r\n        value: nu$9({ can: predicate })\r\n      };\r\n    };\r\n    var preventDefault = function (name) {\r\n      return {\r\n        key: name,\r\n        value: nu$9({\r\n          run: function (component, simulatedEvent) {\r\n            simulatedEvent.event.prevent();\r\n          }\r\n        })\r\n      };\r\n    };\r\n    var run$1 = function (name, handler) {\r\n      return {\r\n        key: name,\r\n        value: nu$9({ run: handler })\r\n      };\r\n    };\r\n    var runActionExtra = function (name, action, extra) {\r\n      return {\r\n        key: name,\r\n        value: nu$9({\r\n          run: function (component, simulatedEvent) {\r\n            action.apply(undefined, [\r\n              component,\r\n              simulatedEvent\r\n            ].concat(extra));\r\n          }\r\n        })\r\n      };\r\n    };\r\n    var runOnName = function (name) {\r\n      return function (handler) {\r\n        return run$1(name, handler);\r\n      };\r\n    };\r\n    var runOnSourceName = function (name) {\r\n      return function (handler) {\r\n        return {\r\n          key: name,\r\n          value: nu$9({\r\n            run: function (component, simulatedEvent) {\r\n              if (isSource(component, simulatedEvent)) {\r\n                handler(component, simulatedEvent);\r\n              }\r\n            }\r\n          })\r\n        };\r\n      };\r\n    };\r\n    var redirectToUid = function (name, uid) {\r\n      return run$1(name, function (component, simulatedEvent) {\r\n        component.getSystem().getByUid(uid).each(function (redirectee) {\r\n          dispatchEvent(redirectee, redirectee.element, name, simulatedEvent);\r\n        });\r\n      });\r\n    };\r\n    var redirectToPart = function (name, detail, partName) {\r\n      var uid = detail.partUids[partName];\r\n      return redirectToUid(name, uid);\r\n    };\r\n    var runWithTarget = function (name, f) {\r\n      return run$1(name, function (component, simulatedEvent) {\r\n        var ev = simulatedEvent.event;\r\n        var target = component.getSystem().getByDom(ev.target).getOrThunk(function () {\r\n          var closest = closest$4(ev.target, function (el) {\r\n            return component.getSystem().getByDom(el).toOptional();\r\n          }, never);\r\n          return closest.getOr(component);\r\n        });\r\n        f(component, target, simulatedEvent);\r\n      });\r\n    };\r\n    var cutter = function (name) {\r\n      return run$1(name, function (component, simulatedEvent) {\r\n        simulatedEvent.cut();\r\n      });\r\n    };\r\n    var stopper = function (name) {\r\n      return run$1(name, function (component, simulatedEvent) {\r\n        simulatedEvent.stop();\r\n      });\r\n    };\r\n    var runOnSource = function (name, f) {\r\n      return runOnSourceName(name)(f);\r\n    };\r\n    var runOnAttached = runOnSourceName(attachedToDom());\r\n    var runOnDetached = runOnSourceName(detachedFromDom());\r\n    var runOnInit = runOnSourceName(systemInit());\r\n    var runOnExecute$1 = runOnName(execute$5());\r\n\r\n    var fromHtml$1 = function (html, scope) {\r\n      var doc = scope || document;\r\n      var div = doc.createElement('div');\r\n      div.innerHTML = html;\r\n      return children(SugarElement.fromDom(div));\r\n    };\r\n\r\n    var get$7 = function (element) {\r\n      return element.dom.innerHTML;\r\n    };\r\n    var set$5 = function (element, content) {\r\n      var owner = owner$4(element);\r\n      var docDom = owner.dom;\r\n      var fragment = SugarElement.fromDom(docDom.createDocumentFragment());\r\n      var contentElements = fromHtml$1(content, docDom);\r\n      append$1(fragment, contentElements);\r\n      empty(element);\r\n      append$2(element, fragment);\r\n    };\r\n    var getOuter = function (element) {\r\n      var container = SugarElement.fromTag('div');\r\n      var clone = SugarElement.fromDom(element.dom.cloneNode(true));\r\n      append$2(container, clone);\r\n      return get$7(container);\r\n    };\r\n\r\n    var clone$2 = function (original, isDeep) {\r\n      return SugarElement.fromDom(original.dom.cloneNode(isDeep));\r\n    };\r\n    var shallow = function (original) {\r\n      return clone$2(original, false);\r\n    };\r\n\r\n    var getHtml = function (element) {\r\n      if (isShadowRoot(element)) {\r\n        return '#shadow-root';\r\n      } else {\r\n        var clone = shallow(element);\r\n        return getOuter(clone);\r\n      }\r\n    };\r\n\r\n    var element = function (elem) {\r\n      return getHtml(elem);\r\n    };\r\n\r\n    var isRecursive = function (component, originator, target) {\r\n      return eq(originator, component.element) && !eq(originator, target);\r\n    };\r\n    var events$i = derive$2([can(focus$4(), function (component, simulatedEvent) {\r\n        var event = simulatedEvent.event;\r\n        var originator = event.originator;\r\n        var target = event.target;\r\n        if (isRecursive(component, originator, target)) {\r\n          console.warn(focus$4() + ' did not get interpreted by the desired target. ' + '\\nOriginator: ' + element(originator) + '\\nTarget: ' + element(target) + '\\nCheck the ' + focus$4() + ' event handlers');\r\n          return false;\r\n        } else {\r\n          return true;\r\n        }\r\n      })]);\r\n\r\n    var DefaultEvents = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        events: events$i\r\n    });\r\n\r\n    var unique = 0;\r\n    var generate$6 = function (prefix) {\r\n      var date = new Date();\r\n      var time = date.getTime();\r\n      var random = Math.floor(Math.random() * 1000000000);\r\n      unique++;\r\n      return prefix + '_' + random + unique + String(time);\r\n    };\r\n\r\n    var prefix$1 = constant$1('alloy-id-');\r\n    var idAttr$1 = constant$1('data-alloy-id');\r\n\r\n    var prefix = prefix$1();\r\n    var idAttr = idAttr$1();\r\n    var write = function (label, elem) {\r\n      var id = generate$6(prefix + label);\r\n      writeOnly(elem, id);\r\n      return id;\r\n    };\r\n    var writeOnly = function (elem, uid) {\r\n      Object.defineProperty(elem.dom, idAttr, {\r\n        value: uid,\r\n        writable: true\r\n      });\r\n    };\r\n    var read$1 = function (elem) {\r\n      var id = isElement$2(elem) ? elem.dom[idAttr] : null;\r\n      return Optional.from(id);\r\n    };\r\n    var generate$5 = function (prefix) {\r\n      return generate$6(prefix);\r\n    };\r\n\r\n    var make$8 = identity$1;\r\n\r\n    var NoContextApi = function (getComp) {\r\n      var getMessage = function (event) {\r\n        return 'The component must be in a context to execute: ' + event + (getComp ? '\\n' + element(getComp().element) + ' is not in context.' : '');\r\n      };\r\n      var fail = function (event) {\r\n        return function () {\r\n          throw new Error(getMessage(event));\r\n        };\r\n      };\r\n      var warn = function (event) {\r\n        return function () {\r\n          console.warn(getMessage(event));\r\n        };\r\n      };\r\n      return {\r\n        debugInfo: constant$1('fake'),\r\n        triggerEvent: warn('triggerEvent'),\r\n        triggerFocus: warn('triggerFocus'),\r\n        triggerEscape: warn('triggerEscape'),\r\n        broadcast: warn('broadcast'),\r\n        broadcastOn: warn('broadcastOn'),\r\n        broadcastEvent: warn('broadcastEvent'),\r\n        build: fail('build'),\r\n        addToWorld: fail('addToWorld'),\r\n        removeFromWorld: fail('removeFromWorld'),\r\n        addToGui: fail('addToGui'),\r\n        removeFromGui: fail('removeFromGui'),\r\n        getByUid: fail('getByUid'),\r\n        getByDom: fail('getByDom'),\r\n        isConnected: never\r\n      };\r\n    };\r\n    var singleton$1 = NoContextApi();\r\n\r\n    var markAsBehaviourApi = function (f, apiName, apiFunction) {\r\n      var delegate = apiFunction.toString();\r\n      var endIndex = delegate.indexOf(')') + 1;\r\n      var openBracketIndex = delegate.indexOf('(');\r\n      var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\\s*/);\r\n      f.toFunctionAnnotation = function () {\r\n        return {\r\n          name: apiName,\r\n          parameters: cleanParameters(parameters.slice(0, 1).concat(parameters.slice(3)))\r\n        };\r\n      };\r\n      return f;\r\n    };\r\n    var cleanParameters = function (parameters) {\r\n      return map$2(parameters, function (p) {\r\n        return endsWith(p, '/*') ? p.substring(0, p.length - '/*'.length) : p;\r\n      });\r\n    };\r\n    var markAsExtraApi = function (f, extraName) {\r\n      var delegate = f.toString();\r\n      var endIndex = delegate.indexOf(')') + 1;\r\n      var openBracketIndex = delegate.indexOf('(');\r\n      var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\\s*/);\r\n      f.toFunctionAnnotation = function () {\r\n        return {\r\n          name: extraName,\r\n          parameters: cleanParameters(parameters)\r\n        };\r\n      };\r\n      return f;\r\n    };\r\n    var markAsSketchApi = function (f, apiFunction) {\r\n      var delegate = apiFunction.toString();\r\n      var endIndex = delegate.indexOf(')') + 1;\r\n      var openBracketIndex = delegate.indexOf('(');\r\n      var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\\s*/);\r\n      f.toFunctionAnnotation = function () {\r\n        return {\r\n          name: 'OVERRIDE',\r\n          parameters: cleanParameters(parameters.slice(1))\r\n        };\r\n      };\r\n      return f;\r\n    };\r\n\r\n    var premadeTag = generate$6('alloy-premade');\r\n    var premade$1 = function (comp) {\r\n      return wrap$1(premadeTag, comp);\r\n    };\r\n    var getPremade = function (spec) {\r\n      return get$e(spec, premadeTag);\r\n    };\r\n    var makeApi = function (f) {\r\n      return markAsSketchApi(function (component) {\r\n        var rest = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n          rest[_i - 1] = arguments[_i];\r\n        }\r\n        return f.apply(void 0, __spreadArray([\r\n          component.getApis(),\r\n          component\r\n        ], rest, false));\r\n      }, f);\r\n    };\r\n\r\n    var NoState = {\r\n      init: function () {\r\n        return nu$8({ readState: constant$1('No State required') });\r\n      }\r\n    };\r\n    var nu$8 = function (spec) {\r\n      return spec;\r\n    };\r\n\r\n    var generateFrom$1 = function (spec, all) {\r\n      var schema = map$2(all, function (a) {\r\n        return optionObjOf(a.name(), [\r\n          required$1('config'),\r\n          defaulted('state', NoState)\r\n        ]);\r\n      });\r\n      var validated = asRaw('component.behaviours', objOf(schema), spec.behaviours).fold(function (errInfo) {\r\n        throw new Error(formatError(errInfo) + '\\nComplete spec:\\n' + JSON.stringify(spec, null, 2));\r\n      }, identity$1);\r\n      return {\r\n        list: all,\r\n        data: map$1(validated, function (optBlobThunk) {\r\n          var output = optBlobThunk.map(function (blob) {\r\n            return {\r\n              config: blob.config,\r\n              state: blob.state.init(blob.config)\r\n            };\r\n          });\r\n          return constant$1(output);\r\n        })\r\n      };\r\n    };\r\n    var getBehaviours$3 = function (bData) {\r\n      return bData.list;\r\n    };\r\n    var getData$2 = function (bData) {\r\n      return bData.data;\r\n    };\r\n\r\n    var byInnerKey = function (data, tuple) {\r\n      var r = {};\r\n      each(data, function (detail, key) {\r\n        each(detail, function (value, indexKey) {\r\n          var chain = get$e(r, indexKey).getOr([]);\r\n          r[indexKey] = chain.concat([tuple(key, value)]);\r\n        });\r\n      });\r\n      return r;\r\n    };\r\n\r\n    var nu$7 = function (s) {\r\n      return {\r\n        classes: isUndefined(s.classes) ? [] : s.classes,\r\n        attributes: isUndefined(s.attributes) ? {} : s.attributes,\r\n        styles: isUndefined(s.styles) ? {} : s.styles\r\n      };\r\n    };\r\n    var merge = function (defnA, mod) {\r\n      return __assign(__assign({}, defnA), {\r\n        attributes: __assign(__assign({}, defnA.attributes), mod.attributes),\r\n        styles: __assign(__assign({}, defnA.styles), mod.styles),\r\n        classes: defnA.classes.concat(mod.classes)\r\n      });\r\n    };\r\n\r\n    var combine$2 = function (info, baseMod, behaviours, base) {\r\n      var modsByBehaviour = __assign({}, baseMod);\r\n      each$1(behaviours, function (behaviour) {\r\n        modsByBehaviour[behaviour.name()] = behaviour.exhibit(info, base);\r\n      });\r\n      var byAspect = byInnerKey(modsByBehaviour, function (name, modification) {\r\n        return {\r\n          name: name,\r\n          modification: modification\r\n        };\r\n      });\r\n      var combineObjects = function (objects) {\r\n        return foldr(objects, function (b, a) {\r\n          return __assign(__assign({}, a.modification), b);\r\n        }, {});\r\n      };\r\n      var combinedClasses = foldr(byAspect.classes, function (b, a) {\r\n        return a.modification.concat(b);\r\n      }, []);\r\n      var combinedAttributes = combineObjects(byAspect.attributes);\r\n      var combinedStyles = combineObjects(byAspect.styles);\r\n      return nu$7({\r\n        classes: combinedClasses,\r\n        attributes: combinedAttributes,\r\n        styles: combinedStyles\r\n      });\r\n    };\r\n\r\n    var sortKeys = function (label, keyName, array, order) {\r\n      try {\r\n        var sorted = sort(array, function (a, b) {\r\n          var aKey = a[keyName];\r\n          var bKey = b[keyName];\r\n          var aIndex = order.indexOf(aKey);\r\n          var bIndex = order.indexOf(bKey);\r\n          if (aIndex === -1) {\r\n            throw new Error('The ordering for ' + label + ' does not have an entry for ' + aKey + '.\\nOrder specified: ' + JSON.stringify(order, null, 2));\r\n          }\r\n          if (bIndex === -1) {\r\n            throw new Error('The ordering for ' + label + ' does not have an entry for ' + bKey + '.\\nOrder specified: ' + JSON.stringify(order, null, 2));\r\n          }\r\n          if (aIndex < bIndex) {\r\n            return -1;\r\n          } else if (bIndex < aIndex) {\r\n            return 1;\r\n          } else {\r\n            return 0;\r\n          }\r\n        });\r\n        return Result.value(sorted);\r\n      } catch (err) {\r\n        return Result.error([err]);\r\n      }\r\n    };\r\n\r\n    var uncurried = function (handler, purpose) {\r\n      return {\r\n        handler: handler,\r\n        purpose: purpose\r\n      };\r\n    };\r\n    var curried = function (handler, purpose) {\r\n      return {\r\n        cHandler: handler,\r\n        purpose: purpose\r\n      };\r\n    };\r\n    var curryArgs = function (descHandler, extraArgs) {\r\n      return curried(curry.apply(undefined, [descHandler.handler].concat(extraArgs)), descHandler.purpose);\r\n    };\r\n    var getCurried = function (descHandler) {\r\n      return descHandler.cHandler;\r\n    };\r\n\r\n    var behaviourTuple = function (name, handler) {\r\n      return {\r\n        name: name,\r\n        handler: handler\r\n      };\r\n    };\r\n    var nameToHandlers = function (behaviours, info) {\r\n      var r = {};\r\n      each$1(behaviours, function (behaviour) {\r\n        r[behaviour.name()] = behaviour.handlers(info);\r\n      });\r\n      return r;\r\n    };\r\n    var groupByEvents = function (info, behaviours, base) {\r\n      var behaviourEvents = __assign(__assign({}, base), nameToHandlers(behaviours, info));\r\n      return byInnerKey(behaviourEvents, behaviourTuple);\r\n    };\r\n    var combine$1 = function (info, eventOrder, behaviours, base) {\r\n      var byEventName = groupByEvents(info, behaviours, base);\r\n      return combineGroups(byEventName, eventOrder);\r\n    };\r\n    var assemble = function (rawHandler) {\r\n      var handler = read$2(rawHandler);\r\n      return function (component, simulatedEvent) {\r\n        var rest = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n          rest[_i - 2] = arguments[_i];\r\n        }\r\n        var args = [\r\n          component,\r\n          simulatedEvent\r\n        ].concat(rest);\r\n        if (handler.abort.apply(undefined, args)) {\r\n          simulatedEvent.stop();\r\n        } else if (handler.can.apply(undefined, args)) {\r\n          handler.run.apply(undefined, args);\r\n        }\r\n      };\r\n    };\r\n    var missingOrderError = function (eventName, tuples) {\r\n      return Result.error(['The event (' + eventName + ') has more than one behaviour that listens to it.\\nWhen this occurs, you must ' + 'specify an event ordering for the behaviours in your spec (e.g. [ \"listing\", \"toggling\" ]).\\nThe behaviours that ' + 'can trigger it are: ' + JSON.stringify(map$2(tuples, function (c) {\r\n          return c.name;\r\n        }), null, 2)]);\r\n    };\r\n    var fuse = function (tuples, eventOrder, eventName) {\r\n      var order = eventOrder[eventName];\r\n      if (!order) {\r\n        return missingOrderError(eventName, tuples);\r\n      } else {\r\n        return sortKeys('Event: ' + eventName, 'name', tuples, order).map(function (sortedTuples) {\r\n          var handlers = map$2(sortedTuples, function (tuple) {\r\n            return tuple.handler;\r\n          });\r\n          return fuse$1(handlers);\r\n        });\r\n      }\r\n    };\r\n    var combineGroups = function (byEventName, eventOrder) {\r\n      var r = mapToArray(byEventName, function (tuples, eventName) {\r\n        var combined = tuples.length === 1 ? Result.value(tuples[0].handler) : fuse(tuples, eventOrder, eventName);\r\n        return combined.map(function (handler) {\r\n          var assembled = assemble(handler);\r\n          var purpose = tuples.length > 1 ? filter$2(eventOrder[eventName], function (o) {\r\n            return exists(tuples, function (t) {\r\n              return t.name === o;\r\n            });\r\n          }).join(' > ') : tuples[0].name;\r\n          return wrap$1(eventName, uncurried(assembled, purpose));\r\n        });\r\n      });\r\n      return consolidate(r, {});\r\n    };\r\n\r\n    var _a$2;\r\n    var baseBehaviour = 'alloy.base.behaviour';\r\n    var schema$z = objOf([\r\n      field$1('dom', 'dom', required$2(), objOf([\r\n        required$1('tag'),\r\n        defaulted('styles', {}),\r\n        defaulted('classes', []),\r\n        defaulted('attributes', {}),\r\n        option('value'),\r\n        option('innerHtml')\r\n      ])),\r\n      required$1('components'),\r\n      required$1('uid'),\r\n      defaulted('events', {}),\r\n      defaulted('apis', {}),\r\n      field$1('eventOrder', 'eventOrder', mergeWith((_a$2 = {}, _a$2[execute$5()] = [\r\n        'disabling',\r\n        baseBehaviour,\r\n        'toggling',\r\n        'typeaheadevents'\r\n      ], _a$2[focus$4()] = [\r\n        baseBehaviour,\r\n        'focusing',\r\n        'keying'\r\n      ], _a$2[systemInit()] = [\r\n        baseBehaviour,\r\n        'disabling',\r\n        'toggling',\r\n        'representing'\r\n      ], _a$2[input()] = [\r\n        baseBehaviour,\r\n        'representing',\r\n        'streaming',\r\n        'invalidating'\r\n      ], _a$2[detachedFromDom()] = [\r\n        baseBehaviour,\r\n        'representing',\r\n        'item-events',\r\n        'tooltipping'\r\n      ], _a$2[mousedown()] = [\r\n        'focusing',\r\n        baseBehaviour,\r\n        'item-type-events'\r\n      ], _a$2[touchstart()] = [\r\n        'focusing',\r\n        baseBehaviour,\r\n        'item-type-events'\r\n      ], _a$2[mouseover()] = [\r\n        'item-type-events',\r\n        'tooltipping'\r\n      ], _a$2[receive()] = [\r\n        'receiving',\r\n        'reflecting',\r\n        'tooltipping'\r\n      ], _a$2)), anyValue()),\r\n      option('domModification')\r\n    ]);\r\n    var toInfo = function (spec) {\r\n      return asRaw('custom.definition', schema$z, spec);\r\n    };\r\n    var toDefinition = function (detail) {\r\n      return __assign(__assign({}, detail.dom), {\r\n        uid: detail.uid,\r\n        domChildren: map$2(detail.components, function (comp) {\r\n          return comp.element;\r\n        })\r\n      });\r\n    };\r\n    var toModification = function (detail) {\r\n      return detail.domModification.fold(function () {\r\n        return nu$7({});\r\n      }, nu$7);\r\n    };\r\n    var toEvents = function (info) {\r\n      return info.events;\r\n    };\r\n\r\n    var read = function (element, attr) {\r\n      var value = get$d(element, attr);\r\n      return value === undefined || value === '' ? [] : value.split(' ');\r\n    };\r\n    var add$4 = function (element, attr, id) {\r\n      var old = read(element, attr);\r\n      var nu = old.concat([id]);\r\n      set$8(element, attr, nu.join(' '));\r\n      return true;\r\n    };\r\n    var remove$4 = function (element, attr, id) {\r\n      var nu = filter$2(read(element, attr), function (v) {\r\n        return v !== id;\r\n      });\r\n      if (nu.length > 0) {\r\n        set$8(element, attr, nu.join(' '));\r\n      } else {\r\n        remove$7(element, attr);\r\n      }\r\n      return false;\r\n    };\r\n\r\n    var supports = function (element) {\r\n      return element.dom.classList !== undefined;\r\n    };\r\n    var get$6 = function (element) {\r\n      return read(element, 'class');\r\n    };\r\n    var add$3 = function (element, clazz) {\r\n      return add$4(element, 'class', clazz);\r\n    };\r\n    var remove$3 = function (element, clazz) {\r\n      return remove$4(element, 'class', clazz);\r\n    };\r\n\r\n    var add$2 = function (element, clazz) {\r\n      if (supports(element)) {\r\n        element.dom.classList.add(clazz);\r\n      } else {\r\n        add$3(element, clazz);\r\n      }\r\n    };\r\n    var cleanClass = function (element) {\r\n      var classList = supports(element) ? element.dom.classList : get$6(element);\r\n      if (classList.length === 0) {\r\n        remove$7(element, 'class');\r\n      }\r\n    };\r\n    var remove$2 = function (element, clazz) {\r\n      if (supports(element)) {\r\n        var classList = element.dom.classList;\r\n        classList.remove(clazz);\r\n      } else {\r\n        remove$3(element, clazz);\r\n      }\r\n      cleanClass(element);\r\n    };\r\n    var has = function (element, clazz) {\r\n      return supports(element) && element.dom.classList.contains(clazz);\r\n    };\r\n\r\n    var add$1 = function (element, classes) {\r\n      each$1(classes, function (x) {\r\n        add$2(element, x);\r\n      });\r\n    };\r\n    var remove$1 = function (element, classes) {\r\n      each$1(classes, function (x) {\r\n        remove$2(element, x);\r\n      });\r\n    };\r\n    var hasAll = function (element, classes) {\r\n      return forall(classes, function (clazz) {\r\n        return has(element, clazz);\r\n      });\r\n    };\r\n\r\n    var get$5 = function (element) {\r\n      return element.dom.value;\r\n    };\r\n    var set$4 = function (element, value) {\r\n      if (value === undefined) {\r\n        throw new Error('Value.set was undefined');\r\n      }\r\n      element.dom.value = value;\r\n    };\r\n\r\n    var renderToDom = function (definition) {\r\n      var subject = SugarElement.fromTag(definition.tag);\r\n      setAll$1(subject, definition.attributes);\r\n      add$1(subject, definition.classes);\r\n      setAll(subject, definition.styles);\r\n      definition.innerHtml.each(function (html) {\r\n        return set$5(subject, html);\r\n      });\r\n      var children = definition.domChildren;\r\n      append$1(subject, children);\r\n      definition.value.each(function (value) {\r\n        set$4(subject, value);\r\n      });\r\n      if (!definition.uid) {\r\n        debugger;\r\n      }\r\n      writeOnly(subject, definition.uid);\r\n      return subject;\r\n    };\r\n\r\n    var getBehaviours$2 = function (spec) {\r\n      var behaviours = get$e(spec, 'behaviours').getOr({});\r\n      return bind$3(keys(behaviours), function (name) {\r\n        var behaviour = behaviours[name];\r\n        return isNonNullable(behaviour) ? [behaviour.me] : [];\r\n      });\r\n    };\r\n    var generateFrom = function (spec, all) {\r\n      return generateFrom$1(spec, all);\r\n    };\r\n    var generate$4 = function (spec) {\r\n      var all = getBehaviours$2(spec);\r\n      return generateFrom(spec, all);\r\n    };\r\n\r\n    var getDomDefinition = function (info, bList, bData) {\r\n      var definition = toDefinition(info);\r\n      var infoModification = toModification(info);\r\n      var baseModification = { 'alloy.base.modification': infoModification };\r\n      var modification = bList.length > 0 ? combine$2(bData, baseModification, bList, definition) : infoModification;\r\n      return merge(definition, modification);\r\n    };\r\n    var getEvents = function (info, bList, bData) {\r\n      var baseEvents = { 'alloy.base.behaviour': toEvents(info) };\r\n      return combine$1(bData, info.eventOrder, bList, baseEvents).getOrDie();\r\n    };\r\n    var build$2 = function (spec) {\r\n      var getMe = function () {\r\n        return me;\r\n      };\r\n      var systemApi = Cell(singleton$1);\r\n      var info = getOrDie(toInfo(spec));\r\n      var bBlob = generate$4(spec);\r\n      var bList = getBehaviours$3(bBlob);\r\n      var bData = getData$2(bBlob);\r\n      var modDefinition = getDomDefinition(info, bList, bData);\r\n      var item = renderToDom(modDefinition);\r\n      var events = getEvents(info, bList, bData);\r\n      var subcomponents = Cell(info.components);\r\n      var connect = function (newApi) {\r\n        systemApi.set(newApi);\r\n      };\r\n      var disconnect = function () {\r\n        systemApi.set(NoContextApi(getMe));\r\n      };\r\n      var syncComponents = function () {\r\n        var children$1 = children(item);\r\n        var subs = bind$3(children$1, function (child) {\r\n          return systemApi.get().getByDom(child).fold(function () {\r\n            return [];\r\n          }, pure$2);\r\n        });\r\n        subcomponents.set(subs);\r\n      };\r\n      var config = function (behaviour) {\r\n        var b = bData;\r\n        var f = isFunction(b[behaviour.name()]) ? b[behaviour.name()] : function () {\r\n          throw new Error('Could not find ' + behaviour.name() + ' in ' + JSON.stringify(spec, null, 2));\r\n        };\r\n        return f();\r\n      };\r\n      var hasConfigured = function (behaviour) {\r\n        return isFunction(bData[behaviour.name()]);\r\n      };\r\n      var getApis = function () {\r\n        return info.apis;\r\n      };\r\n      var readState = function (behaviourName) {\r\n        return bData[behaviourName]().map(function (b) {\r\n          return b.state.readState();\r\n        }).getOr('not enabled');\r\n      };\r\n      var me = {\r\n        uid: spec.uid,\r\n        getSystem: systemApi.get,\r\n        config: config,\r\n        hasConfigured: hasConfigured,\r\n        spec: spec,\r\n        readState: readState,\r\n        getApis: getApis,\r\n        connect: connect,\r\n        disconnect: disconnect,\r\n        element: item,\r\n        syncComponents: syncComponents,\r\n        components: subcomponents.get,\r\n        events: events\r\n      };\r\n      return me;\r\n    };\r\n\r\n    var buildSubcomponents = function (spec) {\r\n      var components = get$e(spec, 'components').getOr([]);\r\n      return map$2(components, build$1);\r\n    };\r\n    var buildFromSpec = function (userSpec) {\r\n      var _a = make$8(userSpec), specEvents = _a.events, spec = __rest(_a, ['events']);\r\n      var components = buildSubcomponents(spec);\r\n      var completeSpec = __assign(__assign({}, spec), {\r\n        events: __assign(__assign({}, DefaultEvents), specEvents),\r\n        components: components\r\n      });\r\n      return Result.value(build$2(completeSpec));\r\n    };\r\n    var text$1 = function (textContent) {\r\n      var element = SugarElement.fromText(textContent);\r\n      return external$2({ element: element });\r\n    };\r\n    var external$2 = function (spec) {\r\n      var extSpec = asRawOrDie$1('external.component', objOfOnly([\r\n        required$1('element'),\r\n        option('uid')\r\n      ]), spec);\r\n      var systemApi = Cell(NoContextApi());\r\n      var connect = function (newApi) {\r\n        systemApi.set(newApi);\r\n      };\r\n      var disconnect = function () {\r\n        systemApi.set(NoContextApi(function () {\r\n          return me;\r\n        }));\r\n      };\r\n      var uid = extSpec.uid.getOrThunk(function () {\r\n        return generate$5('external');\r\n      });\r\n      writeOnly(extSpec.element, uid);\r\n      var me = {\r\n        uid: uid,\r\n        getSystem: systemApi.get,\r\n        config: Optional.none,\r\n        hasConfigured: never,\r\n        connect: connect,\r\n        disconnect: disconnect,\r\n        getApis: function () {\r\n          return {};\r\n        },\r\n        element: extSpec.element,\r\n        spec: spec,\r\n        readState: constant$1('No state'),\r\n        syncComponents: noop,\r\n        components: constant$1([]),\r\n        events: {}\r\n      };\r\n      return premade$1(me);\r\n    };\r\n    var uids = generate$5;\r\n    var isSketchSpec$1 = function (spec) {\r\n      return has$2(spec, 'uid');\r\n    };\r\n    var build$1 = function (spec) {\r\n      return getPremade(spec).getOrThunk(function () {\r\n        var userSpecWithUid = isSketchSpec$1(spec) ? spec : __assign({ uid: uids('') }, spec);\r\n        return buildFromSpec(userSpecWithUid).getOrDie();\r\n      });\r\n    };\r\n    var premade = premade$1;\r\n\r\n    function ClosestOrAncestor (is, ancestor, scope, a, isRoot) {\r\n      if (is(scope, a)) {\r\n        return Optional.some(scope);\r\n      } else if (isFunction(isRoot) && isRoot(scope)) {\r\n        return Optional.none();\r\n      } else {\r\n        return ancestor(scope, a, isRoot);\r\n      }\r\n    }\r\n\r\n    var ancestor$1 = function (scope, predicate, isRoot) {\r\n      var element = scope.dom;\r\n      var stop = isFunction(isRoot) ? isRoot : never;\r\n      while (element.parentNode) {\r\n        element = element.parentNode;\r\n        var el = SugarElement.fromDom(element);\r\n        if (predicate(el)) {\r\n          return Optional.some(el);\r\n        } else if (stop(el)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var closest$3 = function (scope, predicate, isRoot) {\r\n      var is = function (s, test) {\r\n        return test(s);\r\n      };\r\n      return ClosestOrAncestor(is, ancestor$1, scope, predicate, isRoot);\r\n    };\r\n    var child$1 = function (scope, predicate) {\r\n      var pred = function (node) {\r\n        return predicate(SugarElement.fromDom(node));\r\n      };\r\n      var result = find$5(scope.dom.childNodes, pred);\r\n      return result.map(SugarElement.fromDom);\r\n    };\r\n    var descendant$1 = function (scope, predicate) {\r\n      var descend = function (node) {\r\n        for (var i = 0; i < node.childNodes.length; i++) {\r\n          var child_1 = SugarElement.fromDom(node.childNodes[i]);\r\n          if (predicate(child_1)) {\r\n            return Optional.some(child_1);\r\n          }\r\n          var res = descend(node.childNodes[i]);\r\n          if (res.isSome()) {\r\n            return res;\r\n          }\r\n        }\r\n        return Optional.none();\r\n      };\r\n      return descend(scope.dom);\r\n    };\r\n\r\n    var closest$2 = function (scope, predicate, isRoot) {\r\n      return closest$3(scope, predicate, isRoot).isSome();\r\n    };\r\n\r\n    var ancestor = function (scope, selector, isRoot) {\r\n      return ancestor$1(scope, function (e) {\r\n        return is(e, selector);\r\n      }, isRoot);\r\n    };\r\n    var child = function (scope, selector) {\r\n      return child$1(scope, function (e) {\r\n        return is(e, selector);\r\n      });\r\n    };\r\n    var descendant = function (scope, selector) {\r\n      return one(selector, scope);\r\n    };\r\n    var closest$1 = function (scope, selector, isRoot) {\r\n      var is$1 = function (element, selector) {\r\n        return is(element, selector);\r\n      };\r\n      return ClosestOrAncestor(is$1, ancestor, scope, selector, isRoot);\r\n    };\r\n\r\n    var find$1 = function (queryElem) {\r\n      var dependent = closest$3(queryElem, function (elem) {\r\n        if (!isElement$2(elem)) {\r\n          return false;\r\n        }\r\n        var id = get$d(elem, 'id');\r\n        return id !== undefined && id.indexOf('aria-owns') > -1;\r\n      });\r\n      return dependent.bind(function (dep) {\r\n        var id = get$d(dep, 'id');\r\n        var dos = getRootNode(dep);\r\n        return descendant(dos, '[aria-owns=\"' + id + '\"]');\r\n      });\r\n    };\r\n    var manager = function () {\r\n      var ariaId = generate$6('aria-owns');\r\n      var link = function (elem) {\r\n        set$8(elem, 'aria-owns', ariaId);\r\n      };\r\n      var unlink = function (elem) {\r\n        remove$7(elem, 'aria-owns');\r\n      };\r\n      return {\r\n        id: ariaId,\r\n        link: link,\r\n        unlink: unlink\r\n      };\r\n    };\r\n\r\n    var isAriaPartOf = function (component, queryElem) {\r\n      return find$1(queryElem).exists(function (owner) {\r\n        return isPartOf$1(component, owner);\r\n      });\r\n    };\r\n    var isPartOf$1 = function (component, queryElem) {\r\n      return closest$2(queryElem, function (el) {\r\n        return eq(el, component.element);\r\n      }, never) || isAriaPartOf(component, queryElem);\r\n    };\r\n\r\n    var unknown = 'unknown';\r\n    var EventConfiguration;\r\n    (function (EventConfiguration) {\r\n      EventConfiguration[EventConfiguration['STOP'] = 0] = 'STOP';\r\n      EventConfiguration[EventConfiguration['NORMAL'] = 1] = 'NORMAL';\r\n      EventConfiguration[EventConfiguration['LOGGING'] = 2] = 'LOGGING';\r\n    }(EventConfiguration || (EventConfiguration = {})));\r\n    var eventConfig = Cell({});\r\n    var makeEventLogger = function (eventName, initialTarget) {\r\n      var sequence = [];\r\n      var startTime = new Date().getTime();\r\n      return {\r\n        logEventCut: function (_name, target, purpose) {\r\n          sequence.push({\r\n            outcome: 'cut',\r\n            target: target,\r\n            purpose: purpose\r\n          });\r\n        },\r\n        logEventStopped: function (_name, target, purpose) {\r\n          sequence.push({\r\n            outcome: 'stopped',\r\n            target: target,\r\n            purpose: purpose\r\n          });\r\n        },\r\n        logNoParent: function (_name, target, purpose) {\r\n          sequence.push({\r\n            outcome: 'no-parent',\r\n            target: target,\r\n            purpose: purpose\r\n          });\r\n        },\r\n        logEventNoHandlers: function (_name, target) {\r\n          sequence.push({\r\n            outcome: 'no-handlers-left',\r\n            target: target\r\n          });\r\n        },\r\n        logEventResponse: function (_name, target, purpose) {\r\n          sequence.push({\r\n            outcome: 'response',\r\n            purpose: purpose,\r\n            target: target\r\n          });\r\n        },\r\n        write: function () {\r\n          var finishTime = new Date().getTime();\r\n          if (contains$2([\r\n              'mousemove',\r\n              'mouseover',\r\n              'mouseout',\r\n              systemInit()\r\n            ], eventName)) {\r\n            return;\r\n          }\r\n          console.log(eventName, {\r\n            event: eventName,\r\n            time: finishTime - startTime,\r\n            target: initialTarget.dom,\r\n            sequence: map$2(sequence, function (s) {\r\n              if (!contains$2([\r\n                  'cut',\r\n                  'stopped',\r\n                  'response'\r\n                ], s.outcome)) {\r\n                return s.outcome;\r\n              } else {\r\n                return '{' + s.purpose + '} ' + s.outcome + ' at (' + element(s.target) + ')';\r\n              }\r\n            })\r\n          });\r\n        }\r\n      };\r\n    };\r\n    var processEvent = function (eventName, initialTarget, f) {\r\n      var status = get$e(eventConfig.get(), eventName).orThunk(function () {\r\n        var patterns = keys(eventConfig.get());\r\n        return findMap(patterns, function (p) {\r\n          return eventName.indexOf(p) > -1 ? Optional.some(eventConfig.get()[p]) : Optional.none();\r\n        });\r\n      }).getOr(EventConfiguration.NORMAL);\r\n      switch (status) {\r\n      case EventConfiguration.NORMAL:\r\n        return f(noLogger());\r\n      case EventConfiguration.LOGGING: {\r\n          var logger = makeEventLogger(eventName, initialTarget);\r\n          var output = f(logger);\r\n          logger.write();\r\n          return output;\r\n        }\r\n      case EventConfiguration.STOP:\r\n        return true;\r\n      }\r\n    };\r\n    var path = [\r\n      'alloy/data/Fields',\r\n      'alloy/debugging/Debugging'\r\n    ];\r\n    var getTrace = function () {\r\n      var err = new Error();\r\n      if (err.stack !== undefined) {\r\n        var lines = err.stack.split('\\n');\r\n        return find$5(lines, function (line) {\r\n          return line.indexOf('alloy') > 0 && !exists(path, function (p) {\r\n            return line.indexOf(p) > -1;\r\n          });\r\n        }).getOr(unknown);\r\n      } else {\r\n        return unknown;\r\n      }\r\n    };\r\n    var ignoreEvent = {\r\n      logEventCut: noop,\r\n      logEventStopped: noop,\r\n      logNoParent: noop,\r\n      logEventNoHandlers: noop,\r\n      logEventResponse: noop,\r\n      write: noop\r\n    };\r\n    var monitorEvent = function (eventName, initialTarget, f) {\r\n      return processEvent(eventName, initialTarget, f);\r\n    };\r\n    var noLogger = constant$1(ignoreEvent);\r\n\r\n    var menuFields = constant$1([\r\n      required$1('menu'),\r\n      required$1('selectedMenu')\r\n    ]);\r\n    var itemFields = constant$1([\r\n      required$1('item'),\r\n      required$1('selectedItem')\r\n    ]);\r\n    constant$1(objOf(itemFields().concat(menuFields())));\r\n    var itemSchema$3 = constant$1(objOf(itemFields()));\r\n\r\n    var _initSize = requiredObjOf('initSize', [\r\n      required$1('numColumns'),\r\n      required$1('numRows')\r\n    ]);\r\n    var itemMarkers = function () {\r\n      return requiredOf('markers', itemSchema$3());\r\n    };\r\n    var tieredMenuMarkers = function () {\r\n      return requiredObjOf('markers', [required$1('backgroundMenu')].concat(menuFields()).concat(itemFields()));\r\n    };\r\n    var markers$1 = function (required) {\r\n      return requiredObjOf('markers', map$2(required, required$1));\r\n    };\r\n    var onPresenceHandler = function (label, fieldName, presence) {\r\n      getTrace();\r\n      return field$1(fieldName, fieldName, presence, valueOf(function (f) {\r\n        return Result.value(function () {\r\n          var args = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n          }\r\n          return f.apply(undefined, args);\r\n        });\r\n      }));\r\n    };\r\n    var onHandler = function (fieldName) {\r\n      return onPresenceHandler('onHandler', fieldName, defaulted$1(noop));\r\n    };\r\n    var onKeyboardHandler = function (fieldName) {\r\n      return onPresenceHandler('onKeyboardHandler', fieldName, defaulted$1(Optional.none));\r\n    };\r\n    var onStrictHandler = function (fieldName) {\r\n      return onPresenceHandler('onHandler', fieldName, required$2());\r\n    };\r\n    var onStrictKeyboardHandler = function (fieldName) {\r\n      return onPresenceHandler('onKeyboardHandler', fieldName, required$2());\r\n    };\r\n    var output$1 = function (name, value) {\r\n      return customField(name, constant$1(value));\r\n    };\r\n    var snapshot = function (name) {\r\n      return customField(name, identity$1);\r\n    };\r\n    var initSize = constant$1(_initSize);\r\n\r\n    var nu$6 = function (x, y, bubble, direction, placement, boundsRestriction, labelPrefix, alwaysFit) {\r\n      if (alwaysFit === void 0) {\r\n        alwaysFit = false;\r\n      }\r\n      return {\r\n        x: x,\r\n        y: y,\r\n        bubble: bubble,\r\n        direction: direction,\r\n        placement: placement,\r\n        restriction: boundsRestriction,\r\n        label: labelPrefix + '-' + placement,\r\n        alwaysFit: alwaysFit\r\n      };\r\n    };\r\n\r\n    var adt$a = Adt.generate([\r\n      { southeast: [] },\r\n      { southwest: [] },\r\n      { northeast: [] },\r\n      { northwest: [] },\r\n      { south: [] },\r\n      { north: [] },\r\n      { east: [] },\r\n      { west: [] }\r\n    ]);\r\n    var cata$2 = function (subject, southeast, southwest, northeast, northwest, south, north, east, west) {\r\n      return subject.fold(southeast, southwest, northeast, northwest, south, north, east, west);\r\n    };\r\n    var cataVertical = function (subject, south, middle, north) {\r\n      return subject.fold(south, south, north, north, south, north, middle, middle);\r\n    };\r\n    var cataHorizontal = function (subject, east, middle, west) {\r\n      return subject.fold(east, west, east, west, middle, middle, east, west);\r\n    };\r\n    var southeast$3 = adt$a.southeast;\r\n    var southwest$3 = adt$a.southwest;\r\n    var northeast$3 = adt$a.northeast;\r\n    var northwest$3 = adt$a.northwest;\r\n    var south$3 = adt$a.south;\r\n    var north$3 = adt$a.north;\r\n    var east$3 = adt$a.east;\r\n    var west$3 = adt$a.west;\r\n\r\n    var cycleBy = function (value, delta, min, max) {\r\n      var r = value + delta;\r\n      if (r > max) {\r\n        return min;\r\n      } else if (r < min) {\r\n        return max;\r\n      } else {\r\n        return r;\r\n      }\r\n    };\r\n    var clamp$1 = function (value, min, max) {\r\n      return Math.min(Math.max(value, min), max);\r\n    };\r\n\r\n    var getRestriction = function (anchor, restriction) {\r\n      switch (restriction) {\r\n      case 1:\r\n        return anchor.x;\r\n      case 0:\r\n        return anchor.x + anchor.width;\r\n      case 2:\r\n        return anchor.y;\r\n      case 3:\r\n        return anchor.y + anchor.height;\r\n      }\r\n    };\r\n    var boundsRestriction = function (anchor, restrictions) {\r\n      return mapToObject([\r\n        'left',\r\n        'right',\r\n        'top',\r\n        'bottom'\r\n      ], function (dir) {\r\n        return get$e(restrictions, dir).map(function (restriction) {\r\n          return getRestriction(anchor, restriction);\r\n        });\r\n      });\r\n    };\r\n    var adjustBounds = function (bounds$1, restriction, bubbleOffset) {\r\n      var applyRestriction = function (dir, current) {\r\n        return restriction[dir].map(function (pos) {\r\n          var isVerticalAxis = dir === 'top' || dir === 'bottom';\r\n          var offset = isVerticalAxis ? bubbleOffset.top : bubbleOffset.left;\r\n          var comparator = dir === 'left' || dir === 'top' ? Math.max : Math.min;\r\n          var newPos = comparator(pos, current) + offset;\r\n          return isVerticalAxis ? clamp$1(newPos, bounds$1.y, bounds$1.bottom) : clamp$1(newPos, bounds$1.x, bounds$1.right);\r\n        }).getOr(current);\r\n      };\r\n      var adjustedLeft = applyRestriction('left', bounds$1.x);\r\n      var adjustedTop = applyRestriction('top', bounds$1.y);\r\n      var adjustedRight = applyRestriction('right', bounds$1.right);\r\n      var adjustedBottom = applyRestriction('bottom', bounds$1.bottom);\r\n      return bounds(adjustedLeft, adjustedTop, adjustedRight - adjustedLeft, adjustedBottom - adjustedTop);\r\n    };\r\n\r\n    var labelPrefix$2 = 'layout';\r\n    var eastX$1 = function (anchor) {\r\n      return anchor.x;\r\n    };\r\n    var middleX$1 = function (anchor, element) {\r\n      return anchor.x + anchor.width / 2 - element.width / 2;\r\n    };\r\n    var westX$1 = function (anchor, element) {\r\n      return anchor.x + anchor.width - element.width;\r\n    };\r\n    var northY$2 = function (anchor, element) {\r\n      return anchor.y - element.height;\r\n    };\r\n    var southY$2 = function (anchor) {\r\n      return anchor.y + anchor.height;\r\n    };\r\n    var centreY$1 = function (anchor, element) {\r\n      return anchor.y + anchor.height / 2 - element.height / 2;\r\n    };\r\n    var eastEdgeX$1 = function (anchor) {\r\n      return anchor.x + anchor.width;\r\n    };\r\n    var westEdgeX$1 = function (anchor, element) {\r\n      return anchor.x - element.width;\r\n    };\r\n    var southeast$2 = function (anchor, element, bubbles) {\r\n      return nu$6(eastX$1(anchor), southY$2(anchor), bubbles.southeast(), southeast$3(), 'southeast', boundsRestriction(anchor, {\r\n        left: 1,\r\n        top: 3\r\n      }), labelPrefix$2);\r\n    };\r\n    var southwest$2 = function (anchor, element, bubbles) {\r\n      return nu$6(westX$1(anchor, element), southY$2(anchor), bubbles.southwest(), southwest$3(), 'southwest', boundsRestriction(anchor, {\r\n        right: 0,\r\n        top: 3\r\n      }), labelPrefix$2);\r\n    };\r\n    var northeast$2 = function (anchor, element, bubbles) {\r\n      return nu$6(eastX$1(anchor), northY$2(anchor, element), bubbles.northeast(), northeast$3(), 'northeast', boundsRestriction(anchor, {\r\n        left: 1,\r\n        bottom: 2\r\n      }), labelPrefix$2);\r\n    };\r\n    var northwest$2 = function (anchor, element, bubbles) {\r\n      return nu$6(westX$1(anchor, element), northY$2(anchor, element), bubbles.northwest(), northwest$3(), 'northwest', boundsRestriction(anchor, {\r\n        right: 0,\r\n        bottom: 2\r\n      }), labelPrefix$2);\r\n    };\r\n    var north$2 = function (anchor, element, bubbles) {\r\n      return nu$6(middleX$1(anchor, element), northY$2(anchor, element), bubbles.north(), north$3(), 'north', boundsRestriction(anchor, { bottom: 2 }), labelPrefix$2);\r\n    };\r\n    var south$2 = function (anchor, element, bubbles) {\r\n      return nu$6(middleX$1(anchor, element), southY$2(anchor), bubbles.south(), south$3(), 'south', boundsRestriction(anchor, { top: 3 }), labelPrefix$2);\r\n    };\r\n    var east$2 = function (anchor, element, bubbles) {\r\n      return nu$6(eastEdgeX$1(anchor), centreY$1(anchor, element), bubbles.east(), east$3(), 'east', boundsRestriction(anchor, { left: 0 }), labelPrefix$2);\r\n    };\r\n    var west$2 = function (anchor, element, bubbles) {\r\n      return nu$6(westEdgeX$1(anchor, element), centreY$1(anchor, element), bubbles.west(), west$3(), 'west', boundsRestriction(anchor, { right: 1 }), labelPrefix$2);\r\n    };\r\n    var all$1 = function () {\r\n      return [\r\n        southeast$2,\r\n        southwest$2,\r\n        northeast$2,\r\n        northwest$2,\r\n        south$2,\r\n        north$2,\r\n        east$2,\r\n        west$2\r\n      ];\r\n    };\r\n    var allRtl$1 = function () {\r\n      return [\r\n        southwest$2,\r\n        southeast$2,\r\n        northwest$2,\r\n        northeast$2,\r\n        south$2,\r\n        north$2,\r\n        east$2,\r\n        west$2\r\n      ];\r\n    };\r\n    var aboveOrBelow = function () {\r\n      return [\r\n        northeast$2,\r\n        northwest$2,\r\n        southeast$2,\r\n        southwest$2,\r\n        north$2,\r\n        south$2\r\n      ];\r\n    };\r\n    var aboveOrBelowRtl = function () {\r\n      return [\r\n        northwest$2,\r\n        northeast$2,\r\n        southwest$2,\r\n        southeast$2,\r\n        north$2,\r\n        south$2\r\n      ];\r\n    };\r\n    var belowOrAbove = function () {\r\n      return [\r\n        southeast$2,\r\n        southwest$2,\r\n        northeast$2,\r\n        northwest$2,\r\n        south$2,\r\n        north$2\r\n      ];\r\n    };\r\n    var belowOrAboveRtl = function () {\r\n      return [\r\n        southwest$2,\r\n        southeast$2,\r\n        northwest$2,\r\n        northeast$2,\r\n        south$2,\r\n        north$2\r\n      ];\r\n    };\r\n\r\n    var chooseChannels = function (channels, message) {\r\n      return message.universal ? channels : filter$2(channels, function (ch) {\r\n        return contains$2(message.channels, ch);\r\n      });\r\n    };\r\n    var events$h = function (receiveConfig) {\r\n      return derive$2([run$1(receive(), function (component, message) {\r\n          var channelMap = receiveConfig.channels;\r\n          var channels = keys(channelMap);\r\n          var receivingData = message;\r\n          var targetChannels = chooseChannels(channels, receivingData);\r\n          each$1(targetChannels, function (ch) {\r\n            var channelInfo = channelMap[ch];\r\n            var channelSchema = channelInfo.schema;\r\n            var data = asRawOrDie$1('channel[' + ch + '] data\\nReceiver: ' + element(component.element), channelSchema, receivingData.data);\r\n            channelInfo.onReceive(component, data);\r\n          });\r\n        })]);\r\n    };\r\n\r\n    var ActiveReceiving = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        events: events$h\r\n    });\r\n\r\n    var ReceivingSchema = [requiredOf('channels', setOf(Result.value, objOfOnly([\r\n        onStrictHandler('onReceive'),\r\n        defaulted('schema', anyValue())\r\n      ])))];\r\n\r\n    var executeEvent = function (bConfig, bState, executor) {\r\n      return runOnExecute$1(function (component) {\r\n        executor(component, bConfig, bState);\r\n      });\r\n    };\r\n    var loadEvent = function (bConfig, bState, f) {\r\n      return runOnInit(function (component, _simulatedEvent) {\r\n        f(component, bConfig, bState);\r\n      });\r\n    };\r\n    var create$9 = function (schema, name, active, apis, extra, state) {\r\n      var configSchema = objOfOnly(schema);\r\n      var schemaSchema = optionObjOf(name, [optionObjOfOnly('config', schema)]);\r\n      return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);\r\n    };\r\n    var createModes$1 = function (modes, name, active, apis, extra, state) {\r\n      var configSchema = modes;\r\n      var schemaSchema = optionObjOf(name, [optionOf('config', modes)]);\r\n      return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);\r\n    };\r\n    var wrapApi = function (bName, apiFunction, apiName) {\r\n      var f = function (component) {\r\n        var rest = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n          rest[_i - 1] = arguments[_i];\r\n        }\r\n        var args = [component].concat(rest);\r\n        return component.config({ name: constant$1(bName) }).fold(function () {\r\n          throw new Error('We could not find any behaviour configuration for: ' + bName + '. Using API: ' + apiName);\r\n        }, function (info) {\r\n          var rest = Array.prototype.slice.call(args, 1);\r\n          return apiFunction.apply(undefined, [\r\n            component,\r\n            info.config,\r\n            info.state\r\n          ].concat(rest));\r\n        });\r\n      };\r\n      return markAsBehaviourApi(f, apiName, apiFunction);\r\n    };\r\n    var revokeBehaviour = function (name) {\r\n      return {\r\n        key: name,\r\n        value: undefined\r\n      };\r\n    };\r\n    var doCreate = function (configSchema, schemaSchema, name, active, apis, extra, state) {\r\n      var getConfig = function (info) {\r\n        return hasNonNullableKey(info, name) ? info[name]() : Optional.none();\r\n      };\r\n      var wrappedApis = map$1(apis, function (apiF, apiName) {\r\n        return wrapApi(name, apiF, apiName);\r\n      });\r\n      var wrappedExtra = map$1(extra, function (extraF, extraName) {\r\n        return markAsExtraApi(extraF, extraName);\r\n      });\r\n      var me = __assign(__assign(__assign({}, wrappedExtra), wrappedApis), {\r\n        revoke: curry(revokeBehaviour, name),\r\n        config: function (spec) {\r\n          var prepared = asRawOrDie$1(name + '-config', configSchema, spec);\r\n          return {\r\n            key: name,\r\n            value: {\r\n              config: prepared,\r\n              me: me,\r\n              configAsRaw: cached(function () {\r\n                return asRawOrDie$1(name + '-config', configSchema, spec);\r\n              }),\r\n              initialConfig: spec,\r\n              state: state\r\n            }\r\n          };\r\n        },\r\n        schema: constant$1(schemaSchema),\r\n        exhibit: function (info, base) {\r\n          return lift2(getConfig(info), get$e(active, 'exhibit'), function (behaviourInfo, exhibitor) {\r\n            return exhibitor(base, behaviourInfo.config, behaviourInfo.state);\r\n          }).getOrThunk(function () {\r\n            return nu$7({});\r\n          });\r\n        },\r\n        name: constant$1(name),\r\n        handlers: function (info) {\r\n          return getConfig(info).map(function (behaviourInfo) {\r\n            var getEvents = get$e(active, 'events').getOr(function () {\r\n              return {};\r\n            });\r\n            return getEvents(behaviourInfo.config, behaviourInfo.state);\r\n          }).getOr({});\r\n        }\r\n      });\r\n      return me;\r\n    };\r\n\r\n    var derive$1 = function (capabilities) {\r\n      return wrapAll(capabilities);\r\n    };\r\n    var simpleSchema = objOfOnly([\r\n      required$1('fields'),\r\n      required$1('name'),\r\n      defaulted('active', {}),\r\n      defaulted('apis', {}),\r\n      defaulted('state', NoState),\r\n      defaulted('extra', {})\r\n    ]);\r\n    var create$8 = function (data) {\r\n      var value = asRawOrDie$1('Creating behaviour: ' + data.name, simpleSchema, data);\r\n      return create$9(value.fields, value.name, value.active, value.apis, value.extra, value.state);\r\n    };\r\n    var modeSchema = objOfOnly([\r\n      required$1('branchKey'),\r\n      required$1('branches'),\r\n      required$1('name'),\r\n      defaulted('active', {}),\r\n      defaulted('apis', {}),\r\n      defaulted('state', NoState),\r\n      defaulted('extra', {})\r\n    ]);\r\n    var createModes = function (data) {\r\n      var value = asRawOrDie$1('Creating behaviour: ' + data.name, modeSchema, data);\r\n      return createModes$1(choose$1(value.branchKey, value.branches), value.name, value.active, value.apis, value.extra, value.state);\r\n    };\r\n    var revoke = constant$1(undefined);\r\n\r\n    var Receiving = create$8({\r\n      fields: ReceivingSchema,\r\n      name: 'receiving',\r\n      active: ActiveReceiving\r\n    });\r\n\r\n    var exhibit$6 = function (base, posConfig) {\r\n      return nu$7({\r\n        classes: [],\r\n        styles: posConfig.useFixed() ? {} : { position: 'relative' }\r\n      });\r\n    };\r\n\r\n    var ActivePosition = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        exhibit: exhibit$6\r\n    });\r\n\r\n    var getDocument = function () {\r\n      return SugarElement.fromDom(document);\r\n    };\r\n\r\n    var focus$3 = function (element) {\r\n      return element.dom.focus();\r\n    };\r\n    var blur$1 = function (element) {\r\n      return element.dom.blur();\r\n    };\r\n    var hasFocus = function (element) {\r\n      var root = getRootNode(element).dom;\r\n      return element.dom === root.activeElement;\r\n    };\r\n    var active = function (root) {\r\n      if (root === void 0) {\r\n        root = getDocument();\r\n      }\r\n      return Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\r\n    };\r\n    var search = function (element) {\r\n      return active(getRootNode(element)).filter(function (e) {\r\n        return element.dom.contains(e.dom);\r\n      });\r\n    };\r\n\r\n    var preserve$1 = function (f, container) {\r\n      var dos = getRootNode(container);\r\n      var refocus = active(dos).bind(function (focused) {\r\n        var hasFocus = function (elem) {\r\n          return eq(focused, elem);\r\n        };\r\n        return hasFocus(container) ? Optional.some(container) : descendant$1(container, hasFocus);\r\n      });\r\n      var result = f(container);\r\n      refocus.each(function (oldFocus) {\r\n        active(dos).filter(function (newFocus) {\r\n          return eq(newFocus, oldFocus);\r\n        }).fold(function () {\r\n          focus$3(oldFocus);\r\n        }, noop);\r\n      });\r\n      return result;\r\n    };\r\n\r\n    var NuPositionCss = function (position, left, top, right, bottom) {\r\n      var toPx = function (num) {\r\n        return num + 'px';\r\n      };\r\n      return {\r\n        position: position,\r\n        left: left.map(toPx),\r\n        top: top.map(toPx),\r\n        right: right.map(toPx),\r\n        bottom: bottom.map(toPx)\r\n      };\r\n    };\r\n    var toOptions = function (position) {\r\n      return __assign(__assign({}, position), { position: Optional.some(position.position) });\r\n    };\r\n    var applyPositionCss = function (element, position) {\r\n      setOptions(element, toOptions(position));\r\n    };\r\n\r\n    var adt$9 = Adt.generate([\r\n      { none: [] },\r\n      {\r\n        relative: [\r\n          'x',\r\n          'y',\r\n          'width',\r\n          'height'\r\n        ]\r\n      },\r\n      {\r\n        fixed: [\r\n          'x',\r\n          'y',\r\n          'width',\r\n          'height'\r\n        ]\r\n      }\r\n    ]);\r\n    var positionWithDirection = function (posName, decision, x, y, width, height) {\r\n      var decisionRect = decision.rect;\r\n      var decisionX = decisionRect.x - x;\r\n      var decisionY = decisionRect.y - y;\r\n      var decisionWidth = decisionRect.width;\r\n      var decisionHeight = decisionRect.height;\r\n      var decisionRight = width - (decisionX + decisionWidth);\r\n      var decisionBottom = height - (decisionY + decisionHeight);\r\n      var left = Optional.some(decisionX);\r\n      var top = Optional.some(decisionY);\r\n      var right = Optional.some(decisionRight);\r\n      var bottom = Optional.some(decisionBottom);\r\n      var none = Optional.none();\r\n      return cata$2(decision.direction, function () {\r\n        return NuPositionCss(posName, left, top, none, none);\r\n      }, function () {\r\n        return NuPositionCss(posName, none, top, right, none);\r\n      }, function () {\r\n        return NuPositionCss(posName, left, none, none, bottom);\r\n      }, function () {\r\n        return NuPositionCss(posName, none, none, right, bottom);\r\n      }, function () {\r\n        return NuPositionCss(posName, left, top, none, none);\r\n      }, function () {\r\n        return NuPositionCss(posName, left, none, none, bottom);\r\n      }, function () {\r\n        return NuPositionCss(posName, left, top, none, none);\r\n      }, function () {\r\n        return NuPositionCss(posName, none, top, right, none);\r\n      });\r\n    };\r\n    var reposition = function (origin, decision) {\r\n      return origin.fold(function () {\r\n        var decisionRect = decision.rect;\r\n        return NuPositionCss('absolute', Optional.some(decisionRect.x), Optional.some(decisionRect.y), Optional.none(), Optional.none());\r\n      }, function (x, y, width, height) {\r\n        return positionWithDirection('absolute', decision, x, y, width, height);\r\n      }, function (x, y, width, height) {\r\n        return positionWithDirection('fixed', decision, x, y, width, height);\r\n      });\r\n    };\r\n    var toBox = function (origin, element) {\r\n      var rel = curry(find$2, element);\r\n      var position = origin.fold(rel, rel, function () {\r\n        var scroll = get$9();\r\n        return find$2(element).translate(-scroll.left, -scroll.top);\r\n      });\r\n      var width = getOuter$1(element);\r\n      var height = getOuter$2(element);\r\n      return bounds(position.left, position.top, width, height);\r\n    };\r\n    var viewport = function (origin, getBounds) {\r\n      return getBounds.fold(function () {\r\n        return origin.fold(win, win, bounds);\r\n      }, function (b) {\r\n        return origin.fold(b, b, function () {\r\n          var bounds$1 = b();\r\n          var pos = translate$2(origin, bounds$1.x, bounds$1.y);\r\n          return bounds(pos.left, pos.top, bounds$1.width, bounds$1.height);\r\n        });\r\n      });\r\n    };\r\n    var translate$2 = function (origin, x, y) {\r\n      var pos = SugarPosition(x, y);\r\n      var removeScroll = function () {\r\n        var outerScroll = get$9();\r\n        return pos.translate(-outerScroll.left, -outerScroll.top);\r\n      };\r\n      return origin.fold(constant$1(pos), constant$1(pos), removeScroll);\r\n    };\r\n    var cata$1 = function (subject, onNone, onRelative, onFixed) {\r\n      return subject.fold(onNone, onRelative, onFixed);\r\n    };\r\n    adt$9.none;\r\n    var relative$1 = adt$9.relative;\r\n    var fixed$1 = adt$9.fixed;\r\n\r\n    var anchor = function (anchorBox, origin) {\r\n      return {\r\n        anchorBox: anchorBox,\r\n        origin: origin\r\n      };\r\n    };\r\n    var box = function (anchorBox, origin) {\r\n      return anchor(anchorBox, origin);\r\n    };\r\n\r\n    var placementAttribute = 'data-alloy-placement';\r\n    var setPlacement$1 = function (element, placement) {\r\n      set$8(element, placementAttribute, placement);\r\n    };\r\n    var getPlacement = function (element) {\r\n      return getOpt(element, placementAttribute);\r\n    };\r\n    var reset$2 = function (element) {\r\n      return remove$7(element, placementAttribute);\r\n    };\r\n\r\n    var adt$8 = Adt.generate([\r\n      { fit: ['reposition'] },\r\n      {\r\n        nofit: [\r\n          'reposition',\r\n          'visibleW',\r\n          'visibleH',\r\n          'isVisible'\r\n        ]\r\n      }\r\n    ]);\r\n    var determinePosition = function (box, bounds) {\r\n      var boundsX = bounds.x, boundsY = bounds.y, boundsRight = bounds.right, boundsBottom = bounds.bottom;\r\n      var x = box.x, y = box.y, right = box.right, bottom = box.bottom, width = box.width, height = box.height;\r\n      var xInBounds = x >= boundsX && x <= boundsRight;\r\n      var yInBounds = y >= boundsY && y <= boundsBottom;\r\n      var originInBounds = xInBounds && yInBounds;\r\n      var rightInBounds = right <= boundsRight && right >= boundsX;\r\n      var bottomInBounds = bottom <= boundsBottom && bottom >= boundsY;\r\n      var sizeInBounds = rightInBounds && bottomInBounds;\r\n      var visibleW = Math.min(width, x >= boundsX ? boundsRight - x : right - boundsX);\r\n      var visibleH = Math.min(height, y >= boundsY ? boundsBottom - y : bottom - boundsY);\r\n      return {\r\n        originInBounds: originInBounds,\r\n        sizeInBounds: sizeInBounds,\r\n        visibleW: visibleW,\r\n        visibleH: visibleH\r\n      };\r\n    };\r\n    var calcReposition = function (box, bounds$1) {\r\n      var boundsX = bounds$1.x, boundsY = bounds$1.y, boundsRight = bounds$1.right, boundsBottom = bounds$1.bottom;\r\n      var x = box.x, y = box.y, width = box.width, height = box.height;\r\n      var maxX = Math.max(boundsX, boundsRight - width);\r\n      var maxY = Math.max(boundsY, boundsBottom - height);\r\n      var restrictedX = clamp$1(x, boundsX, maxX);\r\n      var restrictedY = clamp$1(y, boundsY, maxY);\r\n      var restrictedWidth = Math.min(restrictedX + width, boundsRight) - restrictedX;\r\n      var restrictedHeight = Math.min(restrictedY + height, boundsBottom) - restrictedY;\r\n      return bounds(restrictedX, restrictedY, restrictedWidth, restrictedHeight);\r\n    };\r\n    var calcMaxSizes = function (direction, box, bounds) {\r\n      var upAvailable = constant$1(box.bottom - bounds.y);\r\n      var downAvailable = constant$1(bounds.bottom - box.y);\r\n      var maxHeight = cataVertical(direction, downAvailable, downAvailable, upAvailable);\r\n      var westAvailable = constant$1(box.right - bounds.x);\r\n      var eastAvailable = constant$1(bounds.right - box.x);\r\n      var maxWidth = cataHorizontal(direction, eastAvailable, eastAvailable, westAvailable);\r\n      return {\r\n        maxWidth: maxWidth,\r\n        maxHeight: maxHeight\r\n      };\r\n    };\r\n    var attempt = function (candidate, width, height, bounds$1) {\r\n      var bubble = candidate.bubble;\r\n      var bubbleOffset = bubble.offset;\r\n      var adjustedBounds = adjustBounds(bounds$1, candidate.restriction, bubbleOffset);\r\n      var newX = candidate.x + bubbleOffset.left;\r\n      var newY = candidate.y + bubbleOffset.top;\r\n      var box = bounds(newX, newY, width, height);\r\n      var _a = determinePosition(box, adjustedBounds), originInBounds = _a.originInBounds, sizeInBounds = _a.sizeInBounds, visibleW = _a.visibleW, visibleH = _a.visibleH;\r\n      var fits = originInBounds && sizeInBounds;\r\n      var fittedBox = fits ? box : calcReposition(box, adjustedBounds);\r\n      var isPartlyVisible = fittedBox.width > 0 && fittedBox.height > 0;\r\n      var _b = calcMaxSizes(candidate.direction, fittedBox, bounds$1), maxWidth = _b.maxWidth, maxHeight = _b.maxHeight;\r\n      var reposition = {\r\n        rect: fittedBox,\r\n        maxHeight: maxHeight,\r\n        maxWidth: maxWidth,\r\n        direction: candidate.direction,\r\n        placement: candidate.placement,\r\n        classes: {\r\n          on: bubble.classesOn,\r\n          off: bubble.classesOff\r\n        },\r\n        layout: candidate.label,\r\n        testY: newY\r\n      };\r\n      return fits || candidate.alwaysFit ? adt$8.fit(reposition) : adt$8.nofit(reposition, visibleW, visibleH, isPartlyVisible);\r\n    };\r\n    var attempts = function (element, candidates, anchorBox, elementBox, bubbles, bounds) {\r\n      var panelWidth = elementBox.width;\r\n      var panelHeight = elementBox.height;\r\n      var attemptBestFit = function (layout, reposition, visibleW, visibleH, isVisible) {\r\n        var next = layout(anchorBox, elementBox, bubbles, element, bounds);\r\n        var attemptLayout = attempt(next, panelWidth, panelHeight, bounds);\r\n        return attemptLayout.fold(constant$1(attemptLayout), function (newReposition, newVisibleW, newVisibleH, newIsVisible) {\r\n          var improved = isVisible === newIsVisible ? newVisibleH > visibleH || newVisibleW > visibleW : !isVisible && newIsVisible;\r\n          return improved ? attemptLayout : adt$8.nofit(reposition, visibleW, visibleH, isVisible);\r\n        });\r\n      };\r\n      var abc = foldl(candidates, function (b, a) {\r\n        var bestNext = curry(attemptBestFit, a);\r\n        return b.fold(constant$1(b), bestNext);\r\n      }, adt$8.nofit({\r\n        rect: anchorBox,\r\n        maxHeight: elementBox.height,\r\n        maxWidth: elementBox.width,\r\n        direction: southeast$3(),\r\n        placement: 'southeast',\r\n        classes: {\r\n          on: [],\r\n          off: []\r\n        },\r\n        layout: 'none',\r\n        testY: anchorBox.y\r\n      }, -1, -1, false));\r\n      return abc.fold(identity$1, identity$1);\r\n    };\r\n\r\n    var singleton = function (doRevoke) {\r\n      var subject = Cell(Optional.none());\r\n      var revoke = function () {\r\n        return subject.get().each(doRevoke);\r\n      };\r\n      var clear = function () {\r\n        revoke();\r\n        subject.set(Optional.none());\r\n      };\r\n      var isSet = function () {\r\n        return subject.get().isSome();\r\n      };\r\n      var get = function () {\r\n        return subject.get();\r\n      };\r\n      var set = function (s) {\r\n        revoke();\r\n        subject.set(Optional.some(s));\r\n      };\r\n      return {\r\n        clear: clear,\r\n        isSet: isSet,\r\n        get: get,\r\n        set: set\r\n      };\r\n    };\r\n    var destroyable = function () {\r\n      return singleton(function (s) {\r\n        return s.destroy();\r\n      });\r\n    };\r\n    var unbindable = function () {\r\n      return singleton(function (s) {\r\n        return s.unbind();\r\n      });\r\n    };\r\n    var api$1 = function () {\r\n      var subject = destroyable();\r\n      var run = function (f) {\r\n        return subject.get().each(f);\r\n      };\r\n      return __assign(__assign({}, subject), { run: run });\r\n    };\r\n    var value$1 = function () {\r\n      var subject = singleton(noop);\r\n      var on = function (f) {\r\n        return subject.get().each(f);\r\n      };\r\n      return __assign(__assign({}, subject), { on: on });\r\n    };\r\n\r\n    var filter = always;\r\n    var bind = function (element, event, handler) {\r\n      return bind$2(element, event, filter, handler);\r\n    };\r\n    var capture = function (element, event, handler) {\r\n      return capture$1(element, event, filter, handler);\r\n    };\r\n    var fromRawEvent = fromRawEvent$1;\r\n\r\n    var properties = [\r\n      'top',\r\n      'bottom',\r\n      'right',\r\n      'left'\r\n    ];\r\n    var timerAttr = 'data-alloy-transition-timer';\r\n    var isTransitioning$1 = function (element, transition) {\r\n      return hasAll(element, transition.classes);\r\n    };\r\n    var shouldApplyTransitionCss = function (transition, decision, lastPlacement) {\r\n      return lastPlacement.exists(function (placer) {\r\n        var mode = transition.mode;\r\n        return mode === 'all' ? true : placer[mode] !== decision[mode];\r\n      });\r\n    };\r\n    var hasChanges = function (position, intermediate) {\r\n      var round = function (value) {\r\n        return parseFloat(value).toFixed(3);\r\n      };\r\n      return find$4(intermediate, function (value, key) {\r\n        var newValue = position[key].map(round);\r\n        var val = value.map(round);\r\n        return !equals(newValue, val);\r\n      }).isSome();\r\n    };\r\n    var getTransitionDuration = function (element) {\r\n      var get = function (name) {\r\n        var style = get$c(element, name);\r\n        var times = isString(style) ? style.split(/\\s*,\\s*/) : [];\r\n        return filter$2(times, isNotEmpty);\r\n      };\r\n      var parse = function (value) {\r\n        if (isString(value) && /^[\\d.]+/.test(value)) {\r\n          var num = parseFloat(value);\r\n          return endsWith(value, 'ms') ? num : num * 1000;\r\n        } else {\r\n          return 0;\r\n        }\r\n      };\r\n      var delay = get('transition-delay');\r\n      var duration = get('transition-duration');\r\n      return foldl(duration, function (acc, dur, i) {\r\n        var time = parse(delay[i]) + parse(dur);\r\n        return Math.max(acc, time);\r\n      }, 0);\r\n    };\r\n    var setupTransitionListeners = function (element, transition) {\r\n      var transitionEnd = unbindable();\r\n      var transitionCancel = unbindable();\r\n      var timer;\r\n      var isSourceTransition = function (e) {\r\n        var _a;\r\n        var pseudoElement = (_a = e.raw.pseudoElement) !== null && _a !== void 0 ? _a : '';\r\n        return eq(e.target, element) && isEmpty(pseudoElement) && contains$2(properties, e.raw.propertyName);\r\n      };\r\n      var transitionDone = function (e) {\r\n        if (isNullable(e) || isSourceTransition(e)) {\r\n          transitionEnd.clear();\r\n          transitionCancel.clear();\r\n          var type = e === null || e === void 0 ? void 0 : e.raw.type;\r\n          if (isNullable(type) || type === transitionend()) {\r\n            clearTimeout(timer);\r\n            remove$7(element, timerAttr);\r\n            remove$1(element, transition.classes);\r\n          }\r\n        }\r\n      };\r\n      var transitionStarted = function () {\r\n        transitionEnd.set(bind(element, transitionend(), transitionDone));\r\n        transitionCancel.set(bind(element, transitioncancel(), transitionDone));\r\n      };\r\n      if ('ontransitionstart' in element.dom) {\r\n        var transitionStart_1 = bind(element, transitionstart(), function (e) {\r\n          if (isSourceTransition(e)) {\r\n            transitionStart_1.unbind();\r\n            transitionStarted();\r\n          }\r\n        });\r\n      } else {\r\n        transitionStarted();\r\n      }\r\n      var duration = getTransitionDuration(element);\r\n      requestAnimationFrame(function () {\r\n        timer = setTimeout(transitionDone, duration + 17);\r\n        set$8(element, timerAttr, timer);\r\n      });\r\n    };\r\n    var startTransitioning = function (element, transition) {\r\n      add$1(element, transition.classes);\r\n      getOpt(element, timerAttr).each(function (timerId) {\r\n        clearTimeout(parseInt(timerId, 10));\r\n        remove$7(element, timerAttr);\r\n      });\r\n      setupTransitionListeners(element, transition);\r\n    };\r\n    var applyTransitionCss = function (element, origin, position, transition, decision, lastPlacement) {\r\n      var shouldTransition = shouldApplyTransitionCss(transition, decision, lastPlacement);\r\n      if (shouldTransition || isTransitioning$1(element, transition)) {\r\n        set$7(element, 'position', position.position);\r\n        var rect = toBox(origin, element);\r\n        var intermediatePosition_1 = reposition(origin, __assign(__assign({}, decision), { rect: rect }));\r\n        var intermediateCssOptions = mapToObject(properties, function (prop) {\r\n          return intermediatePosition_1[prop];\r\n        });\r\n        if (hasChanges(position, intermediateCssOptions)) {\r\n          setOptions(element, intermediateCssOptions);\r\n          if (shouldTransition) {\r\n            startTransitioning(element, transition);\r\n          }\r\n          reflow(element);\r\n        }\r\n      } else {\r\n        remove$1(element, transition.classes);\r\n      }\r\n    };\r\n\r\n    var elementSize = function (p) {\r\n      return {\r\n        width: getOuter$1(p),\r\n        height: getOuter$2(p)\r\n      };\r\n    };\r\n    var layout = function (anchorBox, element, bubbles, options) {\r\n      remove$6(element, 'max-height');\r\n      remove$6(element, 'max-width');\r\n      var elementBox = elementSize(element);\r\n      return attempts(element, options.preference, anchorBox, elementBox, bubbles, options.bounds);\r\n    };\r\n    var setClasses = function (element, decision) {\r\n      var classInfo = decision.classes;\r\n      remove$1(element, classInfo.off);\r\n      add$1(element, classInfo.on);\r\n    };\r\n    var setHeight = function (element, decision, options) {\r\n      var maxHeightFunction = options.maxHeightFunction;\r\n      maxHeightFunction(element, decision.maxHeight);\r\n    };\r\n    var setWidth = function (element, decision, options) {\r\n      var maxWidthFunction = options.maxWidthFunction;\r\n      maxWidthFunction(element, decision.maxWidth);\r\n    };\r\n    var position$2 = function (element, decision, options) {\r\n      var positionCss = reposition(options.origin, decision);\r\n      options.transition.each(function (transition) {\r\n        applyTransitionCss(element, options.origin, positionCss, transition, decision, options.lastPlacement);\r\n      });\r\n      applyPositionCss(element, positionCss);\r\n    };\r\n    var setPlacement = function (element, decision) {\r\n      setPlacement$1(element, decision.placement);\r\n    };\r\n\r\n    var setMaxHeight = function (element, maxHeight) {\r\n      setMax$1(element, Math.floor(maxHeight));\r\n    };\r\n    var anchored = constant$1(function (element, available) {\r\n      setMaxHeight(element, available);\r\n      setAll(element, {\r\n        'overflow-x': 'hidden',\r\n        'overflow-y': 'auto'\r\n      });\r\n    });\r\n    var expandable$1 = constant$1(function (element, available) {\r\n      setMaxHeight(element, available);\r\n    });\r\n\r\n    var defaultOr = function (options, key, dephault) {\r\n      return options[key] === undefined ? dephault : options[key];\r\n    };\r\n    var simple = function (anchor, element, bubble, layouts, lastPlacement, getBounds, overrideOptions, transition) {\r\n      var maxHeightFunction = defaultOr(overrideOptions, 'maxHeightFunction', anchored());\r\n      var maxWidthFunction = defaultOr(overrideOptions, 'maxWidthFunction', noop);\r\n      var anchorBox = anchor.anchorBox;\r\n      var origin = anchor.origin;\r\n      var options = {\r\n        bounds: viewport(origin, getBounds),\r\n        origin: origin,\r\n        preference: layouts,\r\n        maxHeightFunction: maxHeightFunction,\r\n        maxWidthFunction: maxWidthFunction,\r\n        lastPlacement: lastPlacement,\r\n        transition: transition\r\n      };\r\n      return go(anchorBox, element, bubble, options);\r\n    };\r\n    var go = function (anchorBox, element, bubble, options) {\r\n      var decision = layout(anchorBox, element, bubble, options);\r\n      position$2(element, decision, options);\r\n      setPlacement(element, decision);\r\n      setClasses(element, decision);\r\n      setHeight(element, decision, options);\r\n      setWidth(element, decision, options);\r\n      return {\r\n        layout: decision.layout,\r\n        placement: decision.placement\r\n      };\r\n    };\r\n\r\n    var allAlignments = [\r\n      'valignCentre',\r\n      'alignLeft',\r\n      'alignRight',\r\n      'alignCentre',\r\n      'top',\r\n      'bottom',\r\n      'left',\r\n      'right',\r\n      'inset'\r\n    ];\r\n    var nu$5 = function (xOffset, yOffset, classes, insetModifier) {\r\n      if (insetModifier === void 0) {\r\n        insetModifier = 1;\r\n      }\r\n      var insetXOffset = xOffset * insetModifier;\r\n      var insetYOffset = yOffset * insetModifier;\r\n      var getClasses = function (prop) {\r\n        return get$e(classes, prop).getOr([]);\r\n      };\r\n      var make = function (xDelta, yDelta, alignmentsOn) {\r\n        var alignmentsOff = difference(allAlignments, alignmentsOn);\r\n        return {\r\n          offset: SugarPosition(xDelta, yDelta),\r\n          classesOn: bind$3(alignmentsOn, getClasses),\r\n          classesOff: bind$3(alignmentsOff, getClasses)\r\n        };\r\n      };\r\n      return {\r\n        southeast: function () {\r\n          return make(-xOffset, yOffset, [\r\n            'top',\r\n            'alignLeft'\r\n          ]);\r\n        },\r\n        southwest: function () {\r\n          return make(xOffset, yOffset, [\r\n            'top',\r\n            'alignRight'\r\n          ]);\r\n        },\r\n        south: function () {\r\n          return make(-xOffset / 2, yOffset, [\r\n            'top',\r\n            'alignCentre'\r\n          ]);\r\n        },\r\n        northeast: function () {\r\n          return make(-xOffset, -yOffset, [\r\n            'bottom',\r\n            'alignLeft'\r\n          ]);\r\n        },\r\n        northwest: function () {\r\n          return make(xOffset, -yOffset, [\r\n            'bottom',\r\n            'alignRight'\r\n          ]);\r\n        },\r\n        north: function () {\r\n          return make(-xOffset / 2, -yOffset, [\r\n            'bottom',\r\n            'alignCentre'\r\n          ]);\r\n        },\r\n        east: function () {\r\n          return make(xOffset, -yOffset / 2, [\r\n            'valignCentre',\r\n            'left'\r\n          ]);\r\n        },\r\n        west: function () {\r\n          return make(-xOffset, -yOffset / 2, [\r\n            'valignCentre',\r\n            'right'\r\n          ]);\r\n        },\r\n        insetNortheast: function () {\r\n          return make(insetXOffset, insetYOffset, [\r\n            'top',\r\n            'alignLeft',\r\n            'inset'\r\n          ]);\r\n        },\r\n        insetNorthwest: function () {\r\n          return make(-insetXOffset, insetYOffset, [\r\n            'top',\r\n            'alignRight',\r\n            'inset'\r\n          ]);\r\n        },\r\n        insetNorth: function () {\r\n          return make(-insetXOffset / 2, insetYOffset, [\r\n            'top',\r\n            'alignCentre',\r\n            'inset'\r\n          ]);\r\n        },\r\n        insetSoutheast: function () {\r\n          return make(insetXOffset, -insetYOffset, [\r\n            'bottom',\r\n            'alignLeft',\r\n            'inset'\r\n          ]);\r\n        },\r\n        insetSouthwest: function () {\r\n          return make(-insetXOffset, -insetYOffset, [\r\n            'bottom',\r\n            'alignRight',\r\n            'inset'\r\n          ]);\r\n        },\r\n        insetSouth: function () {\r\n          return make(-insetXOffset / 2, -insetYOffset, [\r\n            'bottom',\r\n            'alignCentre',\r\n            'inset'\r\n          ]);\r\n        },\r\n        insetEast: function () {\r\n          return make(-insetXOffset, -insetYOffset / 2, [\r\n            'valignCentre',\r\n            'right',\r\n            'inset'\r\n          ]);\r\n        },\r\n        insetWest: function () {\r\n          return make(insetXOffset, -insetYOffset / 2, [\r\n            'valignCentre',\r\n            'left',\r\n            'inset'\r\n          ]);\r\n        }\r\n      };\r\n    };\r\n    var fallback = function () {\r\n      return nu$5(0, 0, {});\r\n    };\r\n\r\n    var nu$4 = identity$1;\r\n\r\n    var onDirection = function (isLtr, isRtl) {\r\n      return function (element) {\r\n        return getDirection(element) === 'rtl' ? isRtl : isLtr;\r\n      };\r\n    };\r\n    var getDirection = function (element) {\r\n      return get$c(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';\r\n    };\r\n\r\n    var AttributeValue;\r\n    (function (AttributeValue) {\r\n      AttributeValue['TopToBottom'] = 'toptobottom';\r\n      AttributeValue['BottomToTop'] = 'bottomtotop';\r\n    }(AttributeValue || (AttributeValue = {})));\r\n    var Attribute = 'data-alloy-vertical-dir';\r\n    var isBottomToTopDir = function (el) {\r\n      return closest$2(el, function (current) {\r\n        return isElement$2(current) && get$d(current, 'data-alloy-vertical-dir') === AttributeValue.BottomToTop;\r\n      });\r\n    };\r\n\r\n    var schema$y = function () {\r\n      return optionObjOf('layouts', [\r\n        required$1('onLtr'),\r\n        required$1('onRtl'),\r\n        option('onBottomLtr'),\r\n        option('onBottomRtl')\r\n      ]);\r\n    };\r\n    var get$4 = function (elem, info, defaultLtr, defaultRtl, defaultBottomLtr, defaultBottomRtl, dirElement) {\r\n      var isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);\r\n      var customLtr = info.layouts.map(function (ls) {\r\n        return ls.onLtr(elem);\r\n      });\r\n      var customRtl = info.layouts.map(function (ls) {\r\n        return ls.onRtl(elem);\r\n      });\r\n      var ltr = isBottomToTop ? info.layouts.bind(function (ls) {\r\n        return ls.onBottomLtr.map(function (f) {\r\n          return f(elem);\r\n        });\r\n      }).or(customLtr).getOr(defaultBottomLtr) : customLtr.getOr(defaultLtr);\r\n      var rtl = isBottomToTop ? info.layouts.bind(function (ls) {\r\n        return ls.onBottomRtl.map(function (f) {\r\n          return f(elem);\r\n        });\r\n      }).or(customRtl).getOr(defaultBottomRtl) : customRtl.getOr(defaultRtl);\r\n      var f = onDirection(ltr, rtl);\r\n      return f(elem);\r\n    };\r\n\r\n    var placement$4 = function (component, anchorInfo, origin) {\r\n      var hotspot = anchorInfo.hotspot;\r\n      var anchorBox = toBox(origin, hotspot.element);\r\n      var layouts = get$4(component.element, anchorInfo, belowOrAbove(), belowOrAboveRtl(), aboveOrBelow(), aboveOrBelowRtl(), Optional.some(anchorInfo.hotspot.element));\r\n      return Optional.some(nu$4({\r\n        anchorBox: anchorBox,\r\n        bubble: anchorInfo.bubble.getOr(fallback()),\r\n        overrides: anchorInfo.overrides,\r\n        layouts: layouts,\r\n        placer: Optional.none()\r\n      }));\r\n    };\r\n    var HotspotAnchor = [\r\n      required$1('hotspot'),\r\n      option('bubble'),\r\n      defaulted('overrides', {}),\r\n      schema$y(),\r\n      output$1('placement', placement$4)\r\n    ];\r\n\r\n    var placement$3 = function (component, anchorInfo, origin) {\r\n      var pos = translate$2(origin, anchorInfo.x, anchorInfo.y);\r\n      var anchorBox = bounds(pos.left, pos.top, anchorInfo.width, anchorInfo.height);\r\n      var layouts = get$4(component.element, anchorInfo, all$1(), allRtl$1(), all$1(), allRtl$1(), Optional.none());\r\n      return Optional.some(nu$4({\r\n        anchorBox: anchorBox,\r\n        bubble: anchorInfo.bubble,\r\n        overrides: anchorInfo.overrides,\r\n        layouts: layouts,\r\n        placer: Optional.none()\r\n      }));\r\n    };\r\n    var MakeshiftAnchor = [\r\n      required$1('x'),\r\n      required$1('y'),\r\n      defaulted('height', 0),\r\n      defaulted('width', 0),\r\n      defaulted('bubble', fallback()),\r\n      defaulted('overrides', {}),\r\n      schema$y(),\r\n      output$1('placement', placement$3)\r\n    ];\r\n\r\n    var adt$7 = Adt.generate([\r\n      { screen: ['point'] },\r\n      {\r\n        absolute: [\r\n          'point',\r\n          'scrollLeft',\r\n          'scrollTop'\r\n        ]\r\n      }\r\n    ]);\r\n    var toFixed = function (pos) {\r\n      return pos.fold(identity$1, function (point, scrollLeft, scrollTop) {\r\n        return point.translate(-scrollLeft, -scrollTop);\r\n      });\r\n    };\r\n    var toAbsolute = function (pos) {\r\n      return pos.fold(identity$1, identity$1);\r\n    };\r\n    var sum = function (points) {\r\n      return foldl(points, function (b, a) {\r\n        return b.translate(a.left, a.top);\r\n      }, SugarPosition(0, 0));\r\n    };\r\n    var sumAsFixed = function (positions) {\r\n      var points = map$2(positions, toFixed);\r\n      return sum(points);\r\n    };\r\n    var sumAsAbsolute = function (positions) {\r\n      var points = map$2(positions, toAbsolute);\r\n      return sum(points);\r\n    };\r\n    var screen = adt$7.screen;\r\n    var absolute$1 = adt$7.absolute;\r\n\r\n    var getOffset = function (component, origin, anchorInfo) {\r\n      var win = defaultView(anchorInfo.root).dom;\r\n      var hasSameOwner = function (frame) {\r\n        var frameOwner = owner$4(frame);\r\n        var compOwner = owner$4(component.element);\r\n        return eq(frameOwner, compOwner);\r\n      };\r\n      return Optional.from(win.frameElement).map(SugarElement.fromDom).filter(hasSameOwner).map(absolute$3);\r\n    };\r\n    var getRootPoint = function (component, origin, anchorInfo) {\r\n      var doc = owner$4(component.element);\r\n      var outerScroll = get$9(doc);\r\n      var offset = getOffset(component, origin, anchorInfo).getOr(outerScroll);\r\n      return absolute$1(offset, outerScroll.left, outerScroll.top);\r\n    };\r\n\r\n    var getBox = function (left, top, width, height) {\r\n      var point = screen(SugarPosition(left, top));\r\n      return Optional.some(pointed(point, width, height));\r\n    };\r\n    var calcNewAnchor = function (optBox, rootPoint, anchorInfo, origin, elem) {\r\n      return optBox.map(function (box) {\r\n        var points = [\r\n          rootPoint,\r\n          box.point\r\n        ];\r\n        var topLeft = cata$1(origin, function () {\r\n          return sumAsAbsolute(points);\r\n        }, function () {\r\n          return sumAsAbsolute(points);\r\n        }, function () {\r\n          return sumAsFixed(points);\r\n        });\r\n        var anchorBox = rect(topLeft.left, topLeft.top, box.width, box.height);\r\n        var layoutsLtr = anchorInfo.showAbove ? aboveOrBelow() : belowOrAbove();\r\n        var layoutsRtl = anchorInfo.showAbove ? aboveOrBelowRtl() : belowOrAboveRtl();\r\n        var layouts = get$4(elem, anchorInfo, layoutsLtr, layoutsRtl, layoutsLtr, layoutsRtl, Optional.none());\r\n        return nu$4({\r\n          anchorBox: anchorBox,\r\n          bubble: anchorInfo.bubble.getOr(fallback()),\r\n          overrides: anchorInfo.overrides,\r\n          layouts: layouts,\r\n          placer: Optional.none()\r\n        });\r\n      });\r\n    };\r\n\r\n    var placement$2 = function (component, anchorInfo, origin) {\r\n      var rootPoint = getRootPoint(component, origin, anchorInfo);\r\n      return anchorInfo.node.filter(inBody).bind(function (target) {\r\n        var rect = target.dom.getBoundingClientRect();\r\n        var nodeBox = getBox(rect.left, rect.top, rect.width, rect.height);\r\n        var elem = anchorInfo.node.getOr(component.element);\r\n        return calcNewAnchor(nodeBox, rootPoint, anchorInfo, origin, elem);\r\n      });\r\n    };\r\n    var NodeAnchor = [\r\n      required$1('node'),\r\n      required$1('root'),\r\n      option('bubble'),\r\n      schema$y(),\r\n      defaulted('overrides', {}),\r\n      defaulted('showAbove', false),\r\n      output$1('placement', placement$2)\r\n    ];\r\n\r\n    var zeroWidth = '\\uFEFF';\r\n    var nbsp = '\\xA0';\r\n\r\n    var create$7 = function (start, soffset, finish, foffset) {\r\n      return {\r\n        start: start,\r\n        soffset: soffset,\r\n        finish: finish,\r\n        foffset: foffset\r\n      };\r\n    };\r\n    var SimRange = { create: create$7 };\r\n\r\n    var adt$6 = Adt.generate([\r\n      { before: ['element'] },\r\n      {\r\n        on: [\r\n          'element',\r\n          'offset'\r\n        ]\r\n      },\r\n      { after: ['element'] }\r\n    ]);\r\n    var cata = function (subject, onBefore, onOn, onAfter) {\r\n      return subject.fold(onBefore, onOn, onAfter);\r\n    };\r\n    var getStart$1 = function (situ) {\r\n      return situ.fold(identity$1, identity$1, identity$1);\r\n    };\r\n    var before = adt$6.before;\r\n    var on$1 = adt$6.on;\r\n    var after$1 = adt$6.after;\r\n    var Situ = {\r\n      before: before,\r\n      on: on$1,\r\n      after: after$1,\r\n      cata: cata,\r\n      getStart: getStart$1\r\n    };\r\n\r\n    var adt$5 = Adt.generate([\r\n      { domRange: ['rng'] },\r\n      {\r\n        relative: [\r\n          'startSitu',\r\n          'finishSitu'\r\n        ]\r\n      },\r\n      {\r\n        exact: [\r\n          'start',\r\n          'soffset',\r\n          'finish',\r\n          'foffset'\r\n        ]\r\n      }\r\n    ]);\r\n    var exactFromRange = function (simRange) {\r\n      return adt$5.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\r\n    };\r\n    var getStart = function (selection) {\r\n      return selection.match({\r\n        domRange: function (rng) {\r\n          return SugarElement.fromDom(rng.startContainer);\r\n        },\r\n        relative: function (startSitu, _finishSitu) {\r\n          return Situ.getStart(startSitu);\r\n        },\r\n        exact: function (start, _soffset, _finish, _foffset) {\r\n          return start;\r\n        }\r\n      });\r\n    };\r\n    var domRange = adt$5.domRange;\r\n    var relative = adt$5.relative;\r\n    var exact = adt$5.exact;\r\n    var getWin = function (selection) {\r\n      var start = getStart(selection);\r\n      return defaultView(start);\r\n    };\r\n    var range$1 = SimRange.create;\r\n    var SimSelection = {\r\n      domRange: domRange,\r\n      relative: relative,\r\n      exact: exact,\r\n      exactFromRange: exactFromRange,\r\n      getWin: getWin,\r\n      range: range$1\r\n    };\r\n\r\n    var setStart = function (rng, situ) {\r\n      situ.fold(function (e) {\r\n        rng.setStartBefore(e.dom);\r\n      }, function (e, o) {\r\n        rng.setStart(e.dom, o);\r\n      }, function (e) {\r\n        rng.setStartAfter(e.dom);\r\n      });\r\n    };\r\n    var setFinish = function (rng, situ) {\r\n      situ.fold(function (e) {\r\n        rng.setEndBefore(e.dom);\r\n      }, function (e, o) {\r\n        rng.setEnd(e.dom, o);\r\n      }, function (e) {\r\n        rng.setEndAfter(e.dom);\r\n      });\r\n    };\r\n    var relativeToNative = function (win, startSitu, finishSitu) {\r\n      var range = win.document.createRange();\r\n      setStart(range, startSitu);\r\n      setFinish(range, finishSitu);\r\n      return range;\r\n    };\r\n    var exactToNative = function (win, start, soffset, finish, foffset) {\r\n      var rng = win.document.createRange();\r\n      rng.setStart(start.dom, soffset);\r\n      rng.setEnd(finish.dom, foffset);\r\n      return rng;\r\n    };\r\n    var toRect = function (rect) {\r\n      return {\r\n        left: rect.left,\r\n        top: rect.top,\r\n        right: rect.right,\r\n        bottom: rect.bottom,\r\n        width: rect.width,\r\n        height: rect.height\r\n      };\r\n    };\r\n    var getFirstRect$1 = function (rng) {\r\n      var rects = rng.getClientRects();\r\n      var rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();\r\n      return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();\r\n    };\r\n    var getBounds$2 = function (rng) {\r\n      var rect = rng.getBoundingClientRect();\r\n      return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();\r\n    };\r\n\r\n    var adt$4 = Adt.generate([\r\n      {\r\n        ltr: [\r\n          'start',\r\n          'soffset',\r\n          'finish',\r\n          'foffset'\r\n        ]\r\n      },\r\n      {\r\n        rtl: [\r\n          'start',\r\n          'soffset',\r\n          'finish',\r\n          'foffset'\r\n        ]\r\n      }\r\n    ]);\r\n    var fromRange = function (win, type, range) {\r\n      return type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\r\n    };\r\n    var getRanges = function (win, selection) {\r\n      return selection.match({\r\n        domRange: function (rng) {\r\n          return {\r\n            ltr: constant$1(rng),\r\n            rtl: Optional.none\r\n          };\r\n        },\r\n        relative: function (startSitu, finishSitu) {\r\n          return {\r\n            ltr: cached(function () {\r\n              return relativeToNative(win, startSitu, finishSitu);\r\n            }),\r\n            rtl: cached(function () {\r\n              return Optional.some(relativeToNative(win, finishSitu, startSitu));\r\n            })\r\n          };\r\n        },\r\n        exact: function (start, soffset, finish, foffset) {\r\n          return {\r\n            ltr: cached(function () {\r\n              return exactToNative(win, start, soffset, finish, foffset);\r\n            }),\r\n            rtl: cached(function () {\r\n              return Optional.some(exactToNative(win, finish, foffset, start, soffset));\r\n            })\r\n          };\r\n        }\r\n      });\r\n    };\r\n    var doDiagnose = function (win, ranges) {\r\n      var rng = ranges.ltr();\r\n      if (rng.collapsed) {\r\n        var reversed = ranges.rtl().filter(function (rev) {\r\n          return rev.collapsed === false;\r\n        });\r\n        return reversed.map(function (rev) {\r\n          return adt$4.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset);\r\n        }).getOrThunk(function () {\r\n          return fromRange(win, adt$4.ltr, rng);\r\n        });\r\n      } else {\r\n        return fromRange(win, adt$4.ltr, rng);\r\n      }\r\n    };\r\n    var diagnose = function (win, selection) {\r\n      var ranges = getRanges(win, selection);\r\n      return doDiagnose(win, ranges);\r\n    };\r\n    var asLtrRange = function (win, selection) {\r\n      var diagnosis = diagnose(win, selection);\r\n      return diagnosis.match({\r\n        ltr: function (start, soffset, finish, foffset) {\r\n          var rng = win.document.createRange();\r\n          rng.setStart(start.dom, soffset);\r\n          rng.setEnd(finish.dom, foffset);\r\n          return rng;\r\n        },\r\n        rtl: function (start, soffset, finish, foffset) {\r\n          var rng = win.document.createRange();\r\n          rng.setStart(finish.dom, foffset);\r\n          rng.setEnd(start.dom, soffset);\r\n          return rng;\r\n        }\r\n      });\r\n    };\r\n    adt$4.ltr;\r\n    adt$4.rtl;\r\n\r\n    var NodeValue = function (is, name) {\r\n      var get = function (element) {\r\n        if (!is(element)) {\r\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\r\n        }\r\n        return getOption(element).getOr('');\r\n      };\r\n      var getOption = function (element) {\r\n        return is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\r\n      };\r\n      var set = function (element, value) {\r\n        if (!is(element)) {\r\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\r\n        }\r\n        element.dom.nodeValue = value;\r\n      };\r\n      return {\r\n        get: get,\r\n        getOption: getOption,\r\n        set: set\r\n      };\r\n    };\r\n\r\n    var api = NodeValue(isText$1, 'text');\r\n    var get$3 = function (element) {\r\n      return api.get(element);\r\n    };\r\n    var getOption = function (element) {\r\n      return api.getOption(element);\r\n    };\r\n\r\n    var getEnd = function (element) {\r\n      return name$2(element) === 'img' ? 1 : getOption(element).fold(function () {\r\n        return children(element).length;\r\n      }, function (v) {\r\n        return v.length;\r\n      });\r\n    };\r\n    var isTextNodeWithCursorPosition = function (el) {\r\n      return getOption(el).filter(function (text) {\r\n        return text.trim().length !== 0 || text.indexOf(nbsp) > -1;\r\n      }).isSome();\r\n    };\r\n    var elementsWithCursorPosition = [\r\n      'img',\r\n      'br'\r\n    ];\r\n    var isCursorPosition = function (elem) {\r\n      var hasCursorPosition = isTextNodeWithCursorPosition(elem);\r\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name$2(elem));\r\n    };\r\n\r\n    var last$1 = function (element) {\r\n      return descendantRtl(element, isCursorPosition);\r\n    };\r\n    var descendantRtl = function (scope, predicate) {\r\n      var descend = function (element) {\r\n        var children$1 = children(element);\r\n        for (var i = children$1.length - 1; i >= 0; i--) {\r\n          var child = children$1[i];\r\n          if (predicate(child)) {\r\n            return Optional.some(child);\r\n          }\r\n          var res = descend(child);\r\n          if (res.isSome()) {\r\n            return res;\r\n          }\r\n        }\r\n        return Optional.none();\r\n      };\r\n      return descend(scope);\r\n    };\r\n\r\n    var descendants = function (scope, selector) {\r\n      return all$3(selector, scope);\r\n    };\r\n\r\n    var makeRange = function (start, soffset, finish, foffset) {\r\n      var doc = owner$4(start);\r\n      var rng = doc.dom.createRange();\r\n      rng.setStart(start.dom, soffset);\r\n      rng.setEnd(finish.dom, foffset);\r\n      return rng;\r\n    };\r\n    var after = function (start, soffset, finish, foffset) {\r\n      var r = makeRange(start, soffset, finish, foffset);\r\n      var same = eq(start, finish) && soffset === foffset;\r\n      return r.collapsed && !same;\r\n    };\r\n\r\n    var getNativeSelection = function (win) {\r\n      return Optional.from(win.getSelection());\r\n    };\r\n    var readRange = function (selection) {\r\n      if (selection.rangeCount > 0) {\r\n        var firstRng = selection.getRangeAt(0);\r\n        var lastRng = selection.getRangeAt(selection.rangeCount - 1);\r\n        return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var doGetExact = function (selection) {\r\n      if (selection.anchorNode === null || selection.focusNode === null) {\r\n        return readRange(selection);\r\n      } else {\r\n        var anchor = SugarElement.fromDom(selection.anchorNode);\r\n        var focus_1 = SugarElement.fromDom(selection.focusNode);\r\n        return after(anchor, selection.anchorOffset, focus_1, selection.focusOffset) ? Optional.some(SimRange.create(anchor, selection.anchorOffset, focus_1, selection.focusOffset)) : readRange(selection);\r\n      }\r\n    };\r\n    var getExact = function (win) {\r\n      return getNativeSelection(win).filter(function (sel) {\r\n        return sel.rangeCount > 0;\r\n      }).bind(doGetExact);\r\n    };\r\n    var getFirstRect = function (win, selection) {\r\n      var rng = asLtrRange(win, selection);\r\n      return getFirstRect$1(rng);\r\n    };\r\n    var getBounds$1 = function (win, selection) {\r\n      var rng = asLtrRange(win, selection);\r\n      return getBounds$2(rng);\r\n    };\r\n\r\n    var point$1 = function (element, offset) {\r\n      return {\r\n        element: element,\r\n        offset: offset\r\n      };\r\n    };\r\n    var descendOnce$1 = function (element, offset) {\r\n      var children$1 = children(element);\r\n      if (children$1.length === 0) {\r\n        return point$1(element, offset);\r\n      } else if (offset < children$1.length) {\r\n        return point$1(children$1[offset], 0);\r\n      } else {\r\n        var last = children$1[children$1.length - 1];\r\n        var len = isText$1(last) ? get$3(last).length : children(last).length;\r\n        return point$1(last, len);\r\n      }\r\n    };\r\n\r\n    var descendOnce = function (element, offset) {\r\n      return isText$1(element) ? point$1(element, offset) : descendOnce$1(element, offset);\r\n    };\r\n    var getAnchorSelection = function (win, anchorInfo) {\r\n      var getSelection = anchorInfo.getSelection.getOrThunk(function () {\r\n        return function () {\r\n          return getExact(win);\r\n        };\r\n      });\r\n      return getSelection().map(function (sel) {\r\n        var modStart = descendOnce(sel.start, sel.soffset);\r\n        var modFinish = descendOnce(sel.finish, sel.foffset);\r\n        return SimSelection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);\r\n      });\r\n    };\r\n    var placement$1 = function (component, anchorInfo, origin) {\r\n      var win = defaultView(anchorInfo.root).dom;\r\n      var rootPoint = getRootPoint(component, origin, anchorInfo);\r\n      var selectionBox = getAnchorSelection(win, anchorInfo).bind(function (sel) {\r\n        var optRect = getBounds$1(win, SimSelection.exactFromRange(sel)).orThunk(function () {\r\n          var x = SugarElement.fromText(zeroWidth);\r\n          before$2(sel.start, x);\r\n          var rect = getFirstRect(win, SimSelection.exact(x, 0, x, 1));\r\n          remove$5(x);\r\n          return rect;\r\n        });\r\n        return optRect.bind(function (rawRect) {\r\n          return getBox(rawRect.left, rawRect.top, rawRect.width, rawRect.height);\r\n        });\r\n      });\r\n      var targetElement = getAnchorSelection(win, anchorInfo).bind(function (sel) {\r\n        return isElement$2(sel.start) ? Optional.some(sel.start) : parentNode(sel.start);\r\n      });\r\n      var elem = targetElement.getOr(component.element);\r\n      return calcNewAnchor(selectionBox, rootPoint, anchorInfo, origin, elem);\r\n    };\r\n    var SelectionAnchor = [\r\n      option('getSelection'),\r\n      required$1('root'),\r\n      option('bubble'),\r\n      schema$y(),\r\n      defaulted('overrides', {}),\r\n      defaulted('showAbove', false),\r\n      output$1('placement', placement$1)\r\n    ];\r\n\r\n    var labelPrefix$1 = 'link-layout';\r\n    var eastX = function (anchor) {\r\n      return anchor.x + anchor.width;\r\n    };\r\n    var westX = function (anchor, element) {\r\n      return anchor.x - element.width;\r\n    };\r\n    var northY$1 = function (anchor, element) {\r\n      return anchor.y - element.height + anchor.height;\r\n    };\r\n    var southY$1 = function (anchor) {\r\n      return anchor.y;\r\n    };\r\n    var southeast$1 = function (anchor, element, bubbles) {\r\n      return nu$6(eastX(anchor), southY$1(anchor), bubbles.southeast(), southeast$3(), 'southeast', boundsRestriction(anchor, {\r\n        left: 0,\r\n        top: 2\r\n      }), labelPrefix$1);\r\n    };\r\n    var southwest$1 = function (anchor, element, bubbles) {\r\n      return nu$6(westX(anchor, element), southY$1(anchor), bubbles.southwest(), southwest$3(), 'southwest', boundsRestriction(anchor, {\r\n        right: 1,\r\n        top: 2\r\n      }), labelPrefix$1);\r\n    };\r\n    var northeast$1 = function (anchor, element, bubbles) {\r\n      return nu$6(eastX(anchor), northY$1(anchor, element), bubbles.northeast(), northeast$3(), 'northeast', boundsRestriction(anchor, {\r\n        left: 0,\r\n        bottom: 3\r\n      }), labelPrefix$1);\r\n    };\r\n    var northwest$1 = function (anchor, element, bubbles) {\r\n      return nu$6(westX(anchor, element), northY$1(anchor, element), bubbles.northwest(), northwest$3(), 'northwest', boundsRestriction(anchor, {\r\n        right: 1,\r\n        bottom: 3\r\n      }), labelPrefix$1);\r\n    };\r\n    var all = function () {\r\n      return [\r\n        southeast$1,\r\n        southwest$1,\r\n        northeast$1,\r\n        northwest$1\r\n      ];\r\n    };\r\n    var allRtl = function () {\r\n      return [\r\n        southwest$1,\r\n        southeast$1,\r\n        northwest$1,\r\n        northeast$1\r\n      ];\r\n    };\r\n\r\n    var placement = function (component, submenuInfo, origin) {\r\n      var anchorBox = toBox(origin, submenuInfo.item.element);\r\n      var layouts = get$4(component.element, submenuInfo, all(), allRtl(), all(), allRtl(), Optional.none());\r\n      return Optional.some(nu$4({\r\n        anchorBox: anchorBox,\r\n        bubble: fallback(),\r\n        overrides: submenuInfo.overrides,\r\n        layouts: layouts,\r\n        placer: Optional.none()\r\n      }));\r\n    };\r\n    var SubmenuAnchor = [\r\n      required$1('item'),\r\n      schema$y(),\r\n      defaulted('overrides', {}),\r\n      output$1('placement', placement)\r\n    ];\r\n\r\n    var AnchorSchema = choose$1('type', {\r\n      selection: SelectionAnchor,\r\n      node: NodeAnchor,\r\n      hotspot: HotspotAnchor,\r\n      submenu: SubmenuAnchor,\r\n      makeshift: MakeshiftAnchor\r\n    });\r\n\r\n    var TransitionSchema = [\r\n      requiredArrayOf('classes', string),\r\n      defaultedStringEnum('mode', 'all', [\r\n        'all',\r\n        'layout',\r\n        'placement'\r\n      ])\r\n    ];\r\n    var PositionSchema = [\r\n      defaulted('useFixed', never),\r\n      option('getBounds')\r\n    ];\r\n    var PlacementSchema = [\r\n      requiredOf('anchor', AnchorSchema),\r\n      optionObjOf('transition', TransitionSchema)\r\n    ];\r\n\r\n    var getFixedOrigin = function () {\r\n      var html = document.documentElement;\r\n      return fixed$1(0, 0, html.clientWidth, html.clientHeight);\r\n    };\r\n    var getRelativeOrigin = function (component) {\r\n      var position = absolute$3(component.element);\r\n      var bounds = component.element.dom.getBoundingClientRect();\r\n      return relative$1(position.left, position.top, bounds.width, bounds.height);\r\n    };\r\n    var place = function (component, origin, anchoring, getBounds, placee, lastPlace, transition) {\r\n      var anchor = box(anchoring.anchorBox, origin);\r\n      return simple(anchor, placee.element, anchoring.bubble, anchoring.layouts, lastPlace, getBounds, anchoring.overrides, transition);\r\n    };\r\n    var position$1 = function (component, posConfig, posState, placee, placementSpec) {\r\n      positionWithin(component, posConfig, posState, placee, placementSpec, Optional.none());\r\n    };\r\n    var positionWithin = function (component, posConfig, posState, placee, placementSpec, boxElement) {\r\n      var boundsBox = boxElement.map(box$1);\r\n      return positionWithinBounds(component, posConfig, posState, placee, placementSpec, boundsBox);\r\n    };\r\n    var positionWithinBounds = function (component, posConfig, posState, placee, placementSpec, bounds) {\r\n      var placeeDetail = asRawOrDie$1('placement.info', objOf(PlacementSchema), placementSpec);\r\n      var anchorage = placeeDetail.anchor;\r\n      var element = placee.element;\r\n      var placeeState = posState.get(placee.uid);\r\n      preserve$1(function () {\r\n        set$7(element, 'position', 'fixed');\r\n        var oldVisibility = getRaw(element, 'visibility');\r\n        set$7(element, 'visibility', 'hidden');\r\n        var origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);\r\n        var placer = anchorage.placement;\r\n        var getBounds = bounds.map(constant$1).or(posConfig.getBounds);\r\n        placer(component, anchorage, origin).each(function (anchoring) {\r\n          var doPlace = anchoring.placer.getOr(place);\r\n          var newState = doPlace(component, origin, anchoring, getBounds, placee, placeeState, placeeDetail.transition);\r\n          posState.set(placee.uid, newState);\r\n        });\r\n        oldVisibility.fold(function () {\r\n          remove$6(element, 'visibility');\r\n        }, function (vis) {\r\n          set$7(element, 'visibility', vis);\r\n        });\r\n        if (getRaw(element, 'left').isNone() && getRaw(element, 'top').isNone() && getRaw(element, 'right').isNone() && getRaw(element, 'bottom').isNone() && is$1(getRaw(element, 'position'), 'fixed')) {\r\n          remove$6(element, 'position');\r\n        }\r\n      }, element);\r\n    };\r\n    var getMode = function (component, pConfig, _pState) {\r\n      return pConfig.useFixed() ? 'fixed' : 'absolute';\r\n    };\r\n    var reset$1 = function (component, pConfig, posState, placee) {\r\n      var element = placee.element;\r\n      each$1([\r\n        'position',\r\n        'left',\r\n        'right',\r\n        'top',\r\n        'bottom'\r\n      ], function (prop) {\r\n        return remove$6(element, prop);\r\n      });\r\n      reset$2(element);\r\n      posState.clear(placee.uid);\r\n    };\r\n\r\n    var PositionApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        position: position$1,\r\n        positionWithin: positionWithin,\r\n        positionWithinBounds: positionWithinBounds,\r\n        getMode: getMode,\r\n        reset: reset$1\r\n    });\r\n\r\n    var init$g = function () {\r\n      var state = {};\r\n      var set = function (id, data) {\r\n        state[id] = data;\r\n      };\r\n      var get = function (id) {\r\n        return get$e(state, id);\r\n      };\r\n      var clear = function (id) {\r\n        if (isNonNullable(id)) {\r\n          delete state[id];\r\n        } else {\r\n          state = {};\r\n        }\r\n      };\r\n      return nu$8({\r\n        readState: function () {\r\n          return state;\r\n        },\r\n        clear: clear,\r\n        set: set,\r\n        get: get\r\n      });\r\n    };\r\n\r\n    var PositioningState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        init: init$g\r\n    });\r\n\r\n    var Positioning = create$8({\r\n      fields: PositionSchema,\r\n      name: 'positioning',\r\n      active: ActivePosition,\r\n      apis: PositionApis,\r\n      state: PositioningState\r\n    });\r\n\r\n    var fireDetaching = function (component) {\r\n      emit(component, detachedFromDom());\r\n      var children = component.components();\r\n      each$1(children, fireDetaching);\r\n    };\r\n    var fireAttaching = function (component) {\r\n      var children = component.components();\r\n      each$1(children, fireAttaching);\r\n      emit(component, attachedToDom());\r\n    };\r\n    var attach$1 = function (parent, child) {\r\n      append$2(parent.element, child.element);\r\n    };\r\n    var detachChildren$1 = function (component) {\r\n      each$1(component.components(), function (childComp) {\r\n        return remove$5(childComp.element);\r\n      });\r\n      empty(component.element);\r\n      component.syncComponents();\r\n    };\r\n    var replaceChildren = function (component, newChildren) {\r\n      var subs = component.components();\r\n      detachChildren$1(component);\r\n      var deleted = difference(subs, newChildren);\r\n      each$1(deleted, function (comp) {\r\n        fireDetaching(comp);\r\n        component.getSystem().removeFromWorld(comp);\r\n      });\r\n      each$1(newChildren, function (childComp) {\r\n        if (!childComp.getSystem().isConnected()) {\r\n          component.getSystem().addToWorld(childComp);\r\n          attach$1(component, childComp);\r\n          if (inBody(component.element)) {\r\n            fireAttaching(childComp);\r\n          }\r\n        } else {\r\n          attach$1(component, childComp);\r\n        }\r\n        component.syncComponents();\r\n      });\r\n    };\r\n\r\n    var attach = function (parent, child) {\r\n      attachWith(parent, child, append$2);\r\n    };\r\n    var attachWith = function (parent, child, insertion) {\r\n      parent.getSystem().addToWorld(child);\r\n      insertion(parent.element, child.element);\r\n      if (inBody(parent.element)) {\r\n        fireAttaching(child);\r\n      }\r\n      parent.syncComponents();\r\n    };\r\n    var doDetach = function (component) {\r\n      fireDetaching(component);\r\n      remove$5(component.element);\r\n      component.getSystem().removeFromWorld(component);\r\n    };\r\n    var detach = function (component) {\r\n      var parent$1 = parent(component.element).bind(function (p) {\r\n        return component.getSystem().getByDom(p).toOptional();\r\n      });\r\n      doDetach(component);\r\n      parent$1.each(function (p) {\r\n        p.syncComponents();\r\n      });\r\n    };\r\n    var detachChildren = function (component) {\r\n      var subs = component.components();\r\n      each$1(subs, doDetach);\r\n      empty(component.element);\r\n      component.syncComponents();\r\n    };\r\n    var attachSystem = function (element, guiSystem) {\r\n      attachSystemWith(element, guiSystem, append$2);\r\n    };\r\n    var attachSystemAfter = function (element, guiSystem) {\r\n      attachSystemWith(element, guiSystem, after$2);\r\n    };\r\n    var attachSystemWith = function (element, guiSystem, inserter) {\r\n      inserter(element, guiSystem.element);\r\n      var children$1 = children(guiSystem.element);\r\n      each$1(children$1, function (child) {\r\n        guiSystem.getByDom(child).each(fireAttaching);\r\n      });\r\n    };\r\n    var detachSystem = function (guiSystem) {\r\n      var children$1 = children(guiSystem.element);\r\n      each$1(children$1, function (child) {\r\n        guiSystem.getByDom(child).each(fireDetaching);\r\n      });\r\n      remove$5(guiSystem.element);\r\n    };\r\n\r\n    var rebuild = function (sandbox, sConfig, sState, data) {\r\n      sState.get().each(function (_data) {\r\n        detachChildren(sandbox);\r\n      });\r\n      var point = sConfig.getAttachPoint(sandbox);\r\n      attach(point, sandbox);\r\n      var built = sandbox.getSystem().build(data);\r\n      attach(sandbox, built);\r\n      sState.set(built);\r\n      return built;\r\n    };\r\n    var open$1 = function (sandbox, sConfig, sState, data) {\r\n      var newState = rebuild(sandbox, sConfig, sState, data);\r\n      sConfig.onOpen(sandbox, newState);\r\n      return newState;\r\n    };\r\n    var setContent = function (sandbox, sConfig, sState, data) {\r\n      return sState.get().map(function () {\r\n        return rebuild(sandbox, sConfig, sState, data);\r\n      });\r\n    };\r\n    var openWhileCloaked = function (sandbox, sConfig, sState, data, transaction) {\r\n      cloak(sandbox, sConfig);\r\n      open$1(sandbox, sConfig, sState, data);\r\n      transaction();\r\n      decloak(sandbox, sConfig);\r\n    };\r\n    var close$1 = function (sandbox, sConfig, sState) {\r\n      sState.get().each(function (data) {\r\n        detachChildren(sandbox);\r\n        detach(sandbox);\r\n        sConfig.onClose(sandbox, data);\r\n        sState.clear();\r\n      });\r\n    };\r\n    var isOpen$1 = function (_sandbox, _sConfig, sState) {\r\n      return sState.isOpen();\r\n    };\r\n    var isPartOf = function (sandbox, sConfig, sState, queryElem) {\r\n      return isOpen$1(sandbox, sConfig, sState) && sState.get().exists(function (data) {\r\n        return sConfig.isPartOf(sandbox, data, queryElem);\r\n      });\r\n    };\r\n    var getState$2 = function (_sandbox, _sConfig, sState) {\r\n      return sState.get();\r\n    };\r\n    var store = function (sandbox, cssKey, attr, newValue) {\r\n      getRaw(sandbox.element, cssKey).fold(function () {\r\n        remove$7(sandbox.element, attr);\r\n      }, function (v) {\r\n        set$8(sandbox.element, attr, v);\r\n      });\r\n      set$7(sandbox.element, cssKey, newValue);\r\n    };\r\n    var restore = function (sandbox, cssKey, attr) {\r\n      getOpt(sandbox.element, attr).fold(function () {\r\n        return remove$6(sandbox.element, cssKey);\r\n      }, function (oldValue) {\r\n        return set$7(sandbox.element, cssKey, oldValue);\r\n      });\r\n    };\r\n    var cloak = function (sandbox, sConfig, _sState) {\r\n      var sink = sConfig.getAttachPoint(sandbox);\r\n      set$7(sandbox.element, 'position', Positioning.getMode(sink));\r\n      store(sandbox, 'visibility', sConfig.cloakVisibilityAttr, 'hidden');\r\n    };\r\n    var hasPosition = function (element) {\r\n      return exists([\r\n        'top',\r\n        'left',\r\n        'right',\r\n        'bottom'\r\n      ], function (pos) {\r\n        return getRaw(element, pos).isSome();\r\n      });\r\n    };\r\n    var decloak = function (sandbox, sConfig, _sState) {\r\n      if (!hasPosition(sandbox.element)) {\r\n        remove$6(sandbox.element, 'position');\r\n      }\r\n      restore(sandbox, 'visibility', sConfig.cloakVisibilityAttr);\r\n    };\r\n\r\n    var SandboxApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        cloak: cloak,\r\n        decloak: decloak,\r\n        open: open$1,\r\n        openWhileCloaked: openWhileCloaked,\r\n        close: close$1,\r\n        isOpen: isOpen$1,\r\n        isPartOf: isPartOf,\r\n        getState: getState$2,\r\n        setContent: setContent\r\n    });\r\n\r\n    var events$g = function (sandboxConfig, sandboxState) {\r\n      return derive$2([run$1(sandboxClose(), function (sandbox, _simulatedEvent) {\r\n          close$1(sandbox, sandboxConfig, sandboxState);\r\n        })]);\r\n    };\r\n\r\n    var ActiveSandbox = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        events: events$g\r\n    });\r\n\r\n    var SandboxSchema = [\r\n      onHandler('onOpen'),\r\n      onHandler('onClose'),\r\n      required$1('isPartOf'),\r\n      required$1('getAttachPoint'),\r\n      defaulted('cloakVisibilityAttr', 'data-precloak-visibility')\r\n    ];\r\n\r\n    var init$f = function () {\r\n      var contents = value$1();\r\n      var readState = constant$1('not-implemented');\r\n      return nu$8({\r\n        readState: readState,\r\n        isOpen: contents.isSet,\r\n        clear: contents.clear,\r\n        set: contents.set,\r\n        get: contents.get\r\n      });\r\n    };\r\n\r\n    var SandboxState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        init: init$f\r\n    });\r\n\r\n    var Sandboxing = create$8({\r\n      fields: SandboxSchema,\r\n      name: 'sandboxing',\r\n      active: ActiveSandbox,\r\n      apis: SandboxApis,\r\n      state: SandboxState\r\n    });\r\n\r\n    var dismissPopups = constant$1('dismiss.popups');\r\n    var repositionPopups = constant$1('reposition.popups');\r\n    var mouseReleased = constant$1('mouse.released');\r\n\r\n    var schema$x = objOfOnly([\r\n      defaulted('isExtraPart', never),\r\n      optionObjOf('fireEventInstead', [defaulted('event', dismissRequested())])\r\n    ]);\r\n    var receivingChannel$1 = function (rawSpec) {\r\n      var _a;\r\n      var detail = asRawOrDie$1('Dismissal', schema$x, rawSpec);\r\n      return _a = {}, _a[dismissPopups()] = {\r\n        schema: objOfOnly([required$1('target')]),\r\n        onReceive: function (sandbox, data) {\r\n          if (Sandboxing.isOpen(sandbox)) {\r\n            var isPart = Sandboxing.isPartOf(sandbox, data.target) || detail.isExtraPart(sandbox, data.target);\r\n            if (!isPart) {\r\n              detail.fireEventInstead.fold(function () {\r\n                return Sandboxing.close(sandbox);\r\n              }, function (fe) {\r\n                return emit(sandbox, fe.event);\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }, _a;\r\n    };\r\n\r\n    var schema$w = objOfOnly([\r\n      optionObjOf('fireEventInstead', [defaulted('event', repositionRequested())]),\r\n      requiredFunction('doReposition')\r\n    ]);\r\n    var receivingChannel = function (rawSpec) {\r\n      var _a;\r\n      var detail = asRawOrDie$1('Reposition', schema$w, rawSpec);\r\n      return _a = {}, _a[repositionPopups()] = {\r\n        onReceive: function (sandbox) {\r\n          if (Sandboxing.isOpen(sandbox)) {\r\n            detail.fireEventInstead.fold(function () {\r\n              return detail.doReposition(sandbox);\r\n            }, function (fe) {\r\n              return emit(sandbox, fe.event);\r\n            });\r\n          }\r\n        }\r\n      }, _a;\r\n    };\r\n\r\n    var onLoad$5 = function (component, repConfig, repState) {\r\n      repConfig.store.manager.onLoad(component, repConfig, repState);\r\n    };\r\n    var onUnload$2 = function (component, repConfig, repState) {\r\n      repConfig.store.manager.onUnload(component, repConfig, repState);\r\n    };\r\n    var setValue$3 = function (component, repConfig, repState, data) {\r\n      repConfig.store.manager.setValue(component, repConfig, repState, data);\r\n    };\r\n    var getValue$3 = function (component, repConfig, repState) {\r\n      return repConfig.store.manager.getValue(component, repConfig, repState);\r\n    };\r\n    var getState$1 = function (component, repConfig, repState) {\r\n      return repState;\r\n    };\r\n\r\n    var RepresentApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        onLoad: onLoad$5,\r\n        onUnload: onUnload$2,\r\n        setValue: setValue$3,\r\n        getValue: getValue$3,\r\n        getState: getState$1\r\n    });\r\n\r\n    var events$f = function (repConfig, repState) {\r\n      var es = repConfig.resetOnDom ? [\r\n        runOnAttached(function (comp, _se) {\r\n          onLoad$5(comp, repConfig, repState);\r\n        }),\r\n        runOnDetached(function (comp, _se) {\r\n          onUnload$2(comp, repConfig, repState);\r\n        })\r\n      ] : [loadEvent(repConfig, repState, onLoad$5)];\r\n      return derive$2(es);\r\n    };\r\n\r\n    var ActiveRepresenting = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        events: events$f\r\n    });\r\n\r\n    var memory$1 = function () {\r\n      var data = Cell(null);\r\n      var readState = function () {\r\n        return {\r\n          mode: 'memory',\r\n          value: data.get()\r\n        };\r\n      };\r\n      var isNotSet = function () {\r\n        return data.get() === null;\r\n      };\r\n      var clear = function () {\r\n        data.set(null);\r\n      };\r\n      return nu$8({\r\n        set: data.set,\r\n        get: data.get,\r\n        isNotSet: isNotSet,\r\n        clear: clear,\r\n        readState: readState\r\n      });\r\n    };\r\n    var manual = function () {\r\n      var readState = noop;\r\n      return nu$8({ readState: readState });\r\n    };\r\n    var dataset = function () {\r\n      var dataByValue = Cell({});\r\n      var dataByText = Cell({});\r\n      var readState = function () {\r\n        return {\r\n          mode: 'dataset',\r\n          dataByValue: dataByValue.get(),\r\n          dataByText: dataByText.get()\r\n        };\r\n      };\r\n      var clear = function () {\r\n        dataByValue.set({});\r\n        dataByText.set({});\r\n      };\r\n      var lookup = function (itemString) {\r\n        return get$e(dataByValue.get(), itemString).orThunk(function () {\r\n          return get$e(dataByText.get(), itemString);\r\n        });\r\n      };\r\n      var update = function (items) {\r\n        var currentDataByValue = dataByValue.get();\r\n        var currentDataByText = dataByText.get();\r\n        var newDataByValue = {};\r\n        var newDataByText = {};\r\n        each$1(items, function (item) {\r\n          newDataByValue[item.value] = item;\r\n          get$e(item, 'meta').each(function (meta) {\r\n            get$e(meta, 'text').each(function (text) {\r\n              newDataByText[text] = item;\r\n            });\r\n          });\r\n        });\r\n        dataByValue.set(__assign(__assign({}, currentDataByValue), newDataByValue));\r\n        dataByText.set(__assign(__assign({}, currentDataByText), newDataByText));\r\n      };\r\n      return nu$8({\r\n        readState: readState,\r\n        lookup: lookup,\r\n        update: update,\r\n        clear: clear\r\n      });\r\n    };\r\n    var init$e = function (spec) {\r\n      return spec.store.manager.state(spec);\r\n    };\r\n\r\n    var RepresentState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        memory: memory$1,\r\n        dataset: dataset,\r\n        manual: manual,\r\n        init: init$e\r\n    });\r\n\r\n    var setValue$2 = function (component, repConfig, repState, data) {\r\n      var store = repConfig.store;\r\n      repState.update([data]);\r\n      store.setValue(component, data);\r\n      repConfig.onSetValue(component, data);\r\n    };\r\n    var getValue$2 = function (component, repConfig, repState) {\r\n      var store = repConfig.store;\r\n      var key = store.getDataKey(component);\r\n      return repState.lookup(key).getOrThunk(function () {\r\n        return store.getFallbackEntry(key);\r\n      });\r\n    };\r\n    var onLoad$4 = function (component, repConfig, repState) {\r\n      var store = repConfig.store;\r\n      store.initialValue.each(function (data) {\r\n        setValue$2(component, repConfig, repState, data);\r\n      });\r\n    };\r\n    var onUnload$1 = function (component, repConfig, repState) {\r\n      repState.clear();\r\n    };\r\n    var DatasetStore = [\r\n      option('initialValue'),\r\n      required$1('getFallbackEntry'),\r\n      required$1('getDataKey'),\r\n      required$1('setValue'),\r\n      output$1('manager', {\r\n        setValue: setValue$2,\r\n        getValue: getValue$2,\r\n        onLoad: onLoad$4,\r\n        onUnload: onUnload$1,\r\n        state: dataset\r\n      })\r\n    ];\r\n\r\n    var getValue$1 = function (component, repConfig, _repState) {\r\n      return repConfig.store.getValue(component);\r\n    };\r\n    var setValue$1 = function (component, repConfig, _repState, data) {\r\n      repConfig.store.setValue(component, data);\r\n      repConfig.onSetValue(component, data);\r\n    };\r\n    var onLoad$3 = function (component, repConfig, _repState) {\r\n      repConfig.store.initialValue.each(function (data) {\r\n        repConfig.store.setValue(component, data);\r\n      });\r\n    };\r\n    var ManualStore = [\r\n      required$1('getValue'),\r\n      defaulted('setValue', noop),\r\n      option('initialValue'),\r\n      output$1('manager', {\r\n        setValue: setValue$1,\r\n        getValue: getValue$1,\r\n        onLoad: onLoad$3,\r\n        onUnload: noop,\r\n        state: NoState.init\r\n      })\r\n    ];\r\n\r\n    var setValue = function (component, repConfig, repState, data) {\r\n      repState.set(data);\r\n      repConfig.onSetValue(component, data);\r\n    };\r\n    var getValue = function (component, repConfig, repState) {\r\n      return repState.get();\r\n    };\r\n    var onLoad$2 = function (component, repConfig, repState) {\r\n      repConfig.store.initialValue.each(function (initVal) {\r\n        if (repState.isNotSet()) {\r\n          repState.set(initVal);\r\n        }\r\n      });\r\n    };\r\n    var onUnload = function (component, repConfig, repState) {\r\n      repState.clear();\r\n    };\r\n    var MemoryStore = [\r\n      option('initialValue'),\r\n      output$1('manager', {\r\n        setValue: setValue,\r\n        getValue: getValue,\r\n        onLoad: onLoad$2,\r\n        onUnload: onUnload,\r\n        state: memory$1\r\n      })\r\n    ];\r\n\r\n    var RepresentSchema = [\r\n      defaultedOf('store', { mode: 'memory' }, choose$1('mode', {\r\n        memory: MemoryStore,\r\n        manual: ManualStore,\r\n        dataset: DatasetStore\r\n      })),\r\n      onHandler('onSetValue'),\r\n      defaulted('resetOnDom', false)\r\n    ];\r\n\r\n    var Representing = create$8({\r\n      fields: RepresentSchema,\r\n      name: 'representing',\r\n      active: ActiveRepresenting,\r\n      apis: RepresentApis,\r\n      extra: {\r\n        setValueFrom: function (component, source) {\r\n          var value = Representing.getValue(source);\r\n          Representing.setValue(component, value);\r\n        }\r\n      },\r\n      state: RepresentState\r\n    });\r\n\r\n    var field = function (name, forbidden) {\r\n      return defaultedObjOf(name, {}, map$2(forbidden, function (f) {\r\n        return forbid(f.name(), 'Cannot configure ' + f.name() + ' for ' + name);\r\n      }).concat([customField('dump', identity$1)]));\r\n    };\r\n    var get$2 = function (data) {\r\n      return data.dump;\r\n    };\r\n    var augment = function (data, original) {\r\n      return __assign(__assign({}, derive$1(original)), data.dump);\r\n    };\r\n    var SketchBehaviours = {\r\n      field: field,\r\n      augment: augment,\r\n      get: get$2\r\n    };\r\n\r\n    var _placeholder = 'placeholder';\r\n    var adt$3 = Adt.generate([\r\n      {\r\n        single: [\r\n          'required',\r\n          'valueThunk'\r\n        ]\r\n      },\r\n      {\r\n        multiple: [\r\n          'required',\r\n          'valueThunks'\r\n        ]\r\n      }\r\n    ]);\r\n    var isSubstituted = function (spec) {\r\n      return has$2(spec, 'uiType');\r\n    };\r\n    var subPlaceholder = function (owner, detail, compSpec, placeholders) {\r\n      if (owner.exists(function (o) {\r\n          return o !== compSpec.owner;\r\n        })) {\r\n        return adt$3.single(true, constant$1(compSpec));\r\n      }\r\n      return get$e(placeholders, compSpec.name).fold(function () {\r\n        throw new Error('Unknown placeholder component: ' + compSpec.name + '\\nKnown: [' + keys(placeholders) + ']\\nNamespace: ' + owner.getOr('none') + '\\nSpec: ' + JSON.stringify(compSpec, null, 2));\r\n      }, function (newSpec) {\r\n        return newSpec.replace();\r\n      });\r\n    };\r\n    var scan = function (owner, detail, compSpec, placeholders) {\r\n      if (isSubstituted(compSpec) && compSpec.uiType === _placeholder) {\r\n        return subPlaceholder(owner, detail, compSpec, placeholders);\r\n      } else {\r\n        return adt$3.single(false, constant$1(compSpec));\r\n      }\r\n    };\r\n    var substitute = function (owner, detail, compSpec, placeholders) {\r\n      var base = scan(owner, detail, compSpec, placeholders);\r\n      return base.fold(function (req, valueThunk) {\r\n        var value = isSubstituted(compSpec) ? valueThunk(detail, compSpec.config, compSpec.validated) : valueThunk(detail);\r\n        var childSpecs = get$e(value, 'components').getOr([]);\r\n        var substituted = bind$3(childSpecs, function (c) {\r\n          return substitute(owner, detail, c, placeholders);\r\n        });\r\n        return [__assign(__assign({}, value), { components: substituted })];\r\n      }, function (req, valuesThunk) {\r\n        if (isSubstituted(compSpec)) {\r\n          var values = valuesThunk(detail, compSpec.config, compSpec.validated);\r\n          var preprocessor = compSpec.validated.preprocess.getOr(identity$1);\r\n          return preprocessor(values);\r\n        } else {\r\n          return valuesThunk(detail);\r\n        }\r\n      });\r\n    };\r\n    var substituteAll = function (owner, detail, components, placeholders) {\r\n      return bind$3(components, function (c) {\r\n        return substitute(owner, detail, c, placeholders);\r\n      });\r\n    };\r\n    var oneReplace = function (label, replacements) {\r\n      var called = false;\r\n      var used = function () {\r\n        return called;\r\n      };\r\n      var replace = function () {\r\n        if (called) {\r\n          throw new Error('Trying to use the same placeholder more than once: ' + label);\r\n        }\r\n        called = true;\r\n        return replacements;\r\n      };\r\n      var required = function () {\r\n        return replacements.fold(function (req, _) {\r\n          return req;\r\n        }, function (req, _) {\r\n          return req;\r\n        });\r\n      };\r\n      return {\r\n        name: constant$1(label),\r\n        required: required,\r\n        used: used,\r\n        replace: replace\r\n      };\r\n    };\r\n    var substitutePlaces = function (owner, detail, components, placeholders) {\r\n      var ps = map$1(placeholders, function (ph, name) {\r\n        return oneReplace(name, ph);\r\n      });\r\n      var outcome = substituteAll(owner, detail, components, ps);\r\n      each(ps, function (p) {\r\n        if (p.used() === false && p.required()) {\r\n          throw new Error('Placeholder: ' + p.name() + ' was not found in components list\\nNamespace: ' + owner.getOr('none') + '\\nComponents: ' + JSON.stringify(detail.components, null, 2));\r\n        }\r\n      });\r\n      return outcome;\r\n    };\r\n    var single$2 = adt$3.single;\r\n    var multiple = adt$3.multiple;\r\n    var placeholder = constant$1(_placeholder);\r\n\r\n    var adt$2 = Adt.generate([\r\n      { required: ['data'] },\r\n      { external: ['data'] },\r\n      { optional: ['data'] },\r\n      { group: ['data'] }\r\n    ]);\r\n    var fFactory = defaulted('factory', { sketch: identity$1 });\r\n    var fSchema = defaulted('schema', []);\r\n    var fName = required$1('name');\r\n    var fPname = field$1('pname', 'pname', defaultedThunk(function (typeSpec) {\r\n      return '<alloy.' + generate$6(typeSpec.name) + '>';\r\n    }), anyValue());\r\n    var fGroupSchema = customField('schema', function () {\r\n      return [option('preprocess')];\r\n    });\r\n    var fDefaults = defaulted('defaults', constant$1({}));\r\n    var fOverrides = defaulted('overrides', constant$1({}));\r\n    var requiredSpec = objOf([\r\n      fFactory,\r\n      fSchema,\r\n      fName,\r\n      fPname,\r\n      fDefaults,\r\n      fOverrides\r\n    ]);\r\n    var externalSpec = objOf([\r\n      fFactory,\r\n      fSchema,\r\n      fName,\r\n      fDefaults,\r\n      fOverrides\r\n    ]);\r\n    var optionalSpec = objOf([\r\n      fFactory,\r\n      fSchema,\r\n      fName,\r\n      fPname,\r\n      fDefaults,\r\n      fOverrides\r\n    ]);\r\n    var groupSpec = objOf([\r\n      fFactory,\r\n      fGroupSchema,\r\n      fName,\r\n      required$1('unit'),\r\n      fPname,\r\n      fDefaults,\r\n      fOverrides\r\n    ]);\r\n    var asNamedPart = function (part) {\r\n      return part.fold(Optional.some, Optional.none, Optional.some, Optional.some);\r\n    };\r\n    var name$1 = function (part) {\r\n      var get = function (data) {\r\n        return data.name;\r\n      };\r\n      return part.fold(get, get, get, get);\r\n    };\r\n    var asCommon = function (part) {\r\n      return part.fold(identity$1, identity$1, identity$1, identity$1);\r\n    };\r\n    var convert = function (adtConstructor, partSchema) {\r\n      return function (spec) {\r\n        var data = asRawOrDie$1('Converting part type', partSchema, spec);\r\n        return adtConstructor(data);\r\n      };\r\n    };\r\n    var required = convert(adt$2.required, requiredSpec);\r\n    var external$1 = convert(adt$2.external, externalSpec);\r\n    var optional = convert(adt$2.optional, optionalSpec);\r\n    var group = convert(adt$2.group, groupSpec);\r\n    var original = constant$1('entirety');\r\n\r\n    var PartType = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        required: required,\r\n        external: external$1,\r\n        optional: optional,\r\n        group: group,\r\n        asNamedPart: asNamedPart,\r\n        name: name$1,\r\n        asCommon: asCommon,\r\n        original: original\r\n    });\r\n\r\n    var combine = function (detail, data, partSpec, partValidated) {\r\n      return deepMerge(data.defaults(detail, partSpec, partValidated), partSpec, { uid: detail.partUids[data.name] }, data.overrides(detail, partSpec, partValidated));\r\n    };\r\n    var subs = function (owner, detail, parts) {\r\n      var internals = {};\r\n      var externals = {};\r\n      each$1(parts, function (part) {\r\n        part.fold(function (data) {\r\n          internals[data.pname] = single$2(true, function (detail, partSpec, partValidated) {\r\n            return data.factory.sketch(combine(detail, data, partSpec, partValidated));\r\n          });\r\n        }, function (data) {\r\n          var partSpec = detail.parts[data.name];\r\n          externals[data.name] = constant$1(data.factory.sketch(combine(detail, data, partSpec[original()]), partSpec));\r\n        }, function (data) {\r\n          internals[data.pname] = single$2(false, function (detail, partSpec, partValidated) {\r\n            return data.factory.sketch(combine(detail, data, partSpec, partValidated));\r\n          });\r\n        }, function (data) {\r\n          internals[data.pname] = multiple(true, function (detail, _partSpec, _partValidated) {\r\n            var units = detail[data.name];\r\n            return map$2(units, function (u) {\r\n              return data.factory.sketch(deepMerge(data.defaults(detail, u, _partValidated), u, data.overrides(detail, u)));\r\n            });\r\n          });\r\n        });\r\n      });\r\n      return {\r\n        internals: constant$1(internals),\r\n        externals: constant$1(externals)\r\n      };\r\n    };\r\n\r\n    var generate$3 = function (owner, parts) {\r\n      var r = {};\r\n      each$1(parts, function (part) {\r\n        asNamedPart(part).each(function (np) {\r\n          var g = doGenerateOne(owner, np.pname);\r\n          r[np.name] = function (config) {\r\n            var validated = asRawOrDie$1('Part: ' + np.name + ' in ' + owner, objOf(np.schema), config);\r\n            return __assign(__assign({}, g), {\r\n              config: config,\r\n              validated: validated\r\n            });\r\n          };\r\n        });\r\n      });\r\n      return r;\r\n    };\r\n    var doGenerateOne = function (owner, pname) {\r\n      return {\r\n        uiType: placeholder(),\r\n        owner: owner,\r\n        name: pname\r\n      };\r\n    };\r\n    var generateOne$1 = function (owner, pname, config) {\r\n      return {\r\n        uiType: placeholder(),\r\n        owner: owner,\r\n        name: pname,\r\n        config: config,\r\n        validated: {}\r\n      };\r\n    };\r\n    var schemas = function (parts) {\r\n      return bind$3(parts, function (part) {\r\n        return part.fold(Optional.none, Optional.some, Optional.none, Optional.none).map(function (data) {\r\n          return requiredObjOf(data.name, data.schema.concat([snapshot(original())]));\r\n        }).toArray();\r\n      });\r\n    };\r\n    var names = function (parts) {\r\n      return map$2(parts, name$1);\r\n    };\r\n    var substitutes = function (owner, detail, parts) {\r\n      return subs(owner, detail, parts);\r\n    };\r\n    var components$1 = function (owner, detail, internals) {\r\n      return substitutePlaces(Optional.some(owner), detail, detail.components, internals);\r\n    };\r\n    var getPart = function (component, detail, partKey) {\r\n      var uid = detail.partUids[partKey];\r\n      return component.getSystem().getByUid(uid).toOptional();\r\n    };\r\n    var getPartOrDie = function (component, detail, partKey) {\r\n      return getPart(component, detail, partKey).getOrDie('Could not find part: ' + partKey);\r\n    };\r\n    var getParts = function (component, detail, partKeys) {\r\n      var r = {};\r\n      var uids = detail.partUids;\r\n      var system = component.getSystem();\r\n      each$1(partKeys, function (pk) {\r\n        r[pk] = constant$1(system.getByUid(uids[pk]));\r\n      });\r\n      return r;\r\n    };\r\n    var getAllParts = function (component, detail) {\r\n      var system = component.getSystem();\r\n      return map$1(detail.partUids, function (pUid, _k) {\r\n        return constant$1(system.getByUid(pUid));\r\n      });\r\n    };\r\n    var getAllPartNames = function (detail) {\r\n      return keys(detail.partUids);\r\n    };\r\n    var getPartsOrDie = function (component, detail, partKeys) {\r\n      var r = {};\r\n      var uids = detail.partUids;\r\n      var system = component.getSystem();\r\n      each$1(partKeys, function (pk) {\r\n        r[pk] = constant$1(system.getByUid(uids[pk]).getOrDie());\r\n      });\r\n      return r;\r\n    };\r\n    var defaultUids = function (baseUid, partTypes) {\r\n      var partNames = names(partTypes);\r\n      return wrapAll(map$2(partNames, function (pn) {\r\n        return {\r\n          key: pn,\r\n          value: baseUid + '-' + pn\r\n        };\r\n      }));\r\n    };\r\n    var defaultUidsSchema = function (partTypes) {\r\n      return field$1('partUids', 'partUids', mergeWithThunk(function (spec) {\r\n        return defaultUids(spec.uid, partTypes);\r\n      }), anyValue());\r\n    };\r\n\r\n    var AlloyParts = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        generate: generate$3,\r\n        generateOne: generateOne$1,\r\n        schemas: schemas,\r\n        names: names,\r\n        substitutes: substitutes,\r\n        components: components$1,\r\n        defaultUids: defaultUids,\r\n        defaultUidsSchema: defaultUidsSchema,\r\n        getAllParts: getAllParts,\r\n        getAllPartNames: getAllPartNames,\r\n        getPart: getPart,\r\n        getPartOrDie: getPartOrDie,\r\n        getParts: getParts,\r\n        getPartsOrDie: getPartsOrDie\r\n    });\r\n\r\n    var base = function (partSchemas, partUidsSchemas) {\r\n      var ps = partSchemas.length > 0 ? [requiredObjOf('parts', partSchemas)] : [];\r\n      return ps.concat([\r\n        required$1('uid'),\r\n        defaulted('dom', {}),\r\n        defaulted('components', []),\r\n        snapshot('originalSpec'),\r\n        defaulted('debug.sketcher', {})\r\n      ]).concat(partUidsSchemas);\r\n    };\r\n    var asRawOrDie = function (label, schema, spec, partSchemas, partUidsSchemas) {\r\n      var baseS = base(partSchemas, partUidsSchemas);\r\n      return asRawOrDie$1(label + ' [SpecSchema]', objOfOnly(baseS.concat(schema)), spec);\r\n    };\r\n\r\n    var single$1 = function (owner, schema, factory, spec) {\r\n      var specWithUid = supplyUid(spec);\r\n      var detail = asRawOrDie(owner, schema, specWithUid, [], []);\r\n      return factory(detail, specWithUid);\r\n    };\r\n    var composite$1 = function (owner, schema, partTypes, factory, spec) {\r\n      var specWithUid = supplyUid(spec);\r\n      var partSchemas = schemas(partTypes);\r\n      var partUidsSchema = defaultUidsSchema(partTypes);\r\n      var detail = asRawOrDie(owner, schema, specWithUid, partSchemas, [partUidsSchema]);\r\n      var subs = substitutes(owner, detail, partTypes);\r\n      var components = components$1(owner, detail, subs.internals());\r\n      return factory(detail, components, specWithUid, subs.externals());\r\n    };\r\n    var hasUid = function (spec) {\r\n      return has$2(spec, 'uid');\r\n    };\r\n    var supplyUid = function (spec) {\r\n      return hasUid(spec) ? spec : __assign(__assign({}, spec), { uid: generate$5('uid') });\r\n    };\r\n\r\n    var isSketchSpec = function (spec) {\r\n      return spec.uid !== undefined;\r\n    };\r\n    var singleSchema = objOfOnly([\r\n      required$1('name'),\r\n      required$1('factory'),\r\n      required$1('configFields'),\r\n      defaulted('apis', {}),\r\n      defaulted('extraApis', {})\r\n    ]);\r\n    var compositeSchema = objOfOnly([\r\n      required$1('name'),\r\n      required$1('factory'),\r\n      required$1('configFields'),\r\n      required$1('partFields'),\r\n      defaulted('apis', {}),\r\n      defaulted('extraApis', {})\r\n    ]);\r\n    var single = function (rawConfig) {\r\n      var config = asRawOrDie$1('Sketcher for ' + rawConfig.name, singleSchema, rawConfig);\r\n      var sketch = function (spec) {\r\n        return single$1(config.name, config.configFields, config.factory, spec);\r\n      };\r\n      var apis = map$1(config.apis, makeApi);\r\n      var extraApis = map$1(config.extraApis, function (f, k) {\r\n        return markAsExtraApi(f, k);\r\n      });\r\n      return __assign(__assign({\r\n        name: config.name,\r\n        configFields: config.configFields,\r\n        sketch: sketch\r\n      }, apis), extraApis);\r\n    };\r\n    var composite = function (rawConfig) {\r\n      var config = asRawOrDie$1('Sketcher for ' + rawConfig.name, compositeSchema, rawConfig);\r\n      var sketch = function (spec) {\r\n        return composite$1(config.name, config.configFields, config.partFields, config.factory, spec);\r\n      };\r\n      var parts = generate$3(config.name, config.partFields);\r\n      var apis = map$1(config.apis, makeApi);\r\n      var extraApis = map$1(config.extraApis, function (f, k) {\r\n        return markAsExtraApi(f, k);\r\n      });\r\n      return __assign(__assign({\r\n        name: config.name,\r\n        partFields: config.partFields,\r\n        configFields: config.configFields,\r\n        sketch: sketch,\r\n        parts: parts\r\n      }, apis), extraApis);\r\n    };\r\n\r\n    var inside = function (target) {\r\n      return name$2(target) === 'input' && get$d(target, 'type') !== 'radio' || name$2(target) === 'textarea';\r\n    };\r\n\r\n    var getCurrent = function (component, composeConfig, _composeState) {\r\n      return composeConfig.find(component);\r\n    };\r\n\r\n    var ComposeApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        getCurrent: getCurrent\r\n    });\r\n\r\n    var ComposeSchema = [required$1('find')];\r\n\r\n    var Composing = create$8({\r\n      fields: ComposeSchema,\r\n      name: 'composing',\r\n      apis: ComposeApis\r\n    });\r\n\r\n    var nativeDisabled = [\r\n      'input',\r\n      'button',\r\n      'textarea',\r\n      'select'\r\n    ];\r\n    var onLoad$1 = function (component, disableConfig, disableState) {\r\n      var f = disableConfig.disabled() ? disable$1 : enable$1;\r\n      f(component, disableConfig);\r\n    };\r\n    var hasNative = function (component, config) {\r\n      return config.useNative === true && contains$2(nativeDisabled, name$2(component.element));\r\n    };\r\n    var nativeIsDisabled = function (component) {\r\n      return has$1(component.element, 'disabled');\r\n    };\r\n    var nativeDisable = function (component) {\r\n      set$8(component.element, 'disabled', 'disabled');\r\n    };\r\n    var nativeEnable = function (component) {\r\n      remove$7(component.element, 'disabled');\r\n    };\r\n    var ariaIsDisabled = function (component) {\r\n      return get$d(component.element, 'aria-disabled') === 'true';\r\n    };\r\n    var ariaDisable = function (component) {\r\n      set$8(component.element, 'aria-disabled', 'true');\r\n    };\r\n    var ariaEnable = function (component) {\r\n      set$8(component.element, 'aria-disabled', 'false');\r\n    };\r\n    var disable$1 = function (component, disableConfig, _disableState) {\r\n      disableConfig.disableClass.each(function (disableClass) {\r\n        add$2(component.element, disableClass);\r\n      });\r\n      var f = hasNative(component, disableConfig) ? nativeDisable : ariaDisable;\r\n      f(component);\r\n      disableConfig.onDisabled(component);\r\n    };\r\n    var enable$1 = function (component, disableConfig, _disableState) {\r\n      disableConfig.disableClass.each(function (disableClass) {\r\n        remove$2(component.element, disableClass);\r\n      });\r\n      var f = hasNative(component, disableConfig) ? nativeEnable : ariaEnable;\r\n      f(component);\r\n      disableConfig.onEnabled(component);\r\n    };\r\n    var isDisabled = function (component, disableConfig) {\r\n      return hasNative(component, disableConfig) ? nativeIsDisabled(component) : ariaIsDisabled(component);\r\n    };\r\n    var set$3 = function (component, disableConfig, disableState, disabled) {\r\n      var f = disabled ? disable$1 : enable$1;\r\n      f(component, disableConfig);\r\n    };\r\n\r\n    var DisableApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        enable: enable$1,\r\n        disable: disable$1,\r\n        isDisabled: isDisabled,\r\n        onLoad: onLoad$1,\r\n        set: set$3\r\n    });\r\n\r\n    var exhibit$5 = function (base, disableConfig) {\r\n      return nu$7({ classes: disableConfig.disabled() ? disableConfig.disableClass.toArray() : [] });\r\n    };\r\n    var events$e = function (disableConfig, disableState) {\r\n      return derive$2([\r\n        abort(execute$5(), function (component, _simulatedEvent) {\r\n          return isDisabled(component, disableConfig);\r\n        }),\r\n        loadEvent(disableConfig, disableState, onLoad$1)\r\n      ]);\r\n    };\r\n\r\n    var ActiveDisable = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        exhibit: exhibit$5,\r\n        events: events$e\r\n    });\r\n\r\n    var DisableSchema = [\r\n      defaultedFunction('disabled', never),\r\n      defaulted('useNative', true),\r\n      option('disableClass'),\r\n      onHandler('onDisabled'),\r\n      onHandler('onEnabled')\r\n    ];\r\n\r\n    var Disabling = create$8({\r\n      fields: DisableSchema,\r\n      name: 'disabling',\r\n      active: ActiveDisable,\r\n      apis: DisableApis\r\n    });\r\n\r\n    var dehighlightAllExcept = function (component, hConfig, hState, skip) {\r\n      var highlighted = descendants(component.element, '.' + hConfig.highlightClass);\r\n      each$1(highlighted, function (h) {\r\n        if (!exists(skip, function (skipComp) {\r\n            return skipComp.element === h;\r\n          })) {\r\n          remove$2(h, hConfig.highlightClass);\r\n          component.getSystem().getByDom(h).each(function (target) {\r\n            hConfig.onDehighlight(component, target);\r\n            emit(target, dehighlight$1());\r\n          });\r\n        }\r\n      });\r\n    };\r\n    var dehighlightAll = function (component, hConfig, hState) {\r\n      return dehighlightAllExcept(component, hConfig, hState, []);\r\n    };\r\n    var dehighlight = function (component, hConfig, hState, target) {\r\n      if (isHighlighted(component, hConfig, hState, target)) {\r\n        remove$2(target.element, hConfig.highlightClass);\r\n        hConfig.onDehighlight(component, target);\r\n        emit(target, dehighlight$1());\r\n      }\r\n    };\r\n    var highlight = function (component, hConfig, hState, target) {\r\n      dehighlightAllExcept(component, hConfig, hState, [target]);\r\n      if (!isHighlighted(component, hConfig, hState, target)) {\r\n        add$2(target.element, hConfig.highlightClass);\r\n        hConfig.onHighlight(component, target);\r\n        emit(target, highlight$1());\r\n      }\r\n    };\r\n    var highlightFirst = function (component, hConfig, hState) {\r\n      getFirst(component, hConfig).each(function (firstComp) {\r\n        highlight(component, hConfig, hState, firstComp);\r\n      });\r\n    };\r\n    var highlightLast = function (component, hConfig, hState) {\r\n      getLast(component, hConfig).each(function (lastComp) {\r\n        highlight(component, hConfig, hState, lastComp);\r\n      });\r\n    };\r\n    var highlightAt = function (component, hConfig, hState, index) {\r\n      getByIndex(component, hConfig, hState, index).fold(function (err) {\r\n        throw err;\r\n      }, function (firstComp) {\r\n        highlight(component, hConfig, hState, firstComp);\r\n      });\r\n    };\r\n    var highlightBy = function (component, hConfig, hState, predicate) {\r\n      var candidates = getCandidates(component, hConfig);\r\n      var targetComp = find$5(candidates, predicate);\r\n      targetComp.each(function (c) {\r\n        highlight(component, hConfig, hState, c);\r\n      });\r\n    };\r\n    var isHighlighted = function (component, hConfig, hState, queryTarget) {\r\n      return has(queryTarget.element, hConfig.highlightClass);\r\n    };\r\n    var getHighlighted = function (component, hConfig, _hState) {\r\n      return descendant(component.element, '.' + hConfig.highlightClass).bind(function (e) {\r\n        return component.getSystem().getByDom(e).toOptional();\r\n      });\r\n    };\r\n    var getByIndex = function (component, hConfig, hState, index) {\r\n      var items = descendants(component.element, '.' + hConfig.itemClass);\r\n      return Optional.from(items[index]).fold(function () {\r\n        return Result.error(new Error('No element found with index ' + index));\r\n      }, component.getSystem().getByDom);\r\n    };\r\n    var getFirst = function (component, hConfig, _hState) {\r\n      return descendant(component.element, '.' + hConfig.itemClass).bind(function (e) {\r\n        return component.getSystem().getByDom(e).toOptional();\r\n      });\r\n    };\r\n    var getLast = function (component, hConfig, _hState) {\r\n      var items = descendants(component.element, '.' + hConfig.itemClass);\r\n      var last = items.length > 0 ? Optional.some(items[items.length - 1]) : Optional.none();\r\n      return last.bind(function (c) {\r\n        return component.getSystem().getByDom(c).toOptional();\r\n      });\r\n    };\r\n    var getDelta$2 = function (component, hConfig, hState, delta) {\r\n      var items = descendants(component.element, '.' + hConfig.itemClass);\r\n      var current = findIndex$1(items, function (item) {\r\n        return has(item, hConfig.highlightClass);\r\n      });\r\n      return current.bind(function (selected) {\r\n        var dest = cycleBy(selected, delta, 0, items.length - 1);\r\n        return component.getSystem().getByDom(items[dest]).toOptional();\r\n      });\r\n    };\r\n    var getPrevious = function (component, hConfig, hState) {\r\n      return getDelta$2(component, hConfig, hState, -1);\r\n    };\r\n    var getNext = function (component, hConfig, hState) {\r\n      return getDelta$2(component, hConfig, hState, +1);\r\n    };\r\n    var getCandidates = function (component, hConfig, _hState) {\r\n      var items = descendants(component.element, '.' + hConfig.itemClass);\r\n      return cat(map$2(items, function (i) {\r\n        return component.getSystem().getByDom(i).toOptional();\r\n      }));\r\n    };\r\n\r\n    var HighlightApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        dehighlightAll: dehighlightAll,\r\n        dehighlight: dehighlight,\r\n        highlight: highlight,\r\n        highlightFirst: highlightFirst,\r\n        highlightLast: highlightLast,\r\n        highlightAt: highlightAt,\r\n        highlightBy: highlightBy,\r\n        isHighlighted: isHighlighted,\r\n        getHighlighted: getHighlighted,\r\n        getFirst: getFirst,\r\n        getLast: getLast,\r\n        getPrevious: getPrevious,\r\n        getNext: getNext,\r\n        getCandidates: getCandidates\r\n    });\r\n\r\n    var HighlightSchema = [\r\n      required$1('highlightClass'),\r\n      required$1('itemClass'),\r\n      onHandler('onHighlight'),\r\n      onHandler('onDehighlight')\r\n    ];\r\n\r\n    var Highlighting = create$8({\r\n      fields: HighlightSchema,\r\n      name: 'highlighting',\r\n      apis: HighlightApis\r\n    });\r\n\r\n    var BACKSPACE = [8];\r\n    var TAB = [9];\r\n    var ENTER = [13];\r\n    var ESCAPE = [27];\r\n    var SPACE = [32];\r\n    var LEFT = [37];\r\n    var UP = [38];\r\n    var RIGHT = [39];\r\n    var DOWN = [40];\r\n\r\n    var cyclePrev = function (values, index, predicate) {\r\n      var before = reverse(values.slice(0, index));\r\n      var after = reverse(values.slice(index + 1));\r\n      return find$5(before.concat(after), predicate);\r\n    };\r\n    var tryPrev = function (values, index, predicate) {\r\n      var before = reverse(values.slice(0, index));\r\n      return find$5(before, predicate);\r\n    };\r\n    var cycleNext = function (values, index, predicate) {\r\n      var before = values.slice(0, index);\r\n      var after = values.slice(index + 1);\r\n      return find$5(after.concat(before), predicate);\r\n    };\r\n    var tryNext = function (values, index, predicate) {\r\n      var after = values.slice(index + 1);\r\n      return find$5(after, predicate);\r\n    };\r\n\r\n    var inSet = function (keys) {\r\n      return function (event) {\r\n        var raw = event.raw;\r\n        return contains$2(keys, raw.which);\r\n      };\r\n    };\r\n    var and = function (preds) {\r\n      return function (event) {\r\n        return forall(preds, function (pred) {\r\n          return pred(event);\r\n        });\r\n      };\r\n    };\r\n    var isShift = function (event) {\r\n      var raw = event.raw;\r\n      return raw.shiftKey === true;\r\n    };\r\n    var isControl = function (event) {\r\n      var raw = event.raw;\r\n      return raw.ctrlKey === true;\r\n    };\r\n    var isNotShift = not(isShift);\r\n\r\n    var rule = function (matches, action) {\r\n      return {\r\n        matches: matches,\r\n        classification: action\r\n      };\r\n    };\r\n    var choose = function (transitions, event) {\r\n      var transition = find$5(transitions, function (t) {\r\n        return t.matches(event);\r\n      });\r\n      return transition.map(function (t) {\r\n        return t.classification;\r\n      });\r\n    };\r\n\r\n    var reportFocusShifting = function (component, prevFocus, newFocus) {\r\n      var noChange = prevFocus.exists(function (p) {\r\n        return newFocus.exists(function (n) {\r\n          return eq(n, p);\r\n        });\r\n      });\r\n      if (!noChange) {\r\n        emitWith(component, focusShifted(), {\r\n          prevFocus: prevFocus,\r\n          newFocus: newFocus\r\n        });\r\n      }\r\n    };\r\n    var dom$2 = function () {\r\n      var get = function (component) {\r\n        return search(component.element);\r\n      };\r\n      var set = function (component, focusee) {\r\n        var prevFocus = get(component);\r\n        component.getSystem().triggerFocus(focusee, component.element);\r\n        var newFocus = get(component);\r\n        reportFocusShifting(component, prevFocus, newFocus);\r\n      };\r\n      return {\r\n        get: get,\r\n        set: set\r\n      };\r\n    };\r\n    var highlights = function () {\r\n      var get = function (component) {\r\n        return Highlighting.getHighlighted(component).map(function (item) {\r\n          return item.element;\r\n        });\r\n      };\r\n      var set = function (component, element) {\r\n        var prevFocus = get(component);\r\n        component.getSystem().getByDom(element).fold(noop, function (item) {\r\n          Highlighting.highlight(component, item);\r\n        });\r\n        var newFocus = get(component);\r\n        reportFocusShifting(component, prevFocus, newFocus);\r\n      };\r\n      return {\r\n        get: get,\r\n        set: set\r\n      };\r\n    };\r\n\r\n    var FocusInsideModes;\r\n    (function (FocusInsideModes) {\r\n      FocusInsideModes['OnFocusMode'] = 'onFocus';\r\n      FocusInsideModes['OnEnterOrSpaceMode'] = 'onEnterOrSpace';\r\n      FocusInsideModes['OnApiMode'] = 'onApi';\r\n    }(FocusInsideModes || (FocusInsideModes = {})));\r\n\r\n    var typical = function (infoSchema, stateInit, getKeydownRules, getKeyupRules, optFocusIn) {\r\n      var schema = function () {\r\n        return infoSchema.concat([\r\n          defaulted('focusManager', dom$2()),\r\n          defaultedOf('focusInside', 'onFocus', valueOf(function (val) {\r\n            return contains$2([\r\n              'onFocus',\r\n              'onEnterOrSpace',\r\n              'onApi'\r\n            ], val) ? Result.value(val) : Result.error('Invalid value for focusInside');\r\n          })),\r\n          output$1('handler', me),\r\n          output$1('state', stateInit),\r\n          output$1('sendFocusIn', optFocusIn)\r\n        ]);\r\n      };\r\n      var processKey = function (component, simulatedEvent, getRules, keyingConfig, keyingState) {\r\n        var rules = getRules(component, simulatedEvent, keyingConfig, keyingState);\r\n        return choose(rules, simulatedEvent.event).bind(function (rule) {\r\n          return rule(component, simulatedEvent, keyingConfig, keyingState);\r\n        });\r\n      };\r\n      var toEvents = function (keyingConfig, keyingState) {\r\n        var onFocusHandler = keyingConfig.focusInside !== FocusInsideModes.OnFocusMode ? Optional.none() : optFocusIn(keyingConfig).map(function (focusIn) {\r\n          return run$1(focus$4(), function (component, simulatedEvent) {\r\n            focusIn(component, keyingConfig, keyingState);\r\n            simulatedEvent.stop();\r\n          });\r\n        });\r\n        var tryGoInsideComponent = function (component, simulatedEvent) {\r\n          var isEnterOrSpace = inSet(SPACE.concat(ENTER))(simulatedEvent.event);\r\n          if (keyingConfig.focusInside === FocusInsideModes.OnEnterOrSpaceMode && isEnterOrSpace && isSource(component, simulatedEvent)) {\r\n            optFocusIn(keyingConfig).each(function (focusIn) {\r\n              focusIn(component, keyingConfig, keyingState);\r\n              simulatedEvent.stop();\r\n            });\r\n          }\r\n        };\r\n        var keyboardEvents = [\r\n          run$1(keydown(), function (component, simulatedEvent) {\r\n            processKey(component, simulatedEvent, getKeydownRules, keyingConfig, keyingState).fold(function () {\r\n              tryGoInsideComponent(component, simulatedEvent);\r\n            }, function (_) {\r\n              simulatedEvent.stop();\r\n            });\r\n          }),\r\n          run$1(keyup(), function (component, simulatedEvent) {\r\n            processKey(component, simulatedEvent, getKeyupRules, keyingConfig, keyingState).each(function (_) {\r\n              simulatedEvent.stop();\r\n            });\r\n          })\r\n        ];\r\n        return derive$2(onFocusHandler.toArray().concat(keyboardEvents));\r\n      };\r\n      var me = {\r\n        schema: schema,\r\n        processKey: processKey,\r\n        toEvents: toEvents\r\n      };\r\n      return me;\r\n    };\r\n\r\n    var create$6 = function (cyclicField) {\r\n      var schema = [\r\n        option('onEscape'),\r\n        option('onEnter'),\r\n        defaulted('selector', '[data-alloy-tabstop=\"true\"]:not(:disabled)'),\r\n        defaulted('firstTabstop', 0),\r\n        defaulted('useTabstopAt', always),\r\n        option('visibilitySelector')\r\n      ].concat([cyclicField]);\r\n      var isVisible = function (tabbingConfig, element) {\r\n        var target = tabbingConfig.visibilitySelector.bind(function (sel) {\r\n          return closest$1(element, sel);\r\n        }).getOr(element);\r\n        return get$b(target) > 0;\r\n      };\r\n      var findInitial = function (component, tabbingConfig) {\r\n        var tabstops = descendants(component.element, tabbingConfig.selector);\r\n        var visibles = filter$2(tabstops, function (elem) {\r\n          return isVisible(tabbingConfig, elem);\r\n        });\r\n        return Optional.from(visibles[tabbingConfig.firstTabstop]);\r\n      };\r\n      var findCurrent = function (component, tabbingConfig) {\r\n        return tabbingConfig.focusManager.get(component).bind(function (elem) {\r\n          return closest$1(elem, tabbingConfig.selector);\r\n        });\r\n      };\r\n      var isTabstop = function (tabbingConfig, element) {\r\n        return isVisible(tabbingConfig, element) && tabbingConfig.useTabstopAt(element);\r\n      };\r\n      var focusIn = function (component, tabbingConfig, _tabbingState) {\r\n        findInitial(component, tabbingConfig).each(function (target) {\r\n          tabbingConfig.focusManager.set(component, target);\r\n        });\r\n      };\r\n      var goFromTabstop = function (component, tabstops, stopIndex, tabbingConfig, cycle) {\r\n        return cycle(tabstops, stopIndex, function (elem) {\r\n          return isTabstop(tabbingConfig, elem);\r\n        }).fold(function () {\r\n          return tabbingConfig.cyclic ? Optional.some(true) : Optional.none();\r\n        }, function (target) {\r\n          tabbingConfig.focusManager.set(component, target);\r\n          return Optional.some(true);\r\n        });\r\n      };\r\n      var go = function (component, _simulatedEvent, tabbingConfig, cycle) {\r\n        var tabstops = descendants(component.element, tabbingConfig.selector);\r\n        return findCurrent(component, tabbingConfig).bind(function (tabstop) {\r\n          var optStopIndex = findIndex$1(tabstops, curry(eq, tabstop));\r\n          return optStopIndex.bind(function (stopIndex) {\r\n            return goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle);\r\n          });\r\n        });\r\n      };\r\n      var goBackwards = function (component, simulatedEvent, tabbingConfig) {\r\n        var navigate = tabbingConfig.cyclic ? cyclePrev : tryPrev;\r\n        return go(component, simulatedEvent, tabbingConfig, navigate);\r\n      };\r\n      var goForwards = function (component, simulatedEvent, tabbingConfig) {\r\n        var navigate = tabbingConfig.cyclic ? cycleNext : tryNext;\r\n        return go(component, simulatedEvent, tabbingConfig, navigate);\r\n      };\r\n      var execute = function (component, simulatedEvent, tabbingConfig) {\r\n        return tabbingConfig.onEnter.bind(function (f) {\r\n          return f(component, simulatedEvent);\r\n        });\r\n      };\r\n      var exit = function (component, simulatedEvent, tabbingConfig) {\r\n        return tabbingConfig.onEscape.bind(function (f) {\r\n          return f(component, simulatedEvent);\r\n        });\r\n      };\r\n      var getKeydownRules = constant$1([\r\n        rule(and([\r\n          isShift,\r\n          inSet(TAB)\r\n        ]), goBackwards),\r\n        rule(inSet(TAB), goForwards),\r\n        rule(inSet(ESCAPE), exit),\r\n        rule(and([\r\n          isNotShift,\r\n          inSet(ENTER)\r\n        ]), execute)\r\n      ]);\r\n      var getKeyupRules = constant$1([]);\r\n      return typical(schema, NoState.init, getKeydownRules, getKeyupRules, function () {\r\n        return Optional.some(focusIn);\r\n      });\r\n    };\r\n\r\n    var AcyclicType = create$6(customField('cyclic', never));\r\n\r\n    var CyclicType = create$6(customField('cyclic', always));\r\n\r\n    var doDefaultExecute = function (component, _simulatedEvent, focused) {\r\n      dispatch(component, focused, execute$5());\r\n      return Optional.some(true);\r\n    };\r\n    var defaultExecute = function (component, simulatedEvent, focused) {\r\n      var isComplex = inside(focused) && inSet(SPACE)(simulatedEvent.event);\r\n      return isComplex ? Optional.none() : doDefaultExecute(component, simulatedEvent, focused);\r\n    };\r\n    var stopEventForFirefox = function (_component, _simulatedEvent) {\r\n      return Optional.some(true);\r\n    };\r\n\r\n    var schema$v = [\r\n      defaulted('execute', defaultExecute),\r\n      defaulted('useSpace', false),\r\n      defaulted('useEnter', true),\r\n      defaulted('useControlEnter', false),\r\n      defaulted('useDown', false)\r\n    ];\r\n    var execute$4 = function (component, simulatedEvent, executeConfig) {\r\n      return executeConfig.execute(component, simulatedEvent, component.element);\r\n    };\r\n    var getKeydownRules$5 = function (component, _simulatedEvent, executeConfig, _executeState) {\r\n      var spaceExec = executeConfig.useSpace && !inside(component.element) ? SPACE : [];\r\n      var enterExec = executeConfig.useEnter ? ENTER : [];\r\n      var downExec = executeConfig.useDown ? DOWN : [];\r\n      var execKeys = spaceExec.concat(enterExec).concat(downExec);\r\n      return [rule(inSet(execKeys), execute$4)].concat(executeConfig.useControlEnter ? [rule(and([\r\n          isControl,\r\n          inSet(ENTER)\r\n        ]), execute$4)] : []);\r\n    };\r\n    var getKeyupRules$5 = function (component, _simulatedEvent, executeConfig, _executeState) {\r\n      return executeConfig.useSpace && !inside(component.element) ? [rule(inSet(SPACE), stopEventForFirefox)] : [];\r\n    };\r\n    var ExecutionType = typical(schema$v, NoState.init, getKeydownRules$5, getKeyupRules$5, function () {\r\n      return Optional.none();\r\n    });\r\n\r\n    var flatgrid$1 = function () {\r\n      var dimensions = value$1();\r\n      var setGridSize = function (numRows, numColumns) {\r\n        dimensions.set({\r\n          numRows: numRows,\r\n          numColumns: numColumns\r\n        });\r\n      };\r\n      var getNumRows = function () {\r\n        return dimensions.get().map(function (d) {\r\n          return d.numRows;\r\n        });\r\n      };\r\n      var getNumColumns = function () {\r\n        return dimensions.get().map(function (d) {\r\n          return d.numColumns;\r\n        });\r\n      };\r\n      return nu$8({\r\n        readState: function () {\r\n          return dimensions.get().map(function (d) {\r\n            return {\r\n              numRows: String(d.numRows),\r\n              numColumns: String(d.numColumns)\r\n            };\r\n          }).getOr({\r\n            numRows: '?',\r\n            numColumns: '?'\r\n          });\r\n        },\r\n        setGridSize: setGridSize,\r\n        getNumRows: getNumRows,\r\n        getNumColumns: getNumColumns\r\n      });\r\n    };\r\n    var init$d = function (spec) {\r\n      return spec.state(spec);\r\n    };\r\n\r\n    var KeyingState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        flatgrid: flatgrid$1,\r\n        init: init$d\r\n    });\r\n\r\n    var useH = function (movement) {\r\n      return function (component, simulatedEvent, config, state) {\r\n        var move = movement(component.element);\r\n        return use(move, component, simulatedEvent, config, state);\r\n      };\r\n    };\r\n    var west$1 = function (moveLeft, moveRight) {\r\n      var movement = onDirection(moveLeft, moveRight);\r\n      return useH(movement);\r\n    };\r\n    var east$1 = function (moveLeft, moveRight) {\r\n      var movement = onDirection(moveRight, moveLeft);\r\n      return useH(movement);\r\n    };\r\n    var useV = function (move) {\r\n      return function (component, simulatedEvent, config, state) {\r\n        return use(move, component, simulatedEvent, config, state);\r\n      };\r\n    };\r\n    var use = function (move, component, simulatedEvent, config, state) {\r\n      var outcome = config.focusManager.get(component).bind(function (focused) {\r\n        return move(component.element, focused, config, state);\r\n      });\r\n      return outcome.map(function (newFocus) {\r\n        config.focusManager.set(component, newFocus);\r\n        return true;\r\n      });\r\n    };\r\n    var north$1 = useV;\r\n    var south$1 = useV;\r\n    var move$1 = useV;\r\n\r\n    var isHidden$1 = function (dom) {\r\n      return dom.offsetWidth <= 0 && dom.offsetHeight <= 0;\r\n    };\r\n    var isVisible = function (element) {\r\n      return !isHidden$1(element.dom);\r\n    };\r\n\r\n    var locate = function (candidates, predicate) {\r\n      return findIndex$1(candidates, predicate).map(function (index) {\r\n        return {\r\n          index: index,\r\n          candidates: candidates\r\n        };\r\n      });\r\n    };\r\n\r\n    var locateVisible = function (container, current, selector) {\r\n      var predicate = function (x) {\r\n        return eq(x, current);\r\n      };\r\n      var candidates = descendants(container, selector);\r\n      var visible = filter$2(candidates, isVisible);\r\n      return locate(visible, predicate);\r\n    };\r\n    var findIndex = function (elements, target) {\r\n      return findIndex$1(elements, function (elem) {\r\n        return eq(target, elem);\r\n      });\r\n    };\r\n\r\n    var withGrid = function (values, index, numCols, f) {\r\n      var oldRow = Math.floor(index / numCols);\r\n      var oldColumn = index % numCols;\r\n      return f(oldRow, oldColumn).bind(function (address) {\r\n        var newIndex = address.row * numCols + address.column;\r\n        return newIndex >= 0 && newIndex < values.length ? Optional.some(values[newIndex]) : Optional.none();\r\n      });\r\n    };\r\n    var cycleHorizontal$1 = function (values, index, numRows, numCols, delta) {\r\n      return withGrid(values, index, numCols, function (oldRow, oldColumn) {\r\n        var onLastRow = oldRow === numRows - 1;\r\n        var colsInRow = onLastRow ? values.length - oldRow * numCols : numCols;\r\n        var newColumn = cycleBy(oldColumn, delta, 0, colsInRow - 1);\r\n        return Optional.some({\r\n          row: oldRow,\r\n          column: newColumn\r\n        });\r\n      });\r\n    };\r\n    var cycleVertical$1 = function (values, index, numRows, numCols, delta) {\r\n      return withGrid(values, index, numCols, function (oldRow, oldColumn) {\r\n        var newRow = cycleBy(oldRow, delta, 0, numRows - 1);\r\n        var onLastRow = newRow === numRows - 1;\r\n        var colsInRow = onLastRow ? values.length - newRow * numCols : numCols;\r\n        var newCol = clamp$1(oldColumn, 0, colsInRow - 1);\r\n        return Optional.some({\r\n          row: newRow,\r\n          column: newCol\r\n        });\r\n      });\r\n    };\r\n    var cycleRight$1 = function (values, index, numRows, numCols) {\r\n      return cycleHorizontal$1(values, index, numRows, numCols, +1);\r\n    };\r\n    var cycleLeft$1 = function (values, index, numRows, numCols) {\r\n      return cycleHorizontal$1(values, index, numRows, numCols, -1);\r\n    };\r\n    var cycleUp$1 = function (values, index, numRows, numCols) {\r\n      return cycleVertical$1(values, index, numRows, numCols, -1);\r\n    };\r\n    var cycleDown$1 = function (values, index, numRows, numCols) {\r\n      return cycleVertical$1(values, index, numRows, numCols, +1);\r\n    };\r\n\r\n    var schema$u = [\r\n      required$1('selector'),\r\n      defaulted('execute', defaultExecute),\r\n      onKeyboardHandler('onEscape'),\r\n      defaulted('captureTab', false),\r\n      initSize()\r\n    ];\r\n    var focusIn$3 = function (component, gridConfig, _gridState) {\r\n      descendant(component.element, gridConfig.selector).each(function (first) {\r\n        gridConfig.focusManager.set(component, first);\r\n      });\r\n    };\r\n    var findCurrent$1 = function (component, gridConfig) {\r\n      return gridConfig.focusManager.get(component).bind(function (elem) {\r\n        return closest$1(elem, gridConfig.selector);\r\n      });\r\n    };\r\n    var execute$3 = function (component, simulatedEvent, gridConfig, _gridState) {\r\n      return findCurrent$1(component, gridConfig).bind(function (focused) {\r\n        return gridConfig.execute(component, simulatedEvent, focused);\r\n      });\r\n    };\r\n    var doMove$2 = function (cycle) {\r\n      return function (element, focused, gridConfig, gridState) {\r\n        return locateVisible(element, focused, gridConfig.selector).bind(function (identified) {\r\n          return cycle(identified.candidates, identified.index, gridState.getNumRows().getOr(gridConfig.initSize.numRows), gridState.getNumColumns().getOr(gridConfig.initSize.numColumns));\r\n        });\r\n      };\r\n    };\r\n    var handleTab = function (_component, _simulatedEvent, gridConfig) {\r\n      return gridConfig.captureTab ? Optional.some(true) : Optional.none();\r\n    };\r\n    var doEscape$1 = function (component, simulatedEvent, gridConfig) {\r\n      return gridConfig.onEscape(component, simulatedEvent);\r\n    };\r\n    var moveLeft$3 = doMove$2(cycleLeft$1);\r\n    var moveRight$3 = doMove$2(cycleRight$1);\r\n    var moveNorth$1 = doMove$2(cycleUp$1);\r\n    var moveSouth$1 = doMove$2(cycleDown$1);\r\n    var getKeydownRules$4 = constant$1([\r\n      rule(inSet(LEFT), west$1(moveLeft$3, moveRight$3)),\r\n      rule(inSet(RIGHT), east$1(moveLeft$3, moveRight$3)),\r\n      rule(inSet(UP), north$1(moveNorth$1)),\r\n      rule(inSet(DOWN), south$1(moveSouth$1)),\r\n      rule(and([\r\n        isShift,\r\n        inSet(TAB)\r\n      ]), handleTab),\r\n      rule(and([\r\n        isNotShift,\r\n        inSet(TAB)\r\n      ]), handleTab),\r\n      rule(inSet(ESCAPE), doEscape$1),\r\n      rule(inSet(SPACE.concat(ENTER)), execute$3)\r\n    ]);\r\n    var getKeyupRules$4 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);\r\n    var FlatgridType = typical(schema$u, flatgrid$1, getKeydownRules$4, getKeyupRules$4, function () {\r\n      return Optional.some(focusIn$3);\r\n    });\r\n\r\n    var horizontal = function (container, selector, current, delta) {\r\n      var isDisabledButton = function (candidate) {\r\n        return name$2(candidate) === 'button' && get$d(candidate, 'disabled') === 'disabled';\r\n      };\r\n      var tryCycle = function (initial, index, candidates) {\r\n        var newIndex = cycleBy(index, delta, 0, candidates.length - 1);\r\n        if (newIndex === initial) {\r\n          return Optional.none();\r\n        } else {\r\n          return isDisabledButton(candidates[newIndex]) ? tryCycle(initial, newIndex, candidates) : Optional.from(candidates[newIndex]);\r\n        }\r\n      };\r\n      return locateVisible(container, current, selector).bind(function (identified) {\r\n        var index = identified.index;\r\n        var candidates = identified.candidates;\r\n        return tryCycle(index, index, candidates);\r\n      });\r\n    };\r\n\r\n    var schema$t = [\r\n      required$1('selector'),\r\n      defaulted('getInitial', Optional.none),\r\n      defaulted('execute', defaultExecute),\r\n      onKeyboardHandler('onEscape'),\r\n      defaulted('executeOnMove', false),\r\n      defaulted('allowVertical', true)\r\n    ];\r\n    var findCurrent = function (component, flowConfig) {\r\n      return flowConfig.focusManager.get(component).bind(function (elem) {\r\n        return closest$1(elem, flowConfig.selector);\r\n      });\r\n    };\r\n    var execute$2 = function (component, simulatedEvent, flowConfig) {\r\n      return findCurrent(component, flowConfig).bind(function (focused) {\r\n        return flowConfig.execute(component, simulatedEvent, focused);\r\n      });\r\n    };\r\n    var focusIn$2 = function (component, flowConfig, _state) {\r\n      flowConfig.getInitial(component).orThunk(function () {\r\n        return descendant(component.element, flowConfig.selector);\r\n      }).each(function (first) {\r\n        flowConfig.focusManager.set(component, first);\r\n      });\r\n    };\r\n    var moveLeft$2 = function (element, focused, info) {\r\n      return horizontal(element, info.selector, focused, -1);\r\n    };\r\n    var moveRight$2 = function (element, focused, info) {\r\n      return horizontal(element, info.selector, focused, +1);\r\n    };\r\n    var doMove$1 = function (movement) {\r\n      return function (component, simulatedEvent, flowConfig, flowState) {\r\n        return movement(component, simulatedEvent, flowConfig, flowState).bind(function () {\r\n          return flowConfig.executeOnMove ? execute$2(component, simulatedEvent, flowConfig) : Optional.some(true);\r\n        });\r\n      };\r\n    };\r\n    var doEscape = function (component, simulatedEvent, flowConfig) {\r\n      return flowConfig.onEscape(component, simulatedEvent);\r\n    };\r\n    var getKeydownRules$3 = function (_component, _se, flowConfig, _flowState) {\r\n      var westMovers = LEFT.concat(flowConfig.allowVertical ? UP : []);\r\n      var eastMovers = RIGHT.concat(flowConfig.allowVertical ? DOWN : []);\r\n      return [\r\n        rule(inSet(westMovers), doMove$1(west$1(moveLeft$2, moveRight$2))),\r\n        rule(inSet(eastMovers), doMove$1(east$1(moveLeft$2, moveRight$2))),\r\n        rule(inSet(ENTER), execute$2),\r\n        rule(inSet(SPACE), execute$2),\r\n        rule(inSet(ESCAPE), doEscape)\r\n      ];\r\n    };\r\n    var getKeyupRules$3 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);\r\n    var FlowType = typical(schema$t, NoState.init, getKeydownRules$3, getKeyupRules$3, function () {\r\n      return Optional.some(focusIn$2);\r\n    });\r\n\r\n    var toCell = function (matrix, rowIndex, columnIndex) {\r\n      return Optional.from(matrix[rowIndex]).bind(function (row) {\r\n        return Optional.from(row[columnIndex]).map(function (cell) {\r\n          return {\r\n            rowIndex: rowIndex,\r\n            columnIndex: columnIndex,\r\n            cell: cell\r\n          };\r\n        });\r\n      });\r\n    };\r\n    var cycleHorizontal = function (matrix, rowIndex, startCol, deltaCol) {\r\n      var row = matrix[rowIndex];\r\n      var colsInRow = row.length;\r\n      var newColIndex = cycleBy(startCol, deltaCol, 0, colsInRow - 1);\r\n      return toCell(matrix, rowIndex, newColIndex);\r\n    };\r\n    var cycleVertical = function (matrix, colIndex, startRow, deltaRow) {\r\n      var nextRowIndex = cycleBy(startRow, deltaRow, 0, matrix.length - 1);\r\n      var colsInNextRow = matrix[nextRowIndex].length;\r\n      var nextColIndex = clamp$1(colIndex, 0, colsInNextRow - 1);\r\n      return toCell(matrix, nextRowIndex, nextColIndex);\r\n    };\r\n    var moveHorizontal = function (matrix, rowIndex, startCol, deltaCol) {\r\n      var row = matrix[rowIndex];\r\n      var colsInRow = row.length;\r\n      var newColIndex = clamp$1(startCol + deltaCol, 0, colsInRow - 1);\r\n      return toCell(matrix, rowIndex, newColIndex);\r\n    };\r\n    var moveVertical = function (matrix, colIndex, startRow, deltaRow) {\r\n      var nextRowIndex = clamp$1(startRow + deltaRow, 0, matrix.length - 1);\r\n      var colsInNextRow = matrix[nextRowIndex].length;\r\n      var nextColIndex = clamp$1(colIndex, 0, colsInNextRow - 1);\r\n      return toCell(matrix, nextRowIndex, nextColIndex);\r\n    };\r\n    var cycleRight = function (matrix, startRow, startCol) {\r\n      return cycleHorizontal(matrix, startRow, startCol, +1);\r\n    };\r\n    var cycleLeft = function (matrix, startRow, startCol) {\r\n      return cycleHorizontal(matrix, startRow, startCol, -1);\r\n    };\r\n    var cycleUp = function (matrix, startRow, startCol) {\r\n      return cycleVertical(matrix, startCol, startRow, -1);\r\n    };\r\n    var cycleDown = function (matrix, startRow, startCol) {\r\n      return cycleVertical(matrix, startCol, startRow, +1);\r\n    };\r\n    var moveLeft$1 = function (matrix, startRow, startCol) {\r\n      return moveHorizontal(matrix, startRow, startCol, -1);\r\n    };\r\n    var moveRight$1 = function (matrix, startRow, startCol) {\r\n      return moveHorizontal(matrix, startRow, startCol, +1);\r\n    };\r\n    var moveUp$1 = function (matrix, startRow, startCol) {\r\n      return moveVertical(matrix, startCol, startRow, -1);\r\n    };\r\n    var moveDown$1 = function (matrix, startRow, startCol) {\r\n      return moveVertical(matrix, startCol, startRow, +1);\r\n    };\r\n\r\n    var schema$s = [\r\n      requiredObjOf('selectors', [\r\n        required$1('row'),\r\n        required$1('cell')\r\n      ]),\r\n      defaulted('cycles', true),\r\n      defaulted('previousSelector', Optional.none),\r\n      defaulted('execute', defaultExecute)\r\n    ];\r\n    var focusIn$1 = function (component, matrixConfig, _state) {\r\n      var focused = matrixConfig.previousSelector(component).orThunk(function () {\r\n        var selectors = matrixConfig.selectors;\r\n        return descendant(component.element, selectors.cell);\r\n      });\r\n      focused.each(function (cell) {\r\n        matrixConfig.focusManager.set(component, cell);\r\n      });\r\n    };\r\n    var execute$1 = function (component, simulatedEvent, matrixConfig) {\r\n      return search(component.element).bind(function (focused) {\r\n        return matrixConfig.execute(component, simulatedEvent, focused);\r\n      });\r\n    };\r\n    var toMatrix = function (rows, matrixConfig) {\r\n      return map$2(rows, function (row) {\r\n        return descendants(row, matrixConfig.selectors.cell);\r\n      });\r\n    };\r\n    var doMove = function (ifCycle, ifMove) {\r\n      return function (element, focused, matrixConfig) {\r\n        var move = matrixConfig.cycles ? ifCycle : ifMove;\r\n        return closest$1(focused, matrixConfig.selectors.row).bind(function (inRow) {\r\n          var cellsInRow = descendants(inRow, matrixConfig.selectors.cell);\r\n          return findIndex(cellsInRow, focused).bind(function (colIndex) {\r\n            var allRows = descendants(element, matrixConfig.selectors.row);\r\n            return findIndex(allRows, inRow).bind(function (rowIndex) {\r\n              var matrix = toMatrix(allRows, matrixConfig);\r\n              return move(matrix, rowIndex, colIndex).map(function (next) {\r\n                return next.cell;\r\n              });\r\n            });\r\n          });\r\n        });\r\n      };\r\n    };\r\n    var moveLeft = doMove(cycleLeft, moveLeft$1);\r\n    var moveRight = doMove(cycleRight, moveRight$1);\r\n    var moveNorth = doMove(cycleUp, moveUp$1);\r\n    var moveSouth = doMove(cycleDown, moveDown$1);\r\n    var getKeydownRules$2 = constant$1([\r\n      rule(inSet(LEFT), west$1(moveLeft, moveRight)),\r\n      rule(inSet(RIGHT), east$1(moveLeft, moveRight)),\r\n      rule(inSet(UP), north$1(moveNorth)),\r\n      rule(inSet(DOWN), south$1(moveSouth)),\r\n      rule(inSet(SPACE.concat(ENTER)), execute$1)\r\n    ]);\r\n    var getKeyupRules$2 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);\r\n    var MatrixType = typical(schema$s, NoState.init, getKeydownRules$2, getKeyupRules$2, function () {\r\n      return Optional.some(focusIn$1);\r\n    });\r\n\r\n    var schema$r = [\r\n      required$1('selector'),\r\n      defaulted('execute', defaultExecute),\r\n      defaulted('moveOnTab', false)\r\n    ];\r\n    var execute = function (component, simulatedEvent, menuConfig) {\r\n      return menuConfig.focusManager.get(component).bind(function (focused) {\r\n        return menuConfig.execute(component, simulatedEvent, focused);\r\n      });\r\n    };\r\n    var focusIn = function (component, menuConfig, _state) {\r\n      descendant(component.element, menuConfig.selector).each(function (first) {\r\n        menuConfig.focusManager.set(component, first);\r\n      });\r\n    };\r\n    var moveUp = function (element, focused, info) {\r\n      return horizontal(element, info.selector, focused, -1);\r\n    };\r\n    var moveDown = function (element, focused, info) {\r\n      return horizontal(element, info.selector, focused, +1);\r\n    };\r\n    var fireShiftTab = function (component, simulatedEvent, menuConfig, menuState) {\r\n      return menuConfig.moveOnTab ? move$1(moveUp)(component, simulatedEvent, menuConfig, menuState) : Optional.none();\r\n    };\r\n    var fireTab = function (component, simulatedEvent, menuConfig, menuState) {\r\n      return menuConfig.moveOnTab ? move$1(moveDown)(component, simulatedEvent, menuConfig, menuState) : Optional.none();\r\n    };\r\n    var getKeydownRules$1 = constant$1([\r\n      rule(inSet(UP), move$1(moveUp)),\r\n      rule(inSet(DOWN), move$1(moveDown)),\r\n      rule(and([\r\n        isShift,\r\n        inSet(TAB)\r\n      ]), fireShiftTab),\r\n      rule(and([\r\n        isNotShift,\r\n        inSet(TAB)\r\n      ]), fireTab),\r\n      rule(inSet(ENTER), execute),\r\n      rule(inSet(SPACE), execute)\r\n    ]);\r\n    var getKeyupRules$1 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);\r\n    var MenuType = typical(schema$r, NoState.init, getKeydownRules$1, getKeyupRules$1, function () {\r\n      return Optional.some(focusIn);\r\n    });\r\n\r\n    var schema$q = [\r\n      onKeyboardHandler('onSpace'),\r\n      onKeyboardHandler('onEnter'),\r\n      onKeyboardHandler('onShiftEnter'),\r\n      onKeyboardHandler('onLeft'),\r\n      onKeyboardHandler('onRight'),\r\n      onKeyboardHandler('onTab'),\r\n      onKeyboardHandler('onShiftTab'),\r\n      onKeyboardHandler('onUp'),\r\n      onKeyboardHandler('onDown'),\r\n      onKeyboardHandler('onEscape'),\r\n      defaulted('stopSpaceKeyup', false),\r\n      option('focusIn')\r\n    ];\r\n    var getKeydownRules = function (component, simulatedEvent, specialInfo) {\r\n      return [\r\n        rule(inSet(SPACE), specialInfo.onSpace),\r\n        rule(and([\r\n          isNotShift,\r\n          inSet(ENTER)\r\n        ]), specialInfo.onEnter),\r\n        rule(and([\r\n          isShift,\r\n          inSet(ENTER)\r\n        ]), specialInfo.onShiftEnter),\r\n        rule(and([\r\n          isShift,\r\n          inSet(TAB)\r\n        ]), specialInfo.onShiftTab),\r\n        rule(and([\r\n          isNotShift,\r\n          inSet(TAB)\r\n        ]), specialInfo.onTab),\r\n        rule(inSet(UP), specialInfo.onUp),\r\n        rule(inSet(DOWN), specialInfo.onDown),\r\n        rule(inSet(LEFT), specialInfo.onLeft),\r\n        rule(inSet(RIGHT), specialInfo.onRight),\r\n        rule(inSet(SPACE), specialInfo.onSpace),\r\n        rule(inSet(ESCAPE), specialInfo.onEscape)\r\n      ];\r\n    };\r\n    var getKeyupRules = function (component, simulatedEvent, specialInfo) {\r\n      return specialInfo.stopSpaceKeyup ? [rule(inSet(SPACE), stopEventForFirefox)] : [];\r\n    };\r\n    var SpecialType = typical(schema$q, NoState.init, getKeydownRules, getKeyupRules, function (specialInfo) {\r\n      return specialInfo.focusIn;\r\n    });\r\n\r\n    var acyclic = AcyclicType.schema();\r\n    var cyclic = CyclicType.schema();\r\n    var flow = FlowType.schema();\r\n    var flatgrid = FlatgridType.schema();\r\n    var matrix = MatrixType.schema();\r\n    var execution = ExecutionType.schema();\r\n    var menu = MenuType.schema();\r\n    var special = SpecialType.schema();\r\n\r\n    var KeyboardBranches = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        acyclic: acyclic,\r\n        cyclic: cyclic,\r\n        flow: flow,\r\n        flatgrid: flatgrid,\r\n        matrix: matrix,\r\n        execution: execution,\r\n        menu: menu,\r\n        special: special\r\n    });\r\n\r\n    var isFlatgridState = function (keyState) {\r\n      return hasNonNullableKey(keyState, 'setGridSize');\r\n    };\r\n    var Keying = createModes({\r\n      branchKey: 'mode',\r\n      branches: KeyboardBranches,\r\n      name: 'keying',\r\n      active: {\r\n        events: function (keyingConfig, keyingState) {\r\n          var handler = keyingConfig.handler;\r\n          return handler.toEvents(keyingConfig, keyingState);\r\n        }\r\n      },\r\n      apis: {\r\n        focusIn: function (component, keyConfig, keyState) {\r\n          keyConfig.sendFocusIn(keyConfig).fold(function () {\r\n            component.getSystem().triggerFocus(component.element, component.element);\r\n          }, function (sendFocusIn) {\r\n            sendFocusIn(component, keyConfig, keyState);\r\n          });\r\n        },\r\n        setGridSize: function (component, keyConfig, keyState, numRows, numColumns) {\r\n          if (!isFlatgridState(keyState)) {\r\n            console.error('Layout does not support setGridSize');\r\n          } else {\r\n            keyState.setGridSize(numRows, numColumns);\r\n          }\r\n        }\r\n      },\r\n      state: KeyingState\r\n    });\r\n\r\n    var set$2 = function (component, replaceConfig, replaceState, data) {\r\n      preserve$1(function () {\r\n        var newChildren = map$2(data, component.getSystem().build);\r\n        replaceChildren(component, newChildren);\r\n      }, component.element);\r\n    };\r\n    var insert = function (component, replaceConfig, insertion, childSpec) {\r\n      var child = component.getSystem().build(childSpec);\r\n      attachWith(component, child, insertion);\r\n    };\r\n    var append = function (component, replaceConfig, replaceState, appendee) {\r\n      insert(component, replaceConfig, append$2, appendee);\r\n    };\r\n    var prepend = function (component, replaceConfig, replaceState, prependee) {\r\n      insert(component, replaceConfig, prepend$1, prependee);\r\n    };\r\n    var remove = function (component, replaceConfig, replaceState, removee) {\r\n      var children = contents(component);\r\n      var foundChild = find$5(children, function (child) {\r\n        return eq(removee.element, child.element);\r\n      });\r\n      foundChild.each(detach);\r\n    };\r\n    var contents = function (component, _replaceConfig) {\r\n      return component.components();\r\n    };\r\n    var replaceAt = function (component, replaceConfig, replaceState, replaceeIndex, replacer) {\r\n      var children = contents(component);\r\n      return Optional.from(children[replaceeIndex]).map(function (replacee) {\r\n        remove(component, replaceConfig, replaceState, replacee);\r\n        replacer.each(function (r) {\r\n          insert(component, replaceConfig, function (p, c) {\r\n            appendAt(p, c, replaceeIndex);\r\n          }, r);\r\n        });\r\n        return replacee;\r\n      });\r\n    };\r\n    var replaceBy = function (component, replaceConfig, replaceState, replaceePred, replacer) {\r\n      var children = contents(component);\r\n      return findIndex$1(children, replaceePred).bind(function (replaceeIndex) {\r\n        return replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer);\r\n      });\r\n    };\r\n\r\n    var ReplaceApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        append: append,\r\n        prepend: prepend,\r\n        remove: remove,\r\n        replaceAt: replaceAt,\r\n        replaceBy: replaceBy,\r\n        set: set$2,\r\n        contents: contents\r\n    });\r\n\r\n    var Replacing = create$8({\r\n      fields: [],\r\n      name: 'replacing',\r\n      apis: ReplaceApis\r\n    });\r\n\r\n    var events$d = function (name, eventHandlers) {\r\n      var events = derive$2(eventHandlers);\r\n      return create$8({\r\n        fields: [required$1('enabled')],\r\n        name: name,\r\n        active: { events: constant$1(events) }\r\n      });\r\n    };\r\n    var config = function (name, eventHandlers) {\r\n      var me = events$d(name, eventHandlers);\r\n      return {\r\n        key: name,\r\n        value: {\r\n          config: {},\r\n          me: me,\r\n          configAsRaw: constant$1({}),\r\n          initialConfig: {},\r\n          state: NoState\r\n        }\r\n      };\r\n    };\r\n\r\n    var focus$2 = function (component, focusConfig) {\r\n      if (!focusConfig.ignore) {\r\n        focus$3(component.element);\r\n        focusConfig.onFocus(component);\r\n      }\r\n    };\r\n    var blur = function (component, focusConfig) {\r\n      if (!focusConfig.ignore) {\r\n        blur$1(component.element);\r\n      }\r\n    };\r\n    var isFocused = function (component) {\r\n      return hasFocus(component.element);\r\n    };\r\n\r\n    var FocusApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        focus: focus$2,\r\n        blur: blur,\r\n        isFocused: isFocused\r\n    });\r\n\r\n    var exhibit$4 = function (base, focusConfig) {\r\n      var mod = focusConfig.ignore ? {} : { attributes: { tabindex: '-1' } };\r\n      return nu$7(mod);\r\n    };\r\n    var events$c = function (focusConfig) {\r\n      return derive$2([run$1(focus$4(), function (component, simulatedEvent) {\r\n          focus$2(component, focusConfig);\r\n          simulatedEvent.stop();\r\n        })].concat(focusConfig.stopMousedown ? [run$1(mousedown(), function (_, simulatedEvent) {\r\n          simulatedEvent.event.prevent();\r\n        })] : []));\r\n    };\r\n\r\n    var ActiveFocus = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        exhibit: exhibit$4,\r\n        events: events$c\r\n    });\r\n\r\n    var FocusSchema = [\r\n      onHandler('onFocus'),\r\n      defaulted('stopMousedown', false),\r\n      defaulted('ignore', false)\r\n    ];\r\n\r\n    var Focusing = create$8({\r\n      fields: FocusSchema,\r\n      name: 'focusing',\r\n      active: ActiveFocus,\r\n      apis: FocusApis\r\n    });\r\n\r\n    var SetupBehaviourCellState = function (initialState) {\r\n      var init = function () {\r\n        var cell = Cell(initialState);\r\n        var get = function () {\r\n          return cell.get();\r\n        };\r\n        var set = function (newState) {\r\n          return cell.set(newState);\r\n        };\r\n        var clear = function () {\r\n          return cell.set(initialState);\r\n        };\r\n        var readState = function () {\r\n          return cell.get();\r\n        };\r\n        return {\r\n          get: get,\r\n          set: set,\r\n          clear: clear,\r\n          readState: readState\r\n        };\r\n      };\r\n      return { init: init };\r\n    };\r\n\r\n    var updateAriaState = function (component, toggleConfig, toggleState) {\r\n      var ariaInfo = toggleConfig.aria;\r\n      ariaInfo.update(component, ariaInfo, toggleState.get());\r\n    };\r\n    var updateClass = function (component, toggleConfig, toggleState) {\r\n      toggleConfig.toggleClass.each(function (toggleClass) {\r\n        if (toggleState.get()) {\r\n          add$2(component.element, toggleClass);\r\n        } else {\r\n          remove$2(component.element, toggleClass);\r\n        }\r\n      });\r\n    };\r\n    var toggle$2 = function (component, toggleConfig, toggleState) {\r\n      set$1(component, toggleConfig, toggleState, !toggleState.get());\r\n    };\r\n    var on = function (component, toggleConfig, toggleState) {\r\n      toggleState.set(true);\r\n      updateClass(component, toggleConfig, toggleState);\r\n      updateAriaState(component, toggleConfig, toggleState);\r\n    };\r\n    var off = function (component, toggleConfig, toggleState) {\r\n      toggleState.set(false);\r\n      updateClass(component, toggleConfig, toggleState);\r\n      updateAriaState(component, toggleConfig, toggleState);\r\n    };\r\n    var set$1 = function (component, toggleConfig, toggleState, state) {\r\n      var action = state ? on : off;\r\n      action(component, toggleConfig, toggleState);\r\n    };\r\n    var isOn = function (component, toggleConfig, toggleState) {\r\n      return toggleState.get();\r\n    };\r\n    var onLoad = function (component, toggleConfig, toggleState) {\r\n      set$1(component, toggleConfig, toggleState, toggleConfig.selected);\r\n    };\r\n\r\n    var ToggleApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        onLoad: onLoad,\r\n        toggle: toggle$2,\r\n        isOn: isOn,\r\n        on: on,\r\n        off: off,\r\n        set: set$1\r\n    });\r\n\r\n    var exhibit$3 = function () {\r\n      return nu$7({});\r\n    };\r\n    var events$b = function (toggleConfig, toggleState) {\r\n      var execute = executeEvent(toggleConfig, toggleState, toggle$2);\r\n      var load = loadEvent(toggleConfig, toggleState, onLoad);\r\n      return derive$2(flatten([\r\n        toggleConfig.toggleOnExecute ? [execute] : [],\r\n        [load]\r\n      ]));\r\n    };\r\n\r\n    var ActiveToggle = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        exhibit: exhibit$3,\r\n        events: events$b\r\n    });\r\n\r\n    var updatePressed = function (component, ariaInfo, status) {\r\n      set$8(component.element, 'aria-pressed', status);\r\n      if (ariaInfo.syncWithExpanded) {\r\n        updateExpanded(component, ariaInfo, status);\r\n      }\r\n    };\r\n    var updateSelected = function (component, ariaInfo, status) {\r\n      set$8(component.element, 'aria-selected', status);\r\n    };\r\n    var updateChecked = function (component, ariaInfo, status) {\r\n      set$8(component.element, 'aria-checked', status);\r\n    };\r\n    var updateExpanded = function (component, ariaInfo, status) {\r\n      set$8(component.element, 'aria-expanded', status);\r\n    };\r\n\r\n    var ToggleSchema = [\r\n      defaulted('selected', false),\r\n      option('toggleClass'),\r\n      defaulted('toggleOnExecute', true),\r\n      defaultedOf('aria', { mode: 'none' }, choose$1('mode', {\r\n        pressed: [\r\n          defaulted('syncWithExpanded', false),\r\n          output$1('update', updatePressed)\r\n        ],\r\n        checked: [output$1('update', updateChecked)],\r\n        expanded: [output$1('update', updateExpanded)],\r\n        selected: [output$1('update', updateSelected)],\r\n        none: [output$1('update', noop)]\r\n      }))\r\n    ];\r\n\r\n    var Toggling = create$8({\r\n      fields: ToggleSchema,\r\n      name: 'toggling',\r\n      active: ActiveToggle,\r\n      apis: ToggleApis,\r\n      state: SetupBehaviourCellState(false)\r\n    });\r\n\r\n    var pointerEvents = function () {\r\n      var onClick = function (component, simulatedEvent) {\r\n        simulatedEvent.stop();\r\n        emitExecute(component);\r\n      };\r\n      return [\r\n        run$1(click(), onClick),\r\n        run$1(tap(), onClick),\r\n        cutter(touchstart()),\r\n        cutter(mousedown())\r\n      ];\r\n    };\r\n    var events$a = function (optAction) {\r\n      var executeHandler = function (action) {\r\n        return runOnExecute$1(function (component, simulatedEvent) {\r\n          action(component);\r\n          simulatedEvent.stop();\r\n        });\r\n      };\r\n      return derive$2(flatten([\r\n        optAction.map(executeHandler).toArray(),\r\n        pointerEvents()\r\n      ]));\r\n    };\r\n\r\n    var hoverEvent = 'alloy.item-hover';\r\n    var focusEvent = 'alloy.item-focus';\r\n    var onHover = function (item) {\r\n      if (search(item.element).isNone() || Focusing.isFocused(item)) {\r\n        if (!Focusing.isFocused(item)) {\r\n          Focusing.focus(item);\r\n        }\r\n        emitWith(item, hoverEvent, { item: item });\r\n      }\r\n    };\r\n    var onFocus$1 = function (item) {\r\n      emitWith(item, focusEvent, { item: item });\r\n    };\r\n    var hover = constant$1(hoverEvent);\r\n    var focus$1 = constant$1(focusEvent);\r\n\r\n    var builder$2 = function (detail) {\r\n      return {\r\n        dom: detail.dom,\r\n        domModification: __assign(__assign({}, detail.domModification), { attributes: __assign(__assign(__assign({ 'role': detail.toggling.isSome() ? 'menuitemcheckbox' : 'menuitem' }, detail.domModification.attributes), { 'aria-haspopup': detail.hasSubmenu }), detail.hasSubmenu ? { 'aria-expanded': false } : {}) }),\r\n        behaviours: SketchBehaviours.augment(detail.itemBehaviours, [\r\n          detail.toggling.fold(Toggling.revoke, function (tConfig) {\r\n            return Toggling.config(__assign({ aria: { mode: 'checked' } }, tConfig));\r\n          }),\r\n          Focusing.config({\r\n            ignore: detail.ignoreFocus,\r\n            stopMousedown: detail.ignoreFocus,\r\n            onFocus: function (component) {\r\n              onFocus$1(component);\r\n            }\r\n          }),\r\n          Keying.config({ mode: 'execution' }),\r\n          Representing.config({\r\n            store: {\r\n              mode: 'memory',\r\n              initialValue: detail.data\r\n            }\r\n          }),\r\n          config('item-type-events', __spreadArray(__spreadArray([], pointerEvents(), true), [\r\n            run$1(mouseover(), onHover),\r\n            run$1(focusItem(), Focusing.focus)\r\n          ], false))\r\n        ]),\r\n        components: detail.components,\r\n        eventOrder: detail.eventOrder\r\n      };\r\n    };\r\n    var schema$p = [\r\n      required$1('data'),\r\n      required$1('components'),\r\n      required$1('dom'),\r\n      defaulted('hasSubmenu', false),\r\n      option('toggling'),\r\n      SketchBehaviours.field('itemBehaviours', [\r\n        Toggling,\r\n        Focusing,\r\n        Keying,\r\n        Representing\r\n      ]),\r\n      defaulted('ignoreFocus', false),\r\n      defaulted('domModification', {}),\r\n      output$1('builder', builder$2),\r\n      defaulted('eventOrder', {})\r\n    ];\r\n\r\n    var builder$1 = function (detail) {\r\n      return {\r\n        dom: detail.dom,\r\n        components: detail.components,\r\n        events: derive$2([stopper(focusItem())])\r\n      };\r\n    };\r\n    var schema$o = [\r\n      required$1('dom'),\r\n      required$1('components'),\r\n      output$1('builder', builder$1)\r\n    ];\r\n\r\n    var owner$2 = constant$1('item-widget');\r\n    var parts$h = constant$1([required({\r\n        name: 'widget',\r\n        overrides: function (detail) {\r\n          return {\r\n            behaviours: derive$1([Representing.config({\r\n                store: {\r\n                  mode: 'manual',\r\n                  getValue: function (_component) {\r\n                    return detail.data;\r\n                  },\r\n                  setValue: noop\r\n                }\r\n              })])\r\n          };\r\n        }\r\n      })]);\r\n\r\n    var builder = function (detail) {\r\n      var subs = substitutes(owner$2(), detail, parts$h());\r\n      var components = components$1(owner$2(), detail, subs.internals());\r\n      var focusWidget = function (component) {\r\n        return getPart(component, detail, 'widget').map(function (widget) {\r\n          Keying.focusIn(widget);\r\n          return widget;\r\n        });\r\n      };\r\n      var onHorizontalArrow = function (component, simulatedEvent) {\r\n        return inside(simulatedEvent.event.target) ? Optional.none() : function () {\r\n          if (detail.autofocus) {\r\n            simulatedEvent.setSource(component.element);\r\n            return Optional.none();\r\n          } else {\r\n            return Optional.none();\r\n          }\r\n        }();\r\n      };\r\n      return {\r\n        dom: detail.dom,\r\n        components: components,\r\n        domModification: detail.domModification,\r\n        events: derive$2([\r\n          runOnExecute$1(function (component, simulatedEvent) {\r\n            focusWidget(component).each(function (_widget) {\r\n              simulatedEvent.stop();\r\n            });\r\n          }),\r\n          run$1(mouseover(), onHover),\r\n          run$1(focusItem(), function (component, _simulatedEvent) {\r\n            if (detail.autofocus) {\r\n              focusWidget(component);\r\n            } else {\r\n              Focusing.focus(component);\r\n            }\r\n          })\r\n        ]),\r\n        behaviours: SketchBehaviours.augment(detail.widgetBehaviours, [\r\n          Representing.config({\r\n            store: {\r\n              mode: 'memory',\r\n              initialValue: detail.data\r\n            }\r\n          }),\r\n          Focusing.config({\r\n            ignore: detail.ignoreFocus,\r\n            onFocus: function (component) {\r\n              onFocus$1(component);\r\n            }\r\n          }),\r\n          Keying.config({\r\n            mode: 'special',\r\n            focusIn: detail.autofocus ? function (component) {\r\n              focusWidget(component);\r\n            } : revoke(),\r\n            onLeft: onHorizontalArrow,\r\n            onRight: onHorizontalArrow,\r\n            onEscape: function (component, simulatedEvent) {\r\n              if (!Focusing.isFocused(component) && !detail.autofocus) {\r\n                Focusing.focus(component);\r\n                return Optional.some(true);\r\n              } else if (detail.autofocus) {\r\n                simulatedEvent.setSource(component.element);\r\n                return Optional.none();\r\n              } else {\r\n                return Optional.none();\r\n              }\r\n            }\r\n          })\r\n        ])\r\n      };\r\n    };\r\n    var schema$n = [\r\n      required$1('uid'),\r\n      required$1('data'),\r\n      required$1('components'),\r\n      required$1('dom'),\r\n      defaulted('autofocus', false),\r\n      defaulted('ignoreFocus', false),\r\n      SketchBehaviours.field('widgetBehaviours', [\r\n        Representing,\r\n        Focusing,\r\n        Keying\r\n      ]),\r\n      defaulted('domModification', {}),\r\n      defaultUidsSchema(parts$h()),\r\n      output$1('builder', builder)\r\n    ];\r\n\r\n    var itemSchema$2 = choose$1('type', {\r\n      widget: schema$n,\r\n      item: schema$p,\r\n      separator: schema$o\r\n    });\r\n    var configureGrid = function (detail, movementInfo) {\r\n      return {\r\n        mode: 'flatgrid',\r\n        selector: '.' + detail.markers.item,\r\n        initSize: {\r\n          numColumns: movementInfo.initSize.numColumns,\r\n          numRows: movementInfo.initSize.numRows\r\n        },\r\n        focusManager: detail.focusManager\r\n      };\r\n    };\r\n    var configureMatrix = function (detail, movementInfo) {\r\n      return {\r\n        mode: 'matrix',\r\n        selectors: {\r\n          row: movementInfo.rowSelector,\r\n          cell: '.' + detail.markers.item\r\n        },\r\n        focusManager: detail.focusManager\r\n      };\r\n    };\r\n    var configureMenu = function (detail, movementInfo) {\r\n      return {\r\n        mode: 'menu',\r\n        selector: '.' + detail.markers.item,\r\n        moveOnTab: movementInfo.moveOnTab,\r\n        focusManager: detail.focusManager\r\n      };\r\n    };\r\n    var parts$g = constant$1([group({\r\n        factory: {\r\n          sketch: function (spec) {\r\n            var itemInfo = asRawOrDie$1('menu.spec item', itemSchema$2, spec);\r\n            return itemInfo.builder(itemInfo);\r\n          }\r\n        },\r\n        name: 'items',\r\n        unit: 'item',\r\n        defaults: function (detail, u) {\r\n          return has$2(u, 'uid') ? u : __assign(__assign({}, u), { uid: generate$5('item') });\r\n        },\r\n        overrides: function (detail, u) {\r\n          return {\r\n            type: u.type,\r\n            ignoreFocus: detail.fakeFocus,\r\n            domModification: { classes: [detail.markers.item] }\r\n          };\r\n        }\r\n      })]);\r\n    var schema$m = constant$1([\r\n      required$1('value'),\r\n      required$1('items'),\r\n      required$1('dom'),\r\n      required$1('components'),\r\n      defaulted('eventOrder', {}),\r\n      field('menuBehaviours', [\r\n        Highlighting,\r\n        Representing,\r\n        Composing,\r\n        Keying\r\n      ]),\r\n      defaultedOf('movement', {\r\n        mode: 'menu',\r\n        moveOnTab: true\r\n      }, choose$1('mode', {\r\n        grid: [\r\n          initSize(),\r\n          output$1('config', configureGrid)\r\n        ],\r\n        matrix: [\r\n          output$1('config', configureMatrix),\r\n          required$1('rowSelector')\r\n        ],\r\n        menu: [\r\n          defaulted('moveOnTab', true),\r\n          output$1('config', configureMenu)\r\n        ]\r\n      })),\r\n      itemMarkers(),\r\n      defaulted('fakeFocus', false),\r\n      defaulted('focusManager', dom$2()),\r\n      onHandler('onHighlight')\r\n    ]);\r\n\r\n    var focus = constant$1('alloy.menu-focus');\r\n\r\n    var make$7 = function (detail, components, _spec, _externals) {\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        markers: detail.markers,\r\n        behaviours: augment(detail.menuBehaviours, [\r\n          Highlighting.config({\r\n            highlightClass: detail.markers.selectedItem,\r\n            itemClass: detail.markers.item,\r\n            onHighlight: detail.onHighlight\r\n          }),\r\n          Representing.config({\r\n            store: {\r\n              mode: 'memory',\r\n              initialValue: detail.value\r\n            }\r\n          }),\r\n          Composing.config({ find: Optional.some }),\r\n          Keying.config(detail.movement.config(detail, detail.movement))\r\n        ]),\r\n        events: derive$2([\r\n          run$1(focus$1(), function (menu, simulatedEvent) {\r\n            var event = simulatedEvent.event;\r\n            menu.getSystem().getByDom(event.target).each(function (item) {\r\n              Highlighting.highlight(menu, item);\r\n              simulatedEvent.stop();\r\n              emitWith(menu, focus(), {\r\n                menu: menu,\r\n                item: item\r\n              });\r\n            });\r\n          }),\r\n          run$1(hover(), function (menu, simulatedEvent) {\r\n            var item = simulatedEvent.event.item;\r\n            Highlighting.highlight(menu, item);\r\n          })\r\n        ]),\r\n        components: components,\r\n        eventOrder: detail.eventOrder,\r\n        domModification: { attributes: { role: 'menu' } }\r\n      };\r\n    };\r\n\r\n    var Menu = composite({\r\n      name: 'Menu',\r\n      configFields: schema$m(),\r\n      partFields: parts$g(),\r\n      factory: make$7\r\n    });\r\n\r\n    var transpose$1 = function (obj) {\r\n      return tupleMap(obj, function (v, k) {\r\n        return {\r\n          k: v,\r\n          v: k\r\n        };\r\n      });\r\n    };\r\n    var trace = function (items, byItem, byMenu, finish) {\r\n      return get$e(byMenu, finish).bind(function (triggerItem) {\r\n        return get$e(items, triggerItem).bind(function (triggerMenu) {\r\n          var rest = trace(items, byItem, byMenu, triggerMenu);\r\n          return Optional.some([triggerMenu].concat(rest));\r\n        });\r\n      }).getOr([]);\r\n    };\r\n    var generate$2 = function (menus, expansions) {\r\n      var items = {};\r\n      each(menus, function (menuItems, menu) {\r\n        each$1(menuItems, function (item) {\r\n          items[item] = menu;\r\n        });\r\n      });\r\n      var byItem = expansions;\r\n      var byMenu = transpose$1(expansions);\r\n      var menuPaths = map$1(byMenu, function (_triggerItem, submenu) {\r\n        return [submenu].concat(trace(items, byItem, byMenu, submenu));\r\n      });\r\n      return map$1(items, function (menu) {\r\n        return get$e(menuPaths, menu).getOr([menu]);\r\n      });\r\n    };\r\n\r\n    var init$c = function () {\r\n      var expansions = Cell({});\r\n      var menus = Cell({});\r\n      var paths = Cell({});\r\n      var primary = value$1();\r\n      var directory = Cell({});\r\n      var clear = function () {\r\n        expansions.set({});\r\n        menus.set({});\r\n        paths.set({});\r\n        primary.clear();\r\n      };\r\n      var isClear = function () {\r\n        return primary.get().isNone();\r\n      };\r\n      var setMenuBuilt = function (menuName, built) {\r\n        var _a;\r\n        menus.set(__assign(__assign({}, menus.get()), (_a = {}, _a[menuName] = {\r\n          type: 'prepared',\r\n          menu: built\r\n        }, _a)));\r\n      };\r\n      var setContents = function (sPrimary, sMenus, sExpansions, dir) {\r\n        primary.set(sPrimary);\r\n        expansions.set(sExpansions);\r\n        menus.set(sMenus);\r\n        directory.set(dir);\r\n        var sPaths = generate$2(dir, sExpansions);\r\n        paths.set(sPaths);\r\n      };\r\n      var getTriggeringItem = function (menuValue) {\r\n        return find$4(expansions.get(), function (v, _k) {\r\n          return v === menuValue;\r\n        });\r\n      };\r\n      var getTriggerData = function (menuValue, getItemByValue, path) {\r\n        return getPreparedMenu(menuValue).bind(function (menu) {\r\n          return getTriggeringItem(menuValue).bind(function (triggeringItemValue) {\r\n            return getItemByValue(triggeringItemValue).map(function (triggeredItem) {\r\n              return {\r\n                triggeredMenu: menu,\r\n                triggeringItem: triggeredItem,\r\n                triggeringPath: path\r\n              };\r\n            });\r\n          });\r\n        });\r\n      };\r\n      var getTriggeringPath = function (itemValue, getItemByValue) {\r\n        var extraPath = filter$2(lookupItem(itemValue).toArray(), function (menuValue) {\r\n          return getPreparedMenu(menuValue).isSome();\r\n        });\r\n        return get$e(paths.get(), itemValue).bind(function (path) {\r\n          var revPath = reverse(extraPath.concat(path));\r\n          var triggers = bind$3(revPath, function (menuValue, menuIndex) {\r\n            return getTriggerData(menuValue, getItemByValue, revPath.slice(0, menuIndex + 1)).fold(function () {\r\n              return is$1(primary.get(), menuValue) ? [] : [Optional.none()];\r\n            }, function (data) {\r\n              return [Optional.some(data)];\r\n            });\r\n          });\r\n          return sequence(triggers);\r\n        });\r\n      };\r\n      var expand = function (itemValue) {\r\n        return get$e(expansions.get(), itemValue).map(function (menu) {\r\n          var current = get$e(paths.get(), itemValue).getOr([]);\r\n          return [menu].concat(current);\r\n        });\r\n      };\r\n      var collapse = function (itemValue) {\r\n        return get$e(paths.get(), itemValue).bind(function (path) {\r\n          return path.length > 1 ? Optional.some(path.slice(1)) : Optional.none();\r\n        });\r\n      };\r\n      var refresh = function (itemValue) {\r\n        return get$e(paths.get(), itemValue);\r\n      };\r\n      var getPreparedMenu = function (menuValue) {\r\n        return lookupMenu(menuValue).bind(extractPreparedMenu);\r\n      };\r\n      var lookupMenu = function (menuValue) {\r\n        return get$e(menus.get(), menuValue);\r\n      };\r\n      var lookupItem = function (itemValue) {\r\n        return get$e(expansions.get(), itemValue);\r\n      };\r\n      var otherMenus = function (path) {\r\n        var menuValues = directory.get();\r\n        return difference(keys(menuValues), path);\r\n      };\r\n      var getPrimary = function () {\r\n        return primary.get().bind(getPreparedMenu);\r\n      };\r\n      var getMenus = function () {\r\n        return menus.get();\r\n      };\r\n      return {\r\n        setMenuBuilt: setMenuBuilt,\r\n        setContents: setContents,\r\n        expand: expand,\r\n        refresh: refresh,\r\n        collapse: collapse,\r\n        lookupMenu: lookupMenu,\r\n        lookupItem: lookupItem,\r\n        otherMenus: otherMenus,\r\n        getPrimary: getPrimary,\r\n        getMenus: getMenus,\r\n        clear: clear,\r\n        isClear: isClear,\r\n        getTriggeringPath: getTriggeringPath\r\n      };\r\n    };\r\n    var extractPreparedMenu = function (prep) {\r\n      return prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none();\r\n    };\r\n    var LayeredState = {\r\n      init: init$c,\r\n      extractPreparedMenu: extractPreparedMenu\r\n    };\r\n\r\n    var make$6 = function (detail, _rawUiSpec) {\r\n      var submenuParentItems = value$1();\r\n      var buildMenus = function (container, primaryName, menus) {\r\n        return map$1(menus, function (spec, name) {\r\n          var makeSketch = function () {\r\n            return Menu.sketch(__assign(__assign({}, spec), {\r\n              value: name,\r\n              markers: detail.markers,\r\n              fakeFocus: detail.fakeFocus,\r\n              onHighlight: detail.onHighlight,\r\n              focusManager: detail.fakeFocus ? highlights() : dom$2()\r\n            }));\r\n          };\r\n          return name === primaryName ? {\r\n            type: 'prepared',\r\n            menu: container.getSystem().build(makeSketch())\r\n          } : {\r\n            type: 'notbuilt',\r\n            nbMenu: makeSketch\r\n          };\r\n        });\r\n      };\r\n      var layeredState = LayeredState.init();\r\n      var setup = function (container) {\r\n        var componentMap = buildMenus(container, detail.data.primary, detail.data.menus);\r\n        var directory = toDirectory();\r\n        layeredState.setContents(detail.data.primary, componentMap, detail.data.expansions, directory);\r\n        return layeredState.getPrimary();\r\n      };\r\n      var getItemValue = function (item) {\r\n        return Representing.getValue(item).value;\r\n      };\r\n      var getItemByValue = function (_container, menus, itemValue) {\r\n        return findMap(menus, function (menu) {\r\n          if (!menu.getSystem().isConnected()) {\r\n            return Optional.none();\r\n          }\r\n          var candidates = Highlighting.getCandidates(menu);\r\n          return find$5(candidates, function (c) {\r\n            return getItemValue(c) === itemValue;\r\n          });\r\n        });\r\n      };\r\n      var toDirectory = function (_container) {\r\n        return map$1(detail.data.menus, function (data, _menuName) {\r\n          return bind$3(data.items, function (item) {\r\n            return item.type === 'separator' ? [] : [item.data.value];\r\n          });\r\n        });\r\n      };\r\n      var setActiveMenu = function (container, menu) {\r\n        Highlighting.highlight(container, menu);\r\n        Highlighting.getHighlighted(menu).orThunk(function () {\r\n          return Highlighting.getFirst(menu);\r\n        }).each(function (item) {\r\n          dispatch(container, item.element, focusItem());\r\n        });\r\n      };\r\n      var getMenus = function (state, menuValues) {\r\n        return cat(map$2(menuValues, function (mv) {\r\n          return state.lookupMenu(mv).bind(function (prep) {\r\n            return prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none();\r\n          });\r\n        }));\r\n      };\r\n      var closeOthers = function (container, state, path) {\r\n        var others = getMenus(state, state.otherMenus(path));\r\n        each$1(others, function (o) {\r\n          remove$1(o.element, [detail.markers.backgroundMenu]);\r\n          if (!detail.stayInDom) {\r\n            Replacing.remove(container, o);\r\n          }\r\n        });\r\n      };\r\n      var getSubmenuParents = function (container) {\r\n        return submenuParentItems.get().getOrThunk(function () {\r\n          var r = {};\r\n          var items = descendants(container.element, '.' + detail.markers.item);\r\n          var parentItems = filter$2(items, function (i) {\r\n            return get$d(i, 'aria-haspopup') === 'true';\r\n          });\r\n          each$1(parentItems, function (i) {\r\n            container.getSystem().getByDom(i).each(function (itemComp) {\r\n              var key = getItemValue(itemComp);\r\n              r[key] = itemComp;\r\n            });\r\n          });\r\n          submenuParentItems.set(r);\r\n          return r;\r\n        });\r\n      };\r\n      var updateAriaExpansions = function (container, path) {\r\n        var parentItems = getSubmenuParents(container);\r\n        each(parentItems, function (v, k) {\r\n          var expanded = contains$2(path, k);\r\n          set$8(v.element, 'aria-expanded', expanded);\r\n        });\r\n      };\r\n      var updateMenuPath = function (container, state, path) {\r\n        return Optional.from(path[0]).bind(function (latestMenuName) {\r\n          return state.lookupMenu(latestMenuName).bind(function (menuPrep) {\r\n            if (menuPrep.type === 'notbuilt') {\r\n              return Optional.none();\r\n            } else {\r\n              var activeMenu = menuPrep.menu;\r\n              var rest = getMenus(state, path.slice(1));\r\n              each$1(rest, function (r) {\r\n                add$2(r.element, detail.markers.backgroundMenu);\r\n              });\r\n              if (!inBody(activeMenu.element)) {\r\n                Replacing.append(container, premade(activeMenu));\r\n              }\r\n              remove$1(activeMenu.element, [detail.markers.backgroundMenu]);\r\n              setActiveMenu(container, activeMenu);\r\n              closeOthers(container, state, path);\r\n              return Optional.some(activeMenu);\r\n            }\r\n          });\r\n        });\r\n      };\r\n      var ExpandHighlightDecision;\r\n      (function (ExpandHighlightDecision) {\r\n        ExpandHighlightDecision[ExpandHighlightDecision['HighlightSubmenu'] = 0] = 'HighlightSubmenu';\r\n        ExpandHighlightDecision[ExpandHighlightDecision['HighlightParent'] = 1] = 'HighlightParent';\r\n      }(ExpandHighlightDecision || (ExpandHighlightDecision = {})));\r\n      var buildIfRequired = function (container, menuName, menuPrep) {\r\n        if (menuPrep.type === 'notbuilt') {\r\n          var menu = container.getSystem().build(menuPrep.nbMenu());\r\n          layeredState.setMenuBuilt(menuName, menu);\r\n          return menu;\r\n        } else {\r\n          return menuPrep.menu;\r\n        }\r\n      };\r\n      var expandRight = function (container, item, decision) {\r\n        if (decision === void 0) {\r\n          decision = ExpandHighlightDecision.HighlightSubmenu;\r\n        }\r\n        if (item.hasConfigured(Disabling) && Disabling.isDisabled(item)) {\r\n          return Optional.some(item);\r\n        } else {\r\n          var value = getItemValue(item);\r\n          return layeredState.expand(value).bind(function (path) {\r\n            updateAriaExpansions(container, path);\r\n            return Optional.from(path[0]).bind(function (menuName) {\r\n              return layeredState.lookupMenu(menuName).bind(function (activeMenuPrep) {\r\n                var activeMenu = buildIfRequired(container, menuName, activeMenuPrep);\r\n                if (!inBody(activeMenu.element)) {\r\n                  Replacing.append(container, premade(activeMenu));\r\n                }\r\n                detail.onOpenSubmenu(container, item, activeMenu, reverse(path));\r\n                if (decision === ExpandHighlightDecision.HighlightSubmenu) {\r\n                  Highlighting.highlightFirst(activeMenu);\r\n                  return updateMenuPath(container, layeredState, path);\r\n                } else {\r\n                  Highlighting.dehighlightAll(activeMenu);\r\n                  return Optional.some(item);\r\n                }\r\n              });\r\n            });\r\n          });\r\n        }\r\n      };\r\n      var collapseLeft = function (container, item) {\r\n        var value = getItemValue(item);\r\n        return layeredState.collapse(value).bind(function (path) {\r\n          updateAriaExpansions(container, path);\r\n          return updateMenuPath(container, layeredState, path).map(function (activeMenu) {\r\n            detail.onCollapseMenu(container, item, activeMenu);\r\n            return activeMenu;\r\n          });\r\n        });\r\n      };\r\n      var updateView = function (container, item) {\r\n        var value = getItemValue(item);\r\n        return layeredState.refresh(value).bind(function (path) {\r\n          updateAriaExpansions(container, path);\r\n          return updateMenuPath(container, layeredState, path);\r\n        });\r\n      };\r\n      var onRight = function (container, item) {\r\n        return inside(item.element) ? Optional.none() : expandRight(container, item, ExpandHighlightDecision.HighlightSubmenu);\r\n      };\r\n      var onLeft = function (container, item) {\r\n        return inside(item.element) ? Optional.none() : collapseLeft(container, item);\r\n      };\r\n      var onEscape = function (container, item) {\r\n        return collapseLeft(container, item).orThunk(function () {\r\n          return detail.onEscape(container, item).map(function () {\r\n            return container;\r\n          });\r\n        });\r\n      };\r\n      var keyOnItem = function (f) {\r\n        return function (container, simulatedEvent) {\r\n          return closest$1(simulatedEvent.getSource(), '.' + detail.markers.item).bind(function (target) {\r\n            return container.getSystem().getByDom(target).toOptional().bind(function (item) {\r\n              return f(container, item).map(always);\r\n            });\r\n          });\r\n        };\r\n      };\r\n      var events = derive$2([\r\n        run$1(focus(), function (sandbox, simulatedEvent) {\r\n          var item = simulatedEvent.event.item;\r\n          layeredState.lookupItem(getItemValue(item)).each(function () {\r\n            var menu = simulatedEvent.event.menu;\r\n            Highlighting.highlight(sandbox, menu);\r\n            var value = getItemValue(simulatedEvent.event.item);\r\n            layeredState.refresh(value).each(function (path) {\r\n              return closeOthers(sandbox, layeredState, path);\r\n            });\r\n          });\r\n        }),\r\n        runOnExecute$1(function (component, simulatedEvent) {\r\n          var target = simulatedEvent.event.target;\r\n          component.getSystem().getByDom(target).each(function (item) {\r\n            var itemValue = getItemValue(item);\r\n            if (itemValue.indexOf('collapse-item') === 0) {\r\n              collapseLeft(component, item);\r\n            }\r\n            expandRight(component, item, ExpandHighlightDecision.HighlightSubmenu).fold(function () {\r\n              detail.onExecute(component, item);\r\n            }, noop);\r\n          });\r\n        }),\r\n        runOnAttached(function (container, _simulatedEvent) {\r\n          setup(container).each(function (primary) {\r\n            Replacing.append(container, premade(primary));\r\n            detail.onOpenMenu(container, primary);\r\n            if (detail.highlightImmediately) {\r\n              setActiveMenu(container, primary);\r\n            }\r\n          });\r\n        })\r\n      ].concat(detail.navigateOnHover ? [run$1(hover(), function (sandbox, simulatedEvent) {\r\n          var item = simulatedEvent.event.item;\r\n          updateView(sandbox, item);\r\n          expandRight(sandbox, item, ExpandHighlightDecision.HighlightParent);\r\n          detail.onHover(sandbox, item);\r\n        })] : []));\r\n      var getActiveItem = function (container) {\r\n        return Highlighting.getHighlighted(container).bind(Highlighting.getHighlighted);\r\n      };\r\n      var collapseMenuApi = function (container) {\r\n        getActiveItem(container).each(function (currentItem) {\r\n          collapseLeft(container, currentItem);\r\n        });\r\n      };\r\n      var highlightPrimary = function (container) {\r\n        layeredState.getPrimary().each(function (primary) {\r\n          setActiveMenu(container, primary);\r\n        });\r\n      };\r\n      var extractMenuFromContainer = function (container) {\r\n        return Optional.from(container.components()[0]).filter(function (comp) {\r\n          return get$d(comp.element, 'role') === 'menu';\r\n        });\r\n      };\r\n      var repositionMenus = function (container) {\r\n        var maybeActivePrimary = layeredState.getPrimary().bind(function (primary) {\r\n          return getActiveItem(container).bind(function (currentItem) {\r\n            var itemValue = getItemValue(currentItem);\r\n            var allMenus = values(layeredState.getMenus());\r\n            var preparedMenus = cat(map$2(allMenus, LayeredState.extractPreparedMenu));\r\n            return layeredState.getTriggeringPath(itemValue, function (v) {\r\n              return getItemByValue(container, preparedMenus, v);\r\n            });\r\n          }).map(function (triggeringPath) {\r\n            return {\r\n              primary: primary,\r\n              triggeringPath: triggeringPath\r\n            };\r\n          });\r\n        });\r\n        maybeActivePrimary.fold(function () {\r\n          extractMenuFromContainer(container).each(function (primaryMenu) {\r\n            detail.onRepositionMenu(container, primaryMenu, []);\r\n          });\r\n        }, function (_a) {\r\n          var primary = _a.primary, triggeringPath = _a.triggeringPath;\r\n          detail.onRepositionMenu(container, primary, triggeringPath);\r\n        });\r\n      };\r\n      var apis = {\r\n        collapseMenu: collapseMenuApi,\r\n        highlightPrimary: highlightPrimary,\r\n        repositionMenus: repositionMenus\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        markers: detail.markers,\r\n        behaviours: augment(detail.tmenuBehaviours, [\r\n          Keying.config({\r\n            mode: 'special',\r\n            onRight: keyOnItem(onRight),\r\n            onLeft: keyOnItem(onLeft),\r\n            onEscape: keyOnItem(onEscape),\r\n            focusIn: function (container, _keyInfo) {\r\n              layeredState.getPrimary().each(function (primary) {\r\n                dispatch(container, primary.element, focusItem());\r\n              });\r\n            }\r\n          }),\r\n          Highlighting.config({\r\n            highlightClass: detail.markers.selectedMenu,\r\n            itemClass: detail.markers.menu\r\n          }),\r\n          Composing.config({\r\n            find: function (container) {\r\n              return Highlighting.getHighlighted(container);\r\n            }\r\n          }),\r\n          Replacing.config({})\r\n        ]),\r\n        eventOrder: detail.eventOrder,\r\n        apis: apis,\r\n        events: events\r\n      };\r\n    };\r\n    var collapseItem$1 = constant$1('collapse-item');\r\n\r\n    var tieredData = function (primary, menus, expansions) {\r\n      return {\r\n        primary: primary,\r\n        menus: menus,\r\n        expansions: expansions\r\n      };\r\n    };\r\n    var singleData = function (name, menu) {\r\n      return {\r\n        primary: name,\r\n        menus: wrap$1(name, menu),\r\n        expansions: {}\r\n      };\r\n    };\r\n    var collapseItem = function (text) {\r\n      return {\r\n        value: generate$6(collapseItem$1()),\r\n        meta: { text: text }\r\n      };\r\n    };\r\n    var tieredMenu = single({\r\n      name: 'TieredMenu',\r\n      configFields: [\r\n        onStrictKeyboardHandler('onExecute'),\r\n        onStrictKeyboardHandler('onEscape'),\r\n        onStrictHandler('onOpenMenu'),\r\n        onStrictHandler('onOpenSubmenu'),\r\n        onHandler('onRepositionMenu'),\r\n        onHandler('onCollapseMenu'),\r\n        defaulted('highlightImmediately', true),\r\n        requiredObjOf('data', [\r\n          required$1('primary'),\r\n          required$1('menus'),\r\n          required$1('expansions')\r\n        ]),\r\n        defaulted('fakeFocus', false),\r\n        onHandler('onHighlight'),\r\n        onHandler('onHover'),\r\n        tieredMenuMarkers(),\r\n        required$1('dom'),\r\n        defaulted('navigateOnHover', true),\r\n        defaulted('stayInDom', false),\r\n        field('tmenuBehaviours', [\r\n          Keying,\r\n          Highlighting,\r\n          Composing,\r\n          Replacing\r\n        ]),\r\n        defaulted('eventOrder', {})\r\n      ],\r\n      apis: {\r\n        collapseMenu: function (apis, tmenu) {\r\n          apis.collapseMenu(tmenu);\r\n        },\r\n        highlightPrimary: function (apis, tmenu) {\r\n          apis.highlightPrimary(tmenu);\r\n        },\r\n        repositionMenus: function (apis, tmenu) {\r\n          apis.repositionMenus(tmenu);\r\n        }\r\n      },\r\n      factory: make$6,\r\n      extraApis: {\r\n        tieredData: tieredData,\r\n        singleData: singleData,\r\n        collapseItem: collapseItem\r\n      }\r\n    });\r\n\r\n    var makeMenu = function (detail, menuSandbox, placementSpec, menuSpec, getBounds) {\r\n      var lazySink = function () {\r\n        return detail.lazySink(menuSandbox);\r\n      };\r\n      var layouts = menuSpec.type === 'horizontal' ? {\r\n        layouts: {\r\n          onLtr: function () {\r\n            return belowOrAbove();\r\n          },\r\n          onRtl: function () {\r\n            return belowOrAboveRtl();\r\n          }\r\n        }\r\n      } : {};\r\n      var isFirstTierSubmenu = function (triggeringPaths) {\r\n        return triggeringPaths.length === 2;\r\n      };\r\n      var getSubmenuLayouts = function (triggeringPaths) {\r\n        return isFirstTierSubmenu(triggeringPaths) ? layouts : {};\r\n      };\r\n      return tieredMenu.sketch({\r\n        dom: { tag: 'div' },\r\n        data: menuSpec.data,\r\n        markers: menuSpec.menu.markers,\r\n        highlightImmediately: menuSpec.menu.highlightImmediately,\r\n        onEscape: function () {\r\n          Sandboxing.close(menuSandbox);\r\n          detail.onEscape.map(function (handler) {\r\n            return handler(menuSandbox);\r\n          });\r\n          return Optional.some(true);\r\n        },\r\n        onExecute: function () {\r\n          return Optional.some(true);\r\n        },\r\n        onOpenMenu: function (tmenu, menu) {\r\n          Positioning.positionWithinBounds(lazySink().getOrDie(), menu, placementSpec, getBounds());\r\n        },\r\n        onOpenSubmenu: function (tmenu, item, submenu, triggeringPaths) {\r\n          var sink = lazySink().getOrDie();\r\n          Positioning.position(sink, submenu, {\r\n            anchor: __assign({\r\n              type: 'submenu',\r\n              item: item\r\n            }, getSubmenuLayouts(triggeringPaths))\r\n          });\r\n        },\r\n        onRepositionMenu: function (tmenu, primaryMenu, submenuTriggers) {\r\n          var sink = lazySink().getOrDie();\r\n          Positioning.positionWithinBounds(sink, primaryMenu, placementSpec, getBounds());\r\n          each$1(submenuTriggers, function (st) {\r\n            var submenuLayouts = getSubmenuLayouts(st.triggeringPath);\r\n            Positioning.position(sink, st.triggeredMenu, {\r\n              anchor: __assign({\r\n                type: 'submenu',\r\n                item: st.triggeringItem\r\n              }, submenuLayouts)\r\n            });\r\n          });\r\n        }\r\n      });\r\n    };\r\n    var factory$m = function (detail, spec) {\r\n      var isPartOfRelated = function (sandbox, queryElem) {\r\n        var related = detail.getRelated(sandbox);\r\n        return related.exists(function (rel) {\r\n          return isPartOf$1(rel, queryElem);\r\n        });\r\n      };\r\n      var setContent = function (sandbox, thing) {\r\n        Sandboxing.setContent(sandbox, thing);\r\n      };\r\n      var showAt = function (sandbox, thing, placementSpec) {\r\n        showWithin(sandbox, thing, placementSpec, Optional.none());\r\n      };\r\n      var showWithin = function (sandbox, thing, placementSpec, boxElement) {\r\n        showWithinBounds(sandbox, thing, placementSpec, function () {\r\n          return boxElement.map(function (elem) {\r\n            return box$1(elem);\r\n          });\r\n        });\r\n      };\r\n      var showWithinBounds = function (sandbox, thing, placementSpec, getBounds) {\r\n        var sink = detail.lazySink(sandbox).getOrDie();\r\n        Sandboxing.openWhileCloaked(sandbox, thing, function () {\r\n          return Positioning.positionWithinBounds(sink, sandbox, placementSpec, getBounds());\r\n        });\r\n        Representing.setValue(sandbox, Optional.some({\r\n          mode: 'position',\r\n          config: placementSpec,\r\n          getBounds: getBounds\r\n        }));\r\n      };\r\n      var showMenuAt = function (sandbox, placementSpec, menuSpec) {\r\n        showMenuWithinBounds(sandbox, placementSpec, menuSpec, Optional.none);\r\n      };\r\n      var showMenuWithinBounds = function (sandbox, placementSpec, menuSpec, getBounds) {\r\n        var menu = makeMenu(detail, sandbox, placementSpec, menuSpec, getBounds);\r\n        Sandboxing.open(sandbox, menu);\r\n        Representing.setValue(sandbox, Optional.some({\r\n          mode: 'menu',\r\n          menu: menu\r\n        }));\r\n      };\r\n      var hide = function (sandbox) {\r\n        if (Sandboxing.isOpen(sandbox)) {\r\n          Representing.setValue(sandbox, Optional.none());\r\n          Sandboxing.close(sandbox);\r\n        }\r\n      };\r\n      var getContent = function (sandbox) {\r\n        return Sandboxing.getState(sandbox);\r\n      };\r\n      var reposition = function (sandbox) {\r\n        if (Sandboxing.isOpen(sandbox)) {\r\n          Representing.getValue(sandbox).each(function (state) {\r\n            switch (state.mode) {\r\n            case 'menu':\r\n              Sandboxing.getState(sandbox).each(tieredMenu.repositionMenus);\r\n              break;\r\n            case 'position':\r\n              var sink = detail.lazySink(sandbox).getOrDie();\r\n              Positioning.positionWithinBounds(sink, sandbox, state.config, state.getBounds());\r\n              break;\r\n            }\r\n          });\r\n        }\r\n      };\r\n      var apis = {\r\n        setContent: setContent,\r\n        showAt: showAt,\r\n        showWithin: showWithin,\r\n        showWithinBounds: showWithinBounds,\r\n        showMenuAt: showMenuAt,\r\n        showMenuWithinBounds: showMenuWithinBounds,\r\n        hide: hide,\r\n        getContent: getContent,\r\n        reposition: reposition,\r\n        isOpen: Sandboxing.isOpen\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        behaviours: augment(detail.inlineBehaviours, [\r\n          Sandboxing.config({\r\n            isPartOf: function (sandbox, data, queryElem) {\r\n              return isPartOf$1(data, queryElem) || isPartOfRelated(sandbox, queryElem);\r\n            },\r\n            getAttachPoint: function (sandbox) {\r\n              return detail.lazySink(sandbox).getOrDie();\r\n            },\r\n            onOpen: function (sandbox) {\r\n              detail.onShow(sandbox);\r\n            },\r\n            onClose: function (sandbox) {\r\n              detail.onHide(sandbox);\r\n            }\r\n          }),\r\n          Representing.config({\r\n            store: {\r\n              mode: 'memory',\r\n              initialValue: Optional.none()\r\n            }\r\n          }),\r\n          Receiving.config({\r\n            channels: __assign(__assign({}, receivingChannel$1(__assign({ isExtraPart: spec.isExtraPart }, detail.fireDismissalEventInstead.map(function (fe) {\r\n              return { fireEventInstead: { event: fe.event } };\r\n            }).getOr({})))), receivingChannel(__assign(__assign({}, detail.fireRepositionEventInstead.map(function (fe) {\r\n              return { fireEventInstead: { event: fe.event } };\r\n            }).getOr({})), { doReposition: reposition })))\r\n          })\r\n        ]),\r\n        eventOrder: detail.eventOrder,\r\n        apis: apis\r\n      };\r\n    };\r\n    var InlineView = single({\r\n      name: 'InlineView',\r\n      configFields: [\r\n        required$1('lazySink'),\r\n        onHandler('onShow'),\r\n        onHandler('onHide'),\r\n        optionFunction('onEscape'),\r\n        field('inlineBehaviours', [\r\n          Sandboxing,\r\n          Representing,\r\n          Receiving\r\n        ]),\r\n        optionObjOf('fireDismissalEventInstead', [defaulted('event', dismissRequested())]),\r\n        optionObjOf('fireRepositionEventInstead', [defaulted('event', repositionRequested())]),\r\n        defaulted('getRelated', Optional.none),\r\n        defaulted('isExtraPart', never),\r\n        defaulted('eventOrder', Optional.none)\r\n      ],\r\n      factory: factory$m,\r\n      apis: {\r\n        showAt: function (apis, component, anchor, thing) {\r\n          apis.showAt(component, anchor, thing);\r\n        },\r\n        showWithin: function (apis, component, anchor, thing, boxElement) {\r\n          apis.showWithin(component, anchor, thing, boxElement);\r\n        },\r\n        showWithinBounds: function (apis, component, anchor, thing, bounds) {\r\n          apis.showWithinBounds(component, anchor, thing, bounds);\r\n        },\r\n        showMenuAt: function (apis, component, anchor, menuSpec) {\r\n          apis.showMenuAt(component, anchor, menuSpec);\r\n        },\r\n        showMenuWithinBounds: function (apis, component, anchor, menuSpec, bounds) {\r\n          apis.showMenuWithinBounds(component, anchor, menuSpec, bounds);\r\n        },\r\n        hide: function (apis, component) {\r\n          apis.hide(component);\r\n        },\r\n        isOpen: function (apis, component) {\r\n          return apis.isOpen(component);\r\n        },\r\n        getContent: function (apis, component) {\r\n          return apis.getContent(component);\r\n        },\r\n        setContent: function (apis, component, thing) {\r\n          apis.setContent(component, thing);\r\n        },\r\n        reposition: function (apis, component) {\r\n          apis.reposition(component);\r\n        }\r\n      }\r\n    });\r\n\r\n    var labelPrefix = 'layout-inset';\r\n    var westEdgeX = function (anchor) {\r\n      return anchor.x;\r\n    };\r\n    var middleX = function (anchor, element) {\r\n      return anchor.x + anchor.width / 2 - element.width / 2;\r\n    };\r\n    var eastEdgeX = function (anchor, element) {\r\n      return anchor.x + anchor.width - element.width;\r\n    };\r\n    var northY = function (anchor) {\r\n      return anchor.y;\r\n    };\r\n    var southY = function (anchor, element) {\r\n      return anchor.y + anchor.height - element.height;\r\n    };\r\n    var centreY = function (anchor, element) {\r\n      return anchor.y + anchor.height / 2 - element.height / 2;\r\n    };\r\n    var southwest = function (anchor, element, bubbles) {\r\n      return nu$6(eastEdgeX(anchor, element), southY(anchor, element), bubbles.insetSouthwest(), northwest$3(), 'southwest', boundsRestriction(anchor, {\r\n        right: 0,\r\n        bottom: 3\r\n      }), labelPrefix);\r\n    };\r\n    var southeast = function (anchor, element, bubbles) {\r\n      return nu$6(westEdgeX(anchor), southY(anchor, element), bubbles.insetSoutheast(), northeast$3(), 'southeast', boundsRestriction(anchor, {\r\n        left: 1,\r\n        bottom: 3\r\n      }), labelPrefix);\r\n    };\r\n    var northwest = function (anchor, element, bubbles) {\r\n      return nu$6(eastEdgeX(anchor, element), northY(anchor), bubbles.insetNorthwest(), southwest$3(), 'northwest', boundsRestriction(anchor, {\r\n        right: 0,\r\n        top: 2\r\n      }), labelPrefix);\r\n    };\r\n    var northeast = function (anchor, element, bubbles) {\r\n      return nu$6(westEdgeX(anchor), northY(anchor), bubbles.insetNortheast(), southeast$3(), 'northeast', boundsRestriction(anchor, {\r\n        left: 1,\r\n        top: 2\r\n      }), labelPrefix);\r\n    };\r\n    var north = function (anchor, element, bubbles) {\r\n      return nu$6(middleX(anchor, element), northY(anchor), bubbles.insetNorth(), south$3(), 'north', boundsRestriction(anchor, { top: 2 }), labelPrefix);\r\n    };\r\n    var south = function (anchor, element, bubbles) {\r\n      return nu$6(middleX(anchor, element), southY(anchor, element), bubbles.insetSouth(), north$3(), 'south', boundsRestriction(anchor, { bottom: 3 }), labelPrefix);\r\n    };\r\n    var east = function (anchor, element, bubbles) {\r\n      return nu$6(eastEdgeX(anchor, element), centreY(anchor, element), bubbles.insetEast(), west$3(), 'east', boundsRestriction(anchor, { right: 0 }), labelPrefix);\r\n    };\r\n    var west = function (anchor, element, bubbles) {\r\n      return nu$6(westEdgeX(anchor), centreY(anchor, element), bubbles.insetWest(), east$3(), 'west', boundsRestriction(anchor, { left: 1 }), labelPrefix);\r\n    };\r\n    var lookupPreserveLayout = function (lastPlacement) {\r\n      switch (lastPlacement) {\r\n      case 'north':\r\n        return north;\r\n      case 'northeast':\r\n        return northeast;\r\n      case 'northwest':\r\n        return northwest;\r\n      case 'south':\r\n        return south;\r\n      case 'southeast':\r\n        return southeast;\r\n      case 'southwest':\r\n        return southwest;\r\n      case 'east':\r\n        return east;\r\n      case 'west':\r\n        return west;\r\n      }\r\n    };\r\n    var preserve = function (anchor, element, bubbles, placee, bounds) {\r\n      var layout = getPlacement(placee).map(lookupPreserveLayout).getOr(north);\r\n      return layout(anchor, element, bubbles, placee, bounds);\r\n    };\r\n    var lookupFlippedLayout = function (lastPlacement) {\r\n      switch (lastPlacement) {\r\n      case 'north':\r\n        return south;\r\n      case 'northeast':\r\n        return southeast;\r\n      case 'northwest':\r\n        return southwest;\r\n      case 'south':\r\n        return north;\r\n      case 'southeast':\r\n        return northeast;\r\n      case 'southwest':\r\n        return northwest;\r\n      case 'east':\r\n        return west;\r\n      case 'west':\r\n        return east;\r\n      }\r\n    };\r\n    var flip$2 = function (anchor, element, bubbles, placee, bounds) {\r\n      var layout = getPlacement(placee).map(lookupFlippedLayout).getOr(north);\r\n      return layout(anchor, element, bubbles, placee, bounds);\r\n    };\r\n\r\n    var global$f = tinymce.util.Tools.resolve('tinymce.util.Delay');\r\n\r\n    var factory$l = function (detail) {\r\n      var events = events$a(detail.action);\r\n      var tag = detail.dom.tag;\r\n      var lookupAttr = function (attr) {\r\n        return get$e(detail.dom, 'attributes').bind(function (attrs) {\r\n          return get$e(attrs, attr);\r\n        });\r\n      };\r\n      var getModAttributes = function () {\r\n        if (tag === 'button') {\r\n          var type = lookupAttr('type').getOr('button');\r\n          var roleAttrs = lookupAttr('role').map(function (role) {\r\n            return { role: role };\r\n          }).getOr({});\r\n          return __assign({ type: type }, roleAttrs);\r\n        } else {\r\n          var role = lookupAttr('role').getOr('button');\r\n          return { role: role };\r\n        }\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: detail.components,\r\n        events: events,\r\n        behaviours: SketchBehaviours.augment(detail.buttonBehaviours, [\r\n          Focusing.config({}),\r\n          Keying.config({\r\n            mode: 'execution',\r\n            useSpace: true,\r\n            useEnter: true\r\n          })\r\n        ]),\r\n        domModification: { attributes: getModAttributes() },\r\n        eventOrder: detail.eventOrder\r\n      };\r\n    };\r\n    var Button = single({\r\n      name: 'Button',\r\n      factory: factory$l,\r\n      configFields: [\r\n        defaulted('uid', undefined),\r\n        required$1('dom'),\r\n        defaulted('components', []),\r\n        SketchBehaviours.field('buttonBehaviours', [\r\n          Focusing,\r\n          Keying\r\n        ]),\r\n        option('action'),\r\n        option('role'),\r\n        defaulted('eventOrder', {})\r\n      ]\r\n    });\r\n\r\n    var getAttrs = function (elem) {\r\n      var attributes = elem.dom.attributes !== undefined ? elem.dom.attributes : [];\r\n      return foldl(attributes, function (b, attr) {\r\n        var _a;\r\n        if (attr.name === 'class') {\r\n          return b;\r\n        } else {\r\n          return __assign(__assign({}, b), (_a = {}, _a[attr.name] = attr.value, _a));\r\n        }\r\n      }, {});\r\n    };\r\n    var getClasses = function (elem) {\r\n      return Array.prototype.slice.call(elem.dom.classList, 0);\r\n    };\r\n    var fromHtml = function (html) {\r\n      var elem = SugarElement.fromHtml(html);\r\n      var children$1 = children(elem);\r\n      var attrs = getAttrs(elem);\r\n      var classes = getClasses(elem);\r\n      var contents = children$1.length === 0 ? {} : { innerHtml: get$7(elem) };\r\n      return __assign({\r\n        tag: name$2(elem),\r\n        classes: classes,\r\n        attributes: attrs\r\n      }, contents);\r\n    };\r\n\r\n    var record = function (spec) {\r\n      var uid = isSketchSpec(spec) && hasNonNullableKey(spec, 'uid') ? spec.uid : generate$5('memento');\r\n      var get = function (anyInSystem) {\r\n        return anyInSystem.getSystem().getByUid(uid).getOrDie();\r\n      };\r\n      var getOpt = function (anyInSystem) {\r\n        return anyInSystem.getSystem().getByUid(uid).toOptional();\r\n      };\r\n      var asSpec = function () {\r\n        return __assign(__assign({}, spec), { uid: uid });\r\n      };\r\n      return {\r\n        get: get,\r\n        getOpt: getOpt,\r\n        asSpec: asSpec\r\n      };\r\n    };\r\n\r\n    function _typeof(obj) {\r\n      '@babel/helpers - typeof';\r\n      return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function (obj) {\r\n        return typeof obj;\r\n      } : function (obj) {\r\n        return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;\r\n      }, _typeof(obj);\r\n    }\r\n    function _setPrototypeOf(o, p) {\r\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\r\n        o.__proto__ = p;\r\n        return o;\r\n      };\r\n      return _setPrototypeOf(o, p);\r\n    }\r\n    function _isNativeReflectConstruct() {\r\n      if (typeof Reflect === 'undefined' || !Reflect.construct)\r\n        return false;\r\n      if (Reflect.construct.sham)\r\n        return false;\r\n      if (typeof Proxy === 'function')\r\n        return true;\r\n      try {\r\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {\r\n        }));\r\n        return true;\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n    }\r\n    function _construct(Parent, args, Class) {\r\n      if (_isNativeReflectConstruct()) {\r\n        _construct = Reflect.construct;\r\n      } else {\r\n        _construct = function _construct(Parent, args, Class) {\r\n          var a = [null];\r\n          a.push.apply(a, args);\r\n          var Constructor = Function.bind.apply(Parent, a);\r\n          var instance = new Constructor();\r\n          if (Class)\r\n            _setPrototypeOf(instance, Class.prototype);\r\n          return instance;\r\n        };\r\n      }\r\n      return _construct.apply(null, arguments);\r\n    }\r\n    function _toConsumableArray(arr) {\r\n      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\r\n    }\r\n    function _arrayWithoutHoles(arr) {\r\n      if (Array.isArray(arr))\r\n        return _arrayLikeToArray(arr);\r\n    }\r\n    function _iterableToArray(iter) {\r\n      if (typeof Symbol !== 'undefined' && iter[Symbol.iterator] != null || iter['@@iterator'] != null)\r\n        return Array.from(iter);\r\n    }\r\n    function _unsupportedIterableToArray(o, minLen) {\r\n      if (!o)\r\n        return;\r\n      if (typeof o === 'string')\r\n        return _arrayLikeToArray(o, minLen);\r\n      var n = Object.prototype.toString.call(o).slice(8, -1);\r\n      if (n === 'Object' && o.constructor)\r\n        n = o.constructor.name;\r\n      if (n === 'Map' || n === 'Set')\r\n        return Array.from(o);\r\n      if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\r\n        return _arrayLikeToArray(o, minLen);\r\n    }\r\n    function _arrayLikeToArray(arr, len) {\r\n      if (len == null || len > arr.length)\r\n        len = arr.length;\r\n      for (var i = 0, arr2 = new Array(len); i < len; i++)\r\n        arr2[i] = arr[i];\r\n      return arr2;\r\n    }\r\n    function _nonIterableSpread() {\r\n      throw new TypeError('Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');\r\n    }\r\n    var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\r\n    var freeze = Object.freeze, seal = Object.seal, create$5 = Object.create;\r\n    var _ref = typeof Reflect !== 'undefined' && Reflect, apply$1 = _ref.apply, construct = _ref.construct;\r\n    if (!apply$1) {\r\n      apply$1 = function apply(fun, thisValue, args) {\r\n        return fun.apply(thisValue, args);\r\n      };\r\n    }\r\n    if (!freeze) {\r\n      freeze = function freeze(x) {\r\n        return x;\r\n      };\r\n    }\r\n    if (!seal) {\r\n      seal = function seal(x) {\r\n        return x;\r\n      };\r\n    }\r\n    if (!construct) {\r\n      construct = function construct(Func, args) {\r\n        return _construct(Func, _toConsumableArray(args));\r\n      };\r\n    }\r\n    var arrayForEach = unapply(Array.prototype.forEach);\r\n    var arrayPop = unapply(Array.prototype.pop);\r\n    var arrayPush = unapply(Array.prototype.push);\r\n    var stringToLowerCase = unapply(String.prototype.toLowerCase);\r\n    var stringMatch = unapply(String.prototype.match);\r\n    var stringReplace = unapply(String.prototype.replace);\r\n    var stringIndexOf = unapply(String.prototype.indexOf);\r\n    var stringTrim = unapply(String.prototype.trim);\r\n    var regExpTest = unapply(RegExp.prototype.test);\r\n    var typeErrorCreate = unconstruct(TypeError);\r\n    function unapply(func) {\r\n      return function (thisArg) {\r\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n          args[_key - 1] = arguments[_key];\r\n        }\r\n        return apply$1(func, thisArg, args);\r\n      };\r\n    }\r\n    function unconstruct(func) {\r\n      return function () {\r\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n          args[_key2] = arguments[_key2];\r\n        }\r\n        return construct(func, args);\r\n      };\r\n    }\r\n    function addToSet(set, array) {\r\n      if (setPrototypeOf) {\r\n        setPrototypeOf(set, null);\r\n      }\r\n      var l = array.length;\r\n      while (l--) {\r\n        var element = array[l];\r\n        if (typeof element === 'string') {\r\n          var lcElement = stringToLowerCase(element);\r\n          if (lcElement !== element) {\r\n            if (!isFrozen(array)) {\r\n              array[l] = lcElement;\r\n            }\r\n            element = lcElement;\r\n          }\r\n        }\r\n        set[element] = true;\r\n      }\r\n      return set;\r\n    }\r\n    function clone$1(object) {\r\n      var newObject = create$5(null);\r\n      var property;\r\n      for (property in object) {\r\n        if (apply$1(hasOwnProperty, object, [property])) {\r\n          newObject[property] = object[property];\r\n        }\r\n      }\r\n      return newObject;\r\n    }\r\n    function lookupGetter(object, prop) {\r\n      while (object !== null) {\r\n        var desc = getOwnPropertyDescriptor(object, prop);\r\n        if (desc) {\r\n          if (desc.get) {\r\n            return unapply(desc.get);\r\n          }\r\n          if (typeof desc.value === 'function') {\r\n            return unapply(desc.value);\r\n          }\r\n        }\r\n        object = getPrototypeOf(object);\r\n      }\r\n      function fallbackValue(element) {\r\n        console.warn('fallback value for', element);\r\n        return null;\r\n      }\r\n      return fallbackValue;\r\n    }\r\n    var html$1 = freeze([\r\n      'a',\r\n      'abbr',\r\n      'acronym',\r\n      'address',\r\n      'area',\r\n      'article',\r\n      'aside',\r\n      'audio',\r\n      'b',\r\n      'bdi',\r\n      'bdo',\r\n      'big',\r\n      'blink',\r\n      'blockquote',\r\n      'body',\r\n      'br',\r\n      'button',\r\n      'canvas',\r\n      'caption',\r\n      'center',\r\n      'cite',\r\n      'code',\r\n      'col',\r\n      'colgroup',\r\n      'content',\r\n      'data',\r\n      'datalist',\r\n      'dd',\r\n      'decorator',\r\n      'del',\r\n      'details',\r\n      'dfn',\r\n      'dialog',\r\n      'dir',\r\n      'div',\r\n      'dl',\r\n      'dt',\r\n      'element',\r\n      'em',\r\n      'fieldset',\r\n      'figcaption',\r\n      'figure',\r\n      'font',\r\n      'footer',\r\n      'form',\r\n      'h1',\r\n      'h2',\r\n      'h3',\r\n      'h4',\r\n      'h5',\r\n      'h6',\r\n      'head',\r\n      'header',\r\n      'hgroup',\r\n      'hr',\r\n      'html',\r\n      'i',\r\n      'img',\r\n      'input',\r\n      'ins',\r\n      'kbd',\r\n      'label',\r\n      'legend',\r\n      'li',\r\n      'main',\r\n      'map',\r\n      'mark',\r\n      'marquee',\r\n      'menu',\r\n      'menuitem',\r\n      'meter',\r\n      'nav',\r\n      'nobr',\r\n      'ol',\r\n      'optgroup',\r\n      'option',\r\n      'output',\r\n      'p',\r\n      'picture',\r\n      'pre',\r\n      'progress',\r\n      'q',\r\n      'rp',\r\n      'rt',\r\n      'ruby',\r\n      's',\r\n      'samp',\r\n      'section',\r\n      'select',\r\n      'shadow',\r\n      'small',\r\n      'source',\r\n      'spacer',\r\n      'span',\r\n      'strike',\r\n      'strong',\r\n      'style',\r\n      'sub',\r\n      'summary',\r\n      'sup',\r\n      'table',\r\n      'tbody',\r\n      'td',\r\n      'template',\r\n      'textarea',\r\n      'tfoot',\r\n      'th',\r\n      'thead',\r\n      'time',\r\n      'tr',\r\n      'track',\r\n      'tt',\r\n      'u',\r\n      'ul',\r\n      'var',\r\n      'video',\r\n      'wbr'\r\n    ]);\r\n    var svg$1 = freeze([\r\n      'svg',\r\n      'a',\r\n      'altglyph',\r\n      'altglyphdef',\r\n      'altglyphitem',\r\n      'animatecolor',\r\n      'animatemotion',\r\n      'animatetransform',\r\n      'circle',\r\n      'clippath',\r\n      'defs',\r\n      'desc',\r\n      'ellipse',\r\n      'filter',\r\n      'font',\r\n      'g',\r\n      'glyph',\r\n      'glyphref',\r\n      'hkern',\r\n      'image',\r\n      'line',\r\n      'lineargradient',\r\n      'marker',\r\n      'mask',\r\n      'metadata',\r\n      'mpath',\r\n      'path',\r\n      'pattern',\r\n      'polygon',\r\n      'polyline',\r\n      'radialgradient',\r\n      'rect',\r\n      'stop',\r\n      'style',\r\n      'switch',\r\n      'symbol',\r\n      'text',\r\n      'textpath',\r\n      'title',\r\n      'tref',\r\n      'tspan',\r\n      'view',\r\n      'vkern'\r\n    ]);\r\n    var svgFilters = freeze([\r\n      'feBlend',\r\n      'feColorMatrix',\r\n      'feComponentTransfer',\r\n      'feComposite',\r\n      'feConvolveMatrix',\r\n      'feDiffuseLighting',\r\n      'feDisplacementMap',\r\n      'feDistantLight',\r\n      'feFlood',\r\n      'feFuncA',\r\n      'feFuncB',\r\n      'feFuncG',\r\n      'feFuncR',\r\n      'feGaussianBlur',\r\n      'feImage',\r\n      'feMerge',\r\n      'feMergeNode',\r\n      'feMorphology',\r\n      'feOffset',\r\n      'fePointLight',\r\n      'feSpecularLighting',\r\n      'feSpotLight',\r\n      'feTile',\r\n      'feTurbulence'\r\n    ]);\r\n    var svgDisallowed = freeze([\r\n      'animate',\r\n      'color-profile',\r\n      'cursor',\r\n      'discard',\r\n      'fedropshadow',\r\n      'font-face',\r\n      'font-face-format',\r\n      'font-face-name',\r\n      'font-face-src',\r\n      'font-face-uri',\r\n      'foreignobject',\r\n      'hatch',\r\n      'hatchpath',\r\n      'mesh',\r\n      'meshgradient',\r\n      'meshpatch',\r\n      'meshrow',\r\n      'missing-glyph',\r\n      'script',\r\n      'set',\r\n      'solidcolor',\r\n      'unknown',\r\n      'use'\r\n    ]);\r\n    var mathMl$1 = freeze([\r\n      'math',\r\n      'menclose',\r\n      'merror',\r\n      'mfenced',\r\n      'mfrac',\r\n      'mglyph',\r\n      'mi',\r\n      'mlabeledtr',\r\n      'mmultiscripts',\r\n      'mn',\r\n      'mo',\r\n      'mover',\r\n      'mpadded',\r\n      'mphantom',\r\n      'mroot',\r\n      'mrow',\r\n      'ms',\r\n      'mspace',\r\n      'msqrt',\r\n      'mstyle',\r\n      'msub',\r\n      'msup',\r\n      'msubsup',\r\n      'mtable',\r\n      'mtd',\r\n      'mtext',\r\n      'mtr',\r\n      'munder',\r\n      'munderover'\r\n    ]);\r\n    var mathMlDisallowed = freeze([\r\n      'maction',\r\n      'maligngroup',\r\n      'malignmark',\r\n      'mlongdiv',\r\n      'mscarries',\r\n      'mscarry',\r\n      'msgroup',\r\n      'mstack',\r\n      'msline',\r\n      'msrow',\r\n      'semantics',\r\n      'annotation',\r\n      'annotation-xml',\r\n      'mprescripts',\r\n      'none'\r\n    ]);\r\n    var text = freeze(['#text']);\r\n    var html = freeze([\r\n      'accept',\r\n      'action',\r\n      'align',\r\n      'alt',\r\n      'autocapitalize',\r\n      'autocomplete',\r\n      'autopictureinpicture',\r\n      'autoplay',\r\n      'background',\r\n      'bgcolor',\r\n      'border',\r\n      'capture',\r\n      'cellpadding',\r\n      'cellspacing',\r\n      'checked',\r\n      'cite',\r\n      'class',\r\n      'clear',\r\n      'color',\r\n      'cols',\r\n      'colspan',\r\n      'controls',\r\n      'controlslist',\r\n      'coords',\r\n      'crossorigin',\r\n      'datetime',\r\n      'decoding',\r\n      'default',\r\n      'dir',\r\n      'disabled',\r\n      'disablepictureinpicture',\r\n      'disableremoteplayback',\r\n      'download',\r\n      'draggable',\r\n      'enctype',\r\n      'enterkeyhint',\r\n      'face',\r\n      'for',\r\n      'headers',\r\n      'height',\r\n      'hidden',\r\n      'high',\r\n      'href',\r\n      'hreflang',\r\n      'id',\r\n      'inputmode',\r\n      'integrity',\r\n      'ismap',\r\n      'kind',\r\n      'label',\r\n      'lang',\r\n      'list',\r\n      'loading',\r\n      'loop',\r\n      'low',\r\n      'max',\r\n      'maxlength',\r\n      'media',\r\n      'method',\r\n      'min',\r\n      'minlength',\r\n      'multiple',\r\n      'muted',\r\n      'name',\r\n      'nonce',\r\n      'noshade',\r\n      'novalidate',\r\n      'nowrap',\r\n      'open',\r\n      'optimum',\r\n      'pattern',\r\n      'placeholder',\r\n      'playsinline',\r\n      'poster',\r\n      'preload',\r\n      'pubdate',\r\n      'radiogroup',\r\n      'readonly',\r\n      'rel',\r\n      'required',\r\n      'rev',\r\n      'reversed',\r\n      'role',\r\n      'rows',\r\n      'rowspan',\r\n      'spellcheck',\r\n      'scope',\r\n      'selected',\r\n      'shape',\r\n      'size',\r\n      'sizes',\r\n      'span',\r\n      'srclang',\r\n      'start',\r\n      'src',\r\n      'srcset',\r\n      'step',\r\n      'style',\r\n      'summary',\r\n      'tabindex',\r\n      'title',\r\n      'translate',\r\n      'type',\r\n      'usemap',\r\n      'valign',\r\n      'value',\r\n      'width',\r\n      'xmlns',\r\n      'slot'\r\n    ]);\r\n    var svg = freeze([\r\n      'accent-height',\r\n      'accumulate',\r\n      'additive',\r\n      'alignment-baseline',\r\n      'ascent',\r\n      'attributename',\r\n      'attributetype',\r\n      'azimuth',\r\n      'basefrequency',\r\n      'baseline-shift',\r\n      'begin',\r\n      'bias',\r\n      'by',\r\n      'class',\r\n      'clip',\r\n      'clippathunits',\r\n      'clip-path',\r\n      'clip-rule',\r\n      'color',\r\n      'color-interpolation',\r\n      'color-interpolation-filters',\r\n      'color-profile',\r\n      'color-rendering',\r\n      'cx',\r\n      'cy',\r\n      'd',\r\n      'dx',\r\n      'dy',\r\n      'diffuseconstant',\r\n      'direction',\r\n      'display',\r\n      'divisor',\r\n      'dur',\r\n      'edgemode',\r\n      'elevation',\r\n      'end',\r\n      'fill',\r\n      'fill-opacity',\r\n      'fill-rule',\r\n      'filter',\r\n      'filterunits',\r\n      'flood-color',\r\n      'flood-opacity',\r\n      'font-family',\r\n      'font-size',\r\n      'font-size-adjust',\r\n      'font-stretch',\r\n      'font-style',\r\n      'font-variant',\r\n      'font-weight',\r\n      'fx',\r\n      'fy',\r\n      'g1',\r\n      'g2',\r\n      'glyph-name',\r\n      'glyphref',\r\n      'gradientunits',\r\n      'gradienttransform',\r\n      'height',\r\n      'href',\r\n      'id',\r\n      'image-rendering',\r\n      'in',\r\n      'in2',\r\n      'k',\r\n      'k1',\r\n      'k2',\r\n      'k3',\r\n      'k4',\r\n      'kerning',\r\n      'keypoints',\r\n      'keysplines',\r\n      'keytimes',\r\n      'lang',\r\n      'lengthadjust',\r\n      'letter-spacing',\r\n      'kernelmatrix',\r\n      'kernelunitlength',\r\n      'lighting-color',\r\n      'local',\r\n      'marker-end',\r\n      'marker-mid',\r\n      'marker-start',\r\n      'markerheight',\r\n      'markerunits',\r\n      'markerwidth',\r\n      'maskcontentunits',\r\n      'maskunits',\r\n      'max',\r\n      'mask',\r\n      'media',\r\n      'method',\r\n      'mode',\r\n      'min',\r\n      'name',\r\n      'numoctaves',\r\n      'offset',\r\n      'operator',\r\n      'opacity',\r\n      'order',\r\n      'orient',\r\n      'orientation',\r\n      'origin',\r\n      'overflow',\r\n      'paint-order',\r\n      'path',\r\n      'pathlength',\r\n      'patterncontentunits',\r\n      'patterntransform',\r\n      'patternunits',\r\n      'points',\r\n      'preservealpha',\r\n      'preserveaspectratio',\r\n      'primitiveunits',\r\n      'r',\r\n      'rx',\r\n      'ry',\r\n      'radius',\r\n      'refx',\r\n      'refy',\r\n      'repeatcount',\r\n      'repeatdur',\r\n      'restart',\r\n      'result',\r\n      'rotate',\r\n      'scale',\r\n      'seed',\r\n      'shape-rendering',\r\n      'specularconstant',\r\n      'specularexponent',\r\n      'spreadmethod',\r\n      'startoffset',\r\n      'stddeviation',\r\n      'stitchtiles',\r\n      'stop-color',\r\n      'stop-opacity',\r\n      'stroke-dasharray',\r\n      'stroke-dashoffset',\r\n      'stroke-linecap',\r\n      'stroke-linejoin',\r\n      'stroke-miterlimit',\r\n      'stroke-opacity',\r\n      'stroke',\r\n      'stroke-width',\r\n      'style',\r\n      'surfacescale',\r\n      'systemlanguage',\r\n      'tabindex',\r\n      'targetx',\r\n      'targety',\r\n      'transform',\r\n      'transform-origin',\r\n      'text-anchor',\r\n      'text-decoration',\r\n      'text-rendering',\r\n      'textlength',\r\n      'type',\r\n      'u1',\r\n      'u2',\r\n      'unicode',\r\n      'values',\r\n      'viewbox',\r\n      'visibility',\r\n      'version',\r\n      'vert-adv-y',\r\n      'vert-origin-x',\r\n      'vert-origin-y',\r\n      'width',\r\n      'word-spacing',\r\n      'wrap',\r\n      'writing-mode',\r\n      'xchannelselector',\r\n      'ychannelselector',\r\n      'x',\r\n      'x1',\r\n      'x2',\r\n      'xmlns',\r\n      'y',\r\n      'y1',\r\n      'y2',\r\n      'z',\r\n      'zoomandpan'\r\n    ]);\r\n    var mathMl = freeze([\r\n      'accent',\r\n      'accentunder',\r\n      'align',\r\n      'bevelled',\r\n      'close',\r\n      'columnsalign',\r\n      'columnlines',\r\n      'columnspan',\r\n      'denomalign',\r\n      'depth',\r\n      'dir',\r\n      'display',\r\n      'displaystyle',\r\n      'encoding',\r\n      'fence',\r\n      'frame',\r\n      'height',\r\n      'href',\r\n      'id',\r\n      'largeop',\r\n      'length',\r\n      'linethickness',\r\n      'lspace',\r\n      'lquote',\r\n      'mathbackground',\r\n      'mathcolor',\r\n      'mathsize',\r\n      'mathvariant',\r\n      'maxsize',\r\n      'minsize',\r\n      'movablelimits',\r\n      'notation',\r\n      'numalign',\r\n      'open',\r\n      'rowalign',\r\n      'rowlines',\r\n      'rowspacing',\r\n      'rowspan',\r\n      'rspace',\r\n      'rquote',\r\n      'scriptlevel',\r\n      'scriptminsize',\r\n      'scriptsizemultiplier',\r\n      'selection',\r\n      'separator',\r\n      'separators',\r\n      'stretchy',\r\n      'subscriptshift',\r\n      'supscriptshift',\r\n      'symmetric',\r\n      'voffset',\r\n      'width',\r\n      'xmlns'\r\n    ]);\r\n    var xml = freeze([\r\n      'xlink:href',\r\n      'xml:id',\r\n      'xlink:title',\r\n      'xml:space',\r\n      'xmlns:xlink'\r\n    ]);\r\n    var MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm);\r\n    var ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\r\n    var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\r\n    var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\r\n    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\r\n    var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\r\n    var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\r\n    var DOCTYPE_NAME = seal(/^html$/i);\r\n    var getGlobal = function getGlobal() {\r\n      return typeof window === 'undefined' ? null : window;\r\n    };\r\n    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\r\n      if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\r\n        return null;\r\n      }\r\n      var suffix = null;\r\n      var ATTR_NAME = 'data-tt-policy-suffix';\r\n      if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\r\n        suffix = document.currentScript.getAttribute(ATTR_NAME);\r\n      }\r\n      var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\r\n      try {\r\n        return trustedTypes.createPolicy(policyName, {\r\n          createHTML: function createHTML(html) {\r\n            return html;\r\n          }\r\n        });\r\n      } catch (_) {\r\n        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\r\n        return null;\r\n      }\r\n    };\r\n    function createDOMPurify() {\r\n      var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\r\n      var DOMPurify = function DOMPurify(root) {\r\n        return createDOMPurify(root);\r\n      };\r\n      DOMPurify.version = '2.3.8';\r\n      DOMPurify.removed = [];\r\n      if (!window || !window.document || window.document.nodeType !== 9) {\r\n        DOMPurify.isSupported = false;\r\n        return DOMPurify;\r\n      }\r\n      var originalDocument = window.document;\r\n      var document = window.document;\r\n      var DocumentFragment = window.DocumentFragment, HTMLTemplateElement = window.HTMLTemplateElement, Node = window.Node, Element = window.Element, NodeFilter = window.NodeFilter, _window$NamedNodeMap = window.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window.HTMLFormElement, DOMParser = window.DOMParser, trustedTypes = window.trustedTypes;\r\n      var ElementPrototype = Element.prototype;\r\n      var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\r\n      var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\r\n      var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\r\n      var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\r\n      if (typeof HTMLTemplateElement === 'function') {\r\n        var template = document.createElement('template');\r\n        if (template.content && template.content.ownerDocument) {\r\n          document = template.content.ownerDocument;\r\n        }\r\n      }\r\n      var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\r\n      var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';\r\n      var _document = document, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;\r\n      var importNode = originalDocument.importNode;\r\n      var documentMode = {};\r\n      try {\r\n        documentMode = clone$1(document).documentMode ? document.documentMode : {};\r\n      } catch (_) {\r\n      }\r\n      var hooks = {};\r\n      DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\r\n      var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;\r\n      var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;\r\n      var ALLOWED_TAGS = null;\r\n      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));\r\n      var ALLOWED_ATTR = null;\r\n      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));\r\n      var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\r\n        tagNameCheck: {\r\n          writable: true,\r\n          configurable: false,\r\n          enumerable: true,\r\n          value: null\r\n        },\r\n        attributeNameCheck: {\r\n          writable: true,\r\n          configurable: false,\r\n          enumerable: true,\r\n          value: null\r\n        },\r\n        allowCustomizedBuiltInElements: {\r\n          writable: true,\r\n          configurable: false,\r\n          enumerable: true,\r\n          value: false\r\n        }\r\n      }));\r\n      var FORBID_TAGS = null;\r\n      var FORBID_ATTR = null;\r\n      var ALLOW_ARIA_ATTR = true;\r\n      var ALLOW_DATA_ATTR = true;\r\n      var ALLOW_UNKNOWN_PROTOCOLS = false;\r\n      var SAFE_FOR_TEMPLATES = false;\r\n      var WHOLE_DOCUMENT = false;\r\n      var SET_CONFIG = false;\r\n      var FORCE_BODY = false;\r\n      var RETURN_DOM = false;\r\n      var RETURN_DOM_FRAGMENT = false;\r\n      var RETURN_TRUSTED_TYPE = false;\r\n      var SANITIZE_DOM = true;\r\n      var KEEP_CONTENT = true;\r\n      var IN_PLACE = false;\r\n      var USE_PROFILES = {};\r\n      var FORBID_CONTENTS = null;\r\n      var DEFAULT_FORBID_CONTENTS = addToSet({}, [\r\n        'annotation-xml',\r\n        'audio',\r\n        'colgroup',\r\n        'desc',\r\n        'foreignobject',\r\n        'head',\r\n        'iframe',\r\n        'math',\r\n        'mi',\r\n        'mn',\r\n        'mo',\r\n        'ms',\r\n        'mtext',\r\n        'noembed',\r\n        'noframes',\r\n        'noscript',\r\n        'plaintext',\r\n        'script',\r\n        'style',\r\n        'svg',\r\n        'template',\r\n        'thead',\r\n        'title',\r\n        'video',\r\n        'xmp'\r\n      ]);\r\n      var DATA_URI_TAGS = null;\r\n      var DEFAULT_DATA_URI_TAGS = addToSet({}, [\r\n        'audio',\r\n        'video',\r\n        'img',\r\n        'source',\r\n        'image',\r\n        'track'\r\n      ]);\r\n      var URI_SAFE_ATTRIBUTES = null;\r\n      var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\r\n        'alt',\r\n        'class',\r\n        'for',\r\n        'id',\r\n        'label',\r\n        'name',\r\n        'pattern',\r\n        'placeholder',\r\n        'role',\r\n        'summary',\r\n        'title',\r\n        'value',\r\n        'style',\r\n        'xmlns'\r\n      ]);\r\n      var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\r\n      var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\r\n      var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\r\n      var NAMESPACE = HTML_NAMESPACE;\r\n      var IS_EMPTY_INPUT = false;\r\n      var PARSER_MEDIA_TYPE;\r\n      var SUPPORTED_PARSER_MEDIA_TYPES = [\r\n        'application/xhtml+xml',\r\n        'text/html'\r\n      ];\r\n      var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\r\n      var transformCaseFunc;\r\n      var CONFIG = null;\r\n      var formElement = document.createElement('form');\r\n      var isRegexOrFunction = function isRegexOrFunction(testValue) {\r\n        return testValue instanceof RegExp || testValue instanceof Function;\r\n      };\r\n      var _parseConfig = function _parseConfig(cfg) {\r\n        if (CONFIG && CONFIG === cfg) {\r\n          return;\r\n        }\r\n        if (!cfg || _typeof(cfg) !== 'object') {\r\n          cfg = {};\r\n        }\r\n        cfg = clone$1(cfg);\r\n        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\r\n        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\r\n        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone$1(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\r\n        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone$1(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\r\n        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\r\n        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\r\n        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\r\n        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\r\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\r\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\r\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\r\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\r\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\r\n        RETURN_DOM = cfg.RETURN_DOM || false;\r\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\r\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\r\n        FORCE_BODY = cfg.FORCE_BODY || false;\r\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\r\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\r\n        IN_PLACE = cfg.IN_PLACE || false;\r\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;\r\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\r\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\r\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\r\n        }\r\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\r\n          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\r\n        }\r\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\r\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\r\n        }\r\n        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\r\n        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {\r\n          return x;\r\n        } : stringToLowerCase;\r\n        if (SAFE_FOR_TEMPLATES) {\r\n          ALLOW_DATA_ATTR = false;\r\n        }\r\n        if (RETURN_DOM_FRAGMENT) {\r\n          RETURN_DOM = true;\r\n        }\r\n        if (USE_PROFILES) {\r\n          ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));\r\n          ALLOWED_ATTR = [];\r\n          if (USE_PROFILES.html === true) {\r\n            addToSet(ALLOWED_TAGS, html$1);\r\n            addToSet(ALLOWED_ATTR, html);\r\n          }\r\n          if (USE_PROFILES.svg === true) {\r\n            addToSet(ALLOWED_TAGS, svg$1);\r\n            addToSet(ALLOWED_ATTR, svg);\r\n            addToSet(ALLOWED_ATTR, xml);\r\n          }\r\n          if (USE_PROFILES.svgFilters === true) {\r\n            addToSet(ALLOWED_TAGS, svgFilters);\r\n            addToSet(ALLOWED_ATTR, svg);\r\n            addToSet(ALLOWED_ATTR, xml);\r\n          }\r\n          if (USE_PROFILES.mathMl === true) {\r\n            addToSet(ALLOWED_TAGS, mathMl$1);\r\n            addToSet(ALLOWED_ATTR, mathMl);\r\n            addToSet(ALLOWED_ATTR, xml);\r\n          }\r\n        }\r\n        if (cfg.ADD_TAGS) {\r\n          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\r\n            ALLOWED_TAGS = clone$1(ALLOWED_TAGS);\r\n          }\r\n          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\r\n        }\r\n        if (cfg.ADD_ATTR) {\r\n          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\r\n            ALLOWED_ATTR = clone$1(ALLOWED_ATTR);\r\n          }\r\n          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\r\n        }\r\n        if (cfg.ADD_URI_SAFE_ATTR) {\r\n          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\r\n        }\r\n        if (cfg.FORBID_CONTENTS) {\r\n          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\r\n            FORBID_CONTENTS = clone$1(FORBID_CONTENTS);\r\n          }\r\n          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\r\n        }\r\n        if (KEEP_CONTENT) {\r\n          ALLOWED_TAGS['#text'] = true;\r\n        }\r\n        if (WHOLE_DOCUMENT) {\r\n          addToSet(ALLOWED_TAGS, [\r\n            'html',\r\n            'head',\r\n            'body'\r\n          ]);\r\n        }\r\n        if (ALLOWED_TAGS.table) {\r\n          addToSet(ALLOWED_TAGS, ['tbody']);\r\n          delete FORBID_TAGS.tbody;\r\n        }\r\n        if (freeze) {\r\n          freeze(cfg);\r\n        }\r\n        CONFIG = cfg;\r\n      };\r\n      var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\r\n        'mi',\r\n        'mo',\r\n        'mn',\r\n        'ms',\r\n        'mtext'\r\n      ]);\r\n      var HTML_INTEGRATION_POINTS = addToSet({}, [\r\n        'foreignobject',\r\n        'desc',\r\n        'title',\r\n        'annotation-xml'\r\n      ]);\r\n      var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\r\n        'title',\r\n        'style',\r\n        'font',\r\n        'a',\r\n        'script'\r\n      ]);\r\n      var ALL_SVG_TAGS = addToSet({}, svg$1);\r\n      addToSet(ALL_SVG_TAGS, svgFilters);\r\n      addToSet(ALL_SVG_TAGS, svgDisallowed);\r\n      var ALL_MATHML_TAGS = addToSet({}, mathMl$1);\r\n      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\r\n      var _checkValidNamespace = function _checkValidNamespace(element) {\r\n        var parent = getParentNode(element);\r\n        if (!parent || !parent.tagName) {\r\n          parent = {\r\n            namespaceURI: HTML_NAMESPACE,\r\n            tagName: 'template'\r\n          };\r\n        }\r\n        var tagName = stringToLowerCase(element.tagName);\r\n        var parentTagName = stringToLowerCase(parent.tagName);\r\n        if (element.namespaceURI === SVG_NAMESPACE) {\r\n          if (parent.namespaceURI === HTML_NAMESPACE) {\r\n            return tagName === 'svg';\r\n          }\r\n          if (parent.namespaceURI === MATHML_NAMESPACE) {\r\n            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\r\n          }\r\n          return Boolean(ALL_SVG_TAGS[tagName]);\r\n        }\r\n        if (element.namespaceURI === MATHML_NAMESPACE) {\r\n          if (parent.namespaceURI === HTML_NAMESPACE) {\r\n            return tagName === 'math';\r\n          }\r\n          if (parent.namespaceURI === SVG_NAMESPACE) {\r\n            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\r\n          }\r\n          return Boolean(ALL_MATHML_TAGS[tagName]);\r\n        }\r\n        if (element.namespaceURI === HTML_NAMESPACE) {\r\n          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\r\n            return false;\r\n          }\r\n          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\r\n            return false;\r\n          }\r\n          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\r\n        }\r\n        return false;\r\n      };\r\n      var _forceRemove = function _forceRemove(node) {\r\n        arrayPush(DOMPurify.removed, { element: node });\r\n        try {\r\n          node.parentNode.removeChild(node);\r\n        } catch (_) {\r\n          try {\r\n            node.outerHTML = emptyHTML;\r\n          } catch (_) {\r\n            node.remove();\r\n          }\r\n        }\r\n      };\r\n      var _removeAttribute = function _removeAttribute(name, node) {\r\n        try {\r\n          arrayPush(DOMPurify.removed, {\r\n            attribute: node.getAttributeNode(name),\r\n            from: node\r\n          });\r\n        } catch (_) {\r\n          arrayPush(DOMPurify.removed, {\r\n            attribute: null,\r\n            from: node\r\n          });\r\n        }\r\n        node.removeAttribute(name);\r\n        if (name === 'is' && !ALLOWED_ATTR[name]) {\r\n          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\r\n            try {\r\n              _forceRemove(node);\r\n            } catch (_) {\r\n            }\r\n          } else {\r\n            try {\r\n              node.setAttribute(name, '');\r\n            } catch (_) {\r\n            }\r\n          }\r\n        }\r\n      };\r\n      var _initDocument = function _initDocument(dirty) {\r\n        var doc;\r\n        var leadingWhitespace;\r\n        if (FORCE_BODY) {\r\n          dirty = '<remove></remove>' + dirty;\r\n        } else {\r\n          var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\r\n          leadingWhitespace = matches && matches[0];\r\n        }\r\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {\r\n          dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\r\n        }\r\n        var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\r\n        if (NAMESPACE === HTML_NAMESPACE) {\r\n          try {\r\n            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\r\n          } catch (_) {\r\n          }\r\n        }\r\n        if (!doc || !doc.documentElement) {\r\n          doc = implementation.createDocument(NAMESPACE, 'template', null);\r\n          try {\r\n            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\r\n          } catch (_) {\r\n          }\r\n        }\r\n        var body = doc.body || doc.documentElement;\r\n        if (dirty && leadingWhitespace) {\r\n          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\r\n        }\r\n        if (NAMESPACE === HTML_NAMESPACE) {\r\n          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\r\n        }\r\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\r\n      };\r\n      var _createIterator = function _createIterator(root) {\r\n        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\r\n      };\r\n      var _isClobbered = function _isClobbered(elm) {\r\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');\r\n      };\r\n      var _isNode = function _isNode(object) {\r\n        return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\r\n      };\r\n      var _executeHook = function _executeHook(entryPoint, currentNode, data) {\r\n        if (!hooks[entryPoint]) {\r\n          return;\r\n        }\r\n        arrayForEach(hooks[entryPoint], function (hook) {\r\n          hook.call(DOMPurify, currentNode, data, CONFIG);\r\n        });\r\n      };\r\n      var _sanitizeElements = function _sanitizeElements(currentNode) {\r\n        var content;\r\n        _executeHook('beforeSanitizeElements', currentNode, null);\r\n        if (_isClobbered(currentNode)) {\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        if (regExpTest(/[\\u0080-\\uFFFF]/, currentNode.nodeName)) {\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        var tagName = transformCaseFunc(currentNode.nodeName);\r\n        _executeHook('uponSanitizeElement', currentNode, {\r\n          tagName: tagName,\r\n          allowedTags: ALLOWED_TAGS\r\n        });\r\n        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\r\n          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\r\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))\r\n              return false;\r\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))\r\n              return false;\r\n          }\r\n          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\r\n            var parentNode = getParentNode(currentNode) || currentNode.parentNode;\r\n            var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\r\n            if (childNodes && parentNode) {\r\n              var childCount = childNodes.length;\r\n              for (var i = childCount - 1; i >= 0; --i) {\r\n                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\r\n              }\r\n            }\r\n          }\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\r\n          content = currentNode.textContent;\r\n          content = stringReplace(content, MUSTACHE_EXPR$1, ' ');\r\n          content = stringReplace(content, ERB_EXPR$1, ' ');\r\n          if (currentNode.textContent !== content) {\r\n            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\r\n            currentNode.textContent = content;\r\n          }\r\n        }\r\n        _executeHook('afterSanitizeElements', currentNode, null);\r\n        return false;\r\n      };\r\n      var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\r\n        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\r\n          return false;\r\n        }\r\n        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName));\r\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName));\r\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\r\n          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));\r\n          else {\r\n            return false;\r\n          }\r\n        } else if (URI_SAFE_ATTRIBUTES[lcName]);\r\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, '')));\r\n        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]);\r\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, '')));\r\n        else if (!value);\r\n        else {\r\n          return false;\r\n        }\r\n        return true;\r\n      };\r\n      var _basicCustomElementTest = function _basicCustomElementTest(tagName) {\r\n        return tagName.indexOf('-') > 0;\r\n      };\r\n      var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\r\n        var attr;\r\n        var value;\r\n        var lcName;\r\n        var l;\r\n        _executeHook('beforeSanitizeAttributes', currentNode, null);\r\n        var attributes = currentNode.attributes;\r\n        if (!attributes) {\r\n          return;\r\n        }\r\n        var hookEvent = {\r\n          attrName: '',\r\n          attrValue: '',\r\n          keepAttr: true,\r\n          allowedAttributes: ALLOWED_ATTR\r\n        };\r\n        l = attributes.length;\r\n        while (l--) {\r\n          attr = attributes[l];\r\n          var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;\r\n          value = name === 'value' ? attr.value : stringTrim(attr.value);\r\n          lcName = transformCaseFunc(name);\r\n          hookEvent.attrName = lcName;\r\n          hookEvent.attrValue = value;\r\n          hookEvent.keepAttr = true;\r\n          hookEvent.forceKeepAttr = undefined;\r\n          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\r\n          value = hookEvent.attrValue;\r\n          if (hookEvent.forceKeepAttr) {\r\n            continue;\r\n          }\r\n          _removeAttribute(name, currentNode);\r\n          if (!hookEvent.keepAttr) {\r\n            continue;\r\n          }\r\n          if (regExpTest(/\\/>/i, value)) {\r\n            _removeAttribute(name, currentNode);\r\n            continue;\r\n          }\r\n          if (SAFE_FOR_TEMPLATES) {\r\n            value = stringReplace(value, MUSTACHE_EXPR$1, ' ');\r\n            value = stringReplace(value, ERB_EXPR$1, ' ');\r\n          }\r\n          var lcTag = transformCaseFunc(currentNode.nodeName);\r\n          if (!_isValidAttribute(lcTag, lcName, value)) {\r\n            continue;\r\n          }\r\n          try {\r\n            if (namespaceURI) {\r\n              currentNode.setAttributeNS(namespaceURI, name, value);\r\n            } else {\r\n              currentNode.setAttribute(name, value);\r\n            }\r\n            arrayPop(DOMPurify.removed);\r\n          } catch (_) {\r\n          }\r\n        }\r\n        _executeHook('afterSanitizeAttributes', currentNode, null);\r\n      };\r\n      var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\r\n        var shadowNode;\r\n        var shadowIterator = _createIterator(fragment);\r\n        _executeHook('beforeSanitizeShadowDOM', fragment, null);\r\n        while (shadowNode = shadowIterator.nextNode()) {\r\n          _executeHook('uponSanitizeShadowNode', shadowNode, null);\r\n          if (_sanitizeElements(shadowNode)) {\r\n            continue;\r\n          }\r\n          if (shadowNode.content instanceof DocumentFragment) {\r\n            _sanitizeShadowDOM(shadowNode.content);\r\n          }\r\n          _sanitizeAttributes(shadowNode);\r\n        }\r\n        _executeHook('afterSanitizeShadowDOM', fragment, null);\r\n      };\r\n      DOMPurify.sanitize = function (dirty, cfg) {\r\n        var body;\r\n        var importedNode;\r\n        var currentNode;\r\n        var oldNode;\r\n        var returnNode;\r\n        IS_EMPTY_INPUT = !dirty;\r\n        if (IS_EMPTY_INPUT) {\r\n          dirty = '<!-->';\r\n        }\r\n        if (typeof dirty !== 'string' && !_isNode(dirty)) {\r\n          if (typeof dirty.toString !== 'function') {\r\n            throw typeErrorCreate('toString is not a function');\r\n          } else {\r\n            dirty = dirty.toString();\r\n            if (typeof dirty !== 'string') {\r\n              throw typeErrorCreate('dirty is not a string, aborting');\r\n            }\r\n          }\r\n        }\r\n        if (!DOMPurify.isSupported) {\r\n          if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\r\n            if (typeof dirty === 'string') {\r\n              return window.toStaticHTML(dirty);\r\n            }\r\n            if (_isNode(dirty)) {\r\n              return window.toStaticHTML(dirty.outerHTML);\r\n            }\r\n          }\r\n          return dirty;\r\n        }\r\n        if (!SET_CONFIG) {\r\n          _parseConfig(cfg);\r\n        }\r\n        DOMPurify.removed = [];\r\n        if (typeof dirty === 'string') {\r\n          IN_PLACE = false;\r\n        }\r\n        if (IN_PLACE) {\r\n          if (dirty.nodeName) {\r\n            var tagName = transformCaseFunc(dirty.nodeName);\r\n            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\r\n              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\r\n            }\r\n          }\r\n        } else if (dirty instanceof Node) {\r\n          body = _initDocument('<!---->');\r\n          importedNode = body.ownerDocument.importNode(dirty, true);\r\n          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\r\n            body = importedNode;\r\n          } else if (importedNode.nodeName === 'HTML') {\r\n            body = importedNode;\r\n          } else {\r\n            body.appendChild(importedNode);\r\n          }\r\n        } else {\r\n          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\r\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\r\n          }\r\n          body = _initDocument(dirty);\r\n          if (!body) {\r\n            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\r\n          }\r\n        }\r\n        if (body && FORCE_BODY) {\r\n          _forceRemove(body.firstChild);\r\n        }\r\n        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\r\n        while (currentNode = nodeIterator.nextNode()) {\r\n          if (currentNode.nodeType === 3 && currentNode === oldNode) {\r\n            continue;\r\n          }\r\n          if (_sanitizeElements(currentNode)) {\r\n            continue;\r\n          }\r\n          if (currentNode.content instanceof DocumentFragment) {\r\n            _sanitizeShadowDOM(currentNode.content);\r\n          }\r\n          _sanitizeAttributes(currentNode);\r\n          oldNode = currentNode;\r\n        }\r\n        oldNode = null;\r\n        if (IN_PLACE) {\r\n          return dirty;\r\n        }\r\n        if (RETURN_DOM) {\r\n          if (RETURN_DOM_FRAGMENT) {\r\n            returnNode = createDocumentFragment.call(body.ownerDocument);\r\n            while (body.firstChild) {\r\n              returnNode.appendChild(body.firstChild);\r\n            }\r\n          } else {\r\n            returnNode = body;\r\n          }\r\n          if (ALLOWED_ATTR.shadowroot) {\r\n            returnNode = importNode.call(originalDocument, returnNode, true);\r\n          }\r\n          return returnNode;\r\n        }\r\n        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\r\n        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\r\n          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\r\n        }\r\n        if (SAFE_FOR_TEMPLATES) {\r\n          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');\r\n          serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');\r\n        }\r\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\r\n      };\r\n      DOMPurify.setConfig = function (cfg) {\r\n        _parseConfig(cfg);\r\n        SET_CONFIG = true;\r\n      };\r\n      DOMPurify.clearConfig = function () {\r\n        CONFIG = null;\r\n        SET_CONFIG = false;\r\n      };\r\n      DOMPurify.isValidAttribute = function (tag, attr, value) {\r\n        if (!CONFIG) {\r\n          _parseConfig({});\r\n        }\r\n        var lcTag = transformCaseFunc(tag);\r\n        var lcName = transformCaseFunc(attr);\r\n        return _isValidAttribute(lcTag, lcName, value);\r\n      };\r\n      DOMPurify.addHook = function (entryPoint, hookFunction) {\r\n        if (typeof hookFunction !== 'function') {\r\n          return;\r\n        }\r\n        hooks[entryPoint] = hooks[entryPoint] || [];\r\n        arrayPush(hooks[entryPoint], hookFunction);\r\n      };\r\n      DOMPurify.removeHook = function (entryPoint) {\r\n        if (hooks[entryPoint]) {\r\n          return arrayPop(hooks[entryPoint]);\r\n        }\r\n      };\r\n      DOMPurify.removeHooks = function (entryPoint) {\r\n        if (hooks[entryPoint]) {\r\n          hooks[entryPoint] = [];\r\n        }\r\n      };\r\n      DOMPurify.removeAllHooks = function () {\r\n        hooks = {};\r\n      };\r\n      return DOMPurify;\r\n    }\r\n    var purify = createDOMPurify();\r\n\r\n    var sanitizeHtmlString = function (html) {\r\n      return purify().sanitize(html);\r\n    };\r\n\r\n    var global$e = tinymce.util.Tools.resolve('tinymce.util.I18n');\r\n\r\n    var rtlTransform = {\r\n      'indent': true,\r\n      'outdent': true,\r\n      'table-insert-column-after': true,\r\n      'table-insert-column-before': true,\r\n      'paste-column-after': true,\r\n      'paste-column-before': true,\r\n      'unordered-list': true,\r\n      'list-bull-circle': true,\r\n      'list-bull-default': true,\r\n      'list-bull-square': true\r\n    };\r\n    var defaultIconName = 'temporary-placeholder';\r\n    var defaultIcon = function (icons) {\r\n      return function () {\r\n        return get$e(icons, defaultIconName).getOr('!not found!');\r\n      };\r\n    };\r\n    var getIconName = function (name, icons) {\r\n      var lcName = name.toLowerCase();\r\n      if (global$e.isRtl()) {\r\n        var rtlName = ensureTrailing(lcName, '-rtl');\r\n        return has$2(icons, rtlName) ? rtlName : lcName;\r\n      } else {\r\n        return lcName;\r\n      }\r\n    };\r\n    var lookupIcon = function (name, icons) {\r\n      return get$e(icons, getIconName(name, icons));\r\n    };\r\n    var get$1 = function (name, iconProvider) {\r\n      var icons = iconProvider();\r\n      return lookupIcon(name, icons).getOrThunk(defaultIcon(icons));\r\n    };\r\n    var getOr = function (name, iconProvider, fallbackIcon) {\r\n      var icons = iconProvider();\r\n      return lookupIcon(name, icons).or(fallbackIcon).getOrThunk(defaultIcon(icons));\r\n    };\r\n    var needsRtlTransform = function (iconName) {\r\n      return global$e.isRtl() ? has$2(rtlTransform, iconName) : false;\r\n    };\r\n    var addFocusableBehaviour = function () {\r\n      return config('add-focusable', [runOnAttached(function (comp) {\r\n          child(comp.element, 'svg').each(function (svg) {\r\n            return set$8(svg, 'focusable', 'false');\r\n          });\r\n        })]);\r\n    };\r\n    var renderIcon$2 = function (spec, iconName, icons, fallbackIcon) {\r\n      var _a, _b;\r\n      var rtlIconClasses = needsRtlTransform(iconName) ? ['tox-icon--flip'] : [];\r\n      var iconHtml = get$e(icons, getIconName(iconName, icons)).or(fallbackIcon).getOrThunk(defaultIcon(icons));\r\n      return {\r\n        dom: {\r\n          tag: spec.tag,\r\n          attributes: (_a = spec.attributes) !== null && _a !== void 0 ? _a : {},\r\n          classes: spec.classes.concat(rtlIconClasses),\r\n          innerHtml: iconHtml\r\n        },\r\n        behaviours: derive$1(__spreadArray(__spreadArray([], (_b = spec.behaviours) !== null && _b !== void 0 ? _b : [], true), [addFocusableBehaviour()], false))\r\n      };\r\n    };\r\n    var render$3 = function (iconName, spec, iconProvider, fallbackIcon) {\r\n      if (fallbackIcon === void 0) {\r\n        fallbackIcon = Optional.none();\r\n      }\r\n      return renderIcon$2(spec, iconName, iconProvider(), fallbackIcon);\r\n    };\r\n    var renderFirst = function (iconNames, spec, iconProvider) {\r\n      var icons = iconProvider();\r\n      var iconName = find$5(iconNames, function (name) {\r\n        return has$2(icons, getIconName(name, icons));\r\n      });\r\n      return renderIcon$2(spec, iconName.getOr(defaultIconName), icons, Optional.none());\r\n    };\r\n\r\n    var notificationIconMap = {\r\n      success: 'checkmark',\r\n      error: 'warning',\r\n      err: 'error',\r\n      warning: 'warning',\r\n      warn: 'warning',\r\n      info: 'info'\r\n    };\r\n    var factory$k = function (detail) {\r\n      var memBannerText = record({\r\n        dom: fromHtml('<p>' + sanitizeHtmlString(detail.translationProvider(detail.text)) + '</p>'),\r\n        behaviours: derive$1([Replacing.config({})])\r\n      });\r\n      var renderPercentBar = function (percent) {\r\n        return {\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-bar'],\r\n            attributes: { style: 'width: ' + percent + '%' }\r\n          }\r\n        };\r\n      };\r\n      var renderPercentText = function (percent) {\r\n        return {\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-text'],\r\n            innerHtml: percent + '%'\r\n          }\r\n        };\r\n      };\r\n      var memBannerProgress = record({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: detail.progress ? [\r\n            'tox-progress-bar',\r\n            'tox-progress-indicator'\r\n          ] : ['tox-progress-bar']\r\n        },\r\n        components: [\r\n          {\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-bar-container']\r\n            },\r\n            components: [renderPercentBar(0)]\r\n          },\r\n          renderPercentText(0)\r\n        ],\r\n        behaviours: derive$1([Replacing.config({})])\r\n      });\r\n      var updateProgress = function (comp, percent) {\r\n        if (comp.getSystem().isConnected()) {\r\n          memBannerProgress.getOpt(comp).each(function (progress) {\r\n            Replacing.set(progress, [\r\n              {\r\n                dom: {\r\n                  tag: 'div',\r\n                  classes: ['tox-bar-container']\r\n                },\r\n                components: [renderPercentBar(percent)]\r\n              },\r\n              renderPercentText(percent)\r\n            ]);\r\n          });\r\n        }\r\n      };\r\n      var updateText = function (comp, text) {\r\n        if (comp.getSystem().isConnected()) {\r\n          var banner = memBannerText.get(comp);\r\n          Replacing.set(banner, [text$1(text)]);\r\n        }\r\n      };\r\n      var apis = {\r\n        updateProgress: updateProgress,\r\n        updateText: updateText\r\n      };\r\n      var iconChoices = flatten([\r\n        detail.icon.toArray(),\r\n        detail.level.toArray(),\r\n        detail.level.bind(function (level) {\r\n          return Optional.from(notificationIconMap[level]);\r\n        }).toArray()\r\n      ]);\r\n      var memButton = record(Button.sketch({\r\n        dom: {\r\n          tag: 'button',\r\n          classes: [\r\n            'tox-notification__dismiss',\r\n            'tox-button',\r\n            'tox-button--naked',\r\n            'tox-button--icon'\r\n          ]\r\n        },\r\n        components: [render$3('close', {\r\n            tag: 'div',\r\n            classes: ['tox-icon'],\r\n            attributes: { 'aria-label': detail.translationProvider('Close') }\r\n          }, detail.iconProvider)],\r\n        action: function (comp) {\r\n          detail.onAction(comp);\r\n        }\r\n      }));\r\n      var notificationIconSpec = renderFirst(iconChoices, {\r\n        tag: 'div',\r\n        classes: ['tox-notification__icon']\r\n      }, detail.iconProvider);\r\n      var notificationBodySpec = {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-notification__body']\r\n        },\r\n        components: [memBannerText.asSpec()],\r\n        behaviours: derive$1([Replacing.config({})])\r\n      };\r\n      var components = [\r\n        notificationIconSpec,\r\n        notificationBodySpec\r\n      ];\r\n      return {\r\n        uid: detail.uid,\r\n        dom: {\r\n          tag: 'div',\r\n          attributes: { role: 'alert' },\r\n          classes: detail.level.map(function (level) {\r\n            return [\r\n              'tox-notification',\r\n              'tox-notification--in',\r\n              'tox-notification--' + level\r\n            ];\r\n          }).getOr([\r\n            'tox-notification',\r\n            'tox-notification--in'\r\n          ])\r\n        },\r\n        behaviours: derive$1([\r\n          Focusing.config({}),\r\n          config('notification-events', [run$1(focusin(), function (comp) {\r\n              memButton.getOpt(comp).each(Focusing.focus);\r\n            })])\r\n        ]),\r\n        components: components.concat(detail.progress ? [memBannerProgress.asSpec()] : []).concat(!detail.closeButton ? [] : [memButton.asSpec()]),\r\n        apis: apis\r\n      };\r\n    };\r\n    var Notification = single({\r\n      name: 'Notification',\r\n      factory: factory$k,\r\n      configFields: [\r\n        option('level'),\r\n        required$1('progress'),\r\n        required$1('icon'),\r\n        required$1('onAction'),\r\n        required$1('text'),\r\n        required$1('iconProvider'),\r\n        required$1('translationProvider'),\r\n        defaultedBoolean('closeButton', true)\r\n      ],\r\n      apis: {\r\n        updateProgress: function (apis, comp, percent) {\r\n          apis.updateProgress(comp, percent);\r\n        },\r\n        updateText: function (apis, comp, text) {\r\n          apis.updateText(comp, text);\r\n        }\r\n      }\r\n    });\r\n\r\n    function NotificationManagerImpl (editor, extras, uiMothership) {\r\n      var sharedBackstage = extras.backstage.shared;\r\n      var getLayoutDirection = function (rel) {\r\n        switch (rel) {\r\n        case 'bc-bc':\r\n          return south;\r\n        case 'tc-tc':\r\n          return north;\r\n        case 'tc-bc':\r\n          return north$2;\r\n        case 'bc-tc':\r\n        default:\r\n          return south$2;\r\n        }\r\n      };\r\n      var reposition = function (notifications) {\r\n        if (notifications.length > 0) {\r\n          each$1(notifications, function (notification, index) {\r\n            if (index === 0) {\r\n              notification.moveRel(null, 'banner');\r\n            } else {\r\n              notification.moveRel(notifications[index - 1].getEl(), 'bc-tc');\r\n            }\r\n          });\r\n        }\r\n      };\r\n      var open = function (settings, closeCallback) {\r\n        var hideCloseButton = !settings.closeButton && settings.timeout && (settings.timeout > 0 || settings.timeout < 0);\r\n        var close = function () {\r\n          closeCallback();\r\n          InlineView.hide(notificationWrapper);\r\n        };\r\n        var notification = build$1(Notification.sketch({\r\n          text: settings.text,\r\n          level: contains$2([\r\n            'success',\r\n            'error',\r\n            'warning',\r\n            'warn',\r\n            'info'\r\n          ], settings.type) ? settings.type : undefined,\r\n          progress: settings.progressBar === true,\r\n          icon: Optional.from(settings.icon),\r\n          closeButton: !hideCloseButton,\r\n          onAction: close,\r\n          iconProvider: sharedBackstage.providers.icons,\r\n          translationProvider: sharedBackstage.providers.translate\r\n        }));\r\n        var notificationWrapper = build$1(InlineView.sketch(__assign({\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-notifications-container']\r\n          },\r\n          lazySink: sharedBackstage.getSink,\r\n          fireDismissalEventInstead: {}\r\n        }, sharedBackstage.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} })));\r\n        uiMothership.add(notificationWrapper);\r\n        if (settings.timeout > 0) {\r\n          global$f.setTimeout(function () {\r\n            close();\r\n          }, settings.timeout);\r\n        }\r\n        var getBounds = function () {\r\n          var contentArea = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));\r\n          var win$1 = win();\r\n          var x = clamp$1(win$1.x, contentArea.x, contentArea.right);\r\n          var y = clamp$1(win$1.y, contentArea.y, contentArea.bottom);\r\n          var right = Math.max(contentArea.right, win$1.right);\r\n          var bottom = Math.max(contentArea.bottom, win$1.bottom);\r\n          return Optional.some(bounds(x, y, right - x, bottom - y));\r\n        };\r\n        return {\r\n          close: close,\r\n          moveTo: function (x, y) {\r\n            InlineView.showAt(notificationWrapper, premade(notification), {\r\n              anchor: {\r\n                type: 'makeshift',\r\n                x: x,\r\n                y: y\r\n              }\r\n            });\r\n          },\r\n          moveRel: function (element, rel) {\r\n            var notificationSpec = premade(notification);\r\n            var anchorOverrides = { maxHeightFunction: expandable$1() };\r\n            if (rel !== 'banner' && isNonNullable(element)) {\r\n              var layoutDirection_1 = getLayoutDirection(rel);\r\n              var nodeAnchor = {\r\n                type: 'node',\r\n                root: body(),\r\n                node: Optional.some(SugarElement.fromDom(element)),\r\n                overrides: anchorOverrides,\r\n                layouts: {\r\n                  onRtl: function () {\r\n                    return [layoutDirection_1];\r\n                  },\r\n                  onLtr: function () {\r\n                    return [layoutDirection_1];\r\n                  }\r\n                }\r\n              };\r\n              InlineView.showWithinBounds(notificationWrapper, notificationSpec, { anchor: nodeAnchor }, getBounds);\r\n            } else {\r\n              var anchor = __assign(__assign({}, sharedBackstage.anchors.banner()), { overrides: anchorOverrides });\r\n              InlineView.showWithinBounds(notificationWrapper, notificationSpec, { anchor: anchor }, getBounds);\r\n            }\r\n          },\r\n          text: function (nuText) {\r\n            Notification.updateText(notification, nuText);\r\n          },\r\n          settings: settings,\r\n          getEl: function () {\r\n            return notification.element.dom;\r\n          },\r\n          progressBar: {\r\n            value: function (percent) {\r\n              Notification.updateProgress(notification, percent);\r\n            }\r\n          }\r\n        };\r\n      };\r\n      var close = function (notification) {\r\n        notification.close();\r\n      };\r\n      var getArgs = function (notification) {\r\n        return notification.settings;\r\n      };\r\n      return {\r\n        open: open,\r\n        close: close,\r\n        reposition: reposition,\r\n        getArgs: getArgs\r\n      };\r\n    }\r\n\r\n    var first = function (fn, rate) {\r\n      var timer = null;\r\n      var cancel = function () {\r\n        if (!isNull(timer)) {\r\n          clearTimeout(timer);\r\n          timer = null;\r\n        }\r\n      };\r\n      var throttle = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        if (isNull(timer)) {\r\n          timer = setTimeout(function () {\r\n            timer = null;\r\n            fn.apply(null, args);\r\n          }, rate);\r\n        }\r\n      };\r\n      return {\r\n        cancel: cancel,\r\n        throttle: throttle\r\n      };\r\n    };\r\n    var last = function (fn, rate) {\r\n      var timer = null;\r\n      var cancel = function () {\r\n        if (!isNull(timer)) {\r\n          clearTimeout(timer);\r\n          timer = null;\r\n        }\r\n      };\r\n      var throttle = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        cancel();\r\n        timer = setTimeout(function () {\r\n          timer = null;\r\n          fn.apply(null, args);\r\n        }, rate);\r\n      };\r\n      return {\r\n        cancel: cancel,\r\n        throttle: throttle\r\n      };\r\n    };\r\n\r\n    var global$d = tinymce.util.Tools.resolve('tinymce.dom.TextSeeker');\r\n\r\n    var isBoundary = function (dom, node) {\r\n      return dom.isBlock(node) || contains$2([\r\n        'BR',\r\n        'IMG',\r\n        'HR',\r\n        'INPUT'\r\n      ], node.nodeName) || dom.getContentEditable(node) === 'false';\r\n    };\r\n    var repeatLeft = function (dom, node, offset, process, rootNode) {\r\n      var search = global$d(dom, function (node) {\r\n        return isBoundary(dom, node);\r\n      });\r\n      return Optional.from(search.backwards(node, offset, process, rootNode));\r\n    };\r\n\r\n    var autocompleteSelector = '[data-mce-autocompleter]';\r\n    var create$4 = function (editor, range) {\r\n      return detect(SugarElement.fromDom(editor.selection.getNode())).getOrThunk(function () {\r\n        var wrapper = SugarElement.fromHtml('<span data-mce-autocompleter=\"1\" data-mce-bogus=\"1\"></span>', editor.getDoc());\r\n        append$2(wrapper, SugarElement.fromDom(range.extractContents()));\r\n        range.insertNode(wrapper.dom);\r\n        parent(wrapper).each(function (elm) {\r\n          return elm.dom.normalize();\r\n        });\r\n        last$1(wrapper).map(function (last) {\r\n          editor.selection.setCursorLocation(last.dom, getEnd(last));\r\n        });\r\n        return wrapper;\r\n      });\r\n    };\r\n    var detect = function (elm) {\r\n      return closest$1(elm, autocompleteSelector);\r\n    };\r\n\r\n    var isValidTextRange = function (rng) {\r\n      return rng.collapsed && rng.startContainer.nodeType === 3;\r\n    };\r\n    var getText = function (rng) {\r\n      return rng.toString().replace(/\\u00A0/g, ' ').replace(/\\uFEFF/g, '');\r\n    };\r\n    var isWhitespace = function (chr) {\r\n      return chr !== '' && ' \\xA0\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\r\n    };\r\n\r\n    var stripTriggerChar = function (text, triggerCh) {\r\n      return text.substring(triggerCh.length);\r\n    };\r\n    var findChar = function (text, index, ch) {\r\n      var i;\r\n      for (i = index - 1; i >= 0; i--) {\r\n        var char = text.charAt(i);\r\n        if (isWhitespace(char)) {\r\n          return Optional.none();\r\n        }\r\n        if (char === ch) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.some(i);\r\n    };\r\n    var findStart = function (dom, initRange, ch, minChars) {\r\n      if (minChars === void 0) {\r\n        minChars = 0;\r\n      }\r\n      if (!isValidTextRange(initRange)) {\r\n        return Optional.none();\r\n      }\r\n      var findTriggerChIndex = function (element, offset, text) {\r\n        return findChar(text, offset, ch).getOr(offset);\r\n      };\r\n      var root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\r\n      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerChIndex, root).bind(function (spot) {\r\n        var range = initRange.cloneRange();\r\n        range.setStart(spot.container, spot.offset);\r\n        range.setEnd(initRange.endContainer, initRange.endOffset);\r\n        if (range.collapsed) {\r\n          return Optional.none();\r\n        }\r\n        var text = getText(range);\r\n        var triggerCharIndex = text.lastIndexOf(ch);\r\n        if (triggerCharIndex !== 0 || stripTriggerChar(text, ch).length < minChars) {\r\n          return Optional.none();\r\n        } else {\r\n          return Optional.some({\r\n            text: stripTriggerChar(text, ch),\r\n            range: range,\r\n            triggerChar: ch\r\n          });\r\n        }\r\n      });\r\n    };\r\n    var getContext = function (dom, initRange, ch, minChars) {\r\n      if (minChars === void 0) {\r\n        minChars = 0;\r\n      }\r\n      return detect(SugarElement.fromDom(initRange.startContainer)).fold(function () {\r\n        return findStart(dom, initRange, ch, minChars);\r\n      }, function (elm) {\r\n        var range = dom.createRng();\r\n        range.selectNode(elm.dom);\r\n        var text = getText(range);\r\n        return Optional.some({\r\n          range: range,\r\n          text: stripTriggerChar(text, ch),\r\n          triggerChar: ch\r\n        });\r\n      });\r\n    };\r\n\r\n    var setup$e = function (api, editor) {\r\n      editor.on('keypress compositionend', api.onKeypress.throttle);\r\n      editor.on('remove', api.onKeypress.cancel);\r\n      var redirectKeyToItem = function (item, e) {\r\n        emitWith(item, keydown(), { raw: e });\r\n      };\r\n      editor.on('keydown', function (e) {\r\n        var getItem = function () {\r\n          return api.getView().bind(Highlighting.getHighlighted);\r\n        };\r\n        if (e.which === 8) {\r\n          api.onKeypress.throttle(e);\r\n        }\r\n        if (api.isActive()) {\r\n          if (e.which === 27) {\r\n            api.cancelIfNecessary();\r\n          }\r\n          if (api.isMenuOpen()) {\r\n            if (e.which === 13) {\r\n              getItem().each(emitExecute);\r\n              e.preventDefault();\r\n            } else if (e.which === 40) {\r\n              getItem().fold(function () {\r\n                api.getView().each(Highlighting.highlightFirst);\r\n              }, function (item) {\r\n                redirectKeyToItem(item, e);\r\n              });\r\n              e.preventDefault();\r\n              e.stopImmediatePropagation();\r\n            } else if (e.which === 37 || e.which === 38 || e.which === 39) {\r\n              getItem().each(function (item) {\r\n                redirectKeyToItem(item, e);\r\n                e.preventDefault();\r\n                e.stopImmediatePropagation();\r\n              });\r\n            }\r\n          } else {\r\n            if (e.which === 13 || e.which === 38 || e.which === 40) {\r\n              api.cancelIfNecessary();\r\n            }\r\n          }\r\n        }\r\n      });\r\n      editor.on('NodeChange', function (e) {\r\n        if (api.isActive() && !api.isProcessingAction() && detect(SugarElement.fromDom(e.element)).isNone()) {\r\n          api.cancelIfNecessary();\r\n        }\r\n      });\r\n    };\r\n    var AutocompleterEditorEvents = { setup: setup$e };\r\n\r\n    var global$c = tinymce.util.Tools.resolve('tinymce.util.Promise');\r\n\r\n    var point = function (container, offset) {\r\n      return {\r\n        container: container,\r\n        offset: offset\r\n      };\r\n    };\r\n\r\n    var isText = function (node) {\r\n      return node.nodeType === TEXT;\r\n    };\r\n    var isElement$1 = function (node) {\r\n      return node.nodeType === ELEMENT;\r\n    };\r\n    var toLast = function (node) {\r\n      if (isText(node)) {\r\n        return point(node, node.data.length);\r\n      } else {\r\n        var children = node.childNodes;\r\n        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\r\n      }\r\n    };\r\n    var toLeaf = function (node, offset) {\r\n      var children = node.childNodes;\r\n      if (children.length > 0 && offset < children.length) {\r\n        return toLeaf(children[offset], 0);\r\n      } else if (children.length > 0 && isElement$1(node) && children.length === offset) {\r\n        return toLast(children[children.length - 1]);\r\n      } else {\r\n        return point(node, offset);\r\n      }\r\n    };\r\n\r\n    var isPreviousCharContent = function (dom, leaf) {\r\n      return repeatLeft(dom, leaf.container, leaf.offset, function (element, offset) {\r\n        return offset === 0 ? -1 : offset;\r\n      }, dom.getRoot()).filter(function (spot) {\r\n        var char = spot.container.data.charAt(spot.offset - 1);\r\n        return !isWhitespace(char);\r\n      }).isSome();\r\n    };\r\n    var isStartOfWord = function (dom) {\r\n      return function (rng) {\r\n        var leaf = toLeaf(rng.startContainer, rng.startOffset);\r\n        return !isPreviousCharContent(dom, leaf);\r\n      };\r\n    };\r\n    var getTriggerContext = function (dom, initRange, database) {\r\n      return findMap(database.triggerChars, function (ch) {\r\n        return getContext(dom, initRange, ch);\r\n      });\r\n    };\r\n    var lookup$2 = function (editor, getDatabase) {\r\n      var database = getDatabase();\r\n      var rng = editor.selection.getRng();\r\n      return getTriggerContext(editor.dom, rng, database).bind(function (context) {\r\n        return lookupWithContext(editor, getDatabase, context);\r\n      });\r\n    };\r\n    var lookupWithContext = function (editor, getDatabase, context, fetchOptions) {\r\n      if (fetchOptions === void 0) {\r\n        fetchOptions = {};\r\n      }\r\n      var database = getDatabase();\r\n      var rng = editor.selection.getRng();\r\n      var startText = rng.startContainer.nodeValue;\r\n      var autocompleters = filter$2(database.lookupByChar(context.triggerChar), function (autocompleter) {\r\n        return context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(function () {\r\n          return isStartOfWord(editor.dom);\r\n        })(context.range, startText, context.text);\r\n      });\r\n      if (autocompleters.length === 0) {\r\n        return Optional.none();\r\n      }\r\n      var lookupData = global$c.all(map$2(autocompleters, function (ac) {\r\n        var fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\r\n        return fetchResult.then(function (results) {\r\n          return {\r\n            matchText: context.text,\r\n            items: results,\r\n            columns: ac.columns,\r\n            onAction: ac.onAction,\r\n            highlightOn: ac.highlightOn\r\n          };\r\n        });\r\n      }));\r\n      return Optional.some({\r\n        lookupData: lookupData,\r\n        context: context\r\n      });\r\n    };\r\n\r\n    var separatorMenuItemSchema = objOf([\r\n      requiredString('type'),\r\n      optionString('text')\r\n    ]);\r\n    var createSeparatorMenuItem = function (spec) {\r\n      return asRaw('separatormenuitem', separatorMenuItemSchema, spec);\r\n    };\r\n\r\n    var autocompleterItemSchema = objOf([\r\n      defaulted('type', 'autocompleteitem'),\r\n      defaulted('active', false),\r\n      defaulted('disabled', false),\r\n      defaulted('meta', {}),\r\n      requiredString('value'),\r\n      optionString('text'),\r\n      optionString('icon')\r\n    ]);\r\n    var autocompleterSchema = objOf([\r\n      requiredString('type'),\r\n      requiredString('ch'),\r\n      defaultedNumber('minChars', 1),\r\n      defaulted('columns', 1),\r\n      defaultedNumber('maxResults', 10),\r\n      optionFunction('matches'),\r\n      requiredFunction('fetch'),\r\n      requiredFunction('onAction'),\r\n      defaultedArrayOf('highlightOn', [], string)\r\n    ]);\r\n    var createSeparatorItem = function (spec) {\r\n      return asRaw('Autocompleter.Separator', separatorMenuItemSchema, spec);\r\n    };\r\n    var createAutocompleterItem = function (spec) {\r\n      return asRaw('Autocompleter.Item', autocompleterItemSchema, spec);\r\n    };\r\n    var createAutocompleter = function (spec) {\r\n      return asRaw('Autocompleter', autocompleterSchema, spec);\r\n    };\r\n\r\n    var baseToolbarButtonFields = [\r\n      defaultedBoolean('disabled', false),\r\n      optionString('tooltip'),\r\n      optionString('icon'),\r\n      optionString('text'),\r\n      defaultedFunction('onSetup', function () {\r\n        return noop;\r\n      })\r\n    ];\r\n    var toolbarButtonSchema = objOf([\r\n      requiredString('type'),\r\n      requiredFunction('onAction')\r\n    ].concat(baseToolbarButtonFields));\r\n    var createToolbarButton = function (spec) {\r\n      return asRaw('toolbarbutton', toolbarButtonSchema, spec);\r\n    };\r\n\r\n    var baseToolbarToggleButtonFields = [defaultedBoolean('active', false)].concat(baseToolbarButtonFields);\r\n    var toggleButtonSchema = objOf(baseToolbarToggleButtonFields.concat([\r\n      requiredString('type'),\r\n      requiredFunction('onAction')\r\n    ]));\r\n    var createToggleButton = function (spec) {\r\n      return asRaw('ToggleButton', toggleButtonSchema, spec);\r\n    };\r\n\r\n    var contextBarFields = [\r\n      defaultedFunction('predicate', never),\r\n      defaultedStringEnum('scope', 'node', [\r\n        'node',\r\n        'editor'\r\n      ]),\r\n      defaultedStringEnum('position', 'selection', [\r\n        'node',\r\n        'selection',\r\n        'line'\r\n      ])\r\n    ];\r\n\r\n    var contextButtonFields = baseToolbarButtonFields.concat([\r\n      defaulted('type', 'contextformbutton'),\r\n      defaulted('primary', false),\r\n      requiredFunction('onAction'),\r\n      customField('original', identity$1)\r\n    ]);\r\n    var contextToggleButtonFields = baseToolbarToggleButtonFields.concat([\r\n      defaulted('type', 'contextformbutton'),\r\n      defaulted('primary', false),\r\n      requiredFunction('onAction'),\r\n      customField('original', identity$1)\r\n    ]);\r\n    var launchButtonFields = baseToolbarButtonFields.concat([defaulted('type', 'contextformbutton')]);\r\n    var launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaulted('type', 'contextformtogglebutton')]);\r\n    var toggleOrNormal = choose$1('type', {\r\n      contextformbutton: contextButtonFields,\r\n      contextformtogglebutton: contextToggleButtonFields\r\n    });\r\n    var contextFormSchema = objOf([\r\n      defaulted('type', 'contextform'),\r\n      defaultedFunction('initValue', constant$1('')),\r\n      optionString('label'),\r\n      requiredArrayOf('commands', toggleOrNormal),\r\n      optionOf('launch', choose$1('type', {\r\n        contextformbutton: launchButtonFields,\r\n        contextformtogglebutton: launchToggleButtonFields\r\n      }))\r\n    ].concat(contextBarFields));\r\n    var createContextForm = function (spec) {\r\n      return asRaw('ContextForm', contextFormSchema, spec);\r\n    };\r\n\r\n    var contextToolbarSchema = objOf([\r\n      defaulted('type', 'contexttoolbar'),\r\n      requiredString('items')\r\n    ].concat(contextBarFields));\r\n    var createContextToolbar = function (spec) {\r\n      return asRaw('ContextToolbar', contextToolbarSchema, spec);\r\n    };\r\n\r\n    var stringArray = function (a) {\r\n      var all = {};\r\n      each$1(a, function (key) {\r\n        all[key] = {};\r\n      });\r\n      return keys(all);\r\n    };\r\n\r\n    var register$b = function (editor) {\r\n      var popups = editor.ui.registry.getAll().popups;\r\n      var dataset = map$1(popups, function (popup) {\r\n        return createAutocompleter(popup).fold(function (err) {\r\n          throw new Error(formatError(err));\r\n        }, identity$1);\r\n      });\r\n      var triggerChars = stringArray(mapToArray(dataset, function (v) {\r\n        return v.ch;\r\n      }));\r\n      var datasetValues = values(dataset);\r\n      var lookupByChar = function (ch) {\r\n        return filter$2(datasetValues, function (dv) {\r\n          return dv.ch === ch;\r\n        });\r\n      };\r\n      return {\r\n        dataset: dataset,\r\n        triggerChars: triggerChars,\r\n        lookupByChar: lookupByChar\r\n      };\r\n    };\r\n\r\n    var ItemResponse;\r\n    (function (ItemResponse) {\r\n      ItemResponse[ItemResponse['CLOSE_ON_EXECUTE'] = 0] = 'CLOSE_ON_EXECUTE';\r\n      ItemResponse[ItemResponse['BUBBLE_TO_SANDBOX'] = 1] = 'BUBBLE_TO_SANDBOX';\r\n    }(ItemResponse || (ItemResponse = {})));\r\n    var ItemResponse$1 = ItemResponse;\r\n\r\n    var navClass = 'tox-menu-nav__js';\r\n    var selectableClass = 'tox-collection__item';\r\n    var colorClass = 'tox-swatch';\r\n    var presetClasses = {\r\n      normal: navClass,\r\n      color: colorClass\r\n    };\r\n    var tickedClass = 'tox-collection__item--enabled';\r\n    var groupHeadingClass = 'tox-collection__group-heading';\r\n    var iconClass = 'tox-collection__item-icon';\r\n    var textClass = 'tox-collection__item-label';\r\n    var accessoryClass = 'tox-collection__item-accessory';\r\n    var caretClass = 'tox-collection__item-caret';\r\n    var checkmarkClass = 'tox-collection__item-checkmark';\r\n    var activeClass = 'tox-collection__item--active';\r\n    var containerClass = 'tox-collection__item-container';\r\n    var containerColumnClass = 'tox-collection__item-container--column';\r\n    var containerRowClass = 'tox-collection__item-container--row';\r\n    var containerAlignRightClass = 'tox-collection__item-container--align-right';\r\n    var containerAlignLeftClass = 'tox-collection__item-container--align-left';\r\n    var containerValignTopClass = 'tox-collection__item-container--valign-top';\r\n    var containerValignMiddleClass = 'tox-collection__item-container--valign-middle';\r\n    var containerValignBottomClass = 'tox-collection__item-container--valign-bottom';\r\n    var classForPreset = function (presets) {\r\n      return get$e(presetClasses, presets).getOr(navClass);\r\n    };\r\n\r\n    var forMenu = function (presets) {\r\n      if (presets === 'color') {\r\n        return 'tox-swatches';\r\n      } else {\r\n        return 'tox-menu';\r\n      }\r\n    };\r\n    var classes = function (presets) {\r\n      return {\r\n        backgroundMenu: 'tox-background-menu',\r\n        selectedMenu: 'tox-selected-menu',\r\n        selectedItem: 'tox-collection__item--active',\r\n        hasIcons: 'tox-menu--has-icons',\r\n        menu: forMenu(presets),\r\n        tieredMenu: 'tox-tiered-menu'\r\n      };\r\n    };\r\n\r\n    var markers = function (presets) {\r\n      var menuClasses = classes(presets);\r\n      return {\r\n        backgroundMenu: menuClasses.backgroundMenu,\r\n        selectedMenu: menuClasses.selectedMenu,\r\n        menu: menuClasses.menu,\r\n        selectedItem: menuClasses.selectedItem,\r\n        item: classForPreset(presets)\r\n      };\r\n    };\r\n    var dom$1 = function (hasIcons, columns, presets) {\r\n      var menuClasses = classes(presets);\r\n      return {\r\n        tag: 'div',\r\n        classes: flatten([\r\n          [\r\n            menuClasses.menu,\r\n            'tox-menu-' + columns + '-column'\r\n          ],\r\n          hasIcons ? [menuClasses.hasIcons] : []\r\n        ])\r\n      };\r\n    };\r\n    var components = [Menu.parts.items({})];\r\n    var part = function (hasIcons, columns, presets) {\r\n      var menuClasses = classes(presets);\r\n      var d = {\r\n        tag: 'div',\r\n        classes: flatten([[menuClasses.tieredMenu]])\r\n      };\r\n      return {\r\n        dom: d,\r\n        markers: markers(presets)\r\n      };\r\n    };\r\n\r\n    var chunk = function (rowDom, numColumns) {\r\n      return function (items) {\r\n        var chunks = chunk$1(items, numColumns);\r\n        return map$2(chunks, function (c) {\r\n          return {\r\n            dom: rowDom,\r\n            components: c\r\n          };\r\n        });\r\n      };\r\n    };\r\n    var forSwatch = function (columns) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [\r\n            'tox-menu',\r\n            'tox-swatches-menu'\r\n          ]\r\n        },\r\n        components: [{\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-swatches']\r\n            },\r\n            components: [Menu.parts.items({\r\n                preprocess: columns !== 'auto' ? chunk({\r\n                  tag: 'div',\r\n                  classes: ['tox-swatches__row']\r\n                }, columns) : identity$1\r\n              })]\r\n          }]\r\n      };\r\n    };\r\n    var forToolbar = function (columns) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [\r\n            'tox-menu',\r\n            'tox-collection',\r\n            'tox-collection--toolbar',\r\n            'tox-collection--toolbar-lg'\r\n          ]\r\n        },\r\n        components: [Menu.parts.items({\r\n            preprocess: chunk({\r\n              tag: 'div',\r\n              classes: ['tox-collection__group']\r\n            }, columns)\r\n          })]\r\n      };\r\n    };\r\n    var preprocessCollection = function (items, isSeparator) {\r\n      var allSplits = [];\r\n      var currentSplit = [];\r\n      each$1(items, function (item, i) {\r\n        if (isSeparator(item, i)) {\r\n          if (currentSplit.length > 0) {\r\n            allSplits.push(currentSplit);\r\n          }\r\n          currentSplit = [];\r\n          if (has$2(item.dom, 'innerHtml')) {\r\n            currentSplit.push(item);\r\n          }\r\n        } else {\r\n          currentSplit.push(item);\r\n        }\r\n      });\r\n      if (currentSplit.length > 0) {\r\n        allSplits.push(currentSplit);\r\n      }\r\n      return map$2(allSplits, function (s) {\r\n        return {\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-collection__group']\r\n          },\r\n          components: s\r\n        };\r\n      });\r\n    };\r\n    var forCollection = function (columns, initItems, _hasIcons) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [\r\n            'tox-menu',\r\n            'tox-collection'\r\n          ].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid'])\r\n        },\r\n        components: [Menu.parts.items({\r\n            preprocess: function (items) {\r\n              if (columns !== 'auto' && columns > 1) {\r\n                return chunk({\r\n                  tag: 'div',\r\n                  classes: ['tox-collection__group']\r\n                }, columns)(items);\r\n              } else {\r\n                return preprocessCollection(items, function (_item, i) {\r\n                  return initItems[i].type === 'separator';\r\n                });\r\n              }\r\n            }\r\n          })]\r\n      };\r\n    };\r\n    var forHorizontalCollection = function (initItems, _hasIcons) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [\r\n            'tox-collection',\r\n            'tox-collection--horizontal'\r\n          ]\r\n        },\r\n        components: [Menu.parts.items({\r\n            preprocess: function (items) {\r\n              return preprocessCollection(items, function (_item, i) {\r\n                return initItems[i].type === 'separator';\r\n              });\r\n            }\r\n          })]\r\n      };\r\n    };\r\n\r\n    var menuHasIcons = function (xs) {\r\n      return exists(xs, function (item) {\r\n        return 'icon' in item && item.icon !== undefined;\r\n      });\r\n    };\r\n    var handleError = function (error) {\r\n      console.error(formatError(error));\r\n      console.log(error);\r\n      return Optional.none();\r\n    };\r\n    var createHorizontalPartialMenuWithAlloyItems = function (value, _hasIcons, items, _columns, _presets) {\r\n      var structure = forHorizontalCollection(items);\r\n      return {\r\n        value: value,\r\n        dom: structure.dom,\r\n        components: structure.components,\r\n        items: items\r\n      };\r\n    };\r\n    var createPartialMenuWithAlloyItems = function (value, hasIcons, items, columns, presets) {\r\n      if (presets === 'color') {\r\n        var structure = forSwatch(columns);\r\n        return {\r\n          value: value,\r\n          dom: structure.dom,\r\n          components: structure.components,\r\n          items: items\r\n        };\r\n      }\r\n      if (presets === 'normal' && columns === 'auto') {\r\n        var structure = forCollection(columns, items);\r\n        return {\r\n          value: value,\r\n          dom: structure.dom,\r\n          components: structure.components,\r\n          items: items\r\n        };\r\n      }\r\n      if (presets === 'normal' && columns === 1) {\r\n        var structure = forCollection(1, items);\r\n        return {\r\n          value: value,\r\n          dom: structure.dom,\r\n          components: structure.components,\r\n          items: items\r\n        };\r\n      }\r\n      if (presets === 'normal') {\r\n        var structure = forCollection(columns, items);\r\n        return {\r\n          value: value,\r\n          dom: structure.dom,\r\n          components: structure.components,\r\n          items: items\r\n        };\r\n      }\r\n      if (presets === 'listpreview' && columns !== 'auto') {\r\n        var structure = forToolbar(columns);\r\n        return {\r\n          value: value,\r\n          dom: structure.dom,\r\n          components: structure.components,\r\n          items: items\r\n        };\r\n      }\r\n      return {\r\n        value: value,\r\n        dom: dom$1(hasIcons, columns, presets),\r\n        components: components,\r\n        items: items\r\n      };\r\n    };\r\n\r\n    var cardImageFields = [\r\n      requiredString('type'),\r\n      requiredString('src'),\r\n      optionString('alt'),\r\n      defaultedArrayOf('classes', [], string)\r\n    ];\r\n    var cardImageSchema = objOf(cardImageFields);\r\n\r\n    var cardTextFields = [\r\n      requiredString('type'),\r\n      requiredString('text'),\r\n      optionString('name'),\r\n      defaultedArrayOf('classes', ['tox-collection__item-label'], string)\r\n    ];\r\n    var cardTextSchema = objOf(cardTextFields);\r\n\r\n    var itemSchema$1 = valueThunk(function () {\r\n      return choose$2('type', {\r\n        cardimage: cardImageSchema,\r\n        cardtext: cardTextSchema,\r\n        cardcontainer: cardContainerSchema\r\n      });\r\n    });\r\n    var cardContainerSchema = objOf([\r\n      requiredString('type'),\r\n      defaultedString('direction', 'horizontal'),\r\n      defaultedString('align', 'left'),\r\n      defaultedString('valign', 'middle'),\r\n      requiredArrayOf('items', itemSchema$1)\r\n    ]);\r\n\r\n    var commonMenuItemFields = [\r\n      defaultedBoolean('disabled', false),\r\n      optionString('text'),\r\n      optionString('shortcut'),\r\n      field$1('value', 'value', defaultedThunk(function () {\r\n        return generate$6('menuitem-value');\r\n      }), anyValue()),\r\n      defaulted('meta', {})\r\n    ];\r\n\r\n    var cardMenuItemSchema = objOf([\r\n      requiredString('type'),\r\n      optionString('label'),\r\n      requiredArrayOf('items', itemSchema$1),\r\n      defaultedFunction('onSetup', function () {\r\n        return noop;\r\n      }),\r\n      defaultedFunction('onAction', noop)\r\n    ].concat(commonMenuItemFields));\r\n    var createCardMenuItem = function (spec) {\r\n      return asRaw('cardmenuitem', cardMenuItemSchema, spec);\r\n    };\r\n\r\n    var choiceMenuItemSchema = objOf([\r\n      requiredString('type'),\r\n      defaultedBoolean('active', false),\r\n      optionString('icon')\r\n    ].concat(commonMenuItemFields));\r\n    var createChoiceMenuItem = function (spec) {\r\n      return asRaw('choicemenuitem', choiceMenuItemSchema, spec);\r\n    };\r\n\r\n    var baseFields = [\r\n      requiredString('type'),\r\n      requiredString('fancytype'),\r\n      defaultedFunction('onAction', noop)\r\n    ];\r\n    var insertTableFields = [defaulted('initData', {})].concat(baseFields);\r\n    var colorSwatchFields = [defaultedObjOf('initData', {}, [\r\n        defaultedBoolean('allowCustomColors', true),\r\n        optionArrayOf('colors', anyValue())\r\n      ])].concat(baseFields);\r\n    var fancyMenuItemSchema = choose$1('fancytype', {\r\n      inserttable: insertTableFields,\r\n      colorswatch: colorSwatchFields\r\n    });\r\n    var createFancyMenuItem = function (spec) {\r\n      return asRaw('fancymenuitem', fancyMenuItemSchema, spec);\r\n    };\r\n\r\n    var menuItemSchema = objOf([\r\n      requiredString('type'),\r\n      defaultedFunction('onSetup', function () {\r\n        return noop;\r\n      }),\r\n      defaultedFunction('onAction', noop),\r\n      optionString('icon')\r\n    ].concat(commonMenuItemFields));\r\n    var createMenuItem = function (spec) {\r\n      return asRaw('menuitem', menuItemSchema, spec);\r\n    };\r\n\r\n    var nestedMenuItemSchema = objOf([\r\n      requiredString('type'),\r\n      requiredFunction('getSubmenuItems'),\r\n      defaultedFunction('onSetup', function () {\r\n        return noop;\r\n      }),\r\n      optionString('icon')\r\n    ].concat(commonMenuItemFields));\r\n    var createNestedMenuItem = function (spec) {\r\n      return asRaw('nestedmenuitem', nestedMenuItemSchema, spec);\r\n    };\r\n\r\n    var toggleMenuItemSchema = objOf([\r\n      requiredString('type'),\r\n      optionString('icon'),\r\n      defaultedBoolean('active', false),\r\n      defaultedFunction('onSetup', function () {\r\n        return noop;\r\n      }),\r\n      requiredFunction('onAction')\r\n    ].concat(commonMenuItemFields));\r\n    var createToggleMenuItem = function (spec) {\r\n      return asRaw('togglemenuitem', toggleMenuItemSchema, spec);\r\n    };\r\n\r\n    var detectSize = function (comp, margin, selectorClass) {\r\n      var descendants$1 = descendants(comp.element, '.' + selectorClass);\r\n      if (descendants$1.length > 0) {\r\n        var columnLength = findIndex$1(descendants$1, function (c) {\r\n          var thisTop = c.dom.getBoundingClientRect().top;\r\n          var cTop = descendants$1[0].dom.getBoundingClientRect().top;\r\n          return Math.abs(thisTop - cTop) > margin;\r\n        }).getOr(descendants$1.length);\r\n        return Optional.some({\r\n          numColumns: columnLength,\r\n          numRows: Math.ceil(descendants$1.length / columnLength)\r\n        });\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n\r\n    var namedEvents = function (name, handlers) {\r\n      return derive$1([config(name, handlers)]);\r\n    };\r\n    var unnamedEvents = function (handlers) {\r\n      return namedEvents(generate$6('unnamed-events'), handlers);\r\n    };\r\n    var SimpleBehaviours = {\r\n      namedEvents: namedEvents,\r\n      unnamedEvents: unnamedEvents\r\n    };\r\n\r\n    var ExclusivityChannel = generate$6('tooltip.exclusive');\r\n    var ShowTooltipEvent = generate$6('tooltip.show');\r\n    var HideTooltipEvent = generate$6('tooltip.hide');\r\n\r\n    var hideAllExclusive = function (component, _tConfig, _tState) {\r\n      component.getSystem().broadcastOn([ExclusivityChannel], {});\r\n    };\r\n    var setComponents = function (component, tConfig, tState, specs) {\r\n      tState.getTooltip().each(function (tooltip) {\r\n        if (tooltip.getSystem().isConnected()) {\r\n          Replacing.set(tooltip, specs);\r\n        }\r\n      });\r\n    };\r\n\r\n    var TooltippingApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        hideAllExclusive: hideAllExclusive,\r\n        setComponents: setComponents\r\n    });\r\n\r\n    var events$9 = function (tooltipConfig, state) {\r\n      var hide = function (comp) {\r\n        state.getTooltip().each(function (p) {\r\n          detach(p);\r\n          tooltipConfig.onHide(comp, p);\r\n          state.clearTooltip();\r\n        });\r\n        state.clearTimer();\r\n      };\r\n      var show = function (comp) {\r\n        if (!state.isShowing()) {\r\n          hideAllExclusive(comp);\r\n          var sink = tooltipConfig.lazySink(comp).getOrDie();\r\n          var popup = comp.getSystem().build({\r\n            dom: tooltipConfig.tooltipDom,\r\n            components: tooltipConfig.tooltipComponents,\r\n            events: derive$2(tooltipConfig.mode === 'normal' ? [\r\n              run$1(mouseover(), function (_) {\r\n                emit(comp, ShowTooltipEvent);\r\n              }),\r\n              run$1(mouseout(), function (_) {\r\n                emit(comp, HideTooltipEvent);\r\n              })\r\n            ] : []),\r\n            behaviours: derive$1([Replacing.config({})])\r\n          });\r\n          state.setTooltip(popup);\r\n          attach(sink, popup);\r\n          tooltipConfig.onShow(comp, popup);\r\n          Positioning.position(sink, popup, { anchor: tooltipConfig.anchor(comp) });\r\n        }\r\n      };\r\n      return derive$2(flatten([\r\n        [\r\n          run$1(ShowTooltipEvent, function (comp) {\r\n            state.resetTimer(function () {\r\n              show(comp);\r\n            }, tooltipConfig.delay);\r\n          }),\r\n          run$1(HideTooltipEvent, function (comp) {\r\n            state.resetTimer(function () {\r\n              hide(comp);\r\n            }, tooltipConfig.delay);\r\n          }),\r\n          run$1(receive(), function (comp, message) {\r\n            var receivingData = message;\r\n            if (!receivingData.universal) {\r\n              if (contains$2(receivingData.channels, ExclusivityChannel)) {\r\n                hide(comp);\r\n              }\r\n            }\r\n          }),\r\n          runOnDetached(function (comp) {\r\n            hide(comp);\r\n          })\r\n        ],\r\n        tooltipConfig.mode === 'normal' ? [\r\n          run$1(focusin(), function (comp) {\r\n            emit(comp, ShowTooltipEvent);\r\n          }),\r\n          run$1(postBlur(), function (comp) {\r\n            emit(comp, HideTooltipEvent);\r\n          }),\r\n          run$1(mouseover(), function (comp) {\r\n            emit(comp, ShowTooltipEvent);\r\n          }),\r\n          run$1(mouseout(), function (comp) {\r\n            emit(comp, HideTooltipEvent);\r\n          })\r\n        ] : [\r\n          run$1(highlight$1(), function (comp, _se) {\r\n            emit(comp, ShowTooltipEvent);\r\n          }),\r\n          run$1(dehighlight$1(), function (comp) {\r\n            emit(comp, HideTooltipEvent);\r\n          })\r\n        ]\r\n      ]));\r\n    };\r\n\r\n    var ActiveTooltipping = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        events: events$9\r\n    });\r\n\r\n    var TooltippingSchema = [\r\n      required$1('lazySink'),\r\n      required$1('tooltipDom'),\r\n      defaulted('exclusive', true),\r\n      defaulted('tooltipComponents', []),\r\n      defaulted('delay', 300),\r\n      defaultedStringEnum('mode', 'normal', [\r\n        'normal',\r\n        'follow-highlight'\r\n      ]),\r\n      defaulted('anchor', function (comp) {\r\n        return {\r\n          type: 'hotspot',\r\n          hotspot: comp,\r\n          layouts: {\r\n            onLtr: constant$1([\r\n              south$2,\r\n              north$2,\r\n              southeast$2,\r\n              northeast$2,\r\n              southwest$2,\r\n              northwest$2\r\n            ]),\r\n            onRtl: constant$1([\r\n              south$2,\r\n              north$2,\r\n              southeast$2,\r\n              northeast$2,\r\n              southwest$2,\r\n              northwest$2\r\n            ])\r\n          }\r\n        };\r\n      }),\r\n      onHandler('onHide'),\r\n      onHandler('onShow')\r\n    ];\r\n\r\n    var init$b = function () {\r\n      var timer = value$1();\r\n      var popup = value$1();\r\n      var clearTimer = function () {\r\n        timer.on(clearTimeout);\r\n      };\r\n      var resetTimer = function (f, delay) {\r\n        clearTimer();\r\n        timer.set(setTimeout(f, delay));\r\n      };\r\n      var readState = constant$1('not-implemented');\r\n      return nu$8({\r\n        getTooltip: popup.get,\r\n        isShowing: popup.isSet,\r\n        setTooltip: popup.set,\r\n        clearTooltip: popup.clear,\r\n        clearTimer: clearTimer,\r\n        resetTimer: resetTimer,\r\n        readState: readState\r\n      });\r\n    };\r\n\r\n    var TooltippingState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        init: init$b\r\n    });\r\n\r\n    var Tooltipping = create$8({\r\n      fields: TooltippingSchema,\r\n      name: 'tooltipping',\r\n      active: ActiveTooltipping,\r\n      state: TooltippingState,\r\n      apis: TooltippingApis\r\n    });\r\n\r\n    var escape = function (text) {\r\n      return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n    };\r\n\r\n    var global$b = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\r\n\r\n    var global$a = tinymce.util.Tools.resolve('tinymce.EditorManager');\r\n\r\n    var getSkinUrl = function (editor) {\r\n      var skin = editor.getParam('skin');\r\n      var skinUrl = editor.getParam('skin_url');\r\n      if (skin !== false) {\r\n        var skinName = skin ? skin : 'oxide';\r\n        if (skinUrl) {\r\n          skinUrl = editor.documentBaseURI.toAbsolute(skinUrl);\r\n        } else {\r\n          skinUrl = global$a.baseURL + '/skins/ui/' + skinName;\r\n        }\r\n      }\r\n      return skinUrl;\r\n    };\r\n    var isReadOnly = function (editor) {\r\n      return editor.getParam('readonly', false, 'boolean');\r\n    };\r\n    var isSkinDisabled = function (editor) {\r\n      return editor.getParam('skin') === false;\r\n    };\r\n    var getHeightSetting = function (editor) {\r\n      return editor.getParam('height', Math.max(editor.getElement().offsetHeight, 200));\r\n    };\r\n    var getWidthSetting = function (editor) {\r\n      return editor.getParam('width', global$b.DOM.getStyle(editor.getElement(), 'width'));\r\n    };\r\n    var getMinWidthSetting = function (editor) {\r\n      return Optional.from(editor.getParam('min_width')).filter(isNumber);\r\n    };\r\n    var getMinHeightSetting = function (editor) {\r\n      return Optional.from(editor.getParam('min_height')).filter(isNumber);\r\n    };\r\n    var getMaxWidthSetting = function (editor) {\r\n      return Optional.from(editor.getParam('max_width')).filter(isNumber);\r\n    };\r\n    var getMaxHeightSetting = function (editor) {\r\n      return Optional.from(editor.getParam('max_height')).filter(isNumber);\r\n    };\r\n    var getUserStyleFormats = function (editor) {\r\n      return Optional.from(editor.getParam('style_formats')).filter(isArray);\r\n    };\r\n    var isMergeStyleFormats = function (editor) {\r\n      return editor.getParam('style_formats_merge', false, 'boolean');\r\n    };\r\n    var getLineHeightFormats = function (editor) {\r\n      return editor.getParam('lineheight_formats', '1 1.1 1.2 1.3 1.4 1.5 2', 'string').split(' ');\r\n    };\r\n    var getContentLanguages = function (editor) {\r\n      return editor.getParam('content_langs', undefined, 'array');\r\n    };\r\n    var getRemovedMenuItems = function (editor) {\r\n      return editor.getParam('removed_menuitems', '');\r\n    };\r\n    var isMenubarEnabled = function (editor) {\r\n      return editor.getParam('menubar', true, 'boolean') !== false;\r\n    };\r\n    var isToolbarEnabled = function (editor) {\r\n      var toolbar = editor.getParam('toolbar', true);\r\n      var isToolbarTrue = toolbar === true;\r\n      var isToolbarString = isString(toolbar);\r\n      var isToolbarObjectArray = isArray(toolbar) && toolbar.length > 0;\r\n      return !isMultipleToolbars(editor) && (isToolbarObjectArray || isToolbarString || isToolbarTrue);\r\n    };\r\n    var getMultipleToolbarsSetting = function (editor) {\r\n      var toolbars = range$2(9, function (num) {\r\n        return editor.getParam('toolbar' + (num + 1), false, 'string');\r\n      });\r\n      var toolbarArray = filter$2(toolbars, function (toolbar) {\r\n        return typeof toolbar === 'string';\r\n      });\r\n      return toolbarArray.length > 0 ? Optional.some(toolbarArray) : Optional.none();\r\n    };\r\n    var isMultipleToolbars = function (editor) {\r\n      return getMultipleToolbarsSetting(editor).fold(function () {\r\n        var toolbar = editor.getParam('toolbar', [], 'string[]');\r\n        return toolbar.length > 0;\r\n      }, always);\r\n    };\r\n    var ToolbarMode;\r\n    (function (ToolbarMode) {\r\n      ToolbarMode['default'] = 'wrap';\r\n      ToolbarMode['floating'] = 'floating';\r\n      ToolbarMode['sliding'] = 'sliding';\r\n      ToolbarMode['scrolling'] = 'scrolling';\r\n    }(ToolbarMode || (ToolbarMode = {})));\r\n    var getToolbarMode = function (editor) {\r\n      return editor.getParam('toolbar_mode', '', 'string');\r\n    };\r\n    var ToolbarLocation;\r\n    (function (ToolbarLocation) {\r\n      ToolbarLocation['auto'] = 'auto';\r\n      ToolbarLocation['top'] = 'top';\r\n      ToolbarLocation['bottom'] = 'bottom';\r\n    }(ToolbarLocation || (ToolbarLocation = {})));\r\n    var getToolbarGroups = function (editor) {\r\n      return editor.getParam('toolbar_groups', {}, 'object');\r\n    };\r\n    var getToolbarLocation = function (editor) {\r\n      return editor.getParam('toolbar_location', ToolbarLocation.auto, 'string');\r\n    };\r\n    var isToolbarLocationBottom = function (editor) {\r\n      return getToolbarLocation(editor) === ToolbarLocation.bottom;\r\n    };\r\n    var fixedContainerSelector = function (editor) {\r\n      return editor.getParam('fixed_toolbar_container', '', 'string');\r\n    };\r\n    var fixedToolbarContainerTarget = function (editor) {\r\n      return editor.getParam('fixed_toolbar_container_target');\r\n    };\r\n    var isToolbarPersist = function (editor) {\r\n      return editor.getParam('toolbar_persist', false, 'boolean');\r\n    };\r\n    var fixedContainerTarget = function (editor) {\r\n      if (!editor.inline) {\r\n        return Optional.none();\r\n      }\r\n      var selector = fixedContainerSelector(editor);\r\n      if (selector.length > 0) {\r\n        return descendant(body(), selector);\r\n      }\r\n      var element = fixedToolbarContainerTarget(editor);\r\n      if (isNonNullable(element)) {\r\n        return Optional.some(SugarElement.fromDom(element));\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var useFixedContainer = function (editor) {\r\n      return editor.inline && fixedContainerTarget(editor).isSome();\r\n    };\r\n    var getUiContainer = function (editor) {\r\n      var fixedContainer = fixedContainerTarget(editor);\r\n      return fixedContainer.getOrThunk(function () {\r\n        return getContentContainer(getRootNode(SugarElement.fromDom(editor.getElement())));\r\n      });\r\n    };\r\n    var isDistractionFree = function (editor) {\r\n      return editor.inline && !isMenubarEnabled(editor) && !isToolbarEnabled(editor) && !isMultipleToolbars(editor);\r\n    };\r\n    var isStickyToolbar = function (editor) {\r\n      var isStickyToolbar = editor.getParam('toolbar_sticky', false, 'boolean');\r\n      return (isStickyToolbar || editor.inline) && !useFixedContainer(editor) && !isDistractionFree(editor);\r\n    };\r\n    var getStickyToolbarOffset = function (editor) {\r\n      return editor.getParam('toolbar_sticky_offset', 0, 'number');\r\n    };\r\n    var isDraggableModal$1 = function (editor) {\r\n      return editor.getParam('draggable_modal', false, 'boolean');\r\n    };\r\n    var getMenus = function (editor) {\r\n      var menu = editor.getParam('menu');\r\n      if (menu) {\r\n        return map$1(menu, function (menu) {\r\n          return __assign(__assign({}, menu), { items: menu.items });\r\n        });\r\n      } else {\r\n        return {};\r\n      }\r\n    };\r\n    var getMenubar = function (editor) {\r\n      return editor.getParam('menubar');\r\n    };\r\n    var getToolbar = function (editor) {\r\n      return editor.getParam('toolbar', true);\r\n    };\r\n    var getFilePickerCallback = function (editor) {\r\n      return editor.getParam('file_picker_callback');\r\n    };\r\n    var getFilePickerTypes = function (editor) {\r\n      return editor.getParam('file_picker_types');\r\n    };\r\n    var getFileBrowserCallbackTypes = function (editor) {\r\n      return editor.getParam('file_browser_callback_types');\r\n    };\r\n    var noTypeaheadUrls = function (editor) {\r\n      return editor.getParam('typeahead_urls') === false;\r\n    };\r\n    var getAnchorTop = function (editor) {\r\n      return editor.getParam('anchor_top', '#top');\r\n    };\r\n    var getAnchorBottom = function (editor) {\r\n      return editor.getParam('anchor_bottom', '#bottom');\r\n    };\r\n    var getFilePickerValidatorHandler = function (editor) {\r\n      var handler = editor.getParam('file_picker_validator_handler', undefined, 'function');\r\n      if (handler === undefined) {\r\n        return editor.getParam('filepicker_validator_handler', undefined, 'function');\r\n      } else {\r\n        return handler;\r\n      }\r\n    };\r\n\r\n    var ReadOnlyChannel = 'silver.readonly';\r\n    var ReadOnlyDataSchema = objOf([requiredBoolean('readonly')]);\r\n    var broadcastReadonly = function (uiComponents, readonly) {\r\n      var outerContainer = uiComponents.outerContainer;\r\n      var target = outerContainer.element;\r\n      if (readonly) {\r\n        uiComponents.mothership.broadcastOn([dismissPopups()], { target: target });\r\n        uiComponents.uiMothership.broadcastOn([dismissPopups()], { target: target });\r\n      }\r\n      uiComponents.mothership.broadcastOn([ReadOnlyChannel], { readonly: readonly });\r\n      uiComponents.uiMothership.broadcastOn([ReadOnlyChannel], { readonly: readonly });\r\n    };\r\n    var setupReadonlyModeSwitch = function (editor, uiComponents) {\r\n      editor.on('init', function () {\r\n        if (editor.mode.isReadOnly()) {\r\n          broadcastReadonly(uiComponents, true);\r\n        }\r\n      });\r\n      editor.on('SwitchMode', function () {\r\n        return broadcastReadonly(uiComponents, editor.mode.isReadOnly());\r\n      });\r\n      if (isReadOnly(editor)) {\r\n        editor.setMode('readonly');\r\n      }\r\n    };\r\n    var receivingConfig = function () {\r\n      var _a;\r\n      return Receiving.config({\r\n        channels: (_a = {}, _a[ReadOnlyChannel] = {\r\n          schema: ReadOnlyDataSchema,\r\n          onReceive: function (comp, data) {\r\n            Disabling.set(comp, data.readonly);\r\n          }\r\n        }, _a)\r\n      });\r\n    };\r\n\r\n    var item = function (disabled) {\r\n      return Disabling.config({\r\n        disabled: disabled,\r\n        disableClass: 'tox-collection__item--state-disabled'\r\n      });\r\n    };\r\n    var button = function (disabled) {\r\n      return Disabling.config({ disabled: disabled });\r\n    };\r\n    var splitButton = function (disabled) {\r\n      return Disabling.config({\r\n        disabled: disabled,\r\n        disableClass: 'tox-tbtn--disabled'\r\n      });\r\n    };\r\n    var toolbarButton = function (disabled) {\r\n      return Disabling.config({\r\n        disabled: disabled,\r\n        disableClass: 'tox-tbtn--disabled',\r\n        useNative: false\r\n      });\r\n    };\r\n    var DisablingConfigs = {\r\n      item: item,\r\n      button: button,\r\n      splitButton: splitButton,\r\n      toolbarButton: toolbarButton\r\n    };\r\n\r\n    var runWithApi = function (info, comp) {\r\n      var api = info.getApi(comp);\r\n      return function (f) {\r\n        f(api);\r\n      };\r\n    };\r\n    var onControlAttached = function (info, editorOffCell) {\r\n      return runOnAttached(function (comp) {\r\n        var run = runWithApi(info, comp);\r\n        run(function (api) {\r\n          var onDestroy = info.onSetup(api);\r\n          if (isFunction(onDestroy)) {\r\n            editorOffCell.set(onDestroy);\r\n          }\r\n        });\r\n      });\r\n    };\r\n    var onControlDetached = function (getApi, editorOffCell) {\r\n      return runOnDetached(function (comp) {\r\n        return runWithApi(getApi, comp)(editorOffCell.get());\r\n      });\r\n    };\r\n\r\n    var _a$1;\r\n    var onMenuItemExecute = function (info, itemResponse) {\r\n      return runOnExecute$1(function (comp, simulatedEvent) {\r\n        runWithApi(info, comp)(info.onAction);\r\n        if (!info.triggersSubmenu && itemResponse === ItemResponse$1.CLOSE_ON_EXECUTE) {\r\n          emit(comp, sandboxClose());\r\n          simulatedEvent.stop();\r\n        }\r\n      });\r\n    };\r\n    var menuItemEventOrder = (_a$1 = {}, _a$1[execute$5()] = [\r\n      'disabling',\r\n      'alloy.base.behaviour',\r\n      'toggling',\r\n      'item-events'\r\n    ], _a$1);\r\n\r\n    var componentRenderPipeline = cat;\r\n    var renderCommonItem = function (spec, structure, itemResponse, providersbackstage) {\r\n      var editorOffCell = Cell(noop);\r\n      return {\r\n        type: 'item',\r\n        dom: structure.dom,\r\n        components: componentRenderPipeline(structure.optComponents),\r\n        data: spec.data,\r\n        eventOrder: menuItemEventOrder,\r\n        hasSubmenu: spec.triggersSubmenu,\r\n        itemBehaviours: derive$1([\r\n          config('item-events', [\r\n            onMenuItemExecute(spec, itemResponse),\r\n            onControlAttached(spec, editorOffCell),\r\n            onControlDetached(spec, editorOffCell)\r\n          ]),\r\n          DisablingConfigs.item(function () {\r\n            return spec.disabled || providersbackstage.isDisabled();\r\n          }),\r\n          receivingConfig(),\r\n          Replacing.config({})\r\n        ].concat(spec.itemBehaviours))\r\n      };\r\n    };\r\n    var buildData = function (source) {\r\n      return {\r\n        value: source.value,\r\n        meta: __assign({ text: source.text.getOr('') }, source.meta)\r\n      };\r\n    };\r\n\r\n    var global$9 = tinymce.util.Tools.resolve('tinymce.Env');\r\n\r\n    var convertText = function (source) {\r\n      var mac = {\r\n        alt: '&#x2325;',\r\n        ctrl: '&#x2303;',\r\n        shift: '&#x21E7;',\r\n        meta: '&#x2318;',\r\n        access: '&#x2303;&#x2325;'\r\n      };\r\n      var other = {\r\n        meta: 'Ctrl',\r\n        access: 'Shift+Alt'\r\n      };\r\n      var replace = global$9.mac ? mac : other;\r\n      var shortcut = source.split('+');\r\n      var updated = map$2(shortcut, function (segment) {\r\n        var search = segment.toLowerCase().trim();\r\n        return has$2(replace, search) ? replace[search] : segment;\r\n      });\r\n      return global$9.mac ? updated.join('') : updated.join('+');\r\n    };\r\n\r\n    var renderIcon$1 = function (name, icons, classes) {\r\n      if (classes === void 0) {\r\n        classes = [iconClass];\r\n      }\r\n      return render$3(name, {\r\n        tag: 'div',\r\n        classes: classes\r\n      }, icons);\r\n    };\r\n    var renderText = function (text) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [textClass]\r\n        },\r\n        components: [text$1(global$e.translate(text))]\r\n      };\r\n    };\r\n    var renderHtml = function (html, classes) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: classes,\r\n          innerHtml: html\r\n        }\r\n      };\r\n    };\r\n    var renderStyledText = function (style, text) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [textClass]\r\n        },\r\n        components: [{\r\n            dom: {\r\n              tag: style.tag,\r\n              styles: style.styles\r\n            },\r\n            components: [text$1(global$e.translate(text))]\r\n          }]\r\n      };\r\n    };\r\n    var renderShortcut = function (shortcut) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [accessoryClass],\r\n          innerHtml: convertText(shortcut)\r\n        }\r\n      };\r\n    };\r\n    var renderCheckmark = function (icons) {\r\n      return renderIcon$1('checkmark', icons, [checkmarkClass]);\r\n    };\r\n    var renderSubmenuCaret = function (icons) {\r\n      return renderIcon$1('chevron-right', icons, [caretClass]);\r\n    };\r\n    var renderDownwardsCaret = function (icons) {\r\n      return renderIcon$1('chevron-down', icons, [caretClass]);\r\n    };\r\n    var renderContainer = function (container, components) {\r\n      var directionClass = container.direction === 'vertical' ? containerColumnClass : containerRowClass;\r\n      var alignClass = container.align === 'left' ? containerAlignLeftClass : containerAlignRightClass;\r\n      var getValignClass = function () {\r\n        switch (container.valign) {\r\n        case 'top':\r\n          return containerValignTopClass;\r\n        case 'middle':\r\n          return containerValignMiddleClass;\r\n        case 'bottom':\r\n          return containerValignBottomClass;\r\n        }\r\n      };\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [\r\n            containerClass,\r\n            directionClass,\r\n            alignClass,\r\n            getValignClass()\r\n          ]\r\n        },\r\n        components: components\r\n      };\r\n    };\r\n    var renderImage = function (src, classes, alt) {\r\n      return {\r\n        dom: {\r\n          tag: 'img',\r\n          classes: classes,\r\n          attributes: {\r\n            src: src,\r\n            alt: alt.getOr('')\r\n          }\r\n        }\r\n      };\r\n    };\r\n\r\n    var renderColorStructure = function (item, providerBackstage, fallbackIcon) {\r\n      var colorPickerCommand = 'custom';\r\n      var removeColorCommand = 'remove';\r\n      var itemText = item.ariaLabel;\r\n      var itemValue = item.value;\r\n      var iconSvg = item.iconContent.map(function (name) {\r\n        return getOr(name, providerBackstage.icons, fallbackIcon);\r\n      });\r\n      var getDom = function () {\r\n        var common = colorClass;\r\n        var icon = iconSvg.getOr('');\r\n        var attributes = itemText.map(function (text) {\r\n          return { title: providerBackstage.translate(text) };\r\n        }).getOr({});\r\n        var baseDom = {\r\n          tag: 'div',\r\n          attributes: attributes,\r\n          classes: [common]\r\n        };\r\n        if (itemValue === colorPickerCommand) {\r\n          return __assign(__assign({}, baseDom), {\r\n            tag: 'button',\r\n            classes: __spreadArray(__spreadArray([], baseDom.classes, true), ['tox-swatches__picker-btn'], false),\r\n            innerHtml: icon\r\n          });\r\n        } else if (itemValue === removeColorCommand) {\r\n          return __assign(__assign({}, baseDom), {\r\n            classes: __spreadArray(__spreadArray([], baseDom.classes, true), ['tox-swatch--remove'], false),\r\n            innerHtml: icon\r\n          });\r\n        } else {\r\n          return __assign(__assign({}, baseDom), {\r\n            attributes: __assign(__assign({}, baseDom.attributes), { 'data-mce-color': itemValue }),\r\n            styles: { 'background-color': itemValue }\r\n          });\r\n        }\r\n      };\r\n      return {\r\n        dom: getDom(),\r\n        optComponents: []\r\n      };\r\n    };\r\n    var renderItemDomStructure = function (ariaLabel) {\r\n      var domTitle = ariaLabel.map(function (label) {\r\n        return { attributes: { title: global$e.translate(label) } };\r\n      }).getOr({});\r\n      return __assign({\r\n        tag: 'div',\r\n        classes: [\r\n          navClass,\r\n          selectableClass\r\n        ]\r\n      }, domTitle);\r\n    };\r\n    var renderNormalItemStructure = function (info, providersBackstage, renderIcons, fallbackIcon) {\r\n      var iconSpec = {\r\n        tag: 'div',\r\n        classes: [iconClass]\r\n      };\r\n      var renderIcon = function (iconName) {\r\n        return render$3(iconName, iconSpec, providersBackstage.icons, fallbackIcon);\r\n      };\r\n      var renderEmptyIcon = function () {\r\n        return Optional.some({ dom: iconSpec });\r\n      };\r\n      var leftIcon = renderIcons ? info.iconContent.map(renderIcon).orThunk(renderEmptyIcon) : Optional.none();\r\n      var checkmark = info.checkMark;\r\n      var textRender = Optional.from(info.meta).fold(function () {\r\n        return renderText;\r\n      }, function (meta) {\r\n        return has$2(meta, 'style') ? curry(renderStyledText, meta.style) : renderText;\r\n      });\r\n      var content = info.htmlContent.fold(function () {\r\n        return info.textContent.map(textRender);\r\n      }, function (html) {\r\n        return Optional.some(renderHtml(html, [textClass]));\r\n      });\r\n      var menuItem = {\r\n        dom: renderItemDomStructure(info.ariaLabel),\r\n        optComponents: [\r\n          leftIcon,\r\n          content,\r\n          info.shortcutContent.map(renderShortcut),\r\n          checkmark,\r\n          info.caret\r\n        ]\r\n      };\r\n      return menuItem;\r\n    };\r\n    var renderItemStructure = function (info, providersBackstage, renderIcons, fallbackIcon) {\r\n      if (fallbackIcon === void 0) {\r\n        fallbackIcon = Optional.none();\r\n      }\r\n      if (info.presets === 'color') {\r\n        return renderColorStructure(info, providersBackstage, fallbackIcon);\r\n      } else {\r\n        return renderNormalItemStructure(info, providersBackstage, renderIcons, fallbackIcon);\r\n      }\r\n    };\r\n\r\n    var tooltipBehaviour = function (meta, sharedBackstage) {\r\n      return get$e(meta, 'tooltipWorker').map(function (tooltipWorker) {\r\n        return [Tooltipping.config({\r\n            lazySink: sharedBackstage.getSink,\r\n            tooltipDom: {\r\n              tag: 'div',\r\n              classes: ['tox-tooltip-worker-container']\r\n            },\r\n            tooltipComponents: [],\r\n            anchor: function (comp) {\r\n              return {\r\n                type: 'submenu',\r\n                item: comp,\r\n                overrides: { maxHeightFunction: expandable$1 }\r\n              };\r\n            },\r\n            mode: 'follow-highlight',\r\n            onShow: function (component, _tooltip) {\r\n              tooltipWorker(function (elm) {\r\n                Tooltipping.setComponents(component, [external$2({ element: SugarElement.fromDom(elm) })]);\r\n              });\r\n            }\r\n          })];\r\n      }).getOr([]);\r\n    };\r\n    var encodeText = function (text) {\r\n      return global$b.DOM.encode(text);\r\n    };\r\n    var replaceText = function (text, matchText) {\r\n      var translated = global$e.translate(text);\r\n      var encoded = encodeText(translated);\r\n      if (matchText.length > 0) {\r\n        var escapedMatchRegex = new RegExp(escape(matchText), 'gi');\r\n        return encoded.replace(escapedMatchRegex, function (match) {\r\n          return '<span class=\"tox-autocompleter-highlight\">' + match + '</span>';\r\n        });\r\n      } else {\r\n        return encoded;\r\n      }\r\n    };\r\n    var renderAutocompleteItem = function (spec, matchText, useText, presets, onItemValueHandler, itemResponse, sharedBackstage, renderIcons) {\r\n      if (renderIcons === void 0) {\r\n        renderIcons = true;\r\n      }\r\n      var structure = renderItemStructure({\r\n        presets: presets,\r\n        textContent: Optional.none(),\r\n        htmlContent: useText ? spec.text.map(function (text) {\r\n          return replaceText(text, matchText);\r\n        }) : Optional.none(),\r\n        ariaLabel: spec.text,\r\n        iconContent: spec.icon,\r\n        shortcutContent: Optional.none(),\r\n        checkMark: Optional.none(),\r\n        caret: Optional.none(),\r\n        value: spec.value\r\n      }, sharedBackstage.providers, renderIcons, spec.icon);\r\n      return renderCommonItem({\r\n        data: buildData(spec),\r\n        disabled: spec.disabled,\r\n        getApi: constant$1({}),\r\n        onAction: function (_api) {\r\n          return onItemValueHandler(spec.value, spec.meta);\r\n        },\r\n        onSetup: constant$1(noop),\r\n        triggersSubmenu: false,\r\n        itemBehaviours: tooltipBehaviour(spec.meta, sharedBackstage)\r\n      }, structure, itemResponse, sharedBackstage.providers);\r\n    };\r\n\r\n    var render$2 = function (items, extras) {\r\n      return map$2(items, function (item) {\r\n        switch (item.type) {\r\n        case 'cardcontainer':\r\n          return renderContainer(item, render$2(item.items, extras));\r\n        case 'cardimage':\r\n          return renderImage(item.src, item.classes, item.alt);\r\n        case 'cardtext':\r\n          var shouldHighlight = item.name.exists(function (name) {\r\n            return contains$2(extras.cardText.highlightOn, name);\r\n          });\r\n          var matchText = shouldHighlight ? Optional.from(extras.cardText.matchText).getOr('') : '';\r\n          return renderHtml(replaceText(item.text, matchText), item.classes);\r\n        }\r\n      });\r\n    };\r\n    var renderCardMenuItem = function (spec, itemResponse, sharedBackstage, extras) {\r\n      var getApi = function (component) {\r\n        return {\r\n          isDisabled: function () {\r\n            return Disabling.isDisabled(component);\r\n          },\r\n          setDisabled: function (state) {\r\n            Disabling.set(component, state);\r\n            each$1(descendants(component.element, '*'), function (elm) {\r\n              component.getSystem().getByDom(elm).each(function (comp) {\r\n                if (comp.hasConfigured(Disabling)) {\r\n                  Disabling.set(comp, state);\r\n                }\r\n              });\r\n            });\r\n          }\r\n        };\r\n      };\r\n      var structure = {\r\n        dom: renderItemDomStructure(spec.label),\r\n        optComponents: [Optional.some({\r\n            dom: {\r\n              tag: 'div',\r\n              classes: [\r\n                containerClass,\r\n                containerRowClass\r\n              ]\r\n            },\r\n            components: render$2(spec.items, extras)\r\n          })]\r\n      };\r\n      return renderCommonItem({\r\n        data: buildData(__assign({ text: Optional.none() }, spec)),\r\n        disabled: spec.disabled,\r\n        getApi: getApi,\r\n        onAction: spec.onAction,\r\n        onSetup: spec.onSetup,\r\n        triggersSubmenu: false,\r\n        itemBehaviours: Optional.from(extras.itemBehaviours).getOr([])\r\n      }, structure, itemResponse, sharedBackstage.providers);\r\n    };\r\n\r\n    var renderChoiceItem = function (spec, useText, presets, onItemValueHandler, isSelected, itemResponse, providersBackstage, renderIcons) {\r\n      if (renderIcons === void 0) {\r\n        renderIcons = true;\r\n      }\r\n      var getApi = function (component) {\r\n        return {\r\n          setActive: function (state) {\r\n            Toggling.set(component, state);\r\n          },\r\n          isActive: function () {\r\n            return Toggling.isOn(component);\r\n          },\r\n          isDisabled: function () {\r\n            return Disabling.isDisabled(component);\r\n          },\r\n          setDisabled: function (state) {\r\n            return Disabling.set(component, state);\r\n          }\r\n        };\r\n      };\r\n      var structure = renderItemStructure({\r\n        presets: presets,\r\n        textContent: useText ? spec.text : Optional.none(),\r\n        htmlContent: Optional.none(),\r\n        ariaLabel: spec.text,\r\n        iconContent: spec.icon,\r\n        shortcutContent: useText ? spec.shortcut : Optional.none(),\r\n        checkMark: useText ? Optional.some(renderCheckmark(providersBackstage.icons)) : Optional.none(),\r\n        caret: Optional.none(),\r\n        value: spec.value\r\n      }, providersBackstage, renderIcons);\r\n      return deepMerge(renderCommonItem({\r\n        data: buildData(spec),\r\n        disabled: spec.disabled,\r\n        getApi: getApi,\r\n        onAction: function (_api) {\r\n          return onItemValueHandler(spec.value);\r\n        },\r\n        onSetup: function (api) {\r\n          api.setActive(isSelected);\r\n          return noop;\r\n        },\r\n        triggersSubmenu: false,\r\n        itemBehaviours: []\r\n      }, structure, itemResponse, providersBackstage), {\r\n        toggling: {\r\n          toggleClass: tickedClass,\r\n          toggleOnExecute: false,\r\n          selected: spec.active\r\n        }\r\n      });\r\n    };\r\n\r\n    var parts$f = generate$3(owner$2(), parts$h());\r\n\r\n    var hexColour = function (value) {\r\n      return { value: value };\r\n    };\r\n    var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\r\n    var longformRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\r\n    var isHexString = function (hex) {\r\n      return shorthandRegex.test(hex) || longformRegex.test(hex);\r\n    };\r\n    var normalizeHex = function (hex) {\r\n      return removeLeading(hex, '#').toUpperCase();\r\n    };\r\n    var fromString$1 = function (hex) {\r\n      return isHexString(hex) ? Optional.some({ value: normalizeHex(hex) }) : Optional.none();\r\n    };\r\n    var getLongForm = function (hex) {\r\n      var hexString = hex.value.replace(shorthandRegex, function (m, r, g, b) {\r\n        return r + r + g + g + b + b;\r\n      });\r\n      return { value: hexString };\r\n    };\r\n    var extractValues = function (hex) {\r\n      var longForm = getLongForm(hex);\r\n      var splitForm = longformRegex.exec(longForm.value);\r\n      return splitForm === null ? [\r\n        'FFFFFF',\r\n        'FF',\r\n        'FF',\r\n        'FF'\r\n      ] : splitForm;\r\n    };\r\n    var toHex = function (component) {\r\n      var hex = component.toString(16);\r\n      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\r\n    };\r\n    var fromRgba = function (rgbaColour) {\r\n      var value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\r\n      return hexColour(value);\r\n    };\r\n\r\n    var min = Math.min;\r\n    var max = Math.max;\r\n    var round$1 = Math.round;\r\n    var rgbRegex = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/;\r\n    var rgbaRegex = /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*(\\d?(?:\\.\\d+)?)\\)/;\r\n    var rgbaColour = function (red, green, blue, alpha) {\r\n      return {\r\n        red: red,\r\n        green: green,\r\n        blue: blue,\r\n        alpha: alpha\r\n      };\r\n    };\r\n    var isRgbaComponent = function (value) {\r\n      var num = parseInt(value, 10);\r\n      return num.toString() === value && num >= 0 && num <= 255;\r\n    };\r\n    var fromHsv = function (hsv) {\r\n      var r;\r\n      var g;\r\n      var b;\r\n      var hue = (hsv.hue || 0) % 360;\r\n      var saturation = hsv.saturation / 100;\r\n      var brightness = hsv.value / 100;\r\n      saturation = max(0, min(saturation, 1));\r\n      brightness = max(0, min(brightness, 1));\r\n      if (saturation === 0) {\r\n        r = g = b = round$1(255 * brightness);\r\n        return rgbaColour(r, g, b, 1);\r\n      }\r\n      var side = hue / 60;\r\n      var chroma = brightness * saturation;\r\n      var x = chroma * (1 - Math.abs(side % 2 - 1));\r\n      var match = brightness - chroma;\r\n      switch (Math.floor(side)) {\r\n      case 0:\r\n        r = chroma;\r\n        g = x;\r\n        b = 0;\r\n        break;\r\n      case 1:\r\n        r = x;\r\n        g = chroma;\r\n        b = 0;\r\n        break;\r\n      case 2:\r\n        r = 0;\r\n        g = chroma;\r\n        b = x;\r\n        break;\r\n      case 3:\r\n        r = 0;\r\n        g = x;\r\n        b = chroma;\r\n        break;\r\n      case 4:\r\n        r = x;\r\n        g = 0;\r\n        b = chroma;\r\n        break;\r\n      case 5:\r\n        r = chroma;\r\n        g = 0;\r\n        b = x;\r\n        break;\r\n      default:\r\n        r = g = b = 0;\r\n      }\r\n      r = round$1(255 * (r + match));\r\n      g = round$1(255 * (g + match));\r\n      b = round$1(255 * (b + match));\r\n      return rgbaColour(r, g, b, 1);\r\n    };\r\n    var fromHex = function (hexColour) {\r\n      var result = extractValues(hexColour);\r\n      var red = parseInt(result[1], 16);\r\n      var green = parseInt(result[2], 16);\r\n      var blue = parseInt(result[3], 16);\r\n      return rgbaColour(red, green, blue, 1);\r\n    };\r\n    var fromStringValues = function (red, green, blue, alpha) {\r\n      var r = parseInt(red, 10);\r\n      var g = parseInt(green, 10);\r\n      var b = parseInt(blue, 10);\r\n      var a = parseFloat(alpha);\r\n      return rgbaColour(r, g, b, a);\r\n    };\r\n    var fromString = function (rgbaString) {\r\n      if (rgbaString === 'transparent') {\r\n        return Optional.some(rgbaColour(0, 0, 0, 0));\r\n      }\r\n      var rgbMatch = rgbRegex.exec(rgbaString);\r\n      if (rgbMatch !== null) {\r\n        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\r\n      }\r\n      var rgbaMatch = rgbaRegex.exec(rgbaString);\r\n      if (rgbaMatch !== null) {\r\n        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var toString = function (rgba) {\r\n      return 'rgba(' + rgba.red + ',' + rgba.green + ',' + rgba.blue + ',' + rgba.alpha + ')';\r\n    };\r\n    var red = rgbaColour(255, 0, 0, 1);\r\n\r\n    var fireSkinLoaded$1 = function (editor) {\r\n      return editor.fire('SkinLoaded');\r\n    };\r\n    var fireSkinLoadError$1 = function (editor, error) {\r\n      return editor.fire('SkinLoadError', error);\r\n    };\r\n    var fireResizeEditor = function (editor) {\r\n      return editor.fire('ResizeEditor');\r\n    };\r\n    var fireResizeContent = function (editor, e) {\r\n      return editor.fire('ResizeContent', e);\r\n    };\r\n    var fireScrollContent = function (editor, e) {\r\n      return editor.fire('ScrollContent', e);\r\n    };\r\n    var fireTextColorChange = function (editor, data) {\r\n      return editor.fire('TextColorChange', data);\r\n    };\r\n\r\n    var hsvColour = function (hue, saturation, value) {\r\n      return {\r\n        hue: hue,\r\n        saturation: saturation,\r\n        value: value\r\n      };\r\n    };\r\n    var fromRgb = function (rgbaColour) {\r\n      var h = 0;\r\n      var s = 0;\r\n      var v = 0;\r\n      var r = rgbaColour.red / 255;\r\n      var g = rgbaColour.green / 255;\r\n      var b = rgbaColour.blue / 255;\r\n      var minRGB = Math.min(r, Math.min(g, b));\r\n      var maxRGB = Math.max(r, Math.max(g, b));\r\n      if (minRGB === maxRGB) {\r\n        v = minRGB;\r\n        return hsvColour(0, 0, v * 100);\r\n      }\r\n      var d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;\r\n      h = r === minRGB ? 3 : b === minRGB ? 1 : 5;\r\n      h = 60 * (h - d / (maxRGB - minRGB));\r\n      s = (maxRGB - minRGB) / maxRGB;\r\n      v = maxRGB;\r\n      return hsvColour(Math.round(h), Math.round(s * 100), Math.round(v * 100));\r\n    };\r\n\r\n    var hexToHsv = function (hex) {\r\n      return fromRgb(fromHex(hex));\r\n    };\r\n    var hsvToHex = function (hsv) {\r\n      return fromRgba(fromHsv(hsv));\r\n    };\r\n    var anyToHex = function (color) {\r\n      return fromString$1(color).orThunk(function () {\r\n        return fromString(color).map(fromRgba);\r\n      }).getOrThunk(function () {\r\n        var canvas = document.createElement('canvas');\r\n        canvas.height = 1;\r\n        canvas.width = 1;\r\n        var canvasContext = canvas.getContext('2d');\r\n        canvasContext.clearRect(0, 0, canvas.width, canvas.height);\r\n        canvasContext.fillStyle = '#FFFFFF';\r\n        canvasContext.fillStyle = color;\r\n        canvasContext.fillRect(0, 0, 1, 1);\r\n        var rgba = canvasContext.getImageData(0, 0, 1, 1).data;\r\n        var r = rgba[0];\r\n        var g = rgba[1];\r\n        var b = rgba[2];\r\n        var a = rgba[3];\r\n        return fromRgba(rgbaColour(r, g, b, a));\r\n      });\r\n    };\r\n\r\n    var global$8 = tinymce.util.Tools.resolve('tinymce.util.LocalStorage');\r\n\r\n    var storageName = 'tinymce-custom-colors';\r\n    function ColorCache (max) {\r\n      if (max === void 0) {\r\n        max = 10;\r\n      }\r\n      var storageString = global$8.getItem(storageName);\r\n      var localstorage = isString(storageString) ? JSON.parse(storageString) : [];\r\n      var prune = function (list) {\r\n        var diff = max - list.length;\r\n        return diff < 0 ? list.slice(0, max) : list;\r\n      };\r\n      var cache = prune(localstorage);\r\n      var add = function (key) {\r\n        indexOf(cache, key).each(remove);\r\n        cache.unshift(key);\r\n        if (cache.length > max) {\r\n          cache.pop();\r\n        }\r\n        global$8.setItem(storageName, JSON.stringify(cache));\r\n      };\r\n      var remove = function (idx) {\r\n        cache.splice(idx, 1);\r\n      };\r\n      var state = function () {\r\n        return cache.slice(0);\r\n      };\r\n      return {\r\n        add: add,\r\n        state: state\r\n      };\r\n    }\r\n\r\n    var choiceItem = 'choiceitem';\r\n    var defaultColors = [\r\n      {\r\n        type: choiceItem,\r\n        text: 'Light Green',\r\n        value: '#BFEDD2'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Light Yellow',\r\n        value: '#FBEEB8'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Light Red',\r\n        value: '#F8CAC6'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Light Purple',\r\n        value: '#ECCAFA'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Light Blue',\r\n        value: '#C2E0F4'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Green',\r\n        value: '#2DC26B'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Yellow',\r\n        value: '#F1C40F'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Red',\r\n        value: '#E03E2D'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Purple',\r\n        value: '#B96AD9'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Blue',\r\n        value: '#3598DB'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Dark Turquoise',\r\n        value: '#169179'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Orange',\r\n        value: '#E67E23'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Dark Red',\r\n        value: '#BA372A'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Dark Purple',\r\n        value: '#843FA1'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Dark Blue',\r\n        value: '#236FA1'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Light Gray',\r\n        value: '#ECF0F1'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Medium Gray',\r\n        value: '#CED4D9'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Gray',\r\n        value: '#95A5A6'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Dark Gray',\r\n        value: '#7E8C8D'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Navy Blue',\r\n        value: '#34495E'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'Black',\r\n        value: '#000000'\r\n      },\r\n      {\r\n        type: choiceItem,\r\n        text: 'White',\r\n        value: '#ffffff'\r\n      }\r\n    ];\r\n    var colorCache = ColorCache(10);\r\n    var mapColors = function (colorMap) {\r\n      var colors = [];\r\n      for (var i = 0; i < colorMap.length; i += 2) {\r\n        colors.push({\r\n          text: colorMap[i + 1],\r\n          value: '#' + anyToHex(colorMap[i]).value,\r\n          type: 'choiceitem'\r\n        });\r\n      }\r\n      return colors;\r\n    };\r\n    var getColorCols$2 = function (editor, defaultCols) {\r\n      return editor.getParam('color_cols', defaultCols, 'number');\r\n    };\r\n    var hasCustomColors$1 = function (editor) {\r\n      return editor.getParam('custom_colors') !== false;\r\n    };\r\n    var getColorMap = function (editor) {\r\n      return editor.getParam('color_map');\r\n    };\r\n    var getColors$2 = function (editor) {\r\n      var unmapped = getColorMap(editor);\r\n      return unmapped !== undefined ? mapColors(unmapped) : defaultColors;\r\n    };\r\n    var getCurrentColors = function () {\r\n      return map$2(colorCache.state(), function (color) {\r\n        return {\r\n          type: choiceItem,\r\n          text: color,\r\n          value: color\r\n        };\r\n      });\r\n    };\r\n    var addColor = function (color) {\r\n      colorCache.add(color);\r\n    };\r\n\r\n    var fallbackColor = '#000000';\r\n    var getCurrentColor = function (editor, format) {\r\n      var color;\r\n      editor.dom.getParents(editor.selection.getStart(), function (elm) {\r\n        var value;\r\n        if (value = elm.style[format === 'forecolor' ? 'color' : 'background-color']) {\r\n          color = color ? color : value;\r\n        }\r\n      });\r\n      return Optional.from(color);\r\n    };\r\n    var applyFormat = function (editor, format, value) {\r\n      editor.undoManager.transact(function () {\r\n        editor.focus();\r\n        editor.formatter.apply(format, { value: value });\r\n        editor.nodeChanged();\r\n      });\r\n    };\r\n    var removeFormat = function (editor, format) {\r\n      editor.undoManager.transact(function () {\r\n        editor.focus();\r\n        editor.formatter.remove(format, { value: null }, null, true);\r\n        editor.nodeChanged();\r\n      });\r\n    };\r\n    var registerCommands = function (editor) {\r\n      editor.addCommand('mceApplyTextcolor', function (format, value) {\r\n        applyFormat(editor, format, value);\r\n      });\r\n      editor.addCommand('mceRemoveTextcolor', function (format) {\r\n        removeFormat(editor, format);\r\n      });\r\n    };\r\n    var calcCols = function (colors) {\r\n      return Math.max(5, Math.ceil(Math.sqrt(colors)));\r\n    };\r\n    var getColorCols$1 = function (editor) {\r\n      var colors = getColors$2(editor);\r\n      var defaultCols = calcCols(colors.length);\r\n      return getColorCols$2(editor, defaultCols);\r\n    };\r\n    var getAdditionalColors = function (hasCustom) {\r\n      var type = 'choiceitem';\r\n      var remove = {\r\n        type: type,\r\n        text: 'Remove color',\r\n        icon: 'color-swatch-remove-color',\r\n        value: 'remove'\r\n      };\r\n      var custom = {\r\n        type: type,\r\n        text: 'Custom color',\r\n        icon: 'color-picker',\r\n        value: 'custom'\r\n      };\r\n      return hasCustom ? [\r\n        remove,\r\n        custom\r\n      ] : [remove];\r\n    };\r\n    var applyColor = function (editor, format, value, onChoice) {\r\n      if (value === 'custom') {\r\n        var dialog = colorPickerDialog(editor);\r\n        dialog(function (colorOpt) {\r\n          colorOpt.each(function (color) {\r\n            addColor(color);\r\n            editor.execCommand('mceApplyTextcolor', format, color);\r\n            onChoice(color);\r\n          });\r\n        }, fallbackColor);\r\n      } else if (value === 'remove') {\r\n        onChoice('');\r\n        editor.execCommand('mceRemoveTextcolor', format);\r\n      } else {\r\n        onChoice(value);\r\n        editor.execCommand('mceApplyTextcolor', format, value);\r\n      }\r\n    };\r\n    var getColors$1 = function (colors, hasCustom) {\r\n      return colors.concat(getCurrentColors().concat(getAdditionalColors(hasCustom)));\r\n    };\r\n    var getFetch$1 = function (colors, hasCustom) {\r\n      return function (callback) {\r\n        callback(getColors$1(colors, hasCustom));\r\n      };\r\n    };\r\n    var setIconColor = function (splitButtonApi, name, newColor) {\r\n      var id = name === 'forecolor' ? 'tox-icon-text-color__color' : 'tox-icon-highlight-bg-color__color';\r\n      splitButtonApi.setIconFill(id, newColor);\r\n    };\r\n    var registerTextColorButton = function (editor, name, format, tooltip, lastColor) {\r\n      editor.ui.registry.addSplitButton(name, {\r\n        tooltip: tooltip,\r\n        presets: 'color',\r\n        icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',\r\n        select: function (value) {\r\n          var optCurrentRgb = getCurrentColor(editor, format);\r\n          return optCurrentRgb.bind(function (currentRgb) {\r\n            return fromString(currentRgb).map(function (rgba) {\r\n              var currentHex = fromRgba(rgba).value;\r\n              return contains$1(value.toLowerCase(), currentHex);\r\n            });\r\n          }).getOr(false);\r\n        },\r\n        columns: getColorCols$1(editor),\r\n        fetch: getFetch$1(getColors$2(editor), hasCustomColors$1(editor)),\r\n        onAction: function (_splitButtonApi) {\r\n          applyColor(editor, format, lastColor.get(), noop);\r\n        },\r\n        onItemAction: function (_splitButtonApi, value) {\r\n          applyColor(editor, format, value, function (newColor) {\r\n            lastColor.set(newColor);\r\n            fireTextColorChange(editor, {\r\n              name: name,\r\n              color: newColor\r\n            });\r\n          });\r\n        },\r\n        onSetup: function (splitButtonApi) {\r\n          setIconColor(splitButtonApi, name, lastColor.get());\r\n          var handler = function (e) {\r\n            if (e.name === name) {\r\n              setIconColor(splitButtonApi, e.name, e.color);\r\n            }\r\n          };\r\n          editor.on('TextColorChange', handler);\r\n          return function () {\r\n            editor.off('TextColorChange', handler);\r\n          };\r\n        }\r\n      });\r\n    };\r\n    var registerTextColorMenuItem = function (editor, name, format, text) {\r\n      editor.ui.registry.addNestedMenuItem(name, {\r\n        text: text,\r\n        icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',\r\n        getSubmenuItems: function () {\r\n          return [{\r\n              type: 'fancymenuitem',\r\n              fancytype: 'colorswatch',\r\n              onAction: function (data) {\r\n                applyColor(editor, format, data.value, noop);\r\n              }\r\n            }];\r\n        }\r\n      });\r\n    };\r\n    var colorPickerDialog = function (editor) {\r\n      return function (callback, value) {\r\n        var isValid = false;\r\n        var onSubmit = function (api) {\r\n          var data = api.getData();\r\n          var hex = data.colorpicker;\r\n          if (isValid) {\r\n            callback(Optional.from(hex));\r\n            api.close();\r\n          } else {\r\n            editor.windowManager.alert(editor.translate([\r\n              'Invalid hex color code: {0}',\r\n              hex\r\n            ]));\r\n          }\r\n        };\r\n        var onAction = function (_api, details) {\r\n          if (details.name === 'hex-valid') {\r\n            isValid = details.value;\r\n          }\r\n        };\r\n        var initialData = { colorpicker: value };\r\n        editor.windowManager.open({\r\n          title: 'Color Picker',\r\n          size: 'normal',\r\n          body: {\r\n            type: 'panel',\r\n            items: [{\r\n                type: 'colorpicker',\r\n                name: 'colorpicker',\r\n                label: 'Color'\r\n              }]\r\n          },\r\n          buttons: [\r\n            {\r\n              type: 'cancel',\r\n              name: 'cancel',\r\n              text: 'Cancel'\r\n            },\r\n            {\r\n              type: 'submit',\r\n              name: 'save',\r\n              text: 'Save',\r\n              primary: true\r\n            }\r\n          ],\r\n          initialData: initialData,\r\n          onAction: onAction,\r\n          onSubmit: onSubmit,\r\n          onClose: noop,\r\n          onCancel: function () {\r\n            callback(Optional.none());\r\n          }\r\n        });\r\n      };\r\n    };\r\n    var register$a = function (editor) {\r\n      registerCommands(editor);\r\n      var lastForeColor = Cell(fallbackColor);\r\n      var lastBackColor = Cell(fallbackColor);\r\n      registerTextColorButton(editor, 'forecolor', 'forecolor', 'Text color', lastForeColor);\r\n      registerTextColorButton(editor, 'backcolor', 'hilitecolor', 'Background color', lastBackColor);\r\n      registerTextColorMenuItem(editor, 'forecolor', 'forecolor', 'Text color');\r\n      registerTextColorMenuItem(editor, 'backcolor', 'hilitecolor', 'Background color');\r\n    };\r\n\r\n    var createPartialChoiceMenu = function (value, items, onItemValueHandler, columns, presets, itemResponse, select, providersBackstage) {\r\n      var hasIcons = menuHasIcons(items);\r\n      var presetItemTypes = presets !== 'color' ? 'normal' : 'color';\r\n      var alloyItems = createChoiceItems(items, onItemValueHandler, columns, presetItemTypes, itemResponse, select, providersBackstage);\r\n      return createPartialMenuWithAlloyItems(value, hasIcons, alloyItems, columns, presets);\r\n    };\r\n    var createChoiceItems = function (items, onItemValueHandler, columns, itemPresets, itemResponse, select, providersBackstage) {\r\n      return cat(map$2(items, function (item) {\r\n        if (item.type === 'choiceitem') {\r\n          return createChoiceMenuItem(item).fold(handleError, function (d) {\r\n            return Optional.some(renderChoiceItem(d, columns === 1, itemPresets, onItemValueHandler, select(item.value), itemResponse, providersBackstage, menuHasIcons(items)));\r\n          });\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      }));\r\n    };\r\n\r\n    var deriveMenuMovement = function (columns, presets) {\r\n      var menuMarkers = markers(presets);\r\n      if (columns === 1) {\r\n        return {\r\n          mode: 'menu',\r\n          moveOnTab: true\r\n        };\r\n      } else if (columns === 'auto') {\r\n        return {\r\n          mode: 'grid',\r\n          selector: '.' + menuMarkers.item,\r\n          initSize: {\r\n            numColumns: 1,\r\n            numRows: 1\r\n          }\r\n        };\r\n      } else {\r\n        var rowClass = presets === 'color' ? 'tox-swatches__row' : 'tox-collection__group';\r\n        return {\r\n          mode: 'matrix',\r\n          rowSelector: '.' + rowClass\r\n        };\r\n      }\r\n    };\r\n    var deriveCollectionMovement = function (columns, presets) {\r\n      if (columns === 1) {\r\n        return {\r\n          mode: 'menu',\r\n          moveOnTab: false,\r\n          selector: '.tox-collection__item'\r\n        };\r\n      } else if (columns === 'auto') {\r\n        return {\r\n          mode: 'flatgrid',\r\n          selector: '.' + 'tox-collection__item',\r\n          initSize: {\r\n            numColumns: 1,\r\n            numRows: 1\r\n          }\r\n        };\r\n      } else {\r\n        return {\r\n          mode: 'matrix',\r\n          selectors: {\r\n            row: presets === 'color' ? '.tox-swatches__row' : '.tox-collection__group',\r\n            cell: presets === 'color' ? '.' + colorClass : '.' + selectableClass\r\n          }\r\n        };\r\n      }\r\n    };\r\n\r\n    var renderColorSwatchItem = function (spec, backstage) {\r\n      var items = getColorItems(spec, backstage);\r\n      var columns = backstage.colorinput.getColorCols();\r\n      var presets = 'color';\r\n      var menuSpec = createPartialChoiceMenu(generate$6('menu-value'), items, function (value) {\r\n        spec.onAction({ value: value });\r\n      }, columns, presets, ItemResponse$1.CLOSE_ON_EXECUTE, never, backstage.shared.providers);\r\n      var widgetSpec = __assign(__assign({}, menuSpec), {\r\n        markers: markers(presets),\r\n        movement: deriveMenuMovement(columns, presets)\r\n      });\r\n      return {\r\n        type: 'widget',\r\n        data: { value: generate$6('widget-id') },\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-fancymenuitem']\r\n        },\r\n        autofocus: true,\r\n        components: [parts$f.widget(Menu.sketch(widgetSpec))]\r\n      };\r\n    };\r\n    var getColorItems = function (spec, backstage) {\r\n      var useCustomColors = spec.initData.allowCustomColors && backstage.colorinput.hasCustomColors();\r\n      return spec.initData.colors.fold(function () {\r\n        return getColors$1(backstage.colorinput.getColors(), useCustomColors);\r\n      }, function (colors) {\r\n        return colors.concat(getAdditionalColors(useCustomColors));\r\n      });\r\n    };\r\n\r\n    var cellOverEvent = generate$6('cell-over');\r\n    var cellExecuteEvent = generate$6('cell-execute');\r\n    var makeCell = function (row, col, labelId) {\r\n      var _a;\r\n      var emitCellOver = function (c) {\r\n        return emitWith(c, cellOverEvent, {\r\n          row: row,\r\n          col: col\r\n        });\r\n      };\r\n      var emitExecute = function (c) {\r\n        return emitWith(c, cellExecuteEvent, {\r\n          row: row,\r\n          col: col\r\n        });\r\n      };\r\n      var onClick = function (c, se) {\r\n        se.stop();\r\n        emitExecute(c);\r\n      };\r\n      return build$1({\r\n        dom: {\r\n          tag: 'div',\r\n          attributes: (_a = { role: 'button' }, _a['aria-labelledby'] = labelId, _a)\r\n        },\r\n        behaviours: derive$1([\r\n          config('insert-table-picker-cell', [\r\n            run$1(mouseover(), Focusing.focus),\r\n            run$1(execute$5(), emitExecute),\r\n            run$1(click(), onClick),\r\n            run$1(tap(), onClick)\r\n          ]),\r\n          Toggling.config({\r\n            toggleClass: 'tox-insert-table-picker__selected',\r\n            toggleOnExecute: false\r\n          }),\r\n          Focusing.config({ onFocus: emitCellOver })\r\n        ])\r\n      });\r\n    };\r\n    var makeCells = function (labelId, numRows, numCols) {\r\n      var cells = [];\r\n      for (var i = 0; i < numRows; i++) {\r\n        var row = [];\r\n        for (var j = 0; j < numCols; j++) {\r\n          row.push(makeCell(i, j, labelId));\r\n        }\r\n        cells.push(row);\r\n      }\r\n      return cells;\r\n    };\r\n    var selectCells = function (cells, selectedRow, selectedColumn, numRows, numColumns) {\r\n      for (var i = 0; i < numRows; i++) {\r\n        for (var j = 0; j < numColumns; j++) {\r\n          Toggling.set(cells[i][j], i <= selectedRow && j <= selectedColumn);\r\n        }\r\n      }\r\n    };\r\n    var makeComponents = function (cells) {\r\n      return bind$3(cells, function (cellRow) {\r\n        return map$2(cellRow, premade);\r\n      });\r\n    };\r\n    var makeLabelText = function (row, col) {\r\n      return text$1(col + 'x' + row);\r\n    };\r\n    var renderInsertTableMenuItem = function (spec) {\r\n      var numRows = 10;\r\n      var numColumns = 10;\r\n      var sizeLabelId = generate$6('size-label');\r\n      var cells = makeCells(sizeLabelId, numRows, numColumns);\r\n      var emptyLabelText = makeLabelText(0, 0);\r\n      var memLabel = record({\r\n        dom: {\r\n          tag: 'span',\r\n          classes: ['tox-insert-table-picker__label'],\r\n          attributes: { id: sizeLabelId }\r\n        },\r\n        components: [emptyLabelText],\r\n        behaviours: derive$1([Replacing.config({})])\r\n      });\r\n      return {\r\n        type: 'widget',\r\n        data: { value: generate$6('widget-id') },\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-fancymenuitem']\r\n        },\r\n        autofocus: true,\r\n        components: [parts$f.widget({\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-insert-table-picker']\r\n            },\r\n            components: makeComponents(cells).concat(memLabel.asSpec()),\r\n            behaviours: derive$1([\r\n              config('insert-table-picker', [\r\n                runOnAttached(function (c) {\r\n                  Replacing.set(memLabel.get(c), [emptyLabelText]);\r\n                }),\r\n                runWithTarget(cellOverEvent, function (c, t, e) {\r\n                  var _a = e.event, row = _a.row, col = _a.col;\r\n                  selectCells(cells, row, col, numRows, numColumns);\r\n                  Replacing.set(memLabel.get(c), [makeLabelText(row + 1, col + 1)]);\r\n                }),\r\n                runWithTarget(cellExecuteEvent, function (c, _, e) {\r\n                  var _a = e.event, row = _a.row, col = _a.col;\r\n                  spec.onAction({\r\n                    numRows: row + 1,\r\n                    numColumns: col + 1\r\n                  });\r\n                  emit(c, sandboxClose());\r\n                })\r\n              ]),\r\n              Keying.config({\r\n                initSize: {\r\n                  numRows: numRows,\r\n                  numColumns: numColumns\r\n                },\r\n                mode: 'flatgrid',\r\n                selector: '[role=\"button\"]'\r\n              })\r\n            ])\r\n          })]\r\n      };\r\n    };\r\n\r\n    var fancyMenuItems = {\r\n      inserttable: renderInsertTableMenuItem,\r\n      colorswatch: renderColorSwatchItem\r\n    };\r\n    var renderFancyMenuItem = function (spec, backstage) {\r\n      return get$e(fancyMenuItems, spec.fancytype).map(function (render) {\r\n        return render(spec, backstage);\r\n      });\r\n    };\r\n\r\n    var renderNestedItem = function (spec, itemResponse, providersBackstage, renderIcons, downwardsCaret) {\r\n      if (renderIcons === void 0) {\r\n        renderIcons = true;\r\n      }\r\n      if (downwardsCaret === void 0) {\r\n        downwardsCaret = false;\r\n      }\r\n      var caret = downwardsCaret ? renderDownwardsCaret(providersBackstage.icons) : renderSubmenuCaret(providersBackstage.icons);\r\n      var getApi = function (component) {\r\n        return {\r\n          isDisabled: function () {\r\n            return Disabling.isDisabled(component);\r\n          },\r\n          setDisabled: function (state) {\r\n            return Disabling.set(component, state);\r\n          }\r\n        };\r\n      };\r\n      var structure = renderItemStructure({\r\n        presets: 'normal',\r\n        iconContent: spec.icon,\r\n        textContent: spec.text,\r\n        htmlContent: Optional.none(),\r\n        ariaLabel: spec.text,\r\n        caret: Optional.some(caret),\r\n        checkMark: Optional.none(),\r\n        shortcutContent: spec.shortcut\r\n      }, providersBackstage, renderIcons);\r\n      return renderCommonItem({\r\n        data: buildData(spec),\r\n        getApi: getApi,\r\n        disabled: spec.disabled,\r\n        onAction: noop,\r\n        onSetup: spec.onSetup,\r\n        triggersSubmenu: true,\r\n        itemBehaviours: []\r\n      }, structure, itemResponse, providersBackstage);\r\n    };\r\n\r\n    var renderNormalItem = function (spec, itemResponse, providersBackstage, renderIcons) {\r\n      if (renderIcons === void 0) {\r\n        renderIcons = true;\r\n      }\r\n      var getApi = function (component) {\r\n        return {\r\n          isDisabled: function () {\r\n            return Disabling.isDisabled(component);\r\n          },\r\n          setDisabled: function (state) {\r\n            return Disabling.set(component, state);\r\n          }\r\n        };\r\n      };\r\n      var structure = renderItemStructure({\r\n        presets: 'normal',\r\n        iconContent: spec.icon,\r\n        textContent: spec.text,\r\n        htmlContent: Optional.none(),\r\n        ariaLabel: spec.text,\r\n        caret: Optional.none(),\r\n        checkMark: Optional.none(),\r\n        shortcutContent: spec.shortcut\r\n      }, providersBackstage, renderIcons);\r\n      return renderCommonItem({\r\n        data: buildData(spec),\r\n        getApi: getApi,\r\n        disabled: spec.disabled,\r\n        onAction: spec.onAction,\r\n        onSetup: spec.onSetup,\r\n        triggersSubmenu: false,\r\n        itemBehaviours: []\r\n      }, structure, itemResponse, providersBackstage);\r\n    };\r\n\r\n    var renderSeparatorItem = function (spec) {\r\n      var innerHtml = spec.text.fold(function () {\r\n        return {};\r\n      }, function (text) {\r\n        return { innerHtml: text };\r\n      });\r\n      return {\r\n        type: 'separator',\r\n        dom: __assign({\r\n          tag: 'div',\r\n          classes: [\r\n            selectableClass,\r\n            groupHeadingClass\r\n          ]\r\n        }, innerHtml),\r\n        components: []\r\n      };\r\n    };\r\n\r\n    var renderToggleMenuItem = function (spec, itemResponse, providersBackstage, renderIcons) {\r\n      if (renderIcons === void 0) {\r\n        renderIcons = true;\r\n      }\r\n      var getApi = function (component) {\r\n        return {\r\n          setActive: function (state) {\r\n            Toggling.set(component, state);\r\n          },\r\n          isActive: function () {\r\n            return Toggling.isOn(component);\r\n          },\r\n          isDisabled: function () {\r\n            return Disabling.isDisabled(component);\r\n          },\r\n          setDisabled: function (state) {\r\n            return Disabling.set(component, state);\r\n          }\r\n        };\r\n      };\r\n      var structure = renderItemStructure({\r\n        iconContent: spec.icon,\r\n        textContent: spec.text,\r\n        htmlContent: Optional.none(),\r\n        ariaLabel: spec.text,\r\n        checkMark: Optional.some(renderCheckmark(providersBackstage.icons)),\r\n        caret: Optional.none(),\r\n        shortcutContent: spec.shortcut,\r\n        presets: 'normal',\r\n        meta: spec.meta\r\n      }, providersBackstage, renderIcons);\r\n      return deepMerge(renderCommonItem({\r\n        data: buildData(spec),\r\n        disabled: spec.disabled,\r\n        getApi: getApi,\r\n        onAction: spec.onAction,\r\n        onSetup: spec.onSetup,\r\n        triggersSubmenu: false,\r\n        itemBehaviours: []\r\n      }, structure, itemResponse, providersBackstage), {\r\n        toggling: {\r\n          toggleClass: tickedClass,\r\n          toggleOnExecute: false,\r\n          selected: spec.active\r\n        }\r\n      });\r\n    };\r\n\r\n    var autocomplete = renderAutocompleteItem;\r\n    var separator$3 = renderSeparatorItem;\r\n    var normal = renderNormalItem;\r\n    var nested = renderNestedItem;\r\n    var toggle$1 = renderToggleMenuItem;\r\n    var fancy = renderFancyMenuItem;\r\n    var card = renderCardMenuItem;\r\n\r\n    var FocusMode;\r\n    (function (FocusMode) {\r\n      FocusMode[FocusMode['ContentFocus'] = 0] = 'ContentFocus';\r\n      FocusMode[FocusMode['UiFocus'] = 1] = 'UiFocus';\r\n    }(FocusMode || (FocusMode = {})));\r\n    var createMenuItemFromBridge = function (item, itemResponse, backstage, menuHasIcons, isHorizontalMenu) {\r\n      var providersBackstage = backstage.shared.providers;\r\n      var parseForHorizontalMenu = function (menuitem) {\r\n        return !isHorizontalMenu ? menuitem : __assign(__assign({}, menuitem), {\r\n          shortcut: Optional.none(),\r\n          icon: menuitem.text.isSome() ? Optional.none() : menuitem.icon\r\n        });\r\n      };\r\n      switch (item.type) {\r\n      case 'menuitem':\r\n        return createMenuItem(item).fold(handleError, function (d) {\r\n          return Optional.some(normal(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons));\r\n        });\r\n      case 'nestedmenuitem':\r\n        return createNestedMenuItem(item).fold(handleError, function (d) {\r\n          return Optional.some(nested(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons, isHorizontalMenu));\r\n        });\r\n      case 'togglemenuitem':\r\n        return createToggleMenuItem(item).fold(handleError, function (d) {\r\n          return Optional.some(toggle$1(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons));\r\n        });\r\n      case 'separator':\r\n        return createSeparatorMenuItem(item).fold(handleError, function (d) {\r\n          return Optional.some(separator$3(d));\r\n        });\r\n      case 'fancymenuitem':\r\n        return createFancyMenuItem(item).fold(handleError, function (d) {\r\n          return fancy(parseForHorizontalMenu(d), backstage);\r\n        });\r\n      default: {\r\n          console.error('Unknown item in general menu', item);\r\n          return Optional.none();\r\n        }\r\n      }\r\n    };\r\n    var createAutocompleteItems = function (items, matchText, onItemValueHandler, columns, itemResponse, sharedBackstage, highlightOn) {\r\n      var renderText = columns === 1;\r\n      var renderIcons = !renderText || menuHasIcons(items);\r\n      return cat(map$2(items, function (item) {\r\n        switch (item.type) {\r\n        case 'separator':\r\n          return createSeparatorItem(item).fold(handleError, function (d) {\r\n            return Optional.some(separator$3(d));\r\n          });\r\n        case 'cardmenuitem':\r\n          return createCardMenuItem(item).fold(handleError, function (d) {\r\n            return Optional.some(card(__assign(__assign({}, d), {\r\n              onAction: function (api) {\r\n                d.onAction(api);\r\n                onItemValueHandler(d.value, d.meta);\r\n              }\r\n            }), itemResponse, sharedBackstage, {\r\n              itemBehaviours: tooltipBehaviour(d.meta, sharedBackstage),\r\n              cardText: {\r\n                matchText: matchText,\r\n                highlightOn: highlightOn\r\n              }\r\n            }));\r\n          });\r\n        case 'autocompleteitem':\r\n        default:\r\n          return createAutocompleterItem(item).fold(handleError, function (d) {\r\n            return Optional.some(autocomplete(d, matchText, renderText, 'normal', onItemValueHandler, itemResponse, sharedBackstage, renderIcons));\r\n          });\r\n        }\r\n      }));\r\n    };\r\n    var createPartialMenu = function (value, items, itemResponse, backstage, isHorizontalMenu) {\r\n      var hasIcons = menuHasIcons(items);\r\n      var alloyItems = cat(map$2(items, function (item) {\r\n        var itemHasIcon = function (i) {\r\n          return isHorizontalMenu ? !has$2(i, 'text') : hasIcons;\r\n        };\r\n        var createItem = function (i) {\r\n          return createMenuItemFromBridge(i, itemResponse, backstage, itemHasIcon(i), isHorizontalMenu);\r\n        };\r\n        if (item.type === 'nestedmenuitem' && item.getSubmenuItems().length <= 0) {\r\n          return createItem(__assign(__assign({}, item), { disabled: true }));\r\n        } else {\r\n          return createItem(item);\r\n        }\r\n      }));\r\n      var createPartial = isHorizontalMenu ? createHorizontalPartialMenuWithAlloyItems : createPartialMenuWithAlloyItems;\r\n      return createPartial(value, hasIcons, alloyItems, 1, 'normal');\r\n    };\r\n    var createTieredDataFrom = function (partialMenu) {\r\n      return tieredMenu.singleData(partialMenu.value, partialMenu);\r\n    };\r\n    var createMenuFrom = function (partialMenu, columns, focusMode, presets) {\r\n      var focusManager = focusMode === FocusMode.ContentFocus ? highlights() : dom$2();\r\n      var movement = deriveMenuMovement(columns, presets);\r\n      var menuMarkers = markers(presets);\r\n      return {\r\n        dom: partialMenu.dom,\r\n        components: partialMenu.components,\r\n        items: partialMenu.items,\r\n        value: partialMenu.value,\r\n        markers: {\r\n          selectedItem: menuMarkers.selectedItem,\r\n          item: menuMarkers.item\r\n        },\r\n        movement: movement,\r\n        fakeFocus: focusMode === FocusMode.ContentFocus,\r\n        focusManager: focusManager,\r\n        menuBehaviours: SimpleBehaviours.unnamedEvents(columns !== 'auto' ? [] : [runOnAttached(function (comp, _se) {\r\n            detectSize(comp, 4, menuMarkers.item).each(function (_a) {\r\n              var numColumns = _a.numColumns, numRows = _a.numRows;\r\n              Keying.setGridSize(comp, numRows, numColumns);\r\n            });\r\n          })])\r\n      };\r\n    };\r\n\r\n    var register$9 = function (editor, sharedBackstage) {\r\n      var activeAutocompleter = value$1();\r\n      var processingAction = Cell(false);\r\n      var autocompleter = build$1(InlineView.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-autocompleter']\r\n        },\r\n        components: [],\r\n        fireDismissalEventInstead: {},\r\n        inlineBehaviours: derive$1([config('dismissAutocompleter', [run$1(dismissRequested(), function () {\r\n              return cancelIfNecessary();\r\n            })])]),\r\n        lazySink: sharedBackstage.getSink\r\n      }));\r\n      var isMenuOpen = function () {\r\n        return InlineView.isOpen(autocompleter);\r\n      };\r\n      var isActive = function () {\r\n        return activeAutocompleter.get().isSome();\r\n      };\r\n      var hideIfNecessary = function () {\r\n        if (isActive()) {\r\n          InlineView.hide(autocompleter);\r\n        }\r\n      };\r\n      var cancelIfNecessary = function () {\r\n        if (isActive()) {\r\n          var lastElement = activeAutocompleter.get().map(function (ac) {\r\n            return ac.element;\r\n          });\r\n          detect(lastElement.getOr(SugarElement.fromDom(editor.selection.getNode()))).each(unwrap);\r\n          hideIfNecessary();\r\n          activeAutocompleter.clear();\r\n          processingAction.set(false);\r\n        }\r\n      };\r\n      var getAutocompleters = cached(function () {\r\n        return register$b(editor);\r\n      });\r\n      var getCombinedItems = function (triggerChar, matches) {\r\n        var columns = findMap(matches, function (m) {\r\n          return Optional.from(m.columns);\r\n        }).getOr(1);\r\n        return bind$3(matches, function (match) {\r\n          var choices = match.items;\r\n          return createAutocompleteItems(choices, match.matchText, function (itemValue, itemMeta) {\r\n            var nr = editor.selection.getRng();\r\n            getContext(editor.dom, nr, triggerChar).fold(function () {\r\n              return console.error('Lost context. Cursor probably moved');\r\n            }, function (_a) {\r\n              var range = _a.range;\r\n              var autocompleterApi = {\r\n                hide: function () {\r\n                  cancelIfNecessary();\r\n                },\r\n                reload: function (fetchOptions) {\r\n                  hideIfNecessary();\r\n                  load(fetchOptions);\r\n                }\r\n              };\r\n              processingAction.set(true);\r\n              match.onAction(autocompleterApi, range, itemValue, itemMeta);\r\n              processingAction.set(false);\r\n            });\r\n          }, columns, ItemResponse$1.BUBBLE_TO_SANDBOX, sharedBackstage, match.highlightOn);\r\n        });\r\n      };\r\n      var commenceIfNecessary = function (context) {\r\n        if (!isActive()) {\r\n          var wrapper = create$4(editor, context.range);\r\n          activeAutocompleter.set({\r\n            triggerChar: context.triggerChar,\r\n            element: wrapper,\r\n            matchLength: context.text.length\r\n          });\r\n          processingAction.set(false);\r\n        }\r\n      };\r\n      var display = function (ac, context, lookupData, items) {\r\n        ac.matchLength = context.text.length;\r\n        var columns = findMap(lookupData, function (ld) {\r\n          return Optional.from(ld.columns);\r\n        }).getOr(1);\r\n        InlineView.showAt(autocompleter, Menu.sketch(createMenuFrom(createPartialMenuWithAlloyItems('autocompleter-value', true, items, columns, 'normal'), columns, FocusMode.ContentFocus, 'normal')), {\r\n          anchor: {\r\n            type: 'node',\r\n            root: SugarElement.fromDom(editor.getBody()),\r\n            node: Optional.from(ac.element)\r\n          }\r\n        });\r\n        InlineView.getContent(autocompleter).each(Highlighting.highlightFirst);\r\n      };\r\n      var doLookup = function (fetchOptions) {\r\n        return activeAutocompleter.get().map(function (ac) {\r\n          return getContext(editor.dom, editor.selection.getRng(), ac.triggerChar).bind(function (newContext) {\r\n            return lookupWithContext(editor, getAutocompleters, newContext, fetchOptions);\r\n          });\r\n        }).getOrThunk(function () {\r\n          return lookup$2(editor, getAutocompleters);\r\n        });\r\n      };\r\n      var load = function (fetchOptions) {\r\n        doLookup(fetchOptions).fold(cancelIfNecessary, function (lookupInfo) {\r\n          commenceIfNecessary(lookupInfo.context);\r\n          lookupInfo.lookupData.then(function (lookupData) {\r\n            activeAutocompleter.get().map(function (ac) {\r\n              var context = lookupInfo.context;\r\n              if (ac.triggerChar === context.triggerChar) {\r\n                var combinedItems = getCombinedItems(context.triggerChar, lookupData);\r\n                if (combinedItems.length > 0) {\r\n                  display(ac, context, lookupData, combinedItems);\r\n                } else if (context.text.length - ac.matchLength >= 10) {\r\n                  cancelIfNecessary();\r\n                } else {\r\n                  hideIfNecessary();\r\n                }\r\n              }\r\n            });\r\n          });\r\n        });\r\n      };\r\n      var onKeypress = last(function (e) {\r\n        if (e.which === 27) {\r\n          return;\r\n        }\r\n        load();\r\n      }, 50);\r\n      var autocompleterUiApi = {\r\n        onKeypress: onKeypress,\r\n        cancelIfNecessary: cancelIfNecessary,\r\n        isMenuOpen: isMenuOpen,\r\n        isActive: isActive,\r\n        isProcessingAction: processingAction.get,\r\n        getView: function () {\r\n          return InlineView.getContent(autocompleter);\r\n        }\r\n      };\r\n      if (editor.hasPlugin('rtc') === false) {\r\n        AutocompleterEditorEvents.setup(autocompleterUiApi, editor);\r\n      }\r\n    };\r\n    var Autocompleter = { register: register$9 };\r\n\r\n    var closest = function (scope, selector, isRoot) {\r\n      return closest$1(scope, selector, isRoot).isSome();\r\n    };\r\n\r\n    var DelayedFunction = function (fun, delay) {\r\n      var ref = null;\r\n      var schedule = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        ref = setTimeout(function () {\r\n          fun.apply(null, args);\r\n          ref = null;\r\n        }, delay);\r\n      };\r\n      var cancel = function () {\r\n        if (ref !== null) {\r\n          clearTimeout(ref);\r\n          ref = null;\r\n        }\r\n      };\r\n      return {\r\n        cancel: cancel,\r\n        schedule: schedule\r\n      };\r\n    };\r\n\r\n    var SIGNIFICANT_MOVE = 5;\r\n    var LONGPRESS_DELAY = 400;\r\n    var getTouch = function (event) {\r\n      var raw = event.raw;\r\n      if (raw.touches === undefined || raw.touches.length !== 1) {\r\n        return Optional.none();\r\n      }\r\n      return Optional.some(raw.touches[0]);\r\n    };\r\n    var isFarEnough = function (touch, data) {\r\n      var distX = Math.abs(touch.clientX - data.x);\r\n      var distY = Math.abs(touch.clientY - data.y);\r\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\r\n    };\r\n    var monitor = function (settings) {\r\n      var startData = value$1();\r\n      var longpressFired = Cell(false);\r\n      var longpress$1 = DelayedFunction(function (event) {\r\n        settings.triggerEvent(longpress(), event);\r\n        longpressFired.set(true);\r\n      }, LONGPRESS_DELAY);\r\n      var handleTouchstart = function (event) {\r\n        getTouch(event).each(function (touch) {\r\n          longpress$1.cancel();\r\n          var data = {\r\n            x: touch.clientX,\r\n            y: touch.clientY,\r\n            target: event.target\r\n          };\r\n          longpress$1.schedule(event);\r\n          longpressFired.set(false);\r\n          startData.set(data);\r\n        });\r\n        return Optional.none();\r\n      };\r\n      var handleTouchmove = function (event) {\r\n        longpress$1.cancel();\r\n        getTouch(event).each(function (touch) {\r\n          startData.on(function (data) {\r\n            if (isFarEnough(touch, data)) {\r\n              startData.clear();\r\n            }\r\n          });\r\n        });\r\n        return Optional.none();\r\n      };\r\n      var handleTouchend = function (event) {\r\n        longpress$1.cancel();\r\n        var isSame = function (data) {\r\n          return eq(data.target, event.target);\r\n        };\r\n        return startData.get().filter(isSame).map(function (_data) {\r\n          if (longpressFired.get()) {\r\n            event.prevent();\r\n            return false;\r\n          } else {\r\n            return settings.triggerEvent(tap(), event);\r\n          }\r\n        });\r\n      };\r\n      var handlers = wrapAll([\r\n        {\r\n          key: touchstart(),\r\n          value: handleTouchstart\r\n        },\r\n        {\r\n          key: touchmove(),\r\n          value: handleTouchmove\r\n        },\r\n        {\r\n          key: touchend(),\r\n          value: handleTouchend\r\n        }\r\n      ]);\r\n      var fireIfReady = function (event, type) {\r\n        return get$e(handlers, type).bind(function (handler) {\r\n          return handler(event);\r\n        });\r\n      };\r\n      return { fireIfReady: fireIfReady };\r\n    };\r\n\r\n    var isDangerous = function (event) {\r\n      var keyEv = event.raw;\r\n      return keyEv.which === BACKSPACE[0] && !contains$2([\r\n        'input',\r\n        'textarea'\r\n      ], name$2(event.target)) && !closest(event.target, '[contenteditable=\"true\"]');\r\n    };\r\n    var isFirefox = function () {\r\n      return detect$1().browser.isFirefox();\r\n    };\r\n    var bindFocus = function (container, handler) {\r\n      if (isFirefox()) {\r\n        return capture(container, 'focus', handler);\r\n      } else {\r\n        return bind(container, 'focusin', handler);\r\n      }\r\n    };\r\n    var bindBlur = function (container, handler) {\r\n      if (isFirefox()) {\r\n        return capture(container, 'blur', handler);\r\n      } else {\r\n        return bind(container, 'focusout', handler);\r\n      }\r\n    };\r\n    var setup$d = function (container, rawSettings) {\r\n      var settings = __assign({ stopBackspace: true }, rawSettings);\r\n      var pointerEvents = [\r\n        'touchstart',\r\n        'touchmove',\r\n        'touchend',\r\n        'touchcancel',\r\n        'gesturestart',\r\n        'mousedown',\r\n        'mouseup',\r\n        'mouseover',\r\n        'mousemove',\r\n        'mouseout',\r\n        'click'\r\n      ];\r\n      var tapEvent = monitor(settings);\r\n      var simpleEvents = map$2(pointerEvents.concat([\r\n        'selectstart',\r\n        'input',\r\n        'contextmenu',\r\n        'change',\r\n        'transitionend',\r\n        'transitioncancel',\r\n        'drag',\r\n        'dragstart',\r\n        'dragend',\r\n        'dragenter',\r\n        'dragleave',\r\n        'dragover',\r\n        'drop',\r\n        'keyup'\r\n      ]), function (type) {\r\n        return bind(container, type, function (event) {\r\n          tapEvent.fireIfReady(event, type).each(function (tapStopped) {\r\n            if (tapStopped) {\r\n              event.kill();\r\n            }\r\n          });\r\n          var stopped = settings.triggerEvent(type, event);\r\n          if (stopped) {\r\n            event.kill();\r\n          }\r\n        });\r\n      });\r\n      var pasteTimeout = value$1();\r\n      var onPaste = bind(container, 'paste', function (event) {\r\n        tapEvent.fireIfReady(event, 'paste').each(function (tapStopped) {\r\n          if (tapStopped) {\r\n            event.kill();\r\n          }\r\n        });\r\n        var stopped = settings.triggerEvent('paste', event);\r\n        if (stopped) {\r\n          event.kill();\r\n        }\r\n        pasteTimeout.set(setTimeout(function () {\r\n          settings.triggerEvent(postPaste(), event);\r\n        }, 0));\r\n      });\r\n      var onKeydown = bind(container, 'keydown', function (event) {\r\n        var stopped = settings.triggerEvent('keydown', event);\r\n        if (stopped) {\r\n          event.kill();\r\n        } else if (settings.stopBackspace && isDangerous(event)) {\r\n          event.prevent();\r\n        }\r\n      });\r\n      var onFocusIn = bindFocus(container, function (event) {\r\n        var stopped = settings.triggerEvent('focusin', event);\r\n        if (stopped) {\r\n          event.kill();\r\n        }\r\n      });\r\n      var focusoutTimeout = value$1();\r\n      var onFocusOut = bindBlur(container, function (event) {\r\n        var stopped = settings.triggerEvent('focusout', event);\r\n        if (stopped) {\r\n          event.kill();\r\n        }\r\n        focusoutTimeout.set(setTimeout(function () {\r\n          settings.triggerEvent(postBlur(), event);\r\n        }, 0));\r\n      });\r\n      var unbind = function () {\r\n        each$1(simpleEvents, function (e) {\r\n          e.unbind();\r\n        });\r\n        onKeydown.unbind();\r\n        onFocusIn.unbind();\r\n        onFocusOut.unbind();\r\n        onPaste.unbind();\r\n        pasteTimeout.on(clearTimeout);\r\n        focusoutTimeout.on(clearTimeout);\r\n      };\r\n      return { unbind: unbind };\r\n    };\r\n\r\n    var derive = function (rawEvent, rawTarget) {\r\n      var source = get$e(rawEvent, 'target').getOr(rawTarget);\r\n      return Cell(source);\r\n    };\r\n\r\n    var fromSource = function (event, source) {\r\n      var stopper = Cell(false);\r\n      var cutter = Cell(false);\r\n      var stop = function () {\r\n        stopper.set(true);\r\n      };\r\n      var cut = function () {\r\n        cutter.set(true);\r\n      };\r\n      return {\r\n        stop: stop,\r\n        cut: cut,\r\n        isStopped: stopper.get,\r\n        isCut: cutter.get,\r\n        event: event,\r\n        setSource: source.set,\r\n        getSource: source.get\r\n      };\r\n    };\r\n    var fromExternal = function (event) {\r\n      var stopper = Cell(false);\r\n      var stop = function () {\r\n        stopper.set(true);\r\n      };\r\n      return {\r\n        stop: stop,\r\n        cut: noop,\r\n        isStopped: stopper.get,\r\n        isCut: never,\r\n        event: event,\r\n        setSource: die('Cannot set source of a broadcasted event'),\r\n        getSource: die('Cannot get source of a broadcasted event')\r\n      };\r\n    };\r\n\r\n    var adt$1 = Adt.generate([\r\n      { stopped: [] },\r\n      { resume: ['element'] },\r\n      { complete: [] }\r\n    ]);\r\n    var doTriggerHandler = function (lookup, eventType, rawEvent, target, source, logger) {\r\n      var handler = lookup(eventType, target);\r\n      var simulatedEvent = fromSource(rawEvent, source);\r\n      return handler.fold(function () {\r\n        logger.logEventNoHandlers(eventType, target);\r\n        return adt$1.complete();\r\n      }, function (handlerInfo) {\r\n        var descHandler = handlerInfo.descHandler;\r\n        var eventHandler = getCurried(descHandler);\r\n        eventHandler(simulatedEvent);\r\n        if (simulatedEvent.isStopped()) {\r\n          logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose);\r\n          return adt$1.stopped();\r\n        } else if (simulatedEvent.isCut()) {\r\n          logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose);\r\n          return adt$1.complete();\r\n        } else {\r\n          return parent(handlerInfo.element).fold(function () {\r\n            logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose);\r\n            return adt$1.complete();\r\n          }, function (parent) {\r\n            logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose);\r\n            return adt$1.resume(parent);\r\n          });\r\n        }\r\n      });\r\n    };\r\n    var doTriggerOnUntilStopped = function (lookup, eventType, rawEvent, rawTarget, source, logger) {\r\n      return doTriggerHandler(lookup, eventType, rawEvent, rawTarget, source, logger).fold(always, function (parent) {\r\n        return doTriggerOnUntilStopped(lookup, eventType, rawEvent, parent, source, logger);\r\n      }, never);\r\n    };\r\n    var triggerHandler = function (lookup, eventType, rawEvent, target, logger) {\r\n      var source = derive(rawEvent, target);\r\n      return doTriggerHandler(lookup, eventType, rawEvent, target, source, logger);\r\n    };\r\n    var broadcast = function (listeners, rawEvent, _logger) {\r\n      var simulatedEvent = fromExternal(rawEvent);\r\n      each$1(listeners, function (listener) {\r\n        var descHandler = listener.descHandler;\r\n        var handler = getCurried(descHandler);\r\n        handler(simulatedEvent);\r\n      });\r\n      return simulatedEvent.isStopped();\r\n    };\r\n    var triggerUntilStopped = function (lookup, eventType, rawEvent, logger) {\r\n      return triggerOnUntilStopped(lookup, eventType, rawEvent, rawEvent.target, logger);\r\n    };\r\n    var triggerOnUntilStopped = function (lookup, eventType, rawEvent, rawTarget, logger) {\r\n      var source = derive(rawEvent, rawTarget);\r\n      return doTriggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, source, logger);\r\n    };\r\n\r\n    var eventHandler = function (element, descHandler) {\r\n      return {\r\n        element: element,\r\n        descHandler: descHandler\r\n      };\r\n    };\r\n    var broadcastHandler = function (id, handler) {\r\n      return {\r\n        id: id,\r\n        descHandler: handler\r\n      };\r\n    };\r\n    var EventRegistry = function () {\r\n      var registry = {};\r\n      var registerId = function (extraArgs, id, events) {\r\n        each(events, function (v, k) {\r\n          var handlers = registry[k] !== undefined ? registry[k] : {};\r\n          handlers[id] = curryArgs(v, extraArgs);\r\n          registry[k] = handlers;\r\n        });\r\n      };\r\n      var findHandler = function (handlers, elem) {\r\n        return read$1(elem).bind(function (id) {\r\n          return get$e(handlers, id);\r\n        }).map(function (descHandler) {\r\n          return eventHandler(elem, descHandler);\r\n        });\r\n      };\r\n      var filterByType = function (type) {\r\n        return get$e(registry, type).map(function (handlers) {\r\n          return mapToArray(handlers, function (f, id) {\r\n            return broadcastHandler(id, f);\r\n          });\r\n        }).getOr([]);\r\n      };\r\n      var find = function (isAboveRoot, type, target) {\r\n        return get$e(registry, type).bind(function (handlers) {\r\n          return closest$4(target, function (elem) {\r\n            return findHandler(handlers, elem);\r\n          }, isAboveRoot);\r\n        });\r\n      };\r\n      var unregisterId = function (id) {\r\n        each(registry, function (handlersById, _eventName) {\r\n          if (has$2(handlersById, id)) {\r\n            delete handlersById[id];\r\n          }\r\n        });\r\n      };\r\n      return {\r\n        registerId: registerId,\r\n        unregisterId: unregisterId,\r\n        filterByType: filterByType,\r\n        find: find\r\n      };\r\n    };\r\n\r\n    var Registry = function () {\r\n      var events = EventRegistry();\r\n      var components = {};\r\n      var readOrTag = function (component) {\r\n        var elem = component.element;\r\n        return read$1(elem).getOrThunk(function () {\r\n          return write('uid-', component.element);\r\n        });\r\n      };\r\n      var failOnDuplicate = function (component, tagId) {\r\n        var conflict = components[tagId];\r\n        if (conflict === component) {\r\n          unregister(component);\r\n        } else {\r\n          throw new Error('The tagId \"' + tagId + '\" is already used by: ' + element(conflict.element) + '\\nCannot use it for: ' + element(component.element) + '\\n' + 'The conflicting element is' + (inBody(conflict.element) ? ' ' : ' not ') + 'already in the DOM');\r\n        }\r\n      };\r\n      var register = function (component) {\r\n        var tagId = readOrTag(component);\r\n        if (hasNonNullableKey(components, tagId)) {\r\n          failOnDuplicate(component, tagId);\r\n        }\r\n        var extraArgs = [component];\r\n        events.registerId(extraArgs, tagId, component.events);\r\n        components[tagId] = component;\r\n      };\r\n      var unregister = function (component) {\r\n        read$1(component.element).each(function (tagId) {\r\n          delete components[tagId];\r\n          events.unregisterId(tagId);\r\n        });\r\n      };\r\n      var filter = function (type) {\r\n        return events.filterByType(type);\r\n      };\r\n      var find = function (isAboveRoot, type, target) {\r\n        return events.find(isAboveRoot, type, target);\r\n      };\r\n      var getById = function (id) {\r\n        return get$e(components, id);\r\n      };\r\n      return {\r\n        find: find,\r\n        filter: filter,\r\n        register: register,\r\n        unregister: unregister,\r\n        getById: getById\r\n      };\r\n    };\r\n\r\n    var factory$j = function (detail) {\r\n      var _a = detail.dom, attributes = _a.attributes, domWithoutAttributes = __rest(_a, ['attributes']);\r\n      return {\r\n        uid: detail.uid,\r\n        dom: __assign({\r\n          tag: 'div',\r\n          attributes: __assign({ role: 'presentation' }, attributes)\r\n        }, domWithoutAttributes),\r\n        components: detail.components,\r\n        behaviours: get$2(detail.containerBehaviours),\r\n        events: detail.events,\r\n        domModification: detail.domModification,\r\n        eventOrder: detail.eventOrder\r\n      };\r\n    };\r\n    var Container = single({\r\n      name: 'Container',\r\n      factory: factory$j,\r\n      configFields: [\r\n        defaulted('components', []),\r\n        field('containerBehaviours', []),\r\n        defaulted('events', {}),\r\n        defaulted('domModification', {}),\r\n        defaulted('eventOrder', {})\r\n      ]\r\n    });\r\n\r\n    var takeover = function (root) {\r\n      var isAboveRoot = function (el) {\r\n        return parent(root.element).fold(always, function (parent) {\r\n          return eq(el, parent);\r\n        });\r\n      };\r\n      var registry = Registry();\r\n      var lookup = function (eventName, target) {\r\n        return registry.find(isAboveRoot, eventName, target);\r\n      };\r\n      var domEvents = setup$d(root.element, {\r\n        triggerEvent: function (eventName, event) {\r\n          return monitorEvent(eventName, event.target, function (logger) {\r\n            return triggerUntilStopped(lookup, eventName, event, logger);\r\n          });\r\n        }\r\n      });\r\n      var systemApi = {\r\n        debugInfo: constant$1('real'),\r\n        triggerEvent: function (eventName, target, data) {\r\n          monitorEvent(eventName, target, function (logger) {\r\n            return triggerOnUntilStopped(lookup, eventName, data, target, logger);\r\n          });\r\n        },\r\n        triggerFocus: function (target, originator) {\r\n          read$1(target).fold(function () {\r\n            focus$3(target);\r\n          }, function (_alloyId) {\r\n            monitorEvent(focus$4(), target, function (logger) {\r\n              triggerHandler(lookup, focus$4(), {\r\n                originator: originator,\r\n                kill: noop,\r\n                prevent: noop,\r\n                target: target\r\n              }, target, logger);\r\n              return false;\r\n            });\r\n          });\r\n        },\r\n        triggerEscape: function (comp, simulatedEvent) {\r\n          systemApi.triggerEvent('keydown', comp.element, simulatedEvent.event);\r\n        },\r\n        getByUid: function (uid) {\r\n          return getByUid(uid);\r\n        },\r\n        getByDom: function (elem) {\r\n          return getByDom(elem);\r\n        },\r\n        build: build$1,\r\n        addToGui: function (c) {\r\n          add(c);\r\n        },\r\n        removeFromGui: function (c) {\r\n          remove(c);\r\n        },\r\n        addToWorld: function (c) {\r\n          addToWorld(c);\r\n        },\r\n        removeFromWorld: function (c) {\r\n          removeFromWorld(c);\r\n        },\r\n        broadcast: function (message) {\r\n          broadcast$1(message);\r\n        },\r\n        broadcastOn: function (channels, message) {\r\n          broadcastOn(channels, message);\r\n        },\r\n        broadcastEvent: function (eventName, event) {\r\n          broadcastEvent(eventName, event);\r\n        },\r\n        isConnected: always\r\n      };\r\n      var addToWorld = function (component) {\r\n        component.connect(systemApi);\r\n        if (!isText$1(component.element)) {\r\n          registry.register(component);\r\n          each$1(component.components(), addToWorld);\r\n          systemApi.triggerEvent(systemInit(), component.element, { target: component.element });\r\n        }\r\n      };\r\n      var removeFromWorld = function (component) {\r\n        if (!isText$1(component.element)) {\r\n          each$1(component.components(), removeFromWorld);\r\n          registry.unregister(component);\r\n        }\r\n        component.disconnect();\r\n      };\r\n      var add = function (component) {\r\n        attach(root, component);\r\n      };\r\n      var remove = function (component) {\r\n        detach(component);\r\n      };\r\n      var destroy = function () {\r\n        domEvents.unbind();\r\n        remove$5(root.element);\r\n      };\r\n      var broadcastData = function (data) {\r\n        var receivers = registry.filter(receive());\r\n        each$1(receivers, function (receiver) {\r\n          var descHandler = receiver.descHandler;\r\n          var handler = getCurried(descHandler);\r\n          handler(data);\r\n        });\r\n      };\r\n      var broadcast$1 = function (message) {\r\n        broadcastData({\r\n          universal: true,\r\n          data: message\r\n        });\r\n      };\r\n      var broadcastOn = function (channels, message) {\r\n        broadcastData({\r\n          universal: false,\r\n          channels: channels,\r\n          data: message\r\n        });\r\n      };\r\n      var broadcastEvent = function (eventName, event) {\r\n        var listeners = registry.filter(eventName);\r\n        return broadcast(listeners, event);\r\n      };\r\n      var getByUid = function (uid) {\r\n        return registry.getById(uid).fold(function () {\r\n          return Result.error(new Error('Could not find component with uid: \"' + uid + '\" in system.'));\r\n        }, Result.value);\r\n      };\r\n      var getByDom = function (elem) {\r\n        var uid = read$1(elem).getOr('not found');\r\n        return getByUid(uid);\r\n      };\r\n      addToWorld(root);\r\n      return {\r\n        root: root,\r\n        element: root.element,\r\n        destroy: destroy,\r\n        add: add,\r\n        remove: remove,\r\n        getByUid: getByUid,\r\n        getByDom: getByDom,\r\n        addToWorld: addToWorld,\r\n        removeFromWorld: removeFromWorld,\r\n        broadcast: broadcast$1,\r\n        broadcastOn: broadcastOn,\r\n        broadcastEvent: broadcastEvent\r\n      };\r\n    };\r\n\r\n    var renderBar = function (spec, backstage) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [\r\n            'tox-bar',\r\n            'tox-form__controls-h-stack'\r\n          ]\r\n        },\r\n        components: map$2(spec.items, backstage.interpreter)\r\n      };\r\n    };\r\n\r\n    var schema$l = constant$1([\r\n      defaulted('prefix', 'form-field'),\r\n      field('fieldBehaviours', [\r\n        Composing,\r\n        Representing\r\n      ])\r\n    ]);\r\n    var parts$e = constant$1([\r\n      optional({\r\n        schema: [required$1('dom')],\r\n        name: 'label'\r\n      }),\r\n      optional({\r\n        factory: {\r\n          sketch: function (spec) {\r\n            return {\r\n              uid: spec.uid,\r\n              dom: {\r\n                tag: 'span',\r\n                styles: { display: 'none' },\r\n                attributes: { 'aria-hidden': 'true' },\r\n                innerHtml: spec.text\r\n              }\r\n            };\r\n          }\r\n        },\r\n        schema: [required$1('text')],\r\n        name: 'aria-descriptor'\r\n      }),\r\n      required({\r\n        factory: {\r\n          sketch: function (spec) {\r\n            var excludeFactory = exclude(spec, ['factory']);\r\n            return spec.factory.sketch(excludeFactory);\r\n          }\r\n        },\r\n        schema: [required$1('factory')],\r\n        name: 'field'\r\n      })\r\n    ]);\r\n\r\n    var factory$i = function (detail, components, _spec, _externals) {\r\n      var behaviours = augment(detail.fieldBehaviours, [\r\n        Composing.config({\r\n          find: function (container) {\r\n            return getPart(container, detail, 'field');\r\n          }\r\n        }),\r\n        Representing.config({\r\n          store: {\r\n            mode: 'manual',\r\n            getValue: function (field) {\r\n              return Composing.getCurrent(field).bind(Representing.getValue);\r\n            },\r\n            setValue: function (field, value) {\r\n              Composing.getCurrent(field).each(function (current) {\r\n                Representing.setValue(current, value);\r\n              });\r\n            }\r\n          }\r\n        })\r\n      ]);\r\n      var events = derive$2([runOnAttached(function (component, _simulatedEvent) {\r\n          var ps = getParts(component, detail, [\r\n            'label',\r\n            'field',\r\n            'aria-descriptor'\r\n          ]);\r\n          ps.field().each(function (field) {\r\n            var id = generate$6(detail.prefix);\r\n            ps.label().each(function (label) {\r\n              set$8(label.element, 'for', id);\r\n              set$8(field.element, 'id', id);\r\n            });\r\n            ps['aria-descriptor']().each(function (descriptor) {\r\n              var descriptorId = generate$6(detail.prefix);\r\n              set$8(descriptor.element, 'id', descriptorId);\r\n              set$8(field.element, 'aria-describedby', descriptorId);\r\n            });\r\n          });\r\n        })]);\r\n      var apis = {\r\n        getField: function (container) {\r\n          return getPart(container, detail, 'field');\r\n        },\r\n        getLabel: function (container) {\r\n          return getPart(container, detail, 'label');\r\n        }\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        behaviours: behaviours,\r\n        events: events,\r\n        apis: apis\r\n      };\r\n    };\r\n    var FormField = composite({\r\n      name: 'FormField',\r\n      configFields: schema$l(),\r\n      partFields: parts$e(),\r\n      factory: factory$i,\r\n      apis: {\r\n        getField: function (apis, comp) {\r\n          return apis.getField(comp);\r\n        },\r\n        getLabel: function (apis, comp) {\r\n          return apis.getLabel(comp);\r\n        }\r\n      }\r\n    });\r\n\r\n    var exhibit$2 = function (base, tabConfig) {\r\n      return nu$7({\r\n        attributes: wrapAll([{\r\n            key: tabConfig.tabAttr,\r\n            value: 'true'\r\n          }])\r\n      });\r\n    };\r\n\r\n    var ActiveTabstopping = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        exhibit: exhibit$2\r\n    });\r\n\r\n    var TabstopSchema = [defaulted('tabAttr', 'data-alloy-tabstop')];\r\n\r\n    var Tabstopping = create$8({\r\n      fields: TabstopSchema,\r\n      name: 'tabstopping',\r\n      active: ActiveTabstopping\r\n    });\r\n\r\n    var global$7 = tinymce.util.Tools.resolve('tinymce.html.Entities');\r\n\r\n    var renderFormFieldWith = function (pLabel, pField, extraClasses, extraBehaviours) {\r\n      var spec = renderFormFieldSpecWith(pLabel, pField, extraClasses, extraBehaviours);\r\n      return FormField.sketch(spec);\r\n    };\r\n    var renderFormField = function (pLabel, pField) {\r\n      return renderFormFieldWith(pLabel, pField, [], []);\r\n    };\r\n    var renderFormFieldSpecWith = function (pLabel, pField, extraClasses, extraBehaviours) {\r\n      return {\r\n        dom: renderFormFieldDomWith(extraClasses),\r\n        components: pLabel.toArray().concat([pField]),\r\n        fieldBehaviours: derive$1(extraBehaviours)\r\n      };\r\n    };\r\n    var renderFormFieldDom = function () {\r\n      return renderFormFieldDomWith([]);\r\n    };\r\n    var renderFormFieldDomWith = function (extraClasses) {\r\n      return {\r\n        tag: 'div',\r\n        classes: ['tox-form__group'].concat(extraClasses)\r\n      };\r\n    };\r\n    var renderLabel$2 = function (label, providersBackstage) {\r\n      return FormField.parts.label({\r\n        dom: {\r\n          tag: 'label',\r\n          classes: ['tox-label'],\r\n          innerHtml: providersBackstage.translate(label)\r\n        }\r\n      });\r\n    };\r\n\r\n    var formChangeEvent = generate$6('form-component-change');\r\n    var formCloseEvent = generate$6('form-close');\r\n    var formCancelEvent = generate$6('form-cancel');\r\n    var formActionEvent = generate$6('form-action');\r\n    var formSubmitEvent = generate$6('form-submit');\r\n    var formBlockEvent = generate$6('form-block');\r\n    var formUnblockEvent = generate$6('form-unblock');\r\n    var formTabChangeEvent = generate$6('form-tabchange');\r\n    var formResizeEvent = generate$6('form-resize');\r\n\r\n    var renderCollection = function (spec, providersBackstage) {\r\n      var _a;\r\n      var pLabel = spec.label.map(function (label) {\r\n        return renderLabel$2(label, providersBackstage);\r\n      });\r\n      var runOnItem = function (f) {\r\n        return function (comp, se) {\r\n          closest$1(se.event.target, '[data-collection-item-value]').each(function (target) {\r\n            f(comp, se, target, get$d(target, 'data-collection-item-value'));\r\n          });\r\n        };\r\n      };\r\n      var setContents = function (comp, items) {\r\n        var htmlLines = map$2(items, function (item) {\r\n          var itemText = global$e.translate(item.text);\r\n          var textContent = spec.columns === 1 ? '<div class=\"tox-collection__item-label\">' + itemText + '</div>' : '';\r\n          var iconContent = '<div class=\"tox-collection__item-icon\">' + item.icon + '</div>';\r\n          var mapItemName = {\r\n            '_': ' ',\r\n            ' - ': ' ',\r\n            '-': ' '\r\n          };\r\n          var ariaLabel = itemText.replace(/\\_| \\- |\\-/g, function (match) {\r\n            return mapItemName[match];\r\n          });\r\n          var disabledClass = providersBackstage.isDisabled() ? ' tox-collection__item--state-disabled' : '';\r\n          return '<div class=\"tox-collection__item' + disabledClass + '\" tabindex=\"-1\" data-collection-item-value=\"' + global$7.encodeAllRaw(item.value) + '\" title=\"' + ariaLabel + '\" aria-label=\"' + ariaLabel + '\">' + iconContent + textContent + '</div>';\r\n        });\r\n        var chunks = spec.columns !== 'auto' && spec.columns > 1 ? chunk$1(htmlLines, spec.columns) : [htmlLines];\r\n        var html = map$2(chunks, function (ch) {\r\n          return '<div class=\"tox-collection__group\">' + ch.join('') + '</div>';\r\n        });\r\n        set$5(comp.element, html.join(''));\r\n      };\r\n      var onClick = runOnItem(function (comp, se, tgt, itemValue) {\r\n        se.stop();\r\n        if (!providersBackstage.isDisabled()) {\r\n          emitWith(comp, formActionEvent, {\r\n            name: spec.name,\r\n            value: itemValue\r\n          });\r\n        }\r\n      });\r\n      var collectionEvents = [\r\n        run$1(mouseover(), runOnItem(function (comp, se, tgt) {\r\n          focus$3(tgt);\r\n        })),\r\n        run$1(click(), onClick),\r\n        run$1(tap(), onClick),\r\n        run$1(focusin(), runOnItem(function (comp, se, tgt) {\r\n          descendant(comp.element, '.' + activeClass).each(function (currentActive) {\r\n            remove$2(currentActive, activeClass);\r\n          });\r\n          add$2(tgt, activeClass);\r\n        })),\r\n        run$1(focusout(), runOnItem(function (comp) {\r\n          descendant(comp.element, '.' + activeClass).each(function (currentActive) {\r\n            remove$2(currentActive, activeClass);\r\n          });\r\n        })),\r\n        runOnExecute$1(runOnItem(function (comp, se, tgt, itemValue) {\r\n          emitWith(comp, formActionEvent, {\r\n            name: spec.name,\r\n            value: itemValue\r\n          });\r\n        }))\r\n      ];\r\n      var iterCollectionItems = function (comp, applyAttributes) {\r\n        return map$2(descendants(comp.element, '.tox-collection__item'), applyAttributes);\r\n      };\r\n      var pField = FormField.parts.field({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-collection'].concat(spec.columns !== 1 ? ['tox-collection--grid'] : ['tox-collection--list'])\r\n        },\r\n        components: [],\r\n        factory: { sketch: identity$1 },\r\n        behaviours: derive$1([\r\n          Disabling.config({\r\n            disabled: providersBackstage.isDisabled,\r\n            onDisabled: function (comp) {\r\n              iterCollectionItems(comp, function (childElm) {\r\n                add$2(childElm, 'tox-collection__item--state-disabled');\r\n                set$8(childElm, 'aria-disabled', true);\r\n              });\r\n            },\r\n            onEnabled: function (comp) {\r\n              iterCollectionItems(comp, function (childElm) {\r\n                remove$2(childElm, 'tox-collection__item--state-disabled');\r\n                remove$7(childElm, 'aria-disabled');\r\n              });\r\n            }\r\n          }),\r\n          receivingConfig(),\r\n          Replacing.config({}),\r\n          Representing.config({\r\n            store: {\r\n              mode: 'memory',\r\n              initialValue: []\r\n            },\r\n            onSetValue: function (comp, items) {\r\n              setContents(comp, items);\r\n              if (spec.columns === 'auto') {\r\n                detectSize(comp, 5, 'tox-collection__item').each(function (_a) {\r\n                  var numRows = _a.numRows, numColumns = _a.numColumns;\r\n                  Keying.setGridSize(comp, numRows, numColumns);\r\n                });\r\n              }\r\n              emit(comp, formResizeEvent);\r\n            }\r\n          }),\r\n          Tabstopping.config({}),\r\n          Keying.config(deriveCollectionMovement(spec.columns, 'normal')),\r\n          config('collection-events', collectionEvents)\r\n        ]),\r\n        eventOrder: (_a = {}, _a[execute$5()] = [\r\n          'disabling',\r\n          'alloy.base.behaviour',\r\n          'collection-events'\r\n        ], _a)\r\n      });\r\n      var extraClasses = ['tox-form__group--collection'];\r\n      return renderFormFieldWith(pLabel, pField, extraClasses, []);\r\n    };\r\n\r\n    var schema$k = constant$1([\r\n      option('data'),\r\n      defaulted('inputAttributes', {}),\r\n      defaulted('inputStyles', {}),\r\n      defaulted('tag', 'input'),\r\n      defaulted('inputClasses', []),\r\n      onHandler('onSetValue'),\r\n      defaulted('styles', {}),\r\n      defaulted('eventOrder', {}),\r\n      field('inputBehaviours', [\r\n        Representing,\r\n        Focusing\r\n      ]),\r\n      defaulted('selectOnFocus', true)\r\n    ]);\r\n    var focusBehaviours = function (detail) {\r\n      return derive$1([Focusing.config({\r\n          onFocus: !detail.selectOnFocus ? noop : function (component) {\r\n            var input = component.element;\r\n            var value = get$5(input);\r\n            input.dom.setSelectionRange(0, value.length);\r\n          }\r\n        })]);\r\n    };\r\n    var behaviours = function (detail) {\r\n      return __assign(__assign({}, focusBehaviours(detail)), augment(detail.inputBehaviours, [Representing.config({\r\n          store: __assign(__assign({ mode: 'manual' }, detail.data.map(function (data) {\r\n            return { initialValue: data };\r\n          }).getOr({})), {\r\n            getValue: function (input) {\r\n              return get$5(input.element);\r\n            },\r\n            setValue: function (input, data) {\r\n              var current = get$5(input.element);\r\n              if (current !== data) {\r\n                set$4(input.element, data);\r\n              }\r\n            }\r\n          }),\r\n          onSetValue: detail.onSetValue\r\n        })]));\r\n    };\r\n    var dom = function (detail) {\r\n      return {\r\n        tag: detail.tag,\r\n        attributes: __assign({ type: 'text' }, detail.inputAttributes),\r\n        styles: detail.inputStyles,\r\n        classes: detail.inputClasses\r\n      };\r\n    };\r\n\r\n    var factory$h = function (detail, _spec) {\r\n      return {\r\n        uid: detail.uid,\r\n        dom: dom(detail),\r\n        components: [],\r\n        behaviours: behaviours(detail),\r\n        eventOrder: detail.eventOrder\r\n      };\r\n    };\r\n    var Input = single({\r\n      name: 'Input',\r\n      configFields: schema$k(),\r\n      factory: factory$h\r\n    });\r\n\r\n    var exports$1 = {}, module = { exports: exports$1 };\r\n    (function (define, exports, module, require) {\r\n      (function (global, factory) {\r\n        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.EphoxContactWrapper = factory());\r\n      }(this, function () {\r\n        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\r\n        var promise = { exports: {} };\r\n        (function (module) {\r\n          (function (root) {\r\n            var setTimeoutFunc = setTimeout;\r\n            function noop() {\r\n            }\r\n            function bind(fn, thisArg) {\r\n              return function () {\r\n                fn.apply(thisArg, arguments);\r\n              };\r\n            }\r\n            function Promise(fn) {\r\n              if (typeof this !== 'object')\r\n                throw new TypeError('Promises must be constructed via new');\r\n              if (typeof fn !== 'function')\r\n                throw new TypeError('not a function');\r\n              this._state = 0;\r\n              this._handled = false;\r\n              this._value = undefined;\r\n              this._deferreds = [];\r\n              doResolve(fn, this);\r\n            }\r\n            function handle(self, deferred) {\r\n              while (self._state === 3) {\r\n                self = self._value;\r\n              }\r\n              if (self._state === 0) {\r\n                self._deferreds.push(deferred);\r\n                return;\r\n              }\r\n              self._handled = true;\r\n              Promise._immediateFn(function () {\r\n                var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\r\n                if (cb === null) {\r\n                  (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\r\n                  return;\r\n                }\r\n                var ret;\r\n                try {\r\n                  ret = cb(self._value);\r\n                } catch (e) {\r\n                  reject(deferred.promise, e);\r\n                  return;\r\n                }\r\n                resolve(deferred.promise, ret);\r\n              });\r\n            }\r\n            function resolve(self, newValue) {\r\n              try {\r\n                if (newValue === self)\r\n                  throw new TypeError('A promise cannot be resolved with itself.');\r\n                if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\r\n                  var then = newValue.then;\r\n                  if (newValue instanceof Promise) {\r\n                    self._state = 3;\r\n                    self._value = newValue;\r\n                    finale(self);\r\n                    return;\r\n                  } else if (typeof then === 'function') {\r\n                    doResolve(bind(then, newValue), self);\r\n                    return;\r\n                  }\r\n                }\r\n                self._state = 1;\r\n                self._value = newValue;\r\n                finale(self);\r\n              } catch (e) {\r\n                reject(self, e);\r\n              }\r\n            }\r\n            function reject(self, newValue) {\r\n              self._state = 2;\r\n              self._value = newValue;\r\n              finale(self);\r\n            }\r\n            function finale(self) {\r\n              if (self._state === 2 && self._deferreds.length === 0) {\r\n                Promise._immediateFn(function () {\r\n                  if (!self._handled) {\r\n                    Promise._unhandledRejectionFn(self._value);\r\n                  }\r\n                });\r\n              }\r\n              for (var i = 0, len = self._deferreds.length; i < len; i++) {\r\n                handle(self, self._deferreds[i]);\r\n              }\r\n              self._deferreds = null;\r\n            }\r\n            function Handler(onFulfilled, onRejected, promise) {\r\n              this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\r\n              this.onRejected = typeof onRejected === 'function' ? onRejected : null;\r\n              this.promise = promise;\r\n            }\r\n            function doResolve(fn, self) {\r\n              var done = false;\r\n              try {\r\n                fn(function (value) {\r\n                  if (done)\r\n                    return;\r\n                  done = true;\r\n                  resolve(self, value);\r\n                }, function (reason) {\r\n                  if (done)\r\n                    return;\r\n                  done = true;\r\n                  reject(self, reason);\r\n                });\r\n              } catch (ex) {\r\n                if (done)\r\n                  return;\r\n                done = true;\r\n                reject(self, ex);\r\n              }\r\n            }\r\n            Promise.prototype['catch'] = function (onRejected) {\r\n              return this.then(null, onRejected);\r\n            };\r\n            Promise.prototype.then = function (onFulfilled, onRejected) {\r\n              var prom = new this.constructor(noop);\r\n              handle(this, new Handler(onFulfilled, onRejected, prom));\r\n              return prom;\r\n            };\r\n            Promise.all = function (arr) {\r\n              var args = Array.prototype.slice.call(arr);\r\n              return new Promise(function (resolve, reject) {\r\n                if (args.length === 0)\r\n                  return resolve([]);\r\n                var remaining = args.length;\r\n                function res(i, val) {\r\n                  try {\r\n                    if (val && (typeof val === 'object' || typeof val === 'function')) {\r\n                      var then = val.then;\r\n                      if (typeof then === 'function') {\r\n                        then.call(val, function (val) {\r\n                          res(i, val);\r\n                        }, reject);\r\n                        return;\r\n                      }\r\n                    }\r\n                    args[i] = val;\r\n                    if (--remaining === 0) {\r\n                      resolve(args);\r\n                    }\r\n                  } catch (ex) {\r\n                    reject(ex);\r\n                  }\r\n                }\r\n                for (var i = 0; i < args.length; i++) {\r\n                  res(i, args[i]);\r\n                }\r\n              });\r\n            };\r\n            Promise.resolve = function (value) {\r\n              if (value && typeof value === 'object' && value.constructor === Promise) {\r\n                return value;\r\n              }\r\n              return new Promise(function (resolve) {\r\n                resolve(value);\r\n              });\r\n            };\r\n            Promise.reject = function (value) {\r\n              return new Promise(function (resolve, reject) {\r\n                reject(value);\r\n              });\r\n            };\r\n            Promise.race = function (values) {\r\n              return new Promise(function (resolve, reject) {\r\n                for (var i = 0, len = values.length; i < len; i++) {\r\n                  values[i].then(resolve, reject);\r\n                }\r\n              });\r\n            };\r\n            Promise._immediateFn = typeof setImmediate === 'function' ? function (fn) {\r\n              setImmediate(fn);\r\n            } : function (fn) {\r\n              setTimeoutFunc(fn, 0);\r\n            };\r\n            Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\r\n              if (typeof console !== 'undefined' && console) {\r\n                console.warn('Possible Unhandled Promise Rejection:', err);\r\n              }\r\n            };\r\n            Promise._setImmediateFn = function _setImmediateFn(fn) {\r\n              Promise._immediateFn = fn;\r\n            };\r\n            Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\r\n              Promise._unhandledRejectionFn = fn;\r\n            };\r\n            if (module.exports) {\r\n              module.exports = Promise;\r\n            } else if (!root.Promise) {\r\n              root.Promise = Promise;\r\n            }\r\n          }(commonjsGlobal));\r\n        }(promise));\r\n        var promisePolyfill = promise.exports;\r\n        var Global = function () {\r\n          if (typeof window !== 'undefined') {\r\n            return window;\r\n          } else {\r\n            return Function('return this;')();\r\n          }\r\n        }();\r\n        var promisePolyfill_1 = { boltExport: Global.Promise || promisePolyfill };\r\n        return promisePolyfill_1;\r\n      }));\r\n    }(undefined, exports$1, module));\r\n    var Promise$1 = module.exports.boltExport;\r\n\r\n    var nu$3 = function (baseFn) {\r\n      var data = Optional.none();\r\n      var callbacks = [];\r\n      var map = function (f) {\r\n        return nu$3(function (nCallback) {\r\n          get(function (data) {\r\n            nCallback(f(data));\r\n          });\r\n        });\r\n      };\r\n      var get = function (nCallback) {\r\n        if (isReady()) {\r\n          call(nCallback);\r\n        } else {\r\n          callbacks.push(nCallback);\r\n        }\r\n      };\r\n      var set = function (x) {\r\n        if (!isReady()) {\r\n          data = Optional.some(x);\r\n          run(callbacks);\r\n          callbacks = [];\r\n        }\r\n      };\r\n      var isReady = function () {\r\n        return data.isSome();\r\n      };\r\n      var run = function (cbs) {\r\n        each$1(cbs, call);\r\n      };\r\n      var call = function (cb) {\r\n        data.each(function (x) {\r\n          setTimeout(function () {\r\n            cb(x);\r\n          }, 0);\r\n        });\r\n      };\r\n      baseFn(set);\r\n      return {\r\n        get: get,\r\n        map: map,\r\n        isReady: isReady\r\n      };\r\n    };\r\n    var pure$1 = function (a) {\r\n      return nu$3(function (callback) {\r\n        callback(a);\r\n      });\r\n    };\r\n    var LazyValue = {\r\n      nu: nu$3,\r\n      pure: pure$1\r\n    };\r\n\r\n    var errorReporter = function (err) {\r\n      setTimeout(function () {\r\n        throw err;\r\n      }, 0);\r\n    };\r\n    var make$5 = function (run) {\r\n      var get = function (callback) {\r\n        run().then(callback, errorReporter);\r\n      };\r\n      var map = function (fab) {\r\n        return make$5(function () {\r\n          return run().then(fab);\r\n        });\r\n      };\r\n      var bind = function (aFutureB) {\r\n        return make$5(function () {\r\n          return run().then(function (v) {\r\n            return aFutureB(v).toPromise();\r\n          });\r\n        });\r\n      };\r\n      var anonBind = function (futureB) {\r\n        return make$5(function () {\r\n          return run().then(function () {\r\n            return futureB.toPromise();\r\n          });\r\n        });\r\n      };\r\n      var toLazy = function () {\r\n        return LazyValue.nu(get);\r\n      };\r\n      var toCached = function () {\r\n        var cache = null;\r\n        return make$5(function () {\r\n          if (cache === null) {\r\n            cache = run();\r\n          }\r\n          return cache;\r\n        });\r\n      };\r\n      var toPromise = run;\r\n      return {\r\n        map: map,\r\n        bind: bind,\r\n        anonBind: anonBind,\r\n        toLazy: toLazy,\r\n        toCached: toCached,\r\n        toPromise: toPromise,\r\n        get: get\r\n      };\r\n    };\r\n    var nu$2 = function (baseFn) {\r\n      return make$5(function () {\r\n        return new Promise$1(baseFn);\r\n      });\r\n    };\r\n    var pure = function (a) {\r\n      return make$5(function () {\r\n        return Promise$1.resolve(a);\r\n      });\r\n    };\r\n    var Future = {\r\n      nu: nu$2,\r\n      pure: pure\r\n    };\r\n\r\n    var ariaElements = [\r\n      'input',\r\n      'textarea'\r\n    ];\r\n    var isAriaElement = function (elem) {\r\n      var name = name$2(elem);\r\n      return contains$2(ariaElements, name);\r\n    };\r\n    var markValid = function (component, invalidConfig) {\r\n      var elem = invalidConfig.getRoot(component).getOr(component.element);\r\n      remove$2(elem, invalidConfig.invalidClass);\r\n      invalidConfig.notify.each(function (notifyInfo) {\r\n        if (isAriaElement(component.element)) {\r\n          set$8(component.element, 'aria-invalid', false);\r\n        }\r\n        notifyInfo.getContainer(component).each(function (container) {\r\n          set$5(container, notifyInfo.validHtml);\r\n        });\r\n        notifyInfo.onValid(component);\r\n      });\r\n    };\r\n    var markInvalid = function (component, invalidConfig, invalidState, text) {\r\n      var elem = invalidConfig.getRoot(component).getOr(component.element);\r\n      add$2(elem, invalidConfig.invalidClass);\r\n      invalidConfig.notify.each(function (notifyInfo) {\r\n        if (isAriaElement(component.element)) {\r\n          set$8(component.element, 'aria-invalid', true);\r\n        }\r\n        notifyInfo.getContainer(component).each(function (container) {\r\n          set$5(container, text);\r\n        });\r\n        notifyInfo.onInvalid(component, text);\r\n      });\r\n    };\r\n    var query = function (component, invalidConfig, _invalidState) {\r\n      return invalidConfig.validator.fold(function () {\r\n        return Future.pure(Result.value(true));\r\n      }, function (validatorInfo) {\r\n        return validatorInfo.validate(component);\r\n      });\r\n    };\r\n    var run = function (component, invalidConfig, invalidState) {\r\n      invalidConfig.notify.each(function (notifyInfo) {\r\n        notifyInfo.onValidate(component);\r\n      });\r\n      return query(component, invalidConfig).map(function (valid) {\r\n        if (component.getSystem().isConnected()) {\r\n          return valid.fold(function (err) {\r\n            markInvalid(component, invalidConfig, invalidState, err);\r\n            return Result.error(err);\r\n          }, function (v) {\r\n            markValid(component, invalidConfig);\r\n            return Result.value(v);\r\n          });\r\n        } else {\r\n          return Result.error('No longer in system');\r\n        }\r\n      });\r\n    };\r\n    var isInvalid = function (component, invalidConfig) {\r\n      var elem = invalidConfig.getRoot(component).getOr(component.element);\r\n      return has(elem, invalidConfig.invalidClass);\r\n    };\r\n\r\n    var InvalidateApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        markValid: markValid,\r\n        markInvalid: markInvalid,\r\n        query: query,\r\n        run: run,\r\n        isInvalid: isInvalid\r\n    });\r\n\r\n    var events$8 = function (invalidConfig, invalidState) {\r\n      return invalidConfig.validator.map(function (validatorInfo) {\r\n        return derive$2([run$1(validatorInfo.onEvent, function (component) {\r\n            run(component, invalidConfig, invalidState).get(identity$1);\r\n          })].concat(validatorInfo.validateOnLoad ? [runOnAttached(function (component) {\r\n            run(component, invalidConfig, invalidState).get(noop);\r\n          })] : []));\r\n      }).getOr({});\r\n    };\r\n\r\n    var ActiveInvalidate = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        events: events$8\r\n    });\r\n\r\n    var InvalidateSchema = [\r\n      required$1('invalidClass'),\r\n      defaulted('getRoot', Optional.none),\r\n      optionObjOf('notify', [\r\n        defaulted('aria', 'alert'),\r\n        defaulted('getContainer', Optional.none),\r\n        defaulted('validHtml', ''),\r\n        onHandler('onValid'),\r\n        onHandler('onInvalid'),\r\n        onHandler('onValidate')\r\n      ]),\r\n      optionObjOf('validator', [\r\n        required$1('validate'),\r\n        defaulted('onEvent', 'input'),\r\n        defaulted('validateOnLoad', true)\r\n      ])\r\n    ];\r\n\r\n    var Invalidating = create$8({\r\n      fields: InvalidateSchema,\r\n      name: 'invalidating',\r\n      active: ActiveInvalidate,\r\n      apis: InvalidateApis,\r\n      extra: {\r\n        validation: function (validator) {\r\n          return function (component) {\r\n            var v = Representing.getValue(component);\r\n            return Future.pure(validator(v));\r\n          };\r\n        }\r\n      }\r\n    });\r\n\r\n    var getCoupled = function (component, coupleConfig, coupleState, name) {\r\n      return coupleState.getOrCreate(component, coupleConfig, name);\r\n    };\r\n\r\n    var CouplingApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        getCoupled: getCoupled\r\n    });\r\n\r\n    var CouplingSchema = [requiredOf('others', setOf(Result.value, anyValue()))];\r\n\r\n    var init$a = function () {\r\n      var coupled = {};\r\n      var getOrCreate = function (component, coupleConfig, name) {\r\n        var available = keys(coupleConfig.others);\r\n        if (!available) {\r\n          throw new Error('Cannot find coupled component: ' + name + '. Known coupled components: ' + JSON.stringify(available, null, 2));\r\n        } else {\r\n          return get$e(coupled, name).getOrThunk(function () {\r\n            var builder = get$e(coupleConfig.others, name).getOrDie('No information found for coupled component: ' + name);\r\n            var spec = builder(component);\r\n            var built = component.getSystem().build(spec);\r\n            coupled[name] = built;\r\n            return built;\r\n          });\r\n        }\r\n      };\r\n      var readState = constant$1({});\r\n      return nu$8({\r\n        readState: readState,\r\n        getOrCreate: getOrCreate\r\n      });\r\n    };\r\n\r\n    var CouplingState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        init: init$a\r\n    });\r\n\r\n    var Coupling = create$8({\r\n      fields: CouplingSchema,\r\n      name: 'coupling',\r\n      apis: CouplingApis,\r\n      state: CouplingState\r\n    });\r\n\r\n    var suffix = constant$1('sink');\r\n    var partType$1 = constant$1(optional({\r\n      name: suffix(),\r\n      overrides: constant$1({\r\n        dom: { tag: 'div' },\r\n        behaviours: derive$1([Positioning.config({ useFixed: always })]),\r\n        events: derive$2([\r\n          cutter(keydown()),\r\n          cutter(mousedown()),\r\n          cutter(click())\r\n        ])\r\n      })\r\n    }));\r\n\r\n    var HighlightOnOpen;\r\n    (function (HighlightOnOpen) {\r\n      HighlightOnOpen[HighlightOnOpen['HighlightFirst'] = 0] = 'HighlightFirst';\r\n      HighlightOnOpen[HighlightOnOpen['HighlightNone'] = 1] = 'HighlightNone';\r\n    }(HighlightOnOpen || (HighlightOnOpen = {})));\r\n    var getAnchor = function (detail, component) {\r\n      var hotspot = detail.getHotspot(component).getOr(component);\r\n      var type = 'hotspot';\r\n      var overrides = detail.getAnchorOverrides();\r\n      return detail.layouts.fold(function () {\r\n        return {\r\n          type: type,\r\n          hotspot: hotspot,\r\n          overrides: overrides\r\n        };\r\n      }, function (layouts) {\r\n        return {\r\n          type: type,\r\n          hotspot: hotspot,\r\n          overrides: overrides,\r\n          layouts: layouts\r\n        };\r\n      });\r\n    };\r\n    var fetch = function (detail, mapFetch, component) {\r\n      var fetcher = detail.fetch;\r\n      return fetcher(component).map(mapFetch);\r\n    };\r\n    var openF = function (detail, mapFetch, anchor, component, sandbox, externals, highlightOnOpen) {\r\n      var futureData = fetch(detail, mapFetch, component);\r\n      var getLazySink = getSink(component, detail);\r\n      return futureData.map(function (tdata) {\r\n        return tdata.bind(function (data) {\r\n          return Optional.from(tieredMenu.sketch(__assign(__assign({}, externals.menu()), {\r\n            uid: generate$5(''),\r\n            data: data,\r\n            highlightImmediately: highlightOnOpen === HighlightOnOpen.HighlightFirst,\r\n            onOpenMenu: function (tmenu, menu) {\r\n              var sink = getLazySink().getOrDie();\r\n              Positioning.position(sink, menu, { anchor: anchor });\r\n              Sandboxing.decloak(sandbox);\r\n            },\r\n            onOpenSubmenu: function (tmenu, item, submenu) {\r\n              var sink = getLazySink().getOrDie();\r\n              Positioning.position(sink, submenu, {\r\n                anchor: {\r\n                  type: 'submenu',\r\n                  item: item\r\n                }\r\n              });\r\n              Sandboxing.decloak(sandbox);\r\n            },\r\n            onRepositionMenu: function (tmenu, primaryMenu, submenuTriggers) {\r\n              var sink = getLazySink().getOrDie();\r\n              Positioning.position(sink, primaryMenu, { anchor: anchor });\r\n              each$1(submenuTriggers, function (st) {\r\n                Positioning.position(sink, st.triggeredMenu, {\r\n                  anchor: {\r\n                    type: 'submenu',\r\n                    item: st.triggeringItem\r\n                  }\r\n                });\r\n              });\r\n            },\r\n            onEscape: function () {\r\n              Focusing.focus(component);\r\n              Sandboxing.close(sandbox);\r\n              return Optional.some(true);\r\n            }\r\n          })));\r\n        });\r\n      });\r\n    };\r\n    var open = function (detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen) {\r\n      var anchor = getAnchor(detail, hotspot);\r\n      var processed = openF(detail, mapFetch, anchor, hotspot, sandbox, externals, highlightOnOpen);\r\n      return processed.map(function (tdata) {\r\n        tdata.fold(function () {\r\n          if (Sandboxing.isOpen(sandbox)) {\r\n            Sandboxing.close(sandbox);\r\n          }\r\n        }, function (data) {\r\n          Sandboxing.cloak(sandbox);\r\n          Sandboxing.open(sandbox, data);\r\n          onOpenSync(sandbox);\r\n        });\r\n        return sandbox;\r\n      });\r\n    };\r\n    var close = function (detail, mapFetch, component, sandbox, _externals, _onOpenSync, _highlightOnOpen) {\r\n      Sandboxing.close(sandbox);\r\n      return Future.pure(sandbox);\r\n    };\r\n    var togglePopup = function (detail, mapFetch, hotspot, externals, onOpenSync, highlightOnOpen) {\r\n      var sandbox = Coupling.getCoupled(hotspot, 'sandbox');\r\n      var showing = Sandboxing.isOpen(sandbox);\r\n      var action = showing ? close : open;\r\n      return action(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);\r\n    };\r\n    var matchWidth = function (hotspot, container, useMinWidth) {\r\n      var menu = Composing.getCurrent(container).getOr(container);\r\n      var buttonWidth = get$a(hotspot.element);\r\n      if (useMinWidth) {\r\n        set$7(menu.element, 'min-width', buttonWidth + 'px');\r\n      } else {\r\n        set$6(menu.element, buttonWidth);\r\n      }\r\n    };\r\n    var getSink = function (anyInSystem, sinkDetail) {\r\n      return anyInSystem.getSystem().getByUid(sinkDetail.uid + '-' + suffix()).map(function (internalSink) {\r\n        return function () {\r\n          return Result.value(internalSink);\r\n        };\r\n      }).getOrThunk(function () {\r\n        return sinkDetail.lazySink.fold(function () {\r\n          return function () {\r\n            return Result.error(new Error('No internal sink is specified, nor could an external sink be found'));\r\n          };\r\n        }, function (lazySinkFn) {\r\n          return function () {\r\n            return lazySinkFn(anyInSystem);\r\n          };\r\n        });\r\n      });\r\n    };\r\n    var doRepositionMenus = function (sandbox) {\r\n      Sandboxing.getState(sandbox).each(function (tmenu) {\r\n        tieredMenu.repositionMenus(tmenu);\r\n      });\r\n    };\r\n    var makeSandbox$1 = function (detail, hotspot, extras) {\r\n      var ariaOwner = manager();\r\n      var onOpen = function (component, menu) {\r\n        var anchor = getAnchor(detail, hotspot);\r\n        ariaOwner.link(hotspot.element);\r\n        if (detail.matchWidth) {\r\n          matchWidth(anchor.hotspot, menu, detail.useMinWidth);\r\n        }\r\n        detail.onOpen(anchor, component, menu);\r\n        if (extras !== undefined && extras.onOpen !== undefined) {\r\n          extras.onOpen(component, menu);\r\n        }\r\n      };\r\n      var onClose = function (component, menu) {\r\n        ariaOwner.unlink(hotspot.element);\r\n        if (extras !== undefined && extras.onClose !== undefined) {\r\n          extras.onClose(component, menu);\r\n        }\r\n      };\r\n      var lazySink = getSink(hotspot, detail);\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: detail.sandboxClasses,\r\n          attributes: {\r\n            id: ariaOwner.id,\r\n            role: 'listbox'\r\n          }\r\n        },\r\n        behaviours: SketchBehaviours.augment(detail.sandboxBehaviours, [\r\n          Representing.config({\r\n            store: {\r\n              mode: 'memory',\r\n              initialValue: hotspot\r\n            }\r\n          }),\r\n          Sandboxing.config({\r\n            onOpen: onOpen,\r\n            onClose: onClose,\r\n            isPartOf: function (container, data, queryElem) {\r\n              return isPartOf$1(data, queryElem) || isPartOf$1(hotspot, queryElem);\r\n            },\r\n            getAttachPoint: function () {\r\n              return lazySink().getOrDie();\r\n            }\r\n          }),\r\n          Composing.config({\r\n            find: function (sandbox) {\r\n              return Sandboxing.getState(sandbox).bind(function (menu) {\r\n                return Composing.getCurrent(menu);\r\n              });\r\n            }\r\n          }),\r\n          Receiving.config({ channels: __assign(__assign({}, receivingChannel$1({ isExtraPart: never })), receivingChannel({ doReposition: doRepositionMenus })) })\r\n        ])\r\n      };\r\n    };\r\n    var repositionMenus = function (comp) {\r\n      var sandbox = Coupling.getCoupled(comp, 'sandbox');\r\n      doRepositionMenus(sandbox);\r\n    };\r\n\r\n    var sandboxFields = function () {\r\n      return [\r\n        defaulted('sandboxClasses', []),\r\n        SketchBehaviours.field('sandboxBehaviours', [\r\n          Composing,\r\n          Receiving,\r\n          Sandboxing,\r\n          Representing\r\n        ])\r\n      ];\r\n    };\r\n\r\n    var schema$j = constant$1([\r\n      required$1('dom'),\r\n      required$1('fetch'),\r\n      onHandler('onOpen'),\r\n      onKeyboardHandler('onExecute'),\r\n      defaulted('getHotspot', Optional.some),\r\n      defaulted('getAnchorOverrides', constant$1({})),\r\n      schema$y(),\r\n      field('dropdownBehaviours', [\r\n        Toggling,\r\n        Coupling,\r\n        Keying,\r\n        Focusing\r\n      ]),\r\n      required$1('toggleClass'),\r\n      defaulted('eventOrder', {}),\r\n      option('lazySink'),\r\n      defaulted('matchWidth', false),\r\n      defaulted('useMinWidth', false),\r\n      option('role')\r\n    ].concat(sandboxFields()));\r\n    var parts$d = constant$1([\r\n      external$1({\r\n        schema: [tieredMenuMarkers()],\r\n        name: 'menu',\r\n        defaults: function (detail) {\r\n          return { onExecute: detail.onExecute };\r\n        }\r\n      }),\r\n      partType$1()\r\n    ]);\r\n\r\n    var factory$g = function (detail, components, _spec, externals) {\r\n      var _a;\r\n      var lookupAttr = function (attr) {\r\n        return get$e(detail.dom, 'attributes').bind(function (attrs) {\r\n          return get$e(attrs, attr);\r\n        });\r\n      };\r\n      var switchToMenu = function (sandbox) {\r\n        Sandboxing.getState(sandbox).each(function (tmenu) {\r\n          tieredMenu.highlightPrimary(tmenu);\r\n        });\r\n      };\r\n      var action = function (component) {\r\n        var onOpenSync = switchToMenu;\r\n        togglePopup(detail, identity$1, component, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);\r\n      };\r\n      var apis = {\r\n        expand: function (comp) {\r\n          if (!Toggling.isOn(comp)) {\r\n            togglePopup(detail, identity$1, comp, externals, noop, HighlightOnOpen.HighlightNone).get(noop);\r\n          }\r\n        },\r\n        open: function (comp) {\r\n          if (!Toggling.isOn(comp)) {\r\n            togglePopup(detail, identity$1, comp, externals, noop, HighlightOnOpen.HighlightFirst).get(noop);\r\n          }\r\n        },\r\n        isOpen: Toggling.isOn,\r\n        close: function (comp) {\r\n          if (Toggling.isOn(comp)) {\r\n            togglePopup(detail, identity$1, comp, externals, noop, HighlightOnOpen.HighlightFirst).get(noop);\r\n          }\r\n        },\r\n        repositionMenus: function (comp) {\r\n          if (Toggling.isOn(comp)) {\r\n            repositionMenus(comp);\r\n          }\r\n        }\r\n      };\r\n      var triggerExecute = function (comp, _se) {\r\n        emitExecute(comp);\r\n        return Optional.some(true);\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        behaviours: augment(detail.dropdownBehaviours, [\r\n          Toggling.config({\r\n            toggleClass: detail.toggleClass,\r\n            aria: { mode: 'expanded' }\r\n          }),\r\n          Coupling.config({\r\n            others: {\r\n              sandbox: function (hotspot) {\r\n                return makeSandbox$1(detail, hotspot, {\r\n                  onOpen: function () {\r\n                    return Toggling.on(hotspot);\r\n                  },\r\n                  onClose: function () {\r\n                    return Toggling.off(hotspot);\r\n                  }\r\n                });\r\n              }\r\n            }\r\n          }),\r\n          Keying.config({\r\n            mode: 'special',\r\n            onSpace: triggerExecute,\r\n            onEnter: triggerExecute,\r\n            onDown: function (comp, _se) {\r\n              if (Dropdown.isOpen(comp)) {\r\n                var sandbox = Coupling.getCoupled(comp, 'sandbox');\r\n                switchToMenu(sandbox);\r\n              } else {\r\n                Dropdown.open(comp);\r\n              }\r\n              return Optional.some(true);\r\n            },\r\n            onEscape: function (comp, _se) {\r\n              if (Dropdown.isOpen(comp)) {\r\n                Dropdown.close(comp);\r\n                return Optional.some(true);\r\n              } else {\r\n                return Optional.none();\r\n              }\r\n            }\r\n          }),\r\n          Focusing.config({})\r\n        ]),\r\n        events: events$a(Optional.some(action)),\r\n        eventOrder: __assign(__assign({}, detail.eventOrder), (_a = {}, _a[execute$5()] = [\r\n          'disabling',\r\n          'toggling',\r\n          'alloy.base.behaviour'\r\n        ], _a)),\r\n        apis: apis,\r\n        domModification: {\r\n          attributes: __assign(__assign({ 'aria-haspopup': 'true' }, detail.role.fold(function () {\r\n            return {};\r\n          }, function (role) {\r\n            return { role: role };\r\n          })), detail.dom.tag === 'button' ? { type: lookupAttr('type').getOr('button') } : {})\r\n        }\r\n      };\r\n    };\r\n    var Dropdown = composite({\r\n      name: 'Dropdown',\r\n      configFields: schema$j(),\r\n      partFields: parts$d(),\r\n      factory: factory$g,\r\n      apis: {\r\n        open: function (apis, comp) {\r\n          return apis.open(comp);\r\n        },\r\n        expand: function (apis, comp) {\r\n          return apis.expand(comp);\r\n        },\r\n        close: function (apis, comp) {\r\n          return apis.close(comp);\r\n        },\r\n        isOpen: function (apis, comp) {\r\n          return apis.isOpen(comp);\r\n        },\r\n        repositionMenus: function (apis, comp) {\r\n          return apis.repositionMenus(comp);\r\n        }\r\n      }\r\n    });\r\n\r\n    var exhibit$1 = function () {\r\n      return nu$7({\r\n        styles: {\r\n          '-webkit-user-select': 'none',\r\n          'user-select': 'none',\r\n          '-ms-user-select': 'none',\r\n          '-moz-user-select': '-moz-none'\r\n        },\r\n        attributes: { unselectable: 'on' }\r\n      });\r\n    };\r\n    var events$7 = function () {\r\n      return derive$2([abort(selectstart(), always)]);\r\n    };\r\n\r\n    var ActiveUnselecting = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        events: events$7,\r\n        exhibit: exhibit$1\r\n    });\r\n\r\n    var Unselecting = create$8({\r\n      fields: [],\r\n      name: 'unselecting',\r\n      active: ActiveUnselecting\r\n    });\r\n\r\n    var renderPanelButton = function (spec, sharedBackstage) {\r\n      return Dropdown.sketch({\r\n        dom: spec.dom,\r\n        components: spec.components,\r\n        toggleClass: 'mce-active',\r\n        dropdownBehaviours: derive$1([\r\n          DisablingConfigs.button(sharedBackstage.providers.isDisabled),\r\n          receivingConfig(),\r\n          Unselecting.config({}),\r\n          Tabstopping.config({})\r\n        ]),\r\n        layouts: spec.layouts,\r\n        sandboxClasses: ['tox-dialog__popups'],\r\n        lazySink: sharedBackstage.getSink,\r\n        fetch: function (comp) {\r\n          return Future.nu(function (callback) {\r\n            return spec.fetch(callback);\r\n          }).map(function (items) {\r\n            return Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, function (value) {\r\n              spec.onItemAction(comp, value);\r\n            }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, never, sharedBackstage.providers), { movement: deriveMenuMovement(spec.columns, spec.presets) })));\r\n          });\r\n        },\r\n        parts: { menu: part(false, 1, spec.presets) }\r\n      });\r\n    };\r\n\r\n    var colorInputChangeEvent = generate$6('color-input-change');\r\n    var colorSwatchChangeEvent = generate$6('color-swatch-change');\r\n    var colorPickerCancelEvent = generate$6('color-picker-cancel');\r\n    var renderColorInput = function (spec, sharedBackstage, colorInputBackstage) {\r\n      var pField = FormField.parts.field({\r\n        factory: Input,\r\n        inputClasses: ['tox-textfield'],\r\n        onSetValue: function (c) {\r\n          return Invalidating.run(c).get(noop);\r\n        },\r\n        inputBehaviours: derive$1([\r\n          Disabling.config({ disabled: sharedBackstage.providers.isDisabled }),\r\n          receivingConfig(),\r\n          Tabstopping.config({}),\r\n          Invalidating.config({\r\n            invalidClass: 'tox-textbox-field-invalid',\r\n            getRoot: function (comp) {\r\n              return parent(comp.element);\r\n            },\r\n            notify: {\r\n              onValid: function (comp) {\r\n                var val = Representing.getValue(comp);\r\n                emitWith(comp, colorInputChangeEvent, { color: val });\r\n              }\r\n            },\r\n            validator: {\r\n              validateOnLoad: false,\r\n              validate: function (input) {\r\n                var inputValue = Representing.getValue(input);\r\n                if (inputValue.length === 0) {\r\n                  return Future.pure(Result.value(true));\r\n                } else {\r\n                  var span = SugarElement.fromTag('span');\r\n                  set$7(span, 'background-color', inputValue);\r\n                  var res = getRaw(span, 'background-color').fold(function () {\r\n                    return Result.error('blah');\r\n                  }, function (_) {\r\n                    return Result.value(inputValue);\r\n                  });\r\n                  return Future.pure(res);\r\n                }\r\n              }\r\n            }\r\n          })\r\n        ]),\r\n        selectOnFocus: false\r\n      });\r\n      var pLabel = spec.label.map(function (label) {\r\n        return renderLabel$2(label, sharedBackstage.providers);\r\n      });\r\n      var emitSwatchChange = function (colorBit, value) {\r\n        emitWith(colorBit, colorSwatchChangeEvent, { value: value });\r\n      };\r\n      var onItemAction = function (comp, value) {\r\n        memColorButton.getOpt(comp).each(function (colorBit) {\r\n          if (value === 'custom') {\r\n            colorInputBackstage.colorPicker(function (valueOpt) {\r\n              valueOpt.fold(function () {\r\n                return emit(colorBit, colorPickerCancelEvent);\r\n              }, function (value) {\r\n                emitSwatchChange(colorBit, value);\r\n                addColor(value);\r\n              });\r\n            }, '#ffffff');\r\n          } else if (value === 'remove') {\r\n            emitSwatchChange(colorBit, '');\r\n          } else {\r\n            emitSwatchChange(colorBit, value);\r\n          }\r\n        });\r\n      };\r\n      var memColorButton = record(renderPanelButton({\r\n        dom: {\r\n          tag: 'span',\r\n          attributes: { 'aria-label': sharedBackstage.providers.translate('Color swatch') }\r\n        },\r\n        layouts: {\r\n          onRtl: function () {\r\n            return [\r\n              southwest$2,\r\n              southeast$2,\r\n              south$2\r\n            ];\r\n          },\r\n          onLtr: function () {\r\n            return [\r\n              southeast$2,\r\n              southwest$2,\r\n              south$2\r\n            ];\r\n          }\r\n        },\r\n        components: [],\r\n        fetch: getFetch$1(colorInputBackstage.getColors(), colorInputBackstage.hasCustomColors()),\r\n        columns: colorInputBackstage.getColorCols(),\r\n        presets: 'color',\r\n        onItemAction: onItemAction\r\n      }, sharedBackstage));\r\n      return FormField.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-form__group']\r\n        },\r\n        components: pLabel.toArray().concat([{\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-color-input']\r\n            },\r\n            components: [\r\n              pField,\r\n              memColorButton.asSpec()\r\n            ]\r\n          }]),\r\n        fieldBehaviours: derive$1([config('form-field-events', [\r\n            run$1(colorInputChangeEvent, function (comp, se) {\r\n              memColorButton.getOpt(comp).each(function (colorButton) {\r\n                set$7(colorButton.element, 'background-color', se.event.color);\r\n              });\r\n              emitWith(comp, formChangeEvent, { name: spec.name });\r\n            }),\r\n            run$1(colorSwatchChangeEvent, function (comp, se) {\r\n              FormField.getField(comp).each(function (field) {\r\n                Representing.setValue(field, se.event.value);\r\n                Composing.getCurrent(comp).each(Focusing.focus);\r\n              });\r\n            }),\r\n            run$1(colorPickerCancelEvent, function (comp, _se) {\r\n              FormField.getField(comp).each(function (_field) {\r\n                Composing.getCurrent(comp).each(Focusing.focus);\r\n              });\r\n            })\r\n          ])])\r\n      });\r\n    };\r\n\r\n    var labelPart = optional({\r\n      schema: [required$1('dom')],\r\n      name: 'label'\r\n    });\r\n    var edgePart = function (name) {\r\n      return optional({\r\n        name: '' + name + '-edge',\r\n        overrides: function (detail) {\r\n          var action = detail.model.manager.edgeActions[name];\r\n          return action.fold(function () {\r\n            return {};\r\n          }, function (a) {\r\n            return {\r\n              events: derive$2([\r\n                runActionExtra(touchstart(), function (comp, se, d) {\r\n                  return a(comp, d);\r\n                }, [detail]),\r\n                runActionExtra(mousedown(), function (comp, se, d) {\r\n                  return a(comp, d);\r\n                }, [detail]),\r\n                runActionExtra(mousemove(), function (comp, se, det) {\r\n                  if (det.mouseIsDown.get()) {\r\n                    a(comp, det);\r\n                  }\r\n                }, [detail])\r\n              ])\r\n            };\r\n          });\r\n        }\r\n      });\r\n    };\r\n    var tlEdgePart = edgePart('top-left');\r\n    var tedgePart = edgePart('top');\r\n    var trEdgePart = edgePart('top-right');\r\n    var redgePart = edgePart('right');\r\n    var brEdgePart = edgePart('bottom-right');\r\n    var bedgePart = edgePart('bottom');\r\n    var blEdgePart = edgePart('bottom-left');\r\n    var ledgePart = edgePart('left');\r\n    var thumbPart = required({\r\n      name: 'thumb',\r\n      defaults: constant$1({ dom: { styles: { position: 'absolute' } } }),\r\n      overrides: function (detail) {\r\n        return {\r\n          events: derive$2([\r\n            redirectToPart(touchstart(), detail, 'spectrum'),\r\n            redirectToPart(touchmove(), detail, 'spectrum'),\r\n            redirectToPart(touchend(), detail, 'spectrum'),\r\n            redirectToPart(mousedown(), detail, 'spectrum'),\r\n            redirectToPart(mousemove(), detail, 'spectrum'),\r\n            redirectToPart(mouseup(), detail, 'spectrum')\r\n          ])\r\n        };\r\n      }\r\n    });\r\n    var spectrumPart = required({\r\n      schema: [customField('mouseIsDown', function () {\r\n          return Cell(false);\r\n        })],\r\n      name: 'spectrum',\r\n      overrides: function (detail) {\r\n        var modelDetail = detail.model;\r\n        var model = modelDetail.manager;\r\n        var setValueFrom = function (component, simulatedEvent) {\r\n          return model.getValueFromEvent(simulatedEvent).map(function (value) {\r\n            return model.setValueFrom(component, detail, value);\r\n          });\r\n        };\r\n        return {\r\n          behaviours: derive$1([\r\n            Keying.config({\r\n              mode: 'special',\r\n              onLeft: function (spectrum) {\r\n                return model.onLeft(spectrum, detail);\r\n              },\r\n              onRight: function (spectrum) {\r\n                return model.onRight(spectrum, detail);\r\n              },\r\n              onUp: function (spectrum) {\r\n                return model.onUp(spectrum, detail);\r\n              },\r\n              onDown: function (spectrum) {\r\n                return model.onDown(spectrum, detail);\r\n              }\r\n            }),\r\n            Focusing.config({})\r\n          ]),\r\n          events: derive$2([\r\n            run$1(touchstart(), setValueFrom),\r\n            run$1(touchmove(), setValueFrom),\r\n            run$1(mousedown(), setValueFrom),\r\n            run$1(mousemove(), function (spectrum, se) {\r\n              if (detail.mouseIsDown.get()) {\r\n                setValueFrom(spectrum, se);\r\n              }\r\n            })\r\n          ])\r\n        };\r\n      }\r\n    });\r\n    var SliderParts = [\r\n      labelPart,\r\n      ledgePart,\r\n      redgePart,\r\n      tedgePart,\r\n      bedgePart,\r\n      tlEdgePart,\r\n      trEdgePart,\r\n      blEdgePart,\r\n      brEdgePart,\r\n      thumbPart,\r\n      spectrumPart\r\n    ];\r\n\r\n    var _sliderChangeEvent = 'slider.change.value';\r\n    var sliderChangeEvent = constant$1(_sliderChangeEvent);\r\n    var isTouchEvent$2 = function (evt) {\r\n      return evt.type.indexOf('touch') !== -1;\r\n    };\r\n    var getEventSource = function (simulatedEvent) {\r\n      var evt = simulatedEvent.event.raw;\r\n      if (isTouchEvent$2(evt)) {\r\n        var touchEvent = evt;\r\n        return touchEvent.touches !== undefined && touchEvent.touches.length === 1 ? Optional.some(touchEvent.touches[0]).map(function (t) {\r\n          return SugarPosition(t.clientX, t.clientY);\r\n        }) : Optional.none();\r\n      } else {\r\n        var mouseEvent = evt;\r\n        return mouseEvent.clientX !== undefined ? Optional.some(mouseEvent).map(function (me) {\r\n          return SugarPosition(me.clientX, me.clientY);\r\n        }) : Optional.none();\r\n      }\r\n    };\r\n\r\n    var t = 'top', r = 'right', b = 'bottom', l = 'left';\r\n    var minX = function (detail) {\r\n      return detail.model.minX;\r\n    };\r\n    var minY = function (detail) {\r\n      return detail.model.minY;\r\n    };\r\n    var min1X = function (detail) {\r\n      return detail.model.minX - 1;\r\n    };\r\n    var min1Y = function (detail) {\r\n      return detail.model.minY - 1;\r\n    };\r\n    var maxX = function (detail) {\r\n      return detail.model.maxX;\r\n    };\r\n    var maxY = function (detail) {\r\n      return detail.model.maxY;\r\n    };\r\n    var max1X = function (detail) {\r\n      return detail.model.maxX + 1;\r\n    };\r\n    var max1Y = function (detail) {\r\n      return detail.model.maxY + 1;\r\n    };\r\n    var range = function (detail, max, min) {\r\n      return max(detail) - min(detail);\r\n    };\r\n    var xRange = function (detail) {\r\n      return range(detail, maxX, minX);\r\n    };\r\n    var yRange = function (detail) {\r\n      return range(detail, maxY, minY);\r\n    };\r\n    var halfX = function (detail) {\r\n      return xRange(detail) / 2;\r\n    };\r\n    var halfY = function (detail) {\r\n      return yRange(detail) / 2;\r\n    };\r\n    var step = function (detail) {\r\n      return detail.stepSize;\r\n    };\r\n    var snap = function (detail) {\r\n      return detail.snapToGrid;\r\n    };\r\n    var snapStart = function (detail) {\r\n      return detail.snapStart;\r\n    };\r\n    var rounded = function (detail) {\r\n      return detail.rounded;\r\n    };\r\n    var hasEdge = function (detail, edgeName) {\r\n      return detail[edgeName + '-edge'] !== undefined;\r\n    };\r\n    var hasLEdge = function (detail) {\r\n      return hasEdge(detail, l);\r\n    };\r\n    var hasREdge = function (detail) {\r\n      return hasEdge(detail, r);\r\n    };\r\n    var hasTEdge = function (detail) {\r\n      return hasEdge(detail, t);\r\n    };\r\n    var hasBEdge = function (detail) {\r\n      return hasEdge(detail, b);\r\n    };\r\n    var currentValue = function (detail) {\r\n      return detail.model.value.get();\r\n    };\r\n\r\n    var xValue = function (x) {\r\n      return { x: x };\r\n    };\r\n    var yValue = function (y) {\r\n      return { y: y };\r\n    };\r\n    var xyValue = function (x, y) {\r\n      return {\r\n        x: x,\r\n        y: y\r\n      };\r\n    };\r\n    var fireSliderChange$3 = function (component, value) {\r\n      emitWith(component, sliderChangeEvent(), { value: value });\r\n    };\r\n    var setToTLEdgeXY = function (edge, detail) {\r\n      fireSliderChange$3(edge, xyValue(min1X(detail), min1Y(detail)));\r\n    };\r\n    var setToTEdge = function (edge, detail) {\r\n      fireSliderChange$3(edge, yValue(min1Y(detail)));\r\n    };\r\n    var setToTEdgeXY = function (edge, detail) {\r\n      fireSliderChange$3(edge, xyValue(halfX(detail), min1Y(detail)));\r\n    };\r\n    var setToTREdgeXY = function (edge, detail) {\r\n      fireSliderChange$3(edge, xyValue(max1X(detail), min1Y(detail)));\r\n    };\r\n    var setToREdge = function (edge, detail) {\r\n      fireSliderChange$3(edge, xValue(max1X(detail)));\r\n    };\r\n    var setToREdgeXY = function (edge, detail) {\r\n      fireSliderChange$3(edge, xyValue(max1X(detail), halfY(detail)));\r\n    };\r\n    var setToBREdgeXY = function (edge, detail) {\r\n      fireSliderChange$3(edge, xyValue(max1X(detail), max1Y(detail)));\r\n    };\r\n    var setToBEdge = function (edge, detail) {\r\n      fireSliderChange$3(edge, yValue(max1Y(detail)));\r\n    };\r\n    var setToBEdgeXY = function (edge, detail) {\r\n      fireSliderChange$3(edge, xyValue(halfX(detail), max1Y(detail)));\r\n    };\r\n    var setToBLEdgeXY = function (edge, detail) {\r\n      fireSliderChange$3(edge, xyValue(min1X(detail), max1Y(detail)));\r\n    };\r\n    var setToLEdge = function (edge, detail) {\r\n      fireSliderChange$3(edge, xValue(min1X(detail)));\r\n    };\r\n    var setToLEdgeXY = function (edge, detail) {\r\n      fireSliderChange$3(edge, xyValue(min1X(detail), halfY(detail)));\r\n    };\r\n\r\n    var reduceBy = function (value, min, max, step) {\r\n      if (value < min) {\r\n        return value;\r\n      } else if (value > max) {\r\n        return max;\r\n      } else if (value === min) {\r\n        return min - 1;\r\n      } else {\r\n        return Math.max(min, value - step);\r\n      }\r\n    };\r\n    var increaseBy = function (value, min, max, step) {\r\n      if (value > max) {\r\n        return value;\r\n      } else if (value < min) {\r\n        return min;\r\n      } else if (value === max) {\r\n        return max + 1;\r\n      } else {\r\n        return Math.min(max, value + step);\r\n      }\r\n    };\r\n    var capValue = function (value, min, max) {\r\n      return Math.max(min, Math.min(max, value));\r\n    };\r\n    var snapValueOf = function (value, min, max, step, snapStart) {\r\n      return snapStart.fold(function () {\r\n        var initValue = value - min;\r\n        var extraValue = Math.round(initValue / step) * step;\r\n        return capValue(min + extraValue, min - 1, max + 1);\r\n      }, function (start) {\r\n        var remainder = (value - start) % step;\r\n        var adjustment = Math.round(remainder / step);\r\n        var rawSteps = Math.floor((value - start) / step);\r\n        var maxSteps = Math.floor((max - start) / step);\r\n        var numSteps = Math.min(maxSteps, rawSteps + adjustment);\r\n        var r = start + numSteps * step;\r\n        return Math.max(start, r);\r\n      });\r\n    };\r\n    var findOffsetOf = function (value, min, max) {\r\n      return Math.min(max, Math.max(value, min)) - min;\r\n    };\r\n    var findValueOf = function (args) {\r\n      var min = args.min, max = args.max, range = args.range, value = args.value, step = args.step, snap = args.snap, snapStart = args.snapStart, rounded = args.rounded, hasMinEdge = args.hasMinEdge, hasMaxEdge = args.hasMaxEdge, minBound = args.minBound, maxBound = args.maxBound, screenRange = args.screenRange;\r\n      var capMin = hasMinEdge ? min - 1 : min;\r\n      var capMax = hasMaxEdge ? max + 1 : max;\r\n      if (value < minBound) {\r\n        return capMin;\r\n      } else if (value > maxBound) {\r\n        return capMax;\r\n      } else {\r\n        var offset = findOffsetOf(value, minBound, maxBound);\r\n        var newValue = capValue(offset / screenRange * range + min, capMin, capMax);\r\n        if (snap && newValue >= min && newValue <= max) {\r\n          return snapValueOf(newValue, min, max, step, snapStart);\r\n        } else if (rounded) {\r\n          return Math.round(newValue);\r\n        } else {\r\n          return newValue;\r\n        }\r\n      }\r\n    };\r\n    var findOffsetOfValue$2 = function (args) {\r\n      var min = args.min, max = args.max, range = args.range, value = args.value, hasMinEdge = args.hasMinEdge, hasMaxEdge = args.hasMaxEdge, maxBound = args.maxBound, maxOffset = args.maxOffset, centerMinEdge = args.centerMinEdge, centerMaxEdge = args.centerMaxEdge;\r\n      if (value < min) {\r\n        return hasMinEdge ? 0 : centerMinEdge;\r\n      } else if (value > max) {\r\n        return hasMaxEdge ? maxBound : centerMaxEdge;\r\n      } else {\r\n        return (value - min) / range * maxOffset;\r\n      }\r\n    };\r\n\r\n    var top = 'top', right = 'right', bottom = 'bottom', left = 'left', width = 'width', height = 'height';\r\n    var getBounds = function (component) {\r\n      return component.element.dom.getBoundingClientRect();\r\n    };\r\n    var getBoundsProperty = function (bounds, property) {\r\n      return bounds[property];\r\n    };\r\n    var getMinXBounds = function (component) {\r\n      var bounds = getBounds(component);\r\n      return getBoundsProperty(bounds, left);\r\n    };\r\n    var getMaxXBounds = function (component) {\r\n      var bounds = getBounds(component);\r\n      return getBoundsProperty(bounds, right);\r\n    };\r\n    var getMinYBounds = function (component) {\r\n      var bounds = getBounds(component);\r\n      return getBoundsProperty(bounds, top);\r\n    };\r\n    var getMaxYBounds = function (component) {\r\n      var bounds = getBounds(component);\r\n      return getBoundsProperty(bounds, bottom);\r\n    };\r\n    var getXScreenRange = function (component) {\r\n      var bounds = getBounds(component);\r\n      return getBoundsProperty(bounds, width);\r\n    };\r\n    var getYScreenRange = function (component) {\r\n      var bounds = getBounds(component);\r\n      return getBoundsProperty(bounds, height);\r\n    };\r\n    var getCenterOffsetOf = function (componentMinEdge, componentMaxEdge, spectrumMinEdge) {\r\n      return (componentMinEdge + componentMaxEdge) / 2 - spectrumMinEdge;\r\n    };\r\n    var getXCenterOffSetOf = function (component, spectrum) {\r\n      var componentBounds = getBounds(component);\r\n      var spectrumBounds = getBounds(spectrum);\r\n      var componentMinEdge = getBoundsProperty(componentBounds, left);\r\n      var componentMaxEdge = getBoundsProperty(componentBounds, right);\r\n      var spectrumMinEdge = getBoundsProperty(spectrumBounds, left);\r\n      return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);\r\n    };\r\n    var getYCenterOffSetOf = function (component, spectrum) {\r\n      var componentBounds = getBounds(component);\r\n      var spectrumBounds = getBounds(spectrum);\r\n      var componentMinEdge = getBoundsProperty(componentBounds, top);\r\n      var componentMaxEdge = getBoundsProperty(componentBounds, bottom);\r\n      var spectrumMinEdge = getBoundsProperty(spectrumBounds, top);\r\n      return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);\r\n    };\r\n\r\n    var fireSliderChange$2 = function (spectrum, value) {\r\n      emitWith(spectrum, sliderChangeEvent(), { value: value });\r\n    };\r\n    var sliderValue$2 = function (x) {\r\n      return { x: x };\r\n    };\r\n    var findValueOfOffset$1 = function (spectrum, detail, left) {\r\n      var args = {\r\n        min: minX(detail),\r\n        max: maxX(detail),\r\n        range: xRange(detail),\r\n        value: left,\r\n        step: step(detail),\r\n        snap: snap(detail),\r\n        snapStart: snapStart(detail),\r\n        rounded: rounded(detail),\r\n        hasMinEdge: hasLEdge(detail),\r\n        hasMaxEdge: hasREdge(detail),\r\n        minBound: getMinXBounds(spectrum),\r\n        maxBound: getMaxXBounds(spectrum),\r\n        screenRange: getXScreenRange(spectrum)\r\n      };\r\n      return findValueOf(args);\r\n    };\r\n    var setValueFrom$2 = function (spectrum, detail, value) {\r\n      var xValue = findValueOfOffset$1(spectrum, detail, value);\r\n      var sliderVal = sliderValue$2(xValue);\r\n      fireSliderChange$2(spectrum, sliderVal);\r\n      return xValue;\r\n    };\r\n    var setToMin$2 = function (spectrum, detail) {\r\n      var min = minX(detail);\r\n      fireSliderChange$2(spectrum, sliderValue$2(min));\r\n    };\r\n    var setToMax$2 = function (spectrum, detail) {\r\n      var max = maxX(detail);\r\n      fireSliderChange$2(spectrum, sliderValue$2(max));\r\n    };\r\n    var moveBy$2 = function (direction, spectrum, detail) {\r\n      var f = direction > 0 ? increaseBy : reduceBy;\r\n      var xValue = f(currentValue(detail).x, minX(detail), maxX(detail), step(detail));\r\n      fireSliderChange$2(spectrum, sliderValue$2(xValue));\r\n      return Optional.some(xValue);\r\n    };\r\n    var handleMovement$2 = function (direction) {\r\n      return function (spectrum, detail) {\r\n        return moveBy$2(direction, spectrum, detail).map(always);\r\n      };\r\n    };\r\n    var getValueFromEvent$2 = function (simulatedEvent) {\r\n      var pos = getEventSource(simulatedEvent);\r\n      return pos.map(function (p) {\r\n        return p.left;\r\n      });\r\n    };\r\n    var findOffsetOfValue$1 = function (spectrum, detail, value, minEdge, maxEdge) {\r\n      var minOffset = 0;\r\n      var maxOffset = getXScreenRange(spectrum);\r\n      var centerMinEdge = minEdge.bind(function (edge) {\r\n        return Optional.some(getXCenterOffSetOf(edge, spectrum));\r\n      }).getOr(minOffset);\r\n      var centerMaxEdge = maxEdge.bind(function (edge) {\r\n        return Optional.some(getXCenterOffSetOf(edge, spectrum));\r\n      }).getOr(maxOffset);\r\n      var args = {\r\n        min: minX(detail),\r\n        max: maxX(detail),\r\n        range: xRange(detail),\r\n        value: value,\r\n        hasMinEdge: hasLEdge(detail),\r\n        hasMaxEdge: hasREdge(detail),\r\n        minBound: getMinXBounds(spectrum),\r\n        minOffset: minOffset,\r\n        maxBound: getMaxXBounds(spectrum),\r\n        maxOffset: maxOffset,\r\n        centerMinEdge: centerMinEdge,\r\n        centerMaxEdge: centerMaxEdge\r\n      };\r\n      return findOffsetOfValue$2(args);\r\n    };\r\n    var findPositionOfValue$1 = function (slider, spectrum, value, minEdge, maxEdge, detail) {\r\n      var offset = findOffsetOfValue$1(spectrum, detail, value, minEdge, maxEdge);\r\n      return getMinXBounds(spectrum) - getMinXBounds(slider) + offset;\r\n    };\r\n    var setPositionFromValue$2 = function (slider, thumb, detail, edges) {\r\n      var value = currentValue(detail);\r\n      var pos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value.x, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);\r\n      var thumbRadius = get$a(thumb.element) / 2;\r\n      set$7(thumb.element, 'left', pos - thumbRadius + 'px');\r\n    };\r\n    var onLeft$2 = handleMovement$2(-1);\r\n    var onRight$2 = handleMovement$2(1);\r\n    var onUp$2 = Optional.none;\r\n    var onDown$2 = Optional.none;\r\n    var edgeActions$2 = {\r\n      'top-left': Optional.none(),\r\n      'top': Optional.none(),\r\n      'top-right': Optional.none(),\r\n      'right': Optional.some(setToREdge),\r\n      'bottom-right': Optional.none(),\r\n      'bottom': Optional.none(),\r\n      'bottom-left': Optional.none(),\r\n      'left': Optional.some(setToLEdge)\r\n    };\r\n\r\n    var HorizontalModel = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        setValueFrom: setValueFrom$2,\r\n        setToMin: setToMin$2,\r\n        setToMax: setToMax$2,\r\n        findValueOfOffset: findValueOfOffset$1,\r\n        getValueFromEvent: getValueFromEvent$2,\r\n        findPositionOfValue: findPositionOfValue$1,\r\n        setPositionFromValue: setPositionFromValue$2,\r\n        onLeft: onLeft$2,\r\n        onRight: onRight$2,\r\n        onUp: onUp$2,\r\n        onDown: onDown$2,\r\n        edgeActions: edgeActions$2\r\n    });\r\n\r\n    var fireSliderChange$1 = function (spectrum, value) {\r\n      emitWith(spectrum, sliderChangeEvent(), { value: value });\r\n    };\r\n    var sliderValue$1 = function (y) {\r\n      return { y: y };\r\n    };\r\n    var findValueOfOffset = function (spectrum, detail, top) {\r\n      var args = {\r\n        min: minY(detail),\r\n        max: maxY(detail),\r\n        range: yRange(detail),\r\n        value: top,\r\n        step: step(detail),\r\n        snap: snap(detail),\r\n        snapStart: snapStart(detail),\r\n        rounded: rounded(detail),\r\n        hasMinEdge: hasTEdge(detail),\r\n        hasMaxEdge: hasBEdge(detail),\r\n        minBound: getMinYBounds(spectrum),\r\n        maxBound: getMaxYBounds(spectrum),\r\n        screenRange: getYScreenRange(spectrum)\r\n      };\r\n      return findValueOf(args);\r\n    };\r\n    var setValueFrom$1 = function (spectrum, detail, value) {\r\n      var yValue = findValueOfOffset(spectrum, detail, value);\r\n      var sliderVal = sliderValue$1(yValue);\r\n      fireSliderChange$1(spectrum, sliderVal);\r\n      return yValue;\r\n    };\r\n    var setToMin$1 = function (spectrum, detail) {\r\n      var min = minY(detail);\r\n      fireSliderChange$1(spectrum, sliderValue$1(min));\r\n    };\r\n    var setToMax$1 = function (spectrum, detail) {\r\n      var max = maxY(detail);\r\n      fireSliderChange$1(spectrum, sliderValue$1(max));\r\n    };\r\n    var moveBy$1 = function (direction, spectrum, detail) {\r\n      var f = direction > 0 ? increaseBy : reduceBy;\r\n      var yValue = f(currentValue(detail).y, minY(detail), maxY(detail), step(detail));\r\n      fireSliderChange$1(spectrum, sliderValue$1(yValue));\r\n      return Optional.some(yValue);\r\n    };\r\n    var handleMovement$1 = function (direction) {\r\n      return function (spectrum, detail) {\r\n        return moveBy$1(direction, spectrum, detail).map(always);\r\n      };\r\n    };\r\n    var getValueFromEvent$1 = function (simulatedEvent) {\r\n      var pos = getEventSource(simulatedEvent);\r\n      return pos.map(function (p) {\r\n        return p.top;\r\n      });\r\n    };\r\n    var findOffsetOfValue = function (spectrum, detail, value, minEdge, maxEdge) {\r\n      var minOffset = 0;\r\n      var maxOffset = getYScreenRange(spectrum);\r\n      var centerMinEdge = minEdge.bind(function (edge) {\r\n        return Optional.some(getYCenterOffSetOf(edge, spectrum));\r\n      }).getOr(minOffset);\r\n      var centerMaxEdge = maxEdge.bind(function (edge) {\r\n        return Optional.some(getYCenterOffSetOf(edge, spectrum));\r\n      }).getOr(maxOffset);\r\n      var args = {\r\n        min: minY(detail),\r\n        max: maxY(detail),\r\n        range: yRange(detail),\r\n        value: value,\r\n        hasMinEdge: hasTEdge(detail),\r\n        hasMaxEdge: hasBEdge(detail),\r\n        minBound: getMinYBounds(spectrum),\r\n        minOffset: minOffset,\r\n        maxBound: getMaxYBounds(spectrum),\r\n        maxOffset: maxOffset,\r\n        centerMinEdge: centerMinEdge,\r\n        centerMaxEdge: centerMaxEdge\r\n      };\r\n      return findOffsetOfValue$2(args);\r\n    };\r\n    var findPositionOfValue = function (slider, spectrum, value, minEdge, maxEdge, detail) {\r\n      var offset = findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge);\r\n      return getMinYBounds(spectrum) - getMinYBounds(slider) + offset;\r\n    };\r\n    var setPositionFromValue$1 = function (slider, thumb, detail, edges) {\r\n      var value = currentValue(detail);\r\n      var pos = findPositionOfValue(slider, edges.getSpectrum(slider), value.y, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);\r\n      var thumbRadius = get$b(thumb.element) / 2;\r\n      set$7(thumb.element, 'top', pos - thumbRadius + 'px');\r\n    };\r\n    var onLeft$1 = Optional.none;\r\n    var onRight$1 = Optional.none;\r\n    var onUp$1 = handleMovement$1(-1);\r\n    var onDown$1 = handleMovement$1(1);\r\n    var edgeActions$1 = {\r\n      'top-left': Optional.none(),\r\n      'top': Optional.some(setToTEdge),\r\n      'top-right': Optional.none(),\r\n      'right': Optional.none(),\r\n      'bottom-right': Optional.none(),\r\n      'bottom': Optional.some(setToBEdge),\r\n      'bottom-left': Optional.none(),\r\n      'left': Optional.none()\r\n    };\r\n\r\n    var VerticalModel = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        setValueFrom: setValueFrom$1,\r\n        setToMin: setToMin$1,\r\n        setToMax: setToMax$1,\r\n        findValueOfOffset: findValueOfOffset,\r\n        getValueFromEvent: getValueFromEvent$1,\r\n        findPositionOfValue: findPositionOfValue,\r\n        setPositionFromValue: setPositionFromValue$1,\r\n        onLeft: onLeft$1,\r\n        onRight: onRight$1,\r\n        onUp: onUp$1,\r\n        onDown: onDown$1,\r\n        edgeActions: edgeActions$1\r\n    });\r\n\r\n    var fireSliderChange = function (spectrum, value) {\r\n      emitWith(spectrum, sliderChangeEvent(), { value: value });\r\n    };\r\n    var sliderValue = function (x, y) {\r\n      return {\r\n        x: x,\r\n        y: y\r\n      };\r\n    };\r\n    var setValueFrom = function (spectrum, detail, value) {\r\n      var xValue = findValueOfOffset$1(spectrum, detail, value.left);\r\n      var yValue = findValueOfOffset(spectrum, detail, value.top);\r\n      var val = sliderValue(xValue, yValue);\r\n      fireSliderChange(spectrum, val);\r\n      return val;\r\n    };\r\n    var moveBy = function (direction, isVerticalMovement, spectrum, detail) {\r\n      var f = direction > 0 ? increaseBy : reduceBy;\r\n      var xValue = isVerticalMovement ? currentValue(detail).x : f(currentValue(detail).x, minX(detail), maxX(detail), step(detail));\r\n      var yValue = !isVerticalMovement ? currentValue(detail).y : f(currentValue(detail).y, minY(detail), maxY(detail), step(detail));\r\n      fireSliderChange(spectrum, sliderValue(xValue, yValue));\r\n      return Optional.some(xValue);\r\n    };\r\n    var handleMovement = function (direction, isVerticalMovement) {\r\n      return function (spectrum, detail) {\r\n        return moveBy(direction, isVerticalMovement, spectrum, detail).map(always);\r\n      };\r\n    };\r\n    var setToMin = function (spectrum, detail) {\r\n      var mX = minX(detail);\r\n      var mY = minY(detail);\r\n      fireSliderChange(spectrum, sliderValue(mX, mY));\r\n    };\r\n    var setToMax = function (spectrum, detail) {\r\n      var mX = maxX(detail);\r\n      var mY = maxY(detail);\r\n      fireSliderChange(spectrum, sliderValue(mX, mY));\r\n    };\r\n    var getValueFromEvent = function (simulatedEvent) {\r\n      return getEventSource(simulatedEvent);\r\n    };\r\n    var setPositionFromValue = function (slider, thumb, detail, edges) {\r\n      var value = currentValue(detail);\r\n      var xPos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value.x, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);\r\n      var yPos = findPositionOfValue(slider, edges.getSpectrum(slider), value.y, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);\r\n      var thumbXRadius = get$a(thumb.element) / 2;\r\n      var thumbYRadius = get$b(thumb.element) / 2;\r\n      set$7(thumb.element, 'left', xPos - thumbXRadius + 'px');\r\n      set$7(thumb.element, 'top', yPos - thumbYRadius + 'px');\r\n    };\r\n    var onLeft = handleMovement(-1, false);\r\n    var onRight = handleMovement(1, false);\r\n    var onUp = handleMovement(-1, true);\r\n    var onDown = handleMovement(1, true);\r\n    var edgeActions = {\r\n      'top-left': Optional.some(setToTLEdgeXY),\r\n      'top': Optional.some(setToTEdgeXY),\r\n      'top-right': Optional.some(setToTREdgeXY),\r\n      'right': Optional.some(setToREdgeXY),\r\n      'bottom-right': Optional.some(setToBREdgeXY),\r\n      'bottom': Optional.some(setToBEdgeXY),\r\n      'bottom-left': Optional.some(setToBLEdgeXY),\r\n      'left': Optional.some(setToLEdgeXY)\r\n    };\r\n\r\n    var TwoDModel = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        setValueFrom: setValueFrom,\r\n        setToMin: setToMin,\r\n        setToMax: setToMax,\r\n        getValueFromEvent: getValueFromEvent,\r\n        setPositionFromValue: setPositionFromValue,\r\n        onLeft: onLeft,\r\n        onRight: onRight,\r\n        onUp: onUp,\r\n        onDown: onDown,\r\n        edgeActions: edgeActions\r\n    });\r\n\r\n    var SliderSchema = [\r\n      defaulted('stepSize', 1),\r\n      defaulted('onChange', noop),\r\n      defaulted('onChoose', noop),\r\n      defaulted('onInit', noop),\r\n      defaulted('onDragStart', noop),\r\n      defaulted('onDragEnd', noop),\r\n      defaulted('snapToGrid', false),\r\n      defaulted('rounded', true),\r\n      option('snapStart'),\r\n      requiredOf('model', choose$1('mode', {\r\n        x: [\r\n          defaulted('minX', 0),\r\n          defaulted('maxX', 100),\r\n          customField('value', function (spec) {\r\n            return Cell(spec.mode.minX);\r\n          }),\r\n          required$1('getInitialValue'),\r\n          output$1('manager', HorizontalModel)\r\n        ],\r\n        y: [\r\n          defaulted('minY', 0),\r\n          defaulted('maxY', 100),\r\n          customField('value', function (spec) {\r\n            return Cell(spec.mode.minY);\r\n          }),\r\n          required$1('getInitialValue'),\r\n          output$1('manager', VerticalModel)\r\n        ],\r\n        xy: [\r\n          defaulted('minX', 0),\r\n          defaulted('maxX', 100),\r\n          defaulted('minY', 0),\r\n          defaulted('maxY', 100),\r\n          customField('value', function (spec) {\r\n            return Cell({\r\n              x: spec.mode.minX,\r\n              y: spec.mode.minY\r\n            });\r\n          }),\r\n          required$1('getInitialValue'),\r\n          output$1('manager', TwoDModel)\r\n        ]\r\n      })),\r\n      field('sliderBehaviours', [\r\n        Keying,\r\n        Representing\r\n      ]),\r\n      customField('mouseIsDown', function () {\r\n        return Cell(false);\r\n      })\r\n    ];\r\n\r\n    var sketch$2 = function (detail, components, _spec, _externals) {\r\n      var _a;\r\n      var getThumb = function (component) {\r\n        return getPartOrDie(component, detail, 'thumb');\r\n      };\r\n      var getSpectrum = function (component) {\r\n        return getPartOrDie(component, detail, 'spectrum');\r\n      };\r\n      var getLeftEdge = function (component) {\r\n        return getPart(component, detail, 'left-edge');\r\n      };\r\n      var getRightEdge = function (component) {\r\n        return getPart(component, detail, 'right-edge');\r\n      };\r\n      var getTopEdge = function (component) {\r\n        return getPart(component, detail, 'top-edge');\r\n      };\r\n      var getBottomEdge = function (component) {\r\n        return getPart(component, detail, 'bottom-edge');\r\n      };\r\n      var modelDetail = detail.model;\r\n      var model = modelDetail.manager;\r\n      var refresh = function (slider, thumb) {\r\n        model.setPositionFromValue(slider, thumb, detail, {\r\n          getLeftEdge: getLeftEdge,\r\n          getRightEdge: getRightEdge,\r\n          getTopEdge: getTopEdge,\r\n          getBottomEdge: getBottomEdge,\r\n          getSpectrum: getSpectrum\r\n        });\r\n      };\r\n      var setValue = function (slider, newValue) {\r\n        modelDetail.value.set(newValue);\r\n        var thumb = getThumb(slider);\r\n        refresh(slider, thumb);\r\n      };\r\n      var changeValue = function (slider, newValue) {\r\n        setValue(slider, newValue);\r\n        var thumb = getThumb(slider);\r\n        detail.onChange(slider, thumb, newValue);\r\n        return Optional.some(true);\r\n      };\r\n      var resetToMin = function (slider) {\r\n        model.setToMin(slider, detail);\r\n      };\r\n      var resetToMax = function (slider) {\r\n        model.setToMax(slider, detail);\r\n      };\r\n      var choose = function (slider) {\r\n        var fireOnChoose = function () {\r\n          getPart(slider, detail, 'thumb').each(function (thumb) {\r\n            var value = modelDetail.value.get();\r\n            detail.onChoose(slider, thumb, value);\r\n          });\r\n        };\r\n        var wasDown = detail.mouseIsDown.get();\r\n        detail.mouseIsDown.set(false);\r\n        if (wasDown) {\r\n          fireOnChoose();\r\n        }\r\n      };\r\n      var onDragStart = function (slider, simulatedEvent) {\r\n        simulatedEvent.stop();\r\n        detail.mouseIsDown.set(true);\r\n        detail.onDragStart(slider, getThumb(slider));\r\n      };\r\n      var onDragEnd = function (slider, simulatedEvent) {\r\n        simulatedEvent.stop();\r\n        detail.onDragEnd(slider, getThumb(slider));\r\n        choose(slider);\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        behaviours: augment(detail.sliderBehaviours, [\r\n          Keying.config({\r\n            mode: 'special',\r\n            focusIn: function (slider) {\r\n              return getPart(slider, detail, 'spectrum').map(Keying.focusIn).map(always);\r\n            }\r\n          }),\r\n          Representing.config({\r\n            store: {\r\n              mode: 'manual',\r\n              getValue: function (_) {\r\n                return modelDetail.value.get();\r\n              }\r\n            }\r\n          }),\r\n          Receiving.config({ channels: (_a = {}, _a[mouseReleased()] = { onReceive: choose }, _a) })\r\n        ]),\r\n        events: derive$2([\r\n          run$1(sliderChangeEvent(), function (slider, simulatedEvent) {\r\n            changeValue(slider, simulatedEvent.event.value);\r\n          }),\r\n          runOnAttached(function (slider, _simulatedEvent) {\r\n            var getInitial = modelDetail.getInitialValue();\r\n            modelDetail.value.set(getInitial);\r\n            var thumb = getThumb(slider);\r\n            refresh(slider, thumb);\r\n            var spectrum = getSpectrum(slider);\r\n            detail.onInit(slider, thumb, spectrum, modelDetail.value.get());\r\n          }),\r\n          run$1(touchstart(), onDragStart),\r\n          run$1(touchend(), onDragEnd),\r\n          run$1(mousedown(), onDragStart),\r\n          run$1(mouseup(), onDragEnd)\r\n        ]),\r\n        apis: {\r\n          resetToMin: resetToMin,\r\n          resetToMax: resetToMax,\r\n          setValue: setValue,\r\n          refresh: refresh\r\n        },\r\n        domModification: { styles: { position: 'relative' } }\r\n      };\r\n    };\r\n\r\n    var Slider = composite({\r\n      name: 'Slider',\r\n      configFields: SliderSchema,\r\n      partFields: SliderParts,\r\n      factory: sketch$2,\r\n      apis: {\r\n        setValue: function (apis, slider, value) {\r\n          apis.setValue(slider, value);\r\n        },\r\n        resetToMin: function (apis, slider) {\r\n          apis.resetToMin(slider);\r\n        },\r\n        resetToMax: function (apis, slider) {\r\n          apis.resetToMax(slider);\r\n        },\r\n        refresh: function (apis, slider) {\r\n          apis.refresh(slider);\r\n        }\r\n      }\r\n    });\r\n\r\n    var fieldsUpdate = generate$6('rgb-hex-update');\r\n    var sliderUpdate = generate$6('slider-update');\r\n    var paletteUpdate = generate$6('palette-update');\r\n\r\n    var sliderFactory = function (translate, getClass) {\r\n      var spectrum = Slider.parts.spectrum({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [getClass('hue-slider-spectrum')],\r\n          attributes: { role: 'presentation' }\r\n        }\r\n      });\r\n      var thumb = Slider.parts.thumb({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [getClass('hue-slider-thumb')],\r\n          attributes: { role: 'presentation' }\r\n        }\r\n      });\r\n      return Slider.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [getClass('hue-slider')],\r\n          attributes: { role: 'presentation' }\r\n        },\r\n        rounded: false,\r\n        model: {\r\n          mode: 'y',\r\n          getInitialValue: constant$1({ y: 0 })\r\n        },\r\n        components: [\r\n          spectrum,\r\n          thumb\r\n        ],\r\n        sliderBehaviours: derive$1([Focusing.config({})]),\r\n        onChange: function (slider, _thumb, value) {\r\n          emitWith(slider, sliderUpdate, { value: value });\r\n        }\r\n      });\r\n    };\r\n\r\n    var owner$1 = 'form';\r\n    var schema$i = [field('formBehaviours', [Representing])];\r\n    var getPartName$1 = function (name) {\r\n      return '<alloy.field.' + name + '>';\r\n    };\r\n    var sketch$1 = function (fSpec) {\r\n      var parts = function () {\r\n        var record = [];\r\n        var field = function (name, config) {\r\n          record.push(name);\r\n          return generateOne$1(owner$1, getPartName$1(name), config);\r\n        };\r\n        return {\r\n          field: field,\r\n          record: constant$1(record)\r\n        };\r\n      }();\r\n      var spec = fSpec(parts);\r\n      var partNames = parts.record();\r\n      var fieldParts = map$2(partNames, function (n) {\r\n        return required({\r\n          name: n,\r\n          pname: getPartName$1(n)\r\n        });\r\n      });\r\n      return composite$1(owner$1, schema$i, fieldParts, make$4, spec);\r\n    };\r\n    var toResult = function (o, e) {\r\n      return o.fold(function () {\r\n        return Result.error(e);\r\n      }, Result.value);\r\n    };\r\n    var make$4 = function (detail, components) {\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        behaviours: augment(detail.formBehaviours, [Representing.config({\r\n            store: {\r\n              mode: 'manual',\r\n              getValue: function (form) {\r\n                var resPs = getAllParts(form, detail);\r\n                return map$1(resPs, function (resPThunk, pName) {\r\n                  return resPThunk().bind(function (v) {\r\n                    var opt = Composing.getCurrent(v);\r\n                    return toResult(opt, new Error('Cannot find a current component to extract the value from for form part \\'' + pName + '\\': ' + element(v.element)));\r\n                  }).map(Representing.getValue);\r\n                });\r\n              },\r\n              setValue: function (form, values) {\r\n                each(values, function (newValue, key) {\r\n                  getPart(form, detail, key).each(function (wrapper) {\r\n                    Composing.getCurrent(wrapper).each(function (field) {\r\n                      Representing.setValue(field, newValue);\r\n                    });\r\n                  });\r\n                });\r\n              }\r\n            }\r\n          })]),\r\n        apis: {\r\n          getField: function (form, key) {\r\n            return getPart(form, detail, key).bind(Composing.getCurrent);\r\n          }\r\n        }\r\n      };\r\n    };\r\n    var Form = {\r\n      getField: makeApi(function (apis, component, key) {\r\n        return apis.getField(component, key);\r\n      }),\r\n      sketch: sketch$1\r\n    };\r\n\r\n    var validInput = generate$6('valid-input');\r\n    var invalidInput = generate$6('invalid-input');\r\n    var validatingInput = generate$6('validating-input');\r\n    var translatePrefix = 'colorcustom.rgb.';\r\n    var rgbFormFactory = function (translate, getClass, onValidHexx, onInvalidHexx) {\r\n      var invalidation = function (label, isValid) {\r\n        return Invalidating.config({\r\n          invalidClass: getClass('invalid'),\r\n          notify: {\r\n            onValidate: function (comp) {\r\n              emitWith(comp, validatingInput, { type: label });\r\n            },\r\n            onValid: function (comp) {\r\n              emitWith(comp, validInput, {\r\n                type: label,\r\n                value: Representing.getValue(comp)\r\n              });\r\n            },\r\n            onInvalid: function (comp) {\r\n              emitWith(comp, invalidInput, {\r\n                type: label,\r\n                value: Representing.getValue(comp)\r\n              });\r\n            }\r\n          },\r\n          validator: {\r\n            validate: function (comp) {\r\n              var value = Representing.getValue(comp);\r\n              var res = isValid(value) ? Result.value(true) : Result.error(translate('aria.input.invalid'));\r\n              return Future.pure(res);\r\n            },\r\n            validateOnLoad: false\r\n          }\r\n        });\r\n      };\r\n      var renderTextField = function (isValid, name, label, description, data) {\r\n        var helptext = translate(translatePrefix + 'range');\r\n        var pLabel = FormField.parts.label({\r\n          dom: {\r\n            tag: 'label',\r\n            innerHtml: label,\r\n            attributes: { 'aria-label': description }\r\n          }\r\n        });\r\n        var pField = FormField.parts.field({\r\n          data: data,\r\n          factory: Input,\r\n          inputAttributes: __assign({ type: 'text' }, name === 'hex' ? { 'aria-live': 'polite' } : {}),\r\n          inputClasses: [getClass('textfield')],\r\n          inputBehaviours: derive$1([\r\n            invalidation(name, isValid),\r\n            Tabstopping.config({})\r\n          ]),\r\n          onSetValue: function (input) {\r\n            if (Invalidating.isInvalid(input)) {\r\n              var run = Invalidating.run(input);\r\n              run.get(noop);\r\n            }\r\n          }\r\n        });\r\n        var comps = [\r\n          pLabel,\r\n          pField\r\n        ];\r\n        var concats = name !== 'hex' ? [FormField.parts['aria-descriptor']({ text: helptext })] : [];\r\n        var components = comps.concat(concats);\r\n        return {\r\n          dom: {\r\n            tag: 'div',\r\n            attributes: { role: 'presentation' }\r\n          },\r\n          components: components\r\n        };\r\n      };\r\n      var copyRgbToHex = function (form, rgba) {\r\n        var hex = fromRgba(rgba);\r\n        Form.getField(form, 'hex').each(function (hexField) {\r\n          if (!Focusing.isFocused(hexField)) {\r\n            Representing.setValue(form, { hex: hex.value });\r\n          }\r\n        });\r\n        return hex;\r\n      };\r\n      var copyRgbToForm = function (form, rgb) {\r\n        var red = rgb.red;\r\n        var green = rgb.green;\r\n        var blue = rgb.blue;\r\n        Representing.setValue(form, {\r\n          red: red,\r\n          green: green,\r\n          blue: blue\r\n        });\r\n      };\r\n      var memPreview = record({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [getClass('rgba-preview')],\r\n          styles: { 'background-color': 'white' },\r\n          attributes: { role: 'presentation' }\r\n        }\r\n      });\r\n      var updatePreview = function (anyInSystem, hex) {\r\n        memPreview.getOpt(anyInSystem).each(function (preview) {\r\n          set$7(preview.element, 'background-color', '#' + hex.value);\r\n        });\r\n      };\r\n      var factory = function () {\r\n        var state = {\r\n          red: Cell(Optional.some(255)),\r\n          green: Cell(Optional.some(255)),\r\n          blue: Cell(Optional.some(255)),\r\n          hex: Cell(Optional.some('ffffff'))\r\n        };\r\n        var copyHexToRgb = function (form, hex) {\r\n          var rgb = fromHex(hex);\r\n          copyRgbToForm(form, rgb);\r\n          setValueRgb(rgb);\r\n        };\r\n        var get = function (prop) {\r\n          return state[prop].get();\r\n        };\r\n        var set = function (prop, value) {\r\n          state[prop].set(value);\r\n        };\r\n        var getValueRgb = function () {\r\n          return get('red').bind(function (red) {\r\n            return get('green').bind(function (green) {\r\n              return get('blue').map(function (blue) {\r\n                return rgbaColour(red, green, blue, 1);\r\n              });\r\n            });\r\n          });\r\n        };\r\n        var setValueRgb = function (rgb) {\r\n          var red = rgb.red;\r\n          var green = rgb.green;\r\n          var blue = rgb.blue;\r\n          set('red', Optional.some(red));\r\n          set('green', Optional.some(green));\r\n          set('blue', Optional.some(blue));\r\n        };\r\n        var onInvalidInput = function (form, simulatedEvent) {\r\n          var data = simulatedEvent.event;\r\n          if (data.type !== 'hex') {\r\n            set(data.type, Optional.none());\r\n          } else {\r\n            onInvalidHexx(form);\r\n          }\r\n        };\r\n        var onValidHex = function (form, value) {\r\n          onValidHexx(form);\r\n          var hex = hexColour(value);\r\n          set('hex', Optional.some(value));\r\n          var rgb = fromHex(hex);\r\n          copyRgbToForm(form, rgb);\r\n          setValueRgb(rgb);\r\n          emitWith(form, fieldsUpdate, { hex: hex });\r\n          updatePreview(form, hex);\r\n        };\r\n        var onValidRgb = function (form, prop, value) {\r\n          var val = parseInt(value, 10);\r\n          set(prop, Optional.some(val));\r\n          getValueRgb().each(function (rgb) {\r\n            var hex = copyRgbToHex(form, rgb);\r\n            emitWith(form, fieldsUpdate, { hex: hex });\r\n            updatePreview(form, hex);\r\n          });\r\n        };\r\n        var isHexInputEvent = function (data) {\r\n          return data.type === 'hex';\r\n        };\r\n        var onValidInput = function (form, simulatedEvent) {\r\n          var data = simulatedEvent.event;\r\n          if (isHexInputEvent(data)) {\r\n            onValidHex(form, data.value);\r\n          } else {\r\n            onValidRgb(form, data.type, data.value);\r\n          }\r\n        };\r\n        var formPartStrings = function (key) {\r\n          return {\r\n            label: translate(translatePrefix + key + '.label'),\r\n            description: translate(translatePrefix + key + '.description')\r\n          };\r\n        };\r\n        var redStrings = formPartStrings('red');\r\n        var greenStrings = formPartStrings('green');\r\n        var blueStrings = formPartStrings('blue');\r\n        var hexStrings = formPartStrings('hex');\r\n        return deepMerge(Form.sketch(function (parts) {\r\n          return {\r\n            dom: {\r\n              tag: 'form',\r\n              classes: [getClass('rgb-form')],\r\n              attributes: { 'aria-label': translate('aria.color.picker') }\r\n            },\r\n            components: [\r\n              parts.field('red', FormField.sketch(renderTextField(isRgbaComponent, 'red', redStrings.label, redStrings.description, 255))),\r\n              parts.field('green', FormField.sketch(renderTextField(isRgbaComponent, 'green', greenStrings.label, greenStrings.description, 255))),\r\n              parts.field('blue', FormField.sketch(renderTextField(isRgbaComponent, 'blue', blueStrings.label, blueStrings.description, 255))),\r\n              parts.field('hex', FormField.sketch(renderTextField(isHexString, 'hex', hexStrings.label, hexStrings.description, 'ffffff'))),\r\n              memPreview.asSpec()\r\n            ],\r\n            formBehaviours: derive$1([\r\n              Invalidating.config({ invalidClass: getClass('form-invalid') }),\r\n              config('rgb-form-events', [\r\n                run$1(validInput, onValidInput),\r\n                run$1(invalidInput, onInvalidInput),\r\n                run$1(validatingInput, onInvalidInput)\r\n              ])\r\n            ])\r\n          };\r\n        }), {\r\n          apis: {\r\n            updateHex: function (form, hex) {\r\n              Representing.setValue(form, { hex: hex.value });\r\n              copyHexToRgb(form, hex);\r\n              updatePreview(form, hex);\r\n            }\r\n          }\r\n        });\r\n      };\r\n      var rgbFormSketcher = single({\r\n        factory: factory,\r\n        name: 'RgbForm',\r\n        configFields: [],\r\n        apis: {\r\n          updateHex: function (apis, form, hex) {\r\n            apis.updateHex(form, hex);\r\n          }\r\n        },\r\n        extraApis: {}\r\n      });\r\n      return rgbFormSketcher;\r\n    };\r\n\r\n    var paletteFactory = function (_translate, getClass) {\r\n      var spectrumPart = Slider.parts.spectrum({\r\n        dom: {\r\n          tag: 'canvas',\r\n          attributes: { role: 'presentation' },\r\n          classes: [getClass('sv-palette-spectrum')]\r\n        }\r\n      });\r\n      var thumbPart = Slider.parts.thumb({\r\n        dom: {\r\n          tag: 'div',\r\n          attributes: { role: 'presentation' },\r\n          classes: [getClass('sv-palette-thumb')],\r\n          innerHtml: '<div class=' + getClass('sv-palette-inner-thumb') + ' role=\"presentation\"></div>'\r\n        }\r\n      });\r\n      var setColour = function (canvas, rgba) {\r\n        var width = canvas.width, height = canvas.height;\r\n        var ctx = canvas.getContext('2d');\r\n        if (ctx === null) {\r\n          return;\r\n        }\r\n        ctx.fillStyle = rgba;\r\n        ctx.fillRect(0, 0, width, height);\r\n        var grdWhite = ctx.createLinearGradient(0, 0, width, 0);\r\n        grdWhite.addColorStop(0, 'rgba(255,255,255,1)');\r\n        grdWhite.addColorStop(1, 'rgba(255,255,255,0)');\r\n        ctx.fillStyle = grdWhite;\r\n        ctx.fillRect(0, 0, width, height);\r\n        var grdBlack = ctx.createLinearGradient(0, 0, 0, height);\r\n        grdBlack.addColorStop(0, 'rgba(0,0,0,0)');\r\n        grdBlack.addColorStop(1, 'rgba(0,0,0,1)');\r\n        ctx.fillStyle = grdBlack;\r\n        ctx.fillRect(0, 0, width, height);\r\n      };\r\n      var setPaletteHue = function (slider, hue) {\r\n        var canvas = slider.components()[0].element.dom;\r\n        var hsv = hsvColour(hue, 100, 100);\r\n        var rgba = fromHsv(hsv);\r\n        setColour(canvas, toString(rgba));\r\n      };\r\n      var setPaletteThumb = function (slider, hex) {\r\n        var hsv = fromRgb(fromHex(hex));\r\n        Slider.setValue(slider, {\r\n          x: hsv.saturation,\r\n          y: 100 - hsv.value\r\n        });\r\n      };\r\n      var factory = function (_detail) {\r\n        var getInitialValue = constant$1({\r\n          x: 0,\r\n          y: 0\r\n        });\r\n        var onChange = function (slider, _thumb, value) {\r\n          emitWith(slider, paletteUpdate, { value: value });\r\n        };\r\n        var onInit = function (_slider, _thumb, spectrum, _value) {\r\n          setColour(spectrum.element.dom, toString(red));\r\n        };\r\n        var sliderBehaviours = derive$1([\r\n          Composing.config({ find: Optional.some }),\r\n          Focusing.config({})\r\n        ]);\r\n        return Slider.sketch({\r\n          dom: {\r\n            tag: 'div',\r\n            attributes: { role: 'presentation' },\r\n            classes: [getClass('sv-palette')]\r\n          },\r\n          model: {\r\n            mode: 'xy',\r\n            getInitialValue: getInitialValue\r\n          },\r\n          rounded: false,\r\n          components: [\r\n            spectrumPart,\r\n            thumbPart\r\n          ],\r\n          onChange: onChange,\r\n          onInit: onInit,\r\n          sliderBehaviours: sliderBehaviours\r\n        });\r\n      };\r\n      var saturationBrightnessPaletteSketcher = single({\r\n        factory: factory,\r\n        name: 'SaturationBrightnessPalette',\r\n        configFields: [],\r\n        apis: {\r\n          setHue: function (_apis, slider, hue) {\r\n            setPaletteHue(slider, hue);\r\n          },\r\n          setThumb: function (_apis, slider, hex) {\r\n            setPaletteThumb(slider, hex);\r\n          }\r\n        },\r\n        extraApis: {}\r\n      });\r\n      return saturationBrightnessPaletteSketcher;\r\n    };\r\n\r\n    var makeFactory = function (translate, getClass) {\r\n      var factory = function (detail) {\r\n        var rgbForm = rgbFormFactory(translate, getClass, detail.onValidHex, detail.onInvalidHex);\r\n        var sbPalette = paletteFactory(translate, getClass);\r\n        var hueSliderToDegrees = function (hue) {\r\n          return (100 - hue) / 100 * 360;\r\n        };\r\n        var hueDegreesToSlider = function (hue) {\r\n          return 100 - hue / 360 * 100;\r\n        };\r\n        var state = {\r\n          paletteRgba: Cell(red),\r\n          paletteHue: Cell(0)\r\n        };\r\n        var memSlider = record(sliderFactory(translate, getClass));\r\n        var memPalette = record(sbPalette.sketch({}));\r\n        var memRgb = record(rgbForm.sketch({}));\r\n        var updatePalette = function (anyInSystem, _hex, hue) {\r\n          memPalette.getOpt(anyInSystem).each(function (palette) {\r\n            sbPalette.setHue(palette, hue);\r\n          });\r\n        };\r\n        var updateFields = function (anyInSystem, hex) {\r\n          memRgb.getOpt(anyInSystem).each(function (form) {\r\n            rgbForm.updateHex(form, hex);\r\n          });\r\n        };\r\n        var updateSlider = function (anyInSystem, _hex, hue) {\r\n          memSlider.getOpt(anyInSystem).each(function (slider) {\r\n            Slider.setValue(slider, { y: hueDegreesToSlider(hue) });\r\n          });\r\n        };\r\n        var updatePaletteThumb = function (anyInSystem, hex) {\r\n          memPalette.getOpt(anyInSystem).each(function (palette) {\r\n            sbPalette.setThumb(palette, hex);\r\n          });\r\n        };\r\n        var updateState = function (hex, hue) {\r\n          var rgba = fromHex(hex);\r\n          state.paletteRgba.set(rgba);\r\n          state.paletteHue.set(hue);\r\n        };\r\n        var runUpdates = function (anyInSystem, hex, hue, updates) {\r\n          updateState(hex, hue);\r\n          each$1(updates, function (update) {\r\n            update(anyInSystem, hex, hue);\r\n          });\r\n        };\r\n        var onPaletteUpdate = function () {\r\n          var updates = [updateFields];\r\n          return function (form, simulatedEvent) {\r\n            var value = simulatedEvent.event.value;\r\n            var oldHue = state.paletteHue.get();\r\n            var newHsv = hsvColour(oldHue, value.x, 100 - value.y);\r\n            var newHex = hsvToHex(newHsv);\r\n            runUpdates(form, newHex, oldHue, updates);\r\n          };\r\n        };\r\n        var onSliderUpdate = function () {\r\n          var updates = [\r\n            updatePalette,\r\n            updateFields\r\n          ];\r\n          return function (form, simulatedEvent) {\r\n            var hue = hueSliderToDegrees(simulatedEvent.event.value.y);\r\n            var oldRgb = state.paletteRgba.get();\r\n            var oldHsv = fromRgb(oldRgb);\r\n            var newHsv = hsvColour(hue, oldHsv.saturation, oldHsv.value);\r\n            var newHex = hsvToHex(newHsv);\r\n            runUpdates(form, newHex, hue, updates);\r\n          };\r\n        };\r\n        var onFieldsUpdate = function () {\r\n          var updates = [\r\n            updatePalette,\r\n            updateSlider,\r\n            updatePaletteThumb\r\n          ];\r\n          return function (form, simulatedEvent) {\r\n            var hex = simulatedEvent.event.hex;\r\n            var hsv = hexToHsv(hex);\r\n            runUpdates(form, hex, hsv.hue, updates);\r\n          };\r\n        };\r\n        return {\r\n          uid: detail.uid,\r\n          dom: detail.dom,\r\n          components: [\r\n            memPalette.asSpec(),\r\n            memSlider.asSpec(),\r\n            memRgb.asSpec()\r\n          ],\r\n          behaviours: derive$1([\r\n            config('colour-picker-events', [\r\n              run$1(fieldsUpdate, onFieldsUpdate()),\r\n              run$1(paletteUpdate, onPaletteUpdate()),\r\n              run$1(sliderUpdate, onSliderUpdate())\r\n            ]),\r\n            Composing.config({\r\n              find: function (comp) {\r\n                return memRgb.getOpt(comp);\r\n              }\r\n            }),\r\n            Keying.config({ mode: 'acyclic' })\r\n          ])\r\n        };\r\n      };\r\n      var colourPickerSketcher = single({\r\n        name: 'ColourPicker',\r\n        configFields: [\r\n          required$1('dom'),\r\n          defaulted('onValidHex', noop),\r\n          defaulted('onInvalidHex', noop)\r\n        ],\r\n        factory: factory\r\n      });\r\n      return colourPickerSketcher;\r\n    };\r\n\r\n    var self$1 = function () {\r\n      return Composing.config({ find: Optional.some });\r\n    };\r\n    var memento$1 = function (mem) {\r\n      return Composing.config({ find: mem.getOpt });\r\n    };\r\n    var childAt = function (index) {\r\n      return Composing.config({\r\n        find: function (comp) {\r\n          return child$2(comp.element, index).bind(function (element) {\r\n            return comp.getSystem().getByDom(element).toOptional();\r\n          });\r\n        }\r\n      });\r\n    };\r\n    var ComposingConfigs = {\r\n      self: self$1,\r\n      memento: memento$1,\r\n      childAt: childAt\r\n    };\r\n\r\n    var english = {\r\n      'colorcustom.rgb.red.label': 'R',\r\n      'colorcustom.rgb.red.description': 'Red component',\r\n      'colorcustom.rgb.green.label': 'G',\r\n      'colorcustom.rgb.green.description': 'Green component',\r\n      'colorcustom.rgb.blue.label': 'B',\r\n      'colorcustom.rgb.blue.description': 'Blue component',\r\n      'colorcustom.rgb.hex.label': '#',\r\n      'colorcustom.rgb.hex.description': 'Hex color code',\r\n      'colorcustom.rgb.range': 'Range 0 to 255',\r\n      'colorcustom.sb.saturation': 'Saturation',\r\n      'colorcustom.sb.brightness': 'Brightness',\r\n      'colorcustom.sb.picker': 'Saturation and Brightness Picker',\r\n      'colorcustom.sb.palette': 'Saturation and Brightness Palette',\r\n      'colorcustom.sb.instructions': 'Use arrow keys to select saturation and brightness, on x and y axes',\r\n      'colorcustom.hue.hue': 'Hue',\r\n      'colorcustom.hue.slider': 'Hue Slider',\r\n      'colorcustom.hue.palette': 'Hue Palette',\r\n      'colorcustom.hue.instructions': 'Use arrow keys to select a hue',\r\n      'aria.color.picker': 'Color Picker',\r\n      'aria.input.invalid': 'Invalid input'\r\n    };\r\n    var getEnglishText = function (key) {\r\n      return english[key];\r\n    };\r\n    var translate$1 = function (key) {\r\n      return getEnglishText(key);\r\n    };\r\n    var renderColorPicker = function (_spec) {\r\n      var getClass = function (key) {\r\n        return 'tox-' + key;\r\n      };\r\n      var colourPickerFactory = makeFactory(translate$1, getClass);\r\n      var onValidHex = function (form) {\r\n        emitWith(form, formActionEvent, {\r\n          name: 'hex-valid',\r\n          value: true\r\n        });\r\n      };\r\n      var onInvalidHex = function (form) {\r\n        emitWith(form, formActionEvent, {\r\n          name: 'hex-valid',\r\n          value: false\r\n        });\r\n      };\r\n      var memPicker = record(colourPickerFactory.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [getClass('color-picker-container')],\r\n          attributes: { role: 'presentation' }\r\n        },\r\n        onValidHex: onValidHex,\r\n        onInvalidHex: onInvalidHex\r\n      }));\r\n      return {\r\n        dom: { tag: 'div' },\r\n        components: [memPicker.asSpec()],\r\n        behaviours: derive$1([\r\n          Representing.config({\r\n            store: {\r\n              mode: 'manual',\r\n              getValue: function (comp) {\r\n                var picker = memPicker.get(comp);\r\n                var optRgbForm = Composing.getCurrent(picker);\r\n                var optHex = optRgbForm.bind(function (rgbForm) {\r\n                  var formValues = Representing.getValue(rgbForm);\r\n                  return formValues.hex;\r\n                });\r\n                return optHex.map(function (hex) {\r\n                  return '#' + hex;\r\n                }).getOr('');\r\n              },\r\n              setValue: function (comp, newValue) {\r\n                var pattern = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/;\r\n                var m = pattern.exec(newValue);\r\n                var picker = memPicker.get(comp);\r\n                var optRgbForm = Composing.getCurrent(picker);\r\n                optRgbForm.fold(function () {\r\n                  console.log('Can not find form');\r\n                }, function (rgbForm) {\r\n                  Representing.setValue(rgbForm, { hex: Optional.from(m[1]).getOr('') });\r\n                  Form.getField(rgbForm, 'hex').each(function (hexField) {\r\n                    emit(hexField, input());\r\n                  });\r\n                });\r\n              }\r\n            }\r\n          }),\r\n          ComposingConfigs.self()\r\n        ])\r\n      };\r\n    };\r\n\r\n    var global$6 = tinymce.util.Tools.resolve('tinymce.Resource');\r\n\r\n    var isOldCustomEditor = function (spec) {\r\n      return has$2(spec, 'init');\r\n    };\r\n    var renderCustomEditor = function (spec) {\r\n      var editorApi = value$1();\r\n      var memReplaced = record({ dom: { tag: spec.tag } });\r\n      var initialValue = value$1();\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-custom-editor']\r\n        },\r\n        behaviours: derive$1([\r\n          config('custom-editor-events', [runOnAttached(function (component) {\r\n              memReplaced.getOpt(component).each(function (ta) {\r\n                (isOldCustomEditor(spec) ? spec.init(ta.element.dom) : global$6.load(spec.scriptId, spec.scriptUrl).then(function (init) {\r\n                  return init(ta.element.dom, spec.settings);\r\n                })).then(function (ea) {\r\n                  initialValue.on(function (cvalue) {\r\n                    ea.setValue(cvalue);\r\n                  });\r\n                  initialValue.clear();\r\n                  editorApi.set(ea);\r\n                });\r\n              });\r\n            })]),\r\n          Representing.config({\r\n            store: {\r\n              mode: 'manual',\r\n              getValue: function () {\r\n                return editorApi.get().fold(function () {\r\n                  return initialValue.get().getOr('');\r\n                }, function (ed) {\r\n                  return ed.getValue();\r\n                });\r\n              },\r\n              setValue: function (component, value) {\r\n                editorApi.get().fold(function () {\r\n                  initialValue.set(value);\r\n                }, function (ed) {\r\n                  return ed.setValue(value);\r\n                });\r\n              }\r\n            }\r\n          }),\r\n          ComposingConfigs.self()\r\n        ]),\r\n        components: [memReplaced.asSpec()]\r\n      };\r\n    };\r\n\r\n    var global$5 = tinymce.util.Tools.resolve('tinymce.util.Tools');\r\n\r\n    var processors = objOf([\r\n      defaulted('preprocess', identity$1),\r\n      defaulted('postprocess', identity$1)\r\n    ]);\r\n    var memento = function (mem, rawProcessors) {\r\n      var ps = asRawOrDie$1('RepresentingConfigs.memento processors', processors, rawProcessors);\r\n      return Representing.config({\r\n        store: {\r\n          mode: 'manual',\r\n          getValue: function (comp) {\r\n            var other = mem.get(comp);\r\n            var rawValue = Representing.getValue(other);\r\n            return ps.postprocess(rawValue);\r\n          },\r\n          setValue: function (comp, rawValue) {\r\n            var newValue = ps.preprocess(rawValue);\r\n            var other = mem.get(comp);\r\n            Representing.setValue(other, newValue);\r\n          }\r\n        }\r\n      });\r\n    };\r\n    var withComp = function (optInitialValue, getter, setter) {\r\n      return Representing.config(deepMerge({\r\n        store: {\r\n          mode: 'manual',\r\n          getValue: getter,\r\n          setValue: setter\r\n        }\r\n      }, optInitialValue.map(function (initialValue) {\r\n        return { store: { initialValue: initialValue } };\r\n      }).getOr({})));\r\n    };\r\n    var withElement = function (initialValue, getter, setter) {\r\n      return withComp(initialValue, function (c) {\r\n        return getter(c.element);\r\n      }, function (c, v) {\r\n        return setter(c.element, v);\r\n      });\r\n    };\r\n    var domValue = function (optInitialValue) {\r\n      return withElement(optInitialValue, get$5, set$4);\r\n    };\r\n    var domHtml = function (optInitialValue) {\r\n      return withElement(optInitialValue, get$7, set$5);\r\n    };\r\n    var memory = function (initialValue) {\r\n      return Representing.config({\r\n        store: {\r\n          mode: 'memory',\r\n          initialValue: initialValue\r\n        }\r\n      });\r\n    };\r\n    var RepresentingConfigs = {\r\n      memento: memento,\r\n      withElement: withElement,\r\n      withComp: withComp,\r\n      domValue: domValue,\r\n      domHtml: domHtml,\r\n      memory: memory\r\n    };\r\n\r\n    var defaultImageFileTypes = 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp';\r\n    var filterByExtension = function (files, providersBackstage) {\r\n      var allowedImageFileTypes = global$5.explode(providersBackstage.getSetting('images_file_types', defaultImageFileTypes, 'string'));\r\n      var isFileInAllowedTypes = function (file) {\r\n        return exists(allowedImageFileTypes, function (type) {\r\n          return endsWith(file.name.toLowerCase(), '.' + type.toLowerCase());\r\n        });\r\n      };\r\n      return filter$2(from(files), isFileInAllowedTypes);\r\n    };\r\n    var renderDropZone = function (spec, providersBackstage) {\r\n      var stopper = function (_, se) {\r\n        se.stop();\r\n      };\r\n      var sequence = function (actions) {\r\n        return function (comp, se) {\r\n          each$1(actions, function (a) {\r\n            a(comp, se);\r\n          });\r\n        };\r\n      };\r\n      var onDrop = function (comp, se) {\r\n        if (!Disabling.isDisabled(comp)) {\r\n          var transferEvent = se.event.raw;\r\n          handleFiles(comp, transferEvent.dataTransfer.files);\r\n        }\r\n      };\r\n      var onSelect = function (component, simulatedEvent) {\r\n        var input = simulatedEvent.event.raw.target;\r\n        handleFiles(component, input.files);\r\n      };\r\n      var handleFiles = function (component, files) {\r\n        Representing.setValue(component, filterByExtension(files, providersBackstage));\r\n        emitWith(component, formChangeEvent, { name: spec.name });\r\n      };\r\n      var memInput = record({\r\n        dom: {\r\n          tag: 'input',\r\n          attributes: {\r\n            type: 'file',\r\n            accept: 'image/*'\r\n          },\r\n          styles: { display: 'none' }\r\n        },\r\n        behaviours: derive$1([config('input-file-events', [\r\n            cutter(click()),\r\n            cutter(tap())\r\n          ])])\r\n      });\r\n      var renderField = function (s) {\r\n        return {\r\n          uid: s.uid,\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-dropzone-container']\r\n          },\r\n          behaviours: derive$1([\r\n            RepresentingConfigs.memory([]),\r\n            ComposingConfigs.self(),\r\n            Disabling.config({}),\r\n            Toggling.config({\r\n              toggleClass: 'dragenter',\r\n              toggleOnExecute: false\r\n            }),\r\n            config('dropzone-events', [\r\n              run$1('dragenter', sequence([\r\n                stopper,\r\n                Toggling.toggle\r\n              ])),\r\n              run$1('dragleave', sequence([\r\n                stopper,\r\n                Toggling.toggle\r\n              ])),\r\n              run$1('dragover', stopper),\r\n              run$1('drop', sequence([\r\n                stopper,\r\n                onDrop\r\n              ])),\r\n              run$1(change(), onSelect)\r\n            ])\r\n          ]),\r\n          components: [{\r\n              dom: {\r\n                tag: 'div',\r\n                classes: ['tox-dropzone'],\r\n                styles: {}\r\n              },\r\n              components: [\r\n                {\r\n                  dom: {\r\n                    tag: 'p',\r\n                    innerHtml: providersBackstage.translate('Drop an image here')\r\n                  }\r\n                },\r\n                Button.sketch({\r\n                  dom: {\r\n                    tag: 'button',\r\n                    innerHtml: providersBackstage.translate('Browse for an image'),\r\n                    styles: { position: 'relative' },\r\n                    classes: [\r\n                      'tox-button',\r\n                      'tox-button--secondary'\r\n                    ]\r\n                  },\r\n                  components: [memInput.asSpec()],\r\n                  action: function (comp) {\r\n                    var inputComp = memInput.get(comp);\r\n                    inputComp.element.dom.click();\r\n                  },\r\n                  buttonBehaviours: derive$1([\r\n                    Tabstopping.config({}),\r\n                    DisablingConfigs.button(providersBackstage.isDisabled),\r\n                    receivingConfig()\r\n                  ])\r\n                })\r\n              ]\r\n            }]\r\n        };\r\n      };\r\n      var pLabel = spec.label.map(function (label) {\r\n        return renderLabel$2(label, providersBackstage);\r\n      });\r\n      var pField = FormField.parts.field({ factory: { sketch: renderField } });\r\n      return renderFormFieldWith(pLabel, pField, ['tox-form__group--stretched'], []);\r\n    };\r\n\r\n    var renderGrid = function (spec, backstage) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [\r\n            'tox-form__grid',\r\n            'tox-form__grid--' + spec.columns + 'col'\r\n          ]\r\n        },\r\n        components: map$2(spec.items, backstage.interpreter)\r\n      };\r\n    };\r\n\r\n    var beforeObject = generate$6('alloy-fake-before-tabstop');\r\n    var afterObject = generate$6('alloy-fake-after-tabstop');\r\n    var craftWithClasses = function (classes) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          styles: {\r\n            width: '1px',\r\n            height: '1px',\r\n            outline: 'none'\r\n          },\r\n          attributes: { tabindex: '0' },\r\n          classes: classes\r\n        },\r\n        behaviours: derive$1([\r\n          Focusing.config({ ignore: true }),\r\n          Tabstopping.config({})\r\n        ])\r\n      };\r\n    };\r\n    var craft = function (spec) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-navobj']\r\n        },\r\n        components: [\r\n          craftWithClasses([beforeObject]),\r\n          spec,\r\n          craftWithClasses([afterObject])\r\n        ],\r\n        behaviours: derive$1([ComposingConfigs.childAt(1)])\r\n      };\r\n    };\r\n    var triggerTab = function (placeholder, shiftKey) {\r\n      emitWith(placeholder, keydown(), {\r\n        raw: {\r\n          which: 9,\r\n          shiftKey: shiftKey\r\n        }\r\n      });\r\n    };\r\n    var onFocus = function (container, targetComp) {\r\n      var target = targetComp.element;\r\n      if (has(target, beforeObject)) {\r\n        triggerTab(container, true);\r\n      } else if (has(target, afterObject)) {\r\n        triggerTab(container, false);\r\n      }\r\n    };\r\n    var isPseudoStop = function (element) {\r\n      return closest(element, [\r\n        '.' + beforeObject,\r\n        '.' + afterObject\r\n      ].join(','), never);\r\n    };\r\n\r\n    var platformNeedsSandboxing = !(detect$1().browser.isIE() || detect$1().browser.isEdge());\r\n    var getDynamicSource = function (isSandbox) {\r\n      var cachedValue = Cell('');\r\n      return {\r\n        getValue: function (_frameComponent) {\r\n          return cachedValue.get();\r\n        },\r\n        setValue: function (frameComponent, html) {\r\n          if (!isSandbox) {\r\n            set$8(frameComponent.element, 'src', 'javascript:\\'\\'');\r\n            var doc = frameComponent.element.dom.contentWindow.document;\r\n            doc.open();\r\n            doc.write(html);\r\n            doc.close();\r\n          } else {\r\n            set$8(frameComponent.element, 'srcdoc', html);\r\n          }\r\n          cachedValue.set(html);\r\n        }\r\n      };\r\n    };\r\n    var renderIFrame = function (spec, providersBackstage) {\r\n      var isSandbox = platformNeedsSandboxing && spec.sandboxed;\r\n      var attributes = __assign(__assign({}, spec.label.map(function (title) {\r\n        return { title: title };\r\n      }).getOr({})), isSandbox ? { sandbox: 'allow-scripts allow-same-origin' } : {});\r\n      var sourcing = getDynamicSource(isSandbox);\r\n      var pLabel = spec.label.map(function (label) {\r\n        return renderLabel$2(label, providersBackstage);\r\n      });\r\n      var factory = function (newSpec) {\r\n        return craft({\r\n          uid: newSpec.uid,\r\n          dom: {\r\n            tag: 'iframe',\r\n            attributes: attributes\r\n          },\r\n          behaviours: derive$1([\r\n            Tabstopping.config({}),\r\n            Focusing.config({}),\r\n            RepresentingConfigs.withComp(Optional.none(), sourcing.getValue, sourcing.setValue)\r\n          ])\r\n        });\r\n      };\r\n      var pField = FormField.parts.field({ factory: { sketch: factory } });\r\n      return renderFormFieldWith(pLabel, pField, ['tox-form__group--stretched'], []);\r\n    };\r\n\r\n    var create$3 = function (width, height) {\r\n      return resize$3(document.createElement('canvas'), width, height);\r\n    };\r\n    var clone = function (canvas) {\r\n      var tCanvas = create$3(canvas.width, canvas.height);\r\n      var ctx = get2dContext(tCanvas);\r\n      ctx.drawImage(canvas, 0, 0);\r\n      return tCanvas;\r\n    };\r\n    var get2dContext = function (canvas) {\r\n      return canvas.getContext('2d');\r\n    };\r\n    var resize$3 = function (canvas, width, height) {\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n      return canvas;\r\n    };\r\n\r\n    var getWidth$1 = function (image) {\r\n      return image.naturalWidth || image.width;\r\n    };\r\n    var getHeight$1 = function (image) {\r\n      return image.naturalHeight || image.height;\r\n    };\r\n\r\n    var blobToImage = function (blob) {\r\n      return new Promise$1(function (resolve, reject) {\r\n        var blobUrl = URL.createObjectURL(blob);\r\n        var image = new Image();\r\n        var removeListeners = function () {\r\n          image.removeEventListener('load', loaded);\r\n          image.removeEventListener('error', error);\r\n        };\r\n        var loaded = function () {\r\n          removeListeners();\r\n          resolve(image);\r\n        };\r\n        var error = function () {\r\n          removeListeners();\r\n          reject('Unable to load data of type ' + blob.type + ': ' + blobUrl);\r\n        };\r\n        image.addEventListener('load', loaded);\r\n        image.addEventListener('error', error);\r\n        image.src = blobUrl;\r\n        if (image.complete) {\r\n          setTimeout(loaded, 0);\r\n        }\r\n      });\r\n    };\r\n    var dataUriToBlobSync = function (uri) {\r\n      var data = uri.split(',');\r\n      var matches = /data:([^;]+)/.exec(data[0]);\r\n      if (!matches) {\r\n        return Optional.none();\r\n      }\r\n      var mimetype = matches[1];\r\n      var base64 = data[1];\r\n      var sliceSize = 1024;\r\n      var byteCharacters = atob(base64);\r\n      var bytesLength = byteCharacters.length;\r\n      var slicesCount = Math.ceil(bytesLength / sliceSize);\r\n      var byteArrays = new Array(slicesCount);\r\n      for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {\r\n        var begin = sliceIndex * sliceSize;\r\n        var end = Math.min(begin + sliceSize, bytesLength);\r\n        var bytes = new Array(end - begin);\r\n        for (var offset = begin, i = 0; offset < end; ++i, ++offset) {\r\n          bytes[i] = byteCharacters[offset].charCodeAt(0);\r\n        }\r\n        byteArrays[sliceIndex] = new Uint8Array(bytes);\r\n      }\r\n      return Optional.some(new Blob(byteArrays, { type: mimetype }));\r\n    };\r\n    var dataUriToBlob = function (uri) {\r\n      return new Promise$1(function (resolve, reject) {\r\n        dataUriToBlobSync(uri).fold(function () {\r\n          reject('uri is not base64: ' + uri);\r\n        }, resolve);\r\n      });\r\n    };\r\n    var canvasToBlob = function (canvas, type, quality) {\r\n      type = type || 'image/png';\r\n      if (isFunction(HTMLCanvasElement.prototype.toBlob)) {\r\n        return new Promise$1(function (resolve, reject) {\r\n          canvas.toBlob(function (blob) {\r\n            if (blob) {\r\n              resolve(blob);\r\n            } else {\r\n              reject();\r\n            }\r\n          }, type, quality);\r\n        });\r\n      } else {\r\n        return dataUriToBlob(canvas.toDataURL(type, quality));\r\n      }\r\n    };\r\n    var canvasToDataURL = function (canvas, type, quality) {\r\n      type = type || 'image/png';\r\n      return canvas.toDataURL(type, quality);\r\n    };\r\n    var blobToCanvas = function (blob) {\r\n      return blobToImage(blob).then(function (image) {\r\n        revokeImageUrl(image);\r\n        var canvas = create$3(getWidth$1(image), getHeight$1(image));\r\n        var context = get2dContext(canvas);\r\n        context.drawImage(image, 0, 0);\r\n        return canvas;\r\n      });\r\n    };\r\n    var blobToDataUri = function (blob) {\r\n      return new Promise$1(function (resolve) {\r\n        var reader = new FileReader();\r\n        reader.onloadend = function () {\r\n          resolve(reader.result);\r\n        };\r\n        reader.readAsDataURL(blob);\r\n      });\r\n    };\r\n    var revokeImageUrl = function (image) {\r\n      URL.revokeObjectURL(image.src);\r\n    };\r\n\r\n    var create$2 = function (getCanvas, blob, uri) {\r\n      var initialType = blob.type;\r\n      var getType = constant$1(initialType);\r\n      var toBlob = function () {\r\n        return Promise$1.resolve(blob);\r\n      };\r\n      var toDataURL = constant$1(uri);\r\n      var toBase64 = function () {\r\n        return uri.split(',')[1];\r\n      };\r\n      var toAdjustedBlob = function (type, quality) {\r\n        return getCanvas.then(function (canvas) {\r\n          return canvasToBlob(canvas, type, quality);\r\n        });\r\n      };\r\n      var toAdjustedDataURL = function (type, quality) {\r\n        return getCanvas.then(function (canvas) {\r\n          return canvasToDataURL(canvas, type, quality);\r\n        });\r\n      };\r\n      var toAdjustedBase64 = function (type, quality) {\r\n        return toAdjustedDataURL(type, quality).then(function (dataurl) {\r\n          return dataurl.split(',')[1];\r\n        });\r\n      };\r\n      var toCanvas = function () {\r\n        return getCanvas.then(clone);\r\n      };\r\n      return {\r\n        getType: getType,\r\n        toBlob: toBlob,\r\n        toDataURL: toDataURL,\r\n        toBase64: toBase64,\r\n        toAdjustedBlob: toAdjustedBlob,\r\n        toAdjustedDataURL: toAdjustedDataURL,\r\n        toAdjustedBase64: toAdjustedBase64,\r\n        toCanvas: toCanvas\r\n      };\r\n    };\r\n    var fromBlob = function (blob) {\r\n      return blobToDataUri(blob).then(function (uri) {\r\n        return create$2(blobToCanvas(blob), blob, uri);\r\n      });\r\n    };\r\n    var fromCanvas = function (canvas, type) {\r\n      return canvasToBlob(canvas, type).then(function (blob) {\r\n        return create$2(Promise$1.resolve(canvas), blob, canvas.toDataURL());\r\n      });\r\n    };\r\n\r\n    var blobToImageResult = function (blob) {\r\n      return fromBlob(blob);\r\n    };\r\n\r\n    var clamp = function (value, min, max) {\r\n      var parsedValue = typeof value === 'string' ? parseFloat(value) : value;\r\n      if (parsedValue > max) {\r\n        parsedValue = max;\r\n      } else if (parsedValue < min) {\r\n        parsedValue = min;\r\n      }\r\n      return parsedValue;\r\n    };\r\n    var identity = function () {\r\n      return [\r\n        1,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1\r\n      ];\r\n    };\r\n    var DELTA_INDEX = [\r\n      0,\r\n      0.01,\r\n      0.02,\r\n      0.04,\r\n      0.05,\r\n      0.06,\r\n      0.07,\r\n      0.08,\r\n      0.1,\r\n      0.11,\r\n      0.12,\r\n      0.14,\r\n      0.15,\r\n      0.16,\r\n      0.17,\r\n      0.18,\r\n      0.2,\r\n      0.21,\r\n      0.22,\r\n      0.24,\r\n      0.25,\r\n      0.27,\r\n      0.28,\r\n      0.3,\r\n      0.32,\r\n      0.34,\r\n      0.36,\r\n      0.38,\r\n      0.4,\r\n      0.42,\r\n      0.44,\r\n      0.46,\r\n      0.48,\r\n      0.5,\r\n      0.53,\r\n      0.56,\r\n      0.59,\r\n      0.62,\r\n      0.65,\r\n      0.68,\r\n      0.71,\r\n      0.74,\r\n      0.77,\r\n      0.8,\r\n      0.83,\r\n      0.86,\r\n      0.89,\r\n      0.92,\r\n      0.95,\r\n      0.98,\r\n      1,\r\n      1.06,\r\n      1.12,\r\n      1.18,\r\n      1.24,\r\n      1.3,\r\n      1.36,\r\n      1.42,\r\n      1.48,\r\n      1.54,\r\n      1.6,\r\n      1.66,\r\n      1.72,\r\n      1.78,\r\n      1.84,\r\n      1.9,\r\n      1.96,\r\n      2,\r\n      2.12,\r\n      2.25,\r\n      2.37,\r\n      2.5,\r\n      2.62,\r\n      2.75,\r\n      2.87,\r\n      3,\r\n      3.2,\r\n      3.4,\r\n      3.6,\r\n      3.8,\r\n      4,\r\n      4.3,\r\n      4.7,\r\n      4.9,\r\n      5,\r\n      5.5,\r\n      6,\r\n      6.5,\r\n      6.8,\r\n      7,\r\n      7.3,\r\n      7.5,\r\n      7.8,\r\n      8,\r\n      8.4,\r\n      8.7,\r\n      9,\r\n      9.4,\r\n      9.6,\r\n      9.8,\r\n      10\r\n    ];\r\n    var multiply = function (matrix1, matrix2) {\r\n      var col = [];\r\n      var out = new Array(25);\r\n      var val;\r\n      for (var i = 0; i < 5; i++) {\r\n        for (var j = 0; j < 5; j++) {\r\n          col[j] = matrix2[j + i * 5];\r\n        }\r\n        for (var j = 0; j < 5; j++) {\r\n          val = 0;\r\n          for (var k = 0; k < 5; k++) {\r\n            val += matrix1[j + k * 5] * col[k];\r\n          }\r\n          out[j + i * 5] = val;\r\n        }\r\n      }\r\n      return out;\r\n    };\r\n    var adjustContrast = function (matrix, value) {\r\n      var x;\r\n      value = clamp(value, -1, 1);\r\n      value *= 100;\r\n      if (value < 0) {\r\n        x = 127 + value / 100 * 127;\r\n      } else {\r\n        x = value % 1;\r\n        if (x === 0) {\r\n          x = DELTA_INDEX[value];\r\n        } else {\r\n          x = DELTA_INDEX[Math.floor(value)] * (1 - x) + DELTA_INDEX[Math.floor(value) + 1] * x;\r\n        }\r\n        x = x * 127 + 127;\r\n      }\r\n      return multiply(matrix, [\r\n        x / 127,\r\n        0,\r\n        0,\r\n        0,\r\n        0.5 * (127 - x),\r\n        0,\r\n        x / 127,\r\n        0,\r\n        0,\r\n        0.5 * (127 - x),\r\n        0,\r\n        0,\r\n        x / 127,\r\n        0,\r\n        0.5 * (127 - x),\r\n        0,\r\n        0,\r\n        0,\r\n        1,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1\r\n      ]);\r\n    };\r\n    var adjustBrightness = function (matrix, value) {\r\n      value = clamp(255 * value, -255, 255);\r\n      return multiply(matrix, [\r\n        1,\r\n        0,\r\n        0,\r\n        0,\r\n        value,\r\n        0,\r\n        1,\r\n        0,\r\n        0,\r\n        value,\r\n        0,\r\n        0,\r\n        1,\r\n        0,\r\n        value,\r\n        0,\r\n        0,\r\n        0,\r\n        1,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1\r\n      ]);\r\n    };\r\n    var adjustColors = function (matrix, adjustR, adjustG, adjustB) {\r\n      adjustR = clamp(adjustR, 0, 2);\r\n      adjustG = clamp(adjustG, 0, 2);\r\n      adjustB = clamp(adjustB, 0, 2);\r\n      return multiply(matrix, [\r\n        adjustR,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        adjustG,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        adjustB,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1\r\n      ]);\r\n    };\r\n\r\n    var colorFilter = function (ir, matrix) {\r\n      return ir.toCanvas().then(function (canvas) {\r\n        return applyColorFilter(canvas, ir.getType(), matrix);\r\n      });\r\n    };\r\n    var applyColorFilter = function (canvas, type, matrix) {\r\n      var context = get2dContext(canvas);\r\n      var applyMatrix = function (pixelsData, m) {\r\n        var r, g, b, a;\r\n        var data = pixelsData.data, m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7], m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11], m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15], m16 = m[16], m17 = m[17], m18 = m[18], m19 = m[19];\r\n        for (var i = 0; i < data.length; i += 4) {\r\n          r = data[i];\r\n          g = data[i + 1];\r\n          b = data[i + 2];\r\n          a = data[i + 3];\r\n          data[i] = r * m0 + g * m1 + b * m2 + a * m3 + m4;\r\n          data[i + 1] = r * m5 + g * m6 + b * m7 + a * m8 + m9;\r\n          data[i + 2] = r * m10 + g * m11 + b * m12 + a * m13 + m14;\r\n          data[i + 3] = r * m15 + g * m16 + b * m17 + a * m18 + m19;\r\n        }\r\n        return pixelsData;\r\n      };\r\n      var pixels = applyMatrix(context.getImageData(0, 0, canvas.width, canvas.height), matrix);\r\n      context.putImageData(pixels, 0, 0);\r\n      return fromCanvas(canvas, type);\r\n    };\r\n    var convoluteFilter = function (ir, matrix) {\r\n      return ir.toCanvas().then(function (canvas) {\r\n        return applyConvoluteFilter(canvas, ir.getType(), matrix);\r\n      });\r\n    };\r\n    var applyConvoluteFilter = function (canvas, type, matrix) {\r\n      var context = get2dContext(canvas);\r\n      var applyMatrix = function (pIn, pOut, aMatrix) {\r\n        var clamp = function (value, min, max) {\r\n          if (value > max) {\r\n            value = max;\r\n          } else if (value < min) {\r\n            value = min;\r\n          }\r\n          return value;\r\n        };\r\n        var side = Math.round(Math.sqrt(aMatrix.length));\r\n        var halfSide = Math.floor(side / 2);\r\n        var rgba = pIn.data;\r\n        var drgba = pOut.data;\r\n        var w = pIn.width;\r\n        var h = pIn.height;\r\n        for (var y = 0; y < h; y++) {\r\n          for (var x = 0; x < w; x++) {\r\n            var r = 0;\r\n            var g = 0;\r\n            var b = 0;\r\n            for (var cy = 0; cy < side; cy++) {\r\n              for (var cx = 0; cx < side; cx++) {\r\n                var scx = clamp(x + cx - halfSide, 0, w - 1);\r\n                var scy = clamp(y + cy - halfSide, 0, h - 1);\r\n                var innerOffset = (scy * w + scx) * 4;\r\n                var wt = aMatrix[cy * side + cx];\r\n                r += rgba[innerOffset] * wt;\r\n                g += rgba[innerOffset + 1] * wt;\r\n                b += rgba[innerOffset + 2] * wt;\r\n              }\r\n            }\r\n            var offset = (y * w + x) * 4;\r\n            drgba[offset] = clamp(r, 0, 255);\r\n            drgba[offset + 1] = clamp(g, 0, 255);\r\n            drgba[offset + 2] = clamp(b, 0, 255);\r\n          }\r\n        }\r\n        return pOut;\r\n      };\r\n      var pixelsIn = context.getImageData(0, 0, canvas.width, canvas.height);\r\n      var pixelsOut = context.getImageData(0, 0, canvas.width, canvas.height);\r\n      pixelsOut = applyMatrix(pixelsIn, pixelsOut, matrix);\r\n      context.putImageData(pixelsOut, 0, 0);\r\n      return fromCanvas(canvas, type);\r\n    };\r\n    var functionColorFilter = function (colorFn) {\r\n      var filterImpl = function (canvas, type, value) {\r\n        var context = get2dContext(canvas);\r\n        var lookup = new Array(256);\r\n        var applyLookup = function (pixelsData, lookupData) {\r\n          var data = pixelsData.data;\r\n          for (var i = 0; i < data.length; i += 4) {\r\n            data[i] = lookupData[data[i]];\r\n            data[i + 1] = lookupData[data[i + 1]];\r\n            data[i + 2] = lookupData[data[i + 2]];\r\n          }\r\n          return pixelsData;\r\n        };\r\n        for (var i = 0; i < lookup.length; i++) {\r\n          lookup[i] = colorFn(i, value);\r\n        }\r\n        var pixels = applyLookup(context.getImageData(0, 0, canvas.width, canvas.height), lookup);\r\n        context.putImageData(pixels, 0, 0);\r\n        return fromCanvas(canvas, type);\r\n      };\r\n      return function (ir, value) {\r\n        return ir.toCanvas().then(function (canvas) {\r\n          return filterImpl(canvas, ir.getType(), value);\r\n        });\r\n      };\r\n    };\r\n    var complexAdjustableColorFilter = function (matrixAdjustFn) {\r\n      return function (ir, adjust) {\r\n        return colorFilter(ir, matrixAdjustFn(identity(), adjust));\r\n      };\r\n    };\r\n    var basicColorFilter = function (matrix) {\r\n      return function (ir) {\r\n        return colorFilter(ir, matrix);\r\n      };\r\n    };\r\n    var basicConvolutionFilter = function (kernel) {\r\n      return function (ir) {\r\n        return convoluteFilter(ir, kernel);\r\n      };\r\n    };\r\n    var invert$1 = basicColorFilter([\r\n      -1,\r\n      0,\r\n      0,\r\n      0,\r\n      255,\r\n      0,\r\n      -1,\r\n      0,\r\n      0,\r\n      255,\r\n      0,\r\n      0,\r\n      -1,\r\n      0,\r\n      255,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1\r\n    ]);\r\n    var brightness$1 = complexAdjustableColorFilter(adjustBrightness);\r\n    var contrast$1 = complexAdjustableColorFilter(adjustContrast);\r\n    var colorize$1 = function (ir, adjustR, adjustG, adjustB) {\r\n      return colorFilter(ir, adjustColors(identity(), adjustR, adjustG, adjustB));\r\n    };\r\n    var sharpen$1 = basicConvolutionFilter([\r\n      0,\r\n      -1,\r\n      0,\r\n      -1,\r\n      5,\r\n      -1,\r\n      0,\r\n      -1,\r\n      0\r\n    ]);\r\n    var gamma$1 = functionColorFilter(function (color, value) {\r\n      return Math.pow(color / 255, 1 - value) * 255;\r\n    });\r\n\r\n    var scale = function (image, dW, dH) {\r\n      var sW = getWidth$1(image);\r\n      var sH = getHeight$1(image);\r\n      var wRatio = dW / sW;\r\n      var hRatio = dH / sH;\r\n      var scaleCapped = false;\r\n      if (wRatio < 0.5 || wRatio > 2) {\r\n        wRatio = wRatio < 0.5 ? 0.5 : 2;\r\n        scaleCapped = true;\r\n      }\r\n      if (hRatio < 0.5 || hRatio > 2) {\r\n        hRatio = hRatio < 0.5 ? 0.5 : 2;\r\n        scaleCapped = true;\r\n      }\r\n      var scaled = _scale(image, wRatio, hRatio);\r\n      return !scaleCapped ? scaled : scaled.then(function (tCanvas) {\r\n        return scale(tCanvas, dW, dH);\r\n      });\r\n    };\r\n    var _scale = function (image, wRatio, hRatio) {\r\n      return new Promise$1(function (resolve) {\r\n        var sW = getWidth$1(image);\r\n        var sH = getHeight$1(image);\r\n        var dW = Math.floor(sW * wRatio);\r\n        var dH = Math.floor(sH * hRatio);\r\n        var canvas = create$3(dW, dH);\r\n        var context = get2dContext(canvas);\r\n        context.drawImage(image, 0, 0, sW, sH, 0, 0, dW, dH);\r\n        resolve(canvas);\r\n      });\r\n    };\r\n\r\n    var ceilWithPrecision = function (num, precision) {\r\n      if (precision === void 0) {\r\n        precision = 2;\r\n      }\r\n      var mul = Math.pow(10, precision);\r\n      var upper = Math.round(num * mul);\r\n      return Math.ceil(upper / mul);\r\n    };\r\n    var rotate$1 = function (ir, angle) {\r\n      return ir.toCanvas().then(function (canvas) {\r\n        return applyRotate(canvas, ir.getType(), angle);\r\n      });\r\n    };\r\n    var applyRotate = function (image, type, angle) {\r\n      var degrees = angle < 0 ? 360 + angle : angle;\r\n      var rad = degrees * Math.PI / 180;\r\n      var width = image.width;\r\n      var height = image.height;\r\n      var sin = Math.sin(rad);\r\n      var cos = Math.cos(rad);\r\n      var newWidth = ceilWithPrecision(Math.abs(width * cos) + Math.abs(height * sin));\r\n      var newHeight = ceilWithPrecision(Math.abs(width * sin) + Math.abs(height * cos));\r\n      var canvas = create$3(newWidth, newHeight);\r\n      var context = get2dContext(canvas);\r\n      context.translate(newWidth / 2, newHeight / 2);\r\n      context.rotate(rad);\r\n      context.drawImage(image, -width / 2, -height / 2);\r\n      return fromCanvas(canvas, type);\r\n    };\r\n    var flip$1 = function (ir, axis) {\r\n      return ir.toCanvas().then(function (canvas) {\r\n        return applyFlip(canvas, ir.getType(), axis);\r\n      });\r\n    };\r\n    var applyFlip = function (image, type, axis) {\r\n      var canvas = create$3(image.width, image.height);\r\n      var context = get2dContext(canvas);\r\n      if (axis === 'v') {\r\n        context.scale(1, -1);\r\n        context.drawImage(image, 0, -canvas.height);\r\n      } else {\r\n        context.scale(-1, 1);\r\n        context.drawImage(image, -canvas.width, 0);\r\n      }\r\n      return fromCanvas(canvas, type);\r\n    };\r\n    var crop$1 = function (ir, x, y, w, h) {\r\n      return ir.toCanvas().then(function (canvas) {\r\n        return applyCrop(canvas, ir.getType(), x, y, w, h);\r\n      });\r\n    };\r\n    var applyCrop = function (image, type, x, y, w, h) {\r\n      var canvas = create$3(w, h);\r\n      var context = get2dContext(canvas);\r\n      context.drawImage(image, -x, -y);\r\n      return fromCanvas(canvas, type);\r\n    };\r\n    var resize$2 = function (ir, w, h) {\r\n      return ir.toCanvas().then(function (canvas) {\r\n        return scale(canvas, w, h).then(function (newCanvas) {\r\n          return fromCanvas(newCanvas, ir.getType());\r\n        });\r\n      });\r\n    };\r\n\r\n    var invert = function (ir) {\r\n      return invert$1(ir);\r\n    };\r\n    var sharpen = function (ir) {\r\n      return sharpen$1(ir);\r\n    };\r\n    var gamma = function (ir, value) {\r\n      return gamma$1(ir, value);\r\n    };\r\n    var colorize = function (ir, adjustR, adjustG, adjustB) {\r\n      return colorize$1(ir, adjustR, adjustG, adjustB);\r\n    };\r\n    var brightness = function (ir, adjust) {\r\n      return brightness$1(ir, adjust);\r\n    };\r\n    var contrast = function (ir, adjust) {\r\n      return contrast$1(ir, adjust);\r\n    };\r\n    var flip = function (ir, axis) {\r\n      return flip$1(ir, axis);\r\n    };\r\n    var crop = function (ir, x, y, w, h) {\r\n      return crop$1(ir, x, y, w, h);\r\n    };\r\n    var resize$1 = function (ir, w, h) {\r\n      return resize$2(ir, w, h);\r\n    };\r\n    var rotate = function (ir, angle) {\r\n      return rotate$1(ir, angle);\r\n    };\r\n\r\n    var renderIcon = function (iconName, iconsProvider, behaviours) {\r\n      return render$3(iconName, {\r\n        tag: 'span',\r\n        classes: [\r\n          'tox-icon',\r\n          'tox-tbtn__icon-wrap'\r\n        ],\r\n        behaviours: behaviours\r\n      }, iconsProvider);\r\n    };\r\n    var renderIconFromPack = function (iconName, iconsProvider) {\r\n      return renderIcon(iconName, iconsProvider, []);\r\n    };\r\n    var renderReplacableIconFromPack = function (iconName, iconsProvider) {\r\n      return renderIcon(iconName, iconsProvider, [Replacing.config({})]);\r\n    };\r\n    var renderLabel$1 = function (text, prefix, providersBackstage) {\r\n      return {\r\n        dom: {\r\n          tag: 'span',\r\n          innerHtml: providersBackstage.translate(text),\r\n          classes: [prefix + '__select-label']\r\n        },\r\n        behaviours: derive$1([Replacing.config({})])\r\n      };\r\n    };\r\n\r\n    var _a;\r\n    var internalToolbarButtonExecute = generate$6('toolbar.button.execute');\r\n    var onToolbarButtonExecute = function (info) {\r\n      return runOnExecute$1(function (comp, _simulatedEvent) {\r\n        runWithApi(info, comp)(function (itemApi) {\r\n          emitWith(comp, internalToolbarButtonExecute, { buttonApi: itemApi });\r\n          info.onAction(itemApi);\r\n        });\r\n      });\r\n    };\r\n    var toolbarButtonEventOrder = (_a = {}, _a[execute$5()] = [\r\n      'disabling',\r\n      'alloy.base.behaviour',\r\n      'toggling',\r\n      'toolbar-button-events'\r\n    ], _a);\r\n\r\n    var updateMenuText = generate$6('update-menu-text');\r\n    var updateMenuIcon = generate$6('update-menu-icon');\r\n    var renderCommonDropdown = function (spec, prefix, sharedBackstage) {\r\n      var editorOffCell = Cell(noop);\r\n      var optMemDisplayText = spec.text.map(function (text) {\r\n        return record(renderLabel$1(text, prefix, sharedBackstage.providers));\r\n      });\r\n      var optMemDisplayIcon = spec.icon.map(function (iconName) {\r\n        return record(renderReplacableIconFromPack(iconName, sharedBackstage.providers.icons));\r\n      });\r\n      var onLeftOrRightInMenu = function (comp, se) {\r\n        var dropdown = Representing.getValue(comp);\r\n        Focusing.focus(dropdown);\r\n        emitWith(dropdown, 'keydown', { raw: se.event.raw });\r\n        Dropdown.close(dropdown);\r\n        return Optional.some(true);\r\n      };\r\n      var role = spec.role.fold(function () {\r\n        return {};\r\n      }, function (role) {\r\n        return { role: role };\r\n      });\r\n      var tooltipAttributes = spec.tooltip.fold(function () {\r\n        return {};\r\n      }, function (tooltip) {\r\n        var translatedTooltip = sharedBackstage.providers.translate(tooltip);\r\n        return {\r\n          'title': translatedTooltip,\r\n          'aria-label': translatedTooltip\r\n        };\r\n      });\r\n      var iconSpec = render$3('chevron-down', {\r\n        tag: 'div',\r\n        classes: [prefix + '__select-chevron']\r\n      }, sharedBackstage.providers.icons);\r\n      var memDropdown = record(Dropdown.sketch(__assign(__assign(__assign({}, spec.uid ? { uid: spec.uid } : {}), role), {\r\n        dom: {\r\n          tag: 'button',\r\n          classes: [\r\n            prefix,\r\n            prefix + '--select'\r\n          ].concat(map$2(spec.classes, function (c) {\r\n            return prefix + '--' + c;\r\n          })),\r\n          attributes: __assign({}, tooltipAttributes)\r\n        },\r\n        components: componentRenderPipeline([\r\n          optMemDisplayIcon.map(function (mem) {\r\n            return mem.asSpec();\r\n          }),\r\n          optMemDisplayText.map(function (mem) {\r\n            return mem.asSpec();\r\n          }),\r\n          Optional.some(iconSpec)\r\n        ]),\r\n        matchWidth: true,\r\n        useMinWidth: true,\r\n        dropdownBehaviours: derive$1(__spreadArray(__spreadArray([], spec.dropdownBehaviours, true), [\r\n          DisablingConfigs.button(function () {\r\n            return spec.disabled || sharedBackstage.providers.isDisabled();\r\n          }),\r\n          receivingConfig(),\r\n          Unselecting.config({}),\r\n          Replacing.config({}),\r\n          config('dropdown-events', [\r\n            onControlAttached(spec, editorOffCell),\r\n            onControlDetached(spec, editorOffCell)\r\n          ]),\r\n          config('menubutton-update-display-text', [\r\n            run$1(updateMenuText, function (comp, se) {\r\n              optMemDisplayText.bind(function (mem) {\r\n                return mem.getOpt(comp);\r\n              }).each(function (displayText) {\r\n                Replacing.set(displayText, [text$1(sharedBackstage.providers.translate(se.event.text))]);\r\n              });\r\n            }),\r\n            run$1(updateMenuIcon, function (comp, se) {\r\n              optMemDisplayIcon.bind(function (mem) {\r\n                return mem.getOpt(comp);\r\n              }).each(function (displayIcon) {\r\n                Replacing.set(displayIcon, [renderReplacableIconFromPack(se.event.icon, sharedBackstage.providers.icons)]);\r\n              });\r\n            })\r\n          ])\r\n        ], false)),\r\n        eventOrder: deepMerge(toolbarButtonEventOrder, {\r\n          mousedown: [\r\n            'focusing',\r\n            'alloy.base.behaviour',\r\n            'item-type-events',\r\n            'normal-dropdown-events'\r\n          ]\r\n        }),\r\n        sandboxBehaviours: derive$1([Keying.config({\r\n            mode: 'special',\r\n            onLeft: onLeftOrRightInMenu,\r\n            onRight: onLeftOrRightInMenu\r\n          })]),\r\n        lazySink: sharedBackstage.getSink,\r\n        toggleClass: prefix + '--active',\r\n        parts: { menu: part(false, spec.columns, spec.presets) },\r\n        fetch: function (comp) {\r\n          return Future.nu(curry(spec.fetch, comp));\r\n        }\r\n      })));\r\n      return memDropdown.asSpec();\r\n    };\r\n\r\n    var isMenuItemReference = function (item) {\r\n      return isString(item);\r\n    };\r\n    var isSeparator$1 = function (item) {\r\n      return item.type === 'separator';\r\n    };\r\n    var isExpandingMenuItem = function (item) {\r\n      return has$2(item, 'getSubmenuItems');\r\n    };\r\n    var separator$2 = { type: 'separator' };\r\n    var unwrapReferences = function (items, menuItems) {\r\n      var realItems = foldl(items, function (acc, item) {\r\n        if (isMenuItemReference(item)) {\r\n          if (item === '') {\r\n            return acc;\r\n          } else if (item === '|') {\r\n            return acc.length > 0 && !isSeparator$1(acc[acc.length - 1]) ? acc.concat([separator$2]) : acc;\r\n          } else if (has$2(menuItems, item.toLowerCase())) {\r\n            return acc.concat([menuItems[item.toLowerCase()]]);\r\n          } else {\r\n            return acc;\r\n          }\r\n        } else {\r\n          return acc.concat([item]);\r\n        }\r\n      }, []);\r\n      if (realItems.length > 0 && isSeparator$1(realItems[realItems.length - 1])) {\r\n        realItems.pop();\r\n      }\r\n      return realItems;\r\n    };\r\n    var getFromExpandingItem = function (item, menuItems) {\r\n      var submenuItems = item.getSubmenuItems();\r\n      var rest = expand(submenuItems, menuItems);\r\n      var newMenus = deepMerge(rest.menus, wrap$1(item.value, rest.items));\r\n      var newExpansions = deepMerge(rest.expansions, wrap$1(item.value, item.value));\r\n      return {\r\n        item: item,\r\n        menus: newMenus,\r\n        expansions: newExpansions\r\n      };\r\n    };\r\n    var getFromItem = function (item, menuItems) {\r\n      return isExpandingMenuItem(item) ? getFromExpandingItem(item, menuItems) : {\r\n        item: item,\r\n        menus: {},\r\n        expansions: {}\r\n      };\r\n    };\r\n    var generateValueIfRequired = function (item) {\r\n      if (isSeparator$1(item)) {\r\n        return item;\r\n      } else {\r\n        var itemValue = get$e(item, 'value').getOrThunk(function () {\r\n          return generate$6('generated-menu-item');\r\n        });\r\n        return deepMerge({ value: itemValue }, item);\r\n      }\r\n    };\r\n    var expand = function (items, menuItems) {\r\n      var realItems = unwrapReferences(isString(items) ? items.split(' ') : items, menuItems);\r\n      return foldr(realItems, function (acc, item) {\r\n        var itemWithValue = generateValueIfRequired(item);\r\n        var newData = getFromItem(itemWithValue, menuItems);\r\n        return {\r\n          menus: deepMerge(acc.menus, newData.menus),\r\n          items: [newData.item].concat(acc.items),\r\n          expansions: deepMerge(acc.expansions, newData.expansions)\r\n        };\r\n      }, {\r\n        menus: {},\r\n        expansions: {},\r\n        items: []\r\n      });\r\n    };\r\n\r\n    var build = function (items, itemResponse, backstage, isHorizontalMenu) {\r\n      var primary = generate$6('primary-menu');\r\n      var data = expand(items, backstage.shared.providers.menuItems());\r\n      if (data.items.length === 0) {\r\n        return Optional.none();\r\n      }\r\n      var mainMenu = createPartialMenu(primary, data.items, itemResponse, backstage, isHorizontalMenu);\r\n      var submenus = map$1(data.menus, function (menuItems, menuName) {\r\n        return createPartialMenu(menuName, menuItems, itemResponse, backstage, false);\r\n      });\r\n      var menus = deepMerge(submenus, wrap$1(primary, mainMenu));\r\n      return Optional.from(tieredMenu.tieredData(primary, menus, data.expansions));\r\n    };\r\n\r\n    var getMenuButtonApi = function (component) {\r\n      return {\r\n        isDisabled: function () {\r\n          return Disabling.isDisabled(component);\r\n        },\r\n        setDisabled: function (state) {\r\n          return Disabling.set(component, state);\r\n        },\r\n        setActive: function (state) {\r\n          var elm = component.element;\r\n          if (state) {\r\n            add$2(elm, 'tox-tbtn--enabled');\r\n            set$8(elm, 'aria-pressed', true);\r\n          } else {\r\n            remove$2(elm, 'tox-tbtn--enabled');\r\n            remove$7(elm, 'aria-pressed');\r\n          }\r\n        },\r\n        isActive: function () {\r\n          return has(component.element, 'tox-tbtn--enabled');\r\n        }\r\n      };\r\n    };\r\n    var renderMenuButton = function (spec, prefix, backstage, role) {\r\n      return renderCommonDropdown({\r\n        text: spec.text,\r\n        icon: spec.icon,\r\n        tooltip: spec.tooltip,\r\n        role: role,\r\n        fetch: function (_comp, callback) {\r\n          spec.fetch(function (items) {\r\n            callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false));\r\n          });\r\n        },\r\n        onSetup: spec.onSetup,\r\n        getApi: getMenuButtonApi,\r\n        columns: 1,\r\n        presets: 'normal',\r\n        classes: [],\r\n        dropdownBehaviours: [Tabstopping.config({})]\r\n      }, prefix, backstage.shared);\r\n    };\r\n    var getFetch = function (items, getButton, backstage) {\r\n      var getMenuItemAction = function (item) {\r\n        return function (api) {\r\n          var newValue = !api.isActive();\r\n          api.setActive(newValue);\r\n          item.storage.set(newValue);\r\n          backstage.shared.getSink().each(function (sink) {\r\n            getButton().getOpt(sink).each(function (orig) {\r\n              focus$3(orig.element);\r\n              emitWith(orig, formActionEvent, {\r\n                name: item.name,\r\n                value: item.storage.get()\r\n              });\r\n            });\r\n          });\r\n        };\r\n      };\r\n      var getMenuItemSetup = function (item) {\r\n        return function (api) {\r\n          api.setActive(item.storage.get());\r\n        };\r\n      };\r\n      return function (success) {\r\n        success(map$2(items, function (item) {\r\n          var text = item.text.fold(function () {\r\n            return {};\r\n          }, function (text) {\r\n            return { text: text };\r\n          });\r\n          return __assign(__assign({\r\n            type: item.type,\r\n            active: false\r\n          }, text), {\r\n            onAction: getMenuItemAction(item),\r\n            onSetup: getMenuItemSetup(item)\r\n          });\r\n        }));\r\n      };\r\n    };\r\n\r\n    var renderCommonSpec = function (spec, actionOpt, extraBehaviours, dom, components, providersBackstage) {\r\n      if (extraBehaviours === void 0) {\r\n        extraBehaviours = [];\r\n      }\r\n      var action = actionOpt.fold(function () {\r\n        return {};\r\n      }, function (action) {\r\n        return { action: action };\r\n      });\r\n      var common = __assign({\r\n        buttonBehaviours: derive$1([\r\n          DisablingConfigs.button(function () {\r\n            return spec.disabled || providersBackstage.isDisabled();\r\n          }),\r\n          receivingConfig(),\r\n          Tabstopping.config({}),\r\n          config('button press', [\r\n            preventDefault('click'),\r\n            preventDefault('mousedown')\r\n          ])\r\n        ].concat(extraBehaviours)),\r\n        eventOrder: {\r\n          click: [\r\n            'button press',\r\n            'alloy.base.behaviour'\r\n          ],\r\n          mousedown: [\r\n            'button press',\r\n            'alloy.base.behaviour'\r\n          ]\r\n        }\r\n      }, action);\r\n      var domFinal = deepMerge(common, { dom: dom });\r\n      return deepMerge(domFinal, { components: components });\r\n    };\r\n    var renderIconButtonSpec = function (spec, action, providersBackstage, extraBehaviours) {\r\n      if (extraBehaviours === void 0) {\r\n        extraBehaviours = [];\r\n      }\r\n      var tooltipAttributes = spec.tooltip.map(function (tooltip) {\r\n        return {\r\n          'aria-label': providersBackstage.translate(tooltip),\r\n          'title': providersBackstage.translate(tooltip)\r\n        };\r\n      }).getOr({});\r\n      var dom = {\r\n        tag: 'button',\r\n        classes: ['tox-tbtn'],\r\n        attributes: tooltipAttributes\r\n      };\r\n      var icon = spec.icon.map(function (iconName) {\r\n        return renderIconFromPack(iconName, providersBackstage.icons);\r\n      });\r\n      var components = componentRenderPipeline([icon]);\r\n      return renderCommonSpec(spec, action, extraBehaviours, dom, components, providersBackstage);\r\n    };\r\n    var renderIconButton = function (spec, action, providersBackstage, extraBehaviours) {\r\n      if (extraBehaviours === void 0) {\r\n        extraBehaviours = [];\r\n      }\r\n      var iconButtonSpec = renderIconButtonSpec(spec, Optional.some(action), providersBackstage, extraBehaviours);\r\n      return Button.sketch(iconButtonSpec);\r\n    };\r\n    var renderButtonSpec = function (spec, action, providersBackstage, extraBehaviours, extraClasses) {\r\n      if (extraBehaviours === void 0) {\r\n        extraBehaviours = [];\r\n      }\r\n      if (extraClasses === void 0) {\r\n        extraClasses = [];\r\n      }\r\n      var translatedText = providersBackstage.translate(spec.text);\r\n      var icon = spec.icon ? spec.icon.map(function (iconName) {\r\n        return renderIconFromPack(iconName, providersBackstage.icons);\r\n      }) : Optional.none();\r\n      var components = icon.isSome() ? componentRenderPipeline([icon]) : [];\r\n      var innerHtml = icon.isSome() ? {} : { innerHtml: translatedText };\r\n      var classes = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], !spec.primary && !spec.borderless ? [\r\n        'tox-button',\r\n        'tox-button--secondary'\r\n      ] : ['tox-button'], true), icon.isSome() ? ['tox-button--icon'] : [], true), spec.borderless ? ['tox-button--naked'] : [], true), extraClasses, true);\r\n      var dom = __assign(__assign({\r\n        tag: 'button',\r\n        classes: classes\r\n      }, innerHtml), { attributes: { title: translatedText } });\r\n      return renderCommonSpec(spec, action, extraBehaviours, dom, components, providersBackstage);\r\n    };\r\n    var renderButton = function (spec, action, providersBackstage, extraBehaviours, extraClasses) {\r\n      if (extraBehaviours === void 0) {\r\n        extraBehaviours = [];\r\n      }\r\n      if (extraClasses === void 0) {\r\n        extraClasses = [];\r\n      }\r\n      var buttonSpec = renderButtonSpec(spec, Optional.some(action), providersBackstage, extraBehaviours, extraClasses);\r\n      return Button.sketch(buttonSpec);\r\n    };\r\n    var getAction = function (name, buttonType) {\r\n      return function (comp) {\r\n        if (buttonType === 'custom') {\r\n          emitWith(comp, formActionEvent, {\r\n            name: name,\r\n            value: {}\r\n          });\r\n        } else if (buttonType === 'submit') {\r\n          emit(comp, formSubmitEvent);\r\n        } else if (buttonType === 'cancel') {\r\n          emit(comp, formCancelEvent);\r\n        } else {\r\n          console.error('Unknown button type: ', buttonType);\r\n        }\r\n      };\r\n    };\r\n    var isMenuFooterButtonSpec = function (spec, buttonType) {\r\n      return buttonType === 'menu';\r\n    };\r\n    var isNormalFooterButtonSpec = function (spec, buttonType) {\r\n      return buttonType === 'custom' || buttonType === 'cancel' || buttonType === 'submit';\r\n    };\r\n    var renderFooterButton = function (spec, buttonType, backstage) {\r\n      if (isMenuFooterButtonSpec(spec, buttonType)) {\r\n        var getButton = function () {\r\n          return memButton_1;\r\n        };\r\n        var menuButtonSpec = spec;\r\n        var fixedSpec = __assign(__assign({}, spec), {\r\n          onSetup: function (api) {\r\n            api.setDisabled(spec.disabled);\r\n            return noop;\r\n          },\r\n          fetch: getFetch(menuButtonSpec.items, getButton, backstage)\r\n        });\r\n        var memButton_1 = record(renderMenuButton(fixedSpec, 'tox-tbtn', backstage, Optional.none()));\r\n        return memButton_1.asSpec();\r\n      } else if (isNormalFooterButtonSpec(spec, buttonType)) {\r\n        var action = getAction(spec.name, buttonType);\r\n        var buttonSpec = __assign(__assign({}, spec), { borderless: false });\r\n        return renderButton(buttonSpec, action, backstage.shared.providers, []);\r\n      } else {\r\n        console.error('Unknown footer button type: ', buttonType);\r\n      }\r\n    };\r\n    var renderDialogButton = function (spec, providersBackstage) {\r\n      var action = getAction(spec.name, 'custom');\r\n      return renderFormField(Optional.none(), FormField.parts.field(__assign({ factory: Button }, renderButtonSpec(spec, Optional.some(action), providersBackstage, [\r\n        RepresentingConfigs.memory(''),\r\n        ComposingConfigs.self()\r\n      ]))));\r\n    };\r\n\r\n    var schema$h = constant$1([\r\n      defaulted('field1Name', 'field1'),\r\n      defaulted('field2Name', 'field2'),\r\n      onStrictHandler('onLockedChange'),\r\n      markers$1(['lockClass']),\r\n      defaulted('locked', false),\r\n      SketchBehaviours.field('coupledFieldBehaviours', [\r\n        Composing,\r\n        Representing\r\n      ])\r\n    ]);\r\n    var getField = function (comp, detail, partName) {\r\n      return getPart(comp, detail, partName).bind(Composing.getCurrent);\r\n    };\r\n    var coupledPart = function (selfName, otherName) {\r\n      return required({\r\n        factory: FormField,\r\n        name: selfName,\r\n        overrides: function (detail) {\r\n          return {\r\n            fieldBehaviours: derive$1([config('coupled-input-behaviour', [run$1(input(), function (me) {\r\n                  getField(me, detail, otherName).each(function (other) {\r\n                    getPart(me, detail, 'lock').each(function (lock) {\r\n                      if (Toggling.isOn(lock)) {\r\n                        detail.onLockedChange(me, other, lock);\r\n                      }\r\n                    });\r\n                  });\r\n                })])])\r\n          };\r\n        }\r\n      });\r\n    };\r\n    var parts$c = constant$1([\r\n      coupledPart('field1', 'field2'),\r\n      coupledPart('field2', 'field1'),\r\n      required({\r\n        factory: Button,\r\n        schema: [required$1('dom')],\r\n        name: 'lock',\r\n        overrides: function (detail) {\r\n          return {\r\n            buttonBehaviours: derive$1([Toggling.config({\r\n                selected: detail.locked,\r\n                toggleClass: detail.markers.lockClass,\r\n                aria: { mode: 'pressed' }\r\n              })])\r\n          };\r\n        }\r\n      })\r\n    ]);\r\n\r\n    var factory$f = function (detail, components, _spec, _externals) {\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        behaviours: SketchBehaviours.augment(detail.coupledFieldBehaviours, [\r\n          Composing.config({ find: Optional.some }),\r\n          Representing.config({\r\n            store: {\r\n              mode: 'manual',\r\n              getValue: function (comp) {\r\n                var _a;\r\n                var parts = getPartsOrDie(comp, detail, [\r\n                  'field1',\r\n                  'field2'\r\n                ]);\r\n                return _a = {}, _a[detail.field1Name] = Representing.getValue(parts.field1()), _a[detail.field2Name] = Representing.getValue(parts.field2()), _a;\r\n              },\r\n              setValue: function (comp, value) {\r\n                var parts = getPartsOrDie(comp, detail, [\r\n                  'field1',\r\n                  'field2'\r\n                ]);\r\n                if (hasNonNullableKey(value, detail.field1Name)) {\r\n                  Representing.setValue(parts.field1(), value[detail.field1Name]);\r\n                }\r\n                if (hasNonNullableKey(value, detail.field2Name)) {\r\n                  Representing.setValue(parts.field2(), value[detail.field2Name]);\r\n                }\r\n              }\r\n            }\r\n          })\r\n        ]),\r\n        apis: {\r\n          getField1: function (component) {\r\n            return getPart(component, detail, 'field1');\r\n          },\r\n          getField2: function (component) {\r\n            return getPart(component, detail, 'field2');\r\n          },\r\n          getLock: function (component) {\r\n            return getPart(component, detail, 'lock');\r\n          }\r\n        }\r\n      };\r\n    };\r\n    var FormCoupledInputs = composite({\r\n      name: 'FormCoupledInputs',\r\n      configFields: schema$h(),\r\n      partFields: parts$c(),\r\n      factory: factory$f,\r\n      apis: {\r\n        getField1: function (apis, component) {\r\n          return apis.getField1(component);\r\n        },\r\n        getField2: function (apis, component) {\r\n          return apis.getField2(component);\r\n        },\r\n        getLock: function (apis, component) {\r\n          return apis.getLock(component);\r\n        }\r\n      }\r\n    });\r\n\r\n    var formatSize = function (size) {\r\n      var unitDec = {\r\n        '': 0,\r\n        'px': 0,\r\n        'pt': 1,\r\n        'mm': 1,\r\n        'pc': 2,\r\n        'ex': 2,\r\n        'em': 2,\r\n        'ch': 2,\r\n        'rem': 2,\r\n        'cm': 3,\r\n        'in': 4,\r\n        '%': 4\r\n      };\r\n      var maxDecimal = function (unit) {\r\n        return unit in unitDec ? unitDec[unit] : 1;\r\n      };\r\n      var numText = size.value.toFixed(maxDecimal(size.unit));\r\n      if (numText.indexOf('.') !== -1) {\r\n        numText = numText.replace(/\\.?0*$/, '');\r\n      }\r\n      return numText + size.unit;\r\n    };\r\n    var parseSize = function (sizeText) {\r\n      var numPattern = /^\\s*(\\d+(?:\\.\\d+)?)\\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\\s*$/;\r\n      var match = numPattern.exec(sizeText);\r\n      if (match !== null) {\r\n        var value = parseFloat(match[1]);\r\n        var unit = match[2];\r\n        return Result.value({\r\n          value: value,\r\n          unit: unit\r\n        });\r\n      } else {\r\n        return Result.error(sizeText);\r\n      }\r\n    };\r\n    var convertUnit = function (size, unit) {\r\n      var inInch = {\r\n        '': 96,\r\n        'px': 96,\r\n        'pt': 72,\r\n        'cm': 2.54,\r\n        'pc': 12,\r\n        'mm': 25.4,\r\n        'in': 1\r\n      };\r\n      var supported = function (u) {\r\n        return has$2(inInch, u);\r\n      };\r\n      if (size.unit === unit) {\r\n        return Optional.some(size.value);\r\n      } else if (supported(size.unit) && supported(unit)) {\r\n        if (inInch[size.unit] === inInch[unit]) {\r\n          return Optional.some(size.value);\r\n        } else {\r\n          return Optional.some(size.value / inInch[size.unit] * inInch[unit]);\r\n        }\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var noSizeConversion = function (_input) {\r\n      return Optional.none();\r\n    };\r\n    var ratioSizeConversion = function (scale, unit) {\r\n      return function (size) {\r\n        return convertUnit(size, unit).map(function (value) {\r\n          return {\r\n            value: value * scale,\r\n            unit: unit\r\n          };\r\n        });\r\n      };\r\n    };\r\n    var makeRatioConverter = function (currentFieldText, otherFieldText) {\r\n      var cValue = parseSize(currentFieldText).toOptional();\r\n      var oValue = parseSize(otherFieldText).toOptional();\r\n      return lift2(cValue, oValue, function (cSize, oSize) {\r\n        return convertUnit(cSize, oSize.unit).map(function (val) {\r\n          return oSize.value / val;\r\n        }).map(function (r) {\r\n          return ratioSizeConversion(r, oSize.unit);\r\n        }).getOr(noSizeConversion);\r\n      }).getOr(noSizeConversion);\r\n    };\r\n\r\n    var renderSizeInput = function (spec, providersBackstage) {\r\n      var converter = noSizeConversion;\r\n      var ratioEvent = generate$6('ratio-event');\r\n      var makeIcon = function (iconName) {\r\n        return render$3(iconName, {\r\n          tag: 'span',\r\n          classes: [\r\n            'tox-icon',\r\n            'tox-lock-icon__' + iconName\r\n          ]\r\n        }, providersBackstage.icons);\r\n      };\r\n      var pLock = FormCoupledInputs.parts.lock({\r\n        dom: {\r\n          tag: 'button',\r\n          classes: [\r\n            'tox-lock',\r\n            'tox-button',\r\n            'tox-button--naked',\r\n            'tox-button--icon'\r\n          ],\r\n          attributes: { title: providersBackstage.translate(spec.label.getOr('Constrain proportions')) }\r\n        },\r\n        components: [\r\n          makeIcon('lock'),\r\n          makeIcon('unlock')\r\n        ],\r\n        buttonBehaviours: derive$1([\r\n          Disabling.config({\r\n            disabled: function () {\r\n              return spec.disabled || providersBackstage.isDisabled();\r\n            }\r\n          }),\r\n          receivingConfig(),\r\n          Tabstopping.config({})\r\n        ])\r\n      });\r\n      var formGroup = function (components) {\r\n        return {\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-form__group']\r\n          },\r\n          components: components\r\n        };\r\n      };\r\n      var getFieldPart = function (isField1) {\r\n        return FormField.parts.field({\r\n          factory: Input,\r\n          inputClasses: ['tox-textfield'],\r\n          inputBehaviours: derive$1([\r\n            Disabling.config({\r\n              disabled: function () {\r\n                return spec.disabled || providersBackstage.isDisabled();\r\n              }\r\n            }),\r\n            receivingConfig(),\r\n            Tabstopping.config({}),\r\n            config('size-input-events', [\r\n              run$1(focusin(), function (component, _simulatedEvent) {\r\n                emitWith(component, ratioEvent, { isField1: isField1 });\r\n              }),\r\n              run$1(change(), function (component, _simulatedEvent) {\r\n                emitWith(component, formChangeEvent, { name: spec.name });\r\n              })\r\n            ])\r\n          ]),\r\n          selectOnFocus: false\r\n        });\r\n      };\r\n      var getLabel = function (label) {\r\n        return {\r\n          dom: {\r\n            tag: 'label',\r\n            classes: ['tox-label'],\r\n            innerHtml: providersBackstage.translate(label)\r\n          }\r\n        };\r\n      };\r\n      var widthField = FormCoupledInputs.parts.field1(formGroup([\r\n        FormField.parts.label(getLabel('Width')),\r\n        getFieldPart(true)\r\n      ]));\r\n      var heightField = FormCoupledInputs.parts.field2(formGroup([\r\n        FormField.parts.label(getLabel('Height')),\r\n        getFieldPart(false)\r\n      ]));\r\n      return FormCoupledInputs.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-form__group']\r\n        },\r\n        components: [{\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-form__controls-h-stack']\r\n            },\r\n            components: [\r\n              widthField,\r\n              heightField,\r\n              formGroup([\r\n                getLabel('&nbsp;'),\r\n                pLock\r\n              ])\r\n            ]\r\n          }],\r\n        field1Name: 'width',\r\n        field2Name: 'height',\r\n        locked: true,\r\n        markers: { lockClass: 'tox-locked' },\r\n        onLockedChange: function (current, other, _lock) {\r\n          parseSize(Representing.getValue(current)).each(function (size) {\r\n            converter(size).each(function (newSize) {\r\n              Representing.setValue(other, formatSize(newSize));\r\n            });\r\n          });\r\n        },\r\n        coupledFieldBehaviours: derive$1([\r\n          Disabling.config({\r\n            disabled: function () {\r\n              return spec.disabled || providersBackstage.isDisabled();\r\n            },\r\n            onDisabled: function (comp) {\r\n              FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.disable);\r\n              FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.disable);\r\n              FormCoupledInputs.getLock(comp).each(Disabling.disable);\r\n            },\r\n            onEnabled: function (comp) {\r\n              FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.enable);\r\n              FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.enable);\r\n              FormCoupledInputs.getLock(comp).each(Disabling.enable);\r\n            }\r\n          }),\r\n          receivingConfig(),\r\n          config('size-input-events2', [run$1(ratioEvent, function (component, simulatedEvent) {\r\n              var isField1 = simulatedEvent.event.isField1;\r\n              var optCurrent = isField1 ? FormCoupledInputs.getField1(component) : FormCoupledInputs.getField2(component);\r\n              var optOther = isField1 ? FormCoupledInputs.getField2(component) : FormCoupledInputs.getField1(component);\r\n              var value1 = optCurrent.map(Representing.getValue).getOr('');\r\n              var value2 = optOther.map(Representing.getValue).getOr('');\r\n              converter = makeRatioConverter(value1, value2);\r\n            })])\r\n        ])\r\n      });\r\n    };\r\n\r\n    var undo = constant$1(generate$6('undo'));\r\n    var redo = constant$1(generate$6('redo'));\r\n    var zoom = constant$1(generate$6('zoom'));\r\n    var back = constant$1(generate$6('back'));\r\n    var apply = constant$1(generate$6('apply'));\r\n    var swap = constant$1(generate$6('swap'));\r\n    var transform$1 = constant$1(generate$6('transform'));\r\n    var tempTransform = constant$1(generate$6('temp-transform'));\r\n    var transformApply = constant$1(generate$6('transform-apply'));\r\n    var internal = {\r\n      undo: undo,\r\n      redo: redo,\r\n      zoom: zoom,\r\n      back: back,\r\n      apply: apply,\r\n      swap: swap,\r\n      transform: transform$1,\r\n      tempTransform: tempTransform,\r\n      transformApply: transformApply\r\n    };\r\n    var saveState = constant$1('save-state');\r\n    var disable = constant$1('disable');\r\n    var enable = constant$1('enable');\r\n    var external = {\r\n      formActionEvent: formActionEvent,\r\n      saveState: saveState,\r\n      disable: disable,\r\n      enable: enable\r\n    };\r\n\r\n    var renderEditPanel = function (imagePanel, providersBackstage) {\r\n      var createButton = function (text, action, disabled, primary) {\r\n        return record(renderButton({\r\n          name: text,\r\n          text: text,\r\n          disabled: disabled,\r\n          primary: primary,\r\n          icon: Optional.none(),\r\n          borderless: false\r\n        }, action, providersBackstage));\r\n      };\r\n      var createIconButton = function (icon, tooltip, action, disabled) {\r\n        return record(renderIconButton({\r\n          name: icon,\r\n          icon: Optional.some(icon),\r\n          tooltip: Optional.some(tooltip),\r\n          disabled: disabled,\r\n          primary: false,\r\n          borderless: false\r\n        }, action, providersBackstage));\r\n      };\r\n      var disableAllComponents = function (comps, eventcomp) {\r\n        comps.map(function (mem) {\r\n          var component = mem.get(eventcomp);\r\n          if (component.hasConfigured(Disabling)) {\r\n            Disabling.disable(component);\r\n          }\r\n        });\r\n      };\r\n      var enableAllComponents = function (comps, eventcomp) {\r\n        comps.map(function (mem) {\r\n          var component = mem.get(eventcomp);\r\n          if (component.hasConfigured(Disabling)) {\r\n            Disabling.enable(component);\r\n          }\r\n        });\r\n      };\r\n      var panelDom = {\r\n        tag: 'div',\r\n        classes: [\r\n          'tox-image-tools__toolbar',\r\n          'tox-image-tools-edit-panel'\r\n        ]\r\n      };\r\n      var noop$1 = noop;\r\n      var emit$1 = function (comp, event, data) {\r\n        emitWith(comp, event, data);\r\n      };\r\n      var emitDisable = function (component) {\r\n        return emit(component, external.disable());\r\n      };\r\n      var emitEnable = function (component) {\r\n        return emit(component, external.enable());\r\n      };\r\n      var emitTransform = function (comp, transform) {\r\n        emitDisable(comp);\r\n        emit$1(comp, internal.transform(), { transform: transform });\r\n        emitEnable(comp);\r\n      };\r\n      var emitTempTransform = function (comp, transform) {\r\n        emitDisable(comp);\r\n        emit$1(comp, internal.tempTransform(), { transform: transform });\r\n        emitEnable(comp);\r\n      };\r\n      var getBackSwap = function (anyInSystem) {\r\n        return function () {\r\n          memContainer.getOpt(anyInSystem).each(function (container) {\r\n            Replacing.set(container, [ButtonPanel]);\r\n          });\r\n        };\r\n      };\r\n      var emitTransformApply = function (comp, transform) {\r\n        emitDisable(comp);\r\n        emit$1(comp, internal.transformApply(), {\r\n          transform: transform,\r\n          swap: getBackSwap(comp)\r\n        });\r\n        emitEnable(comp);\r\n      };\r\n      var createBackButton = function () {\r\n        return createButton('Back', function (button) {\r\n          return emit$1(button, internal.back(), { swap: getBackSwap(button) });\r\n        }, false, false);\r\n      };\r\n      var createSpacer = function () {\r\n        return record({\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-spacer']\r\n          },\r\n          behaviours: derive$1([Disabling.config({})])\r\n        });\r\n      };\r\n      var createApplyButton = function () {\r\n        return createButton('Apply', function (button) {\r\n          return emit$1(button, internal.apply(), { swap: getBackSwap(button) });\r\n        }, true, true);\r\n      };\r\n      var makeCropTransform = function () {\r\n        return function (ir) {\r\n          var rect = imagePanel.getRect();\r\n          return crop(ir, rect.x, rect.y, rect.w, rect.h);\r\n        };\r\n      };\r\n      var cropPanelComponents = [\r\n        createBackButton(),\r\n        createSpacer(),\r\n        createButton('Apply', function (button) {\r\n          var transform = makeCropTransform();\r\n          emitTransformApply(button, transform);\r\n          imagePanel.hideCrop();\r\n        }, false, true)\r\n      ];\r\n      var CropPanel = Container.sketch({\r\n        dom: panelDom,\r\n        components: cropPanelComponents.map(function (mem) {\r\n          return mem.asSpec();\r\n        }),\r\n        containerBehaviours: derive$1([config('image-tools-crop-buttons-events', [\r\n            run$1(external.disable(), function (comp, _se) {\r\n              disableAllComponents(cropPanelComponents, comp);\r\n            }),\r\n            run$1(external.enable(), function (comp, _se) {\r\n              enableAllComponents(cropPanelComponents, comp);\r\n            })\r\n          ])])\r\n      });\r\n      var memSize = record(renderSizeInput({\r\n        name: 'size',\r\n        label: Optional.none(),\r\n        constrain: true,\r\n        disabled: false\r\n      }, providersBackstage));\r\n      var makeResizeTransform = function (width, height) {\r\n        return function (ir) {\r\n          return resize$1(ir, width, height);\r\n        };\r\n      };\r\n      var resizePanelComponents = [\r\n        createBackButton(),\r\n        createSpacer(),\r\n        memSize,\r\n        createSpacer(),\r\n        createButton('Apply', function (button) {\r\n          memSize.getOpt(button).each(function (sizeInput) {\r\n            var value = Representing.getValue(sizeInput);\r\n            var width = parseInt(value.width, 10);\r\n            var height = parseInt(value.height, 10);\r\n            var transform = makeResizeTransform(width, height);\r\n            emitTransformApply(button, transform);\r\n          });\r\n        }, false, true)\r\n      ];\r\n      var ResizePanel = Container.sketch({\r\n        dom: panelDom,\r\n        components: resizePanelComponents.map(function (mem) {\r\n          return mem.asSpec();\r\n        }),\r\n        containerBehaviours: derive$1([config('image-tools-resize-buttons-events', [\r\n            run$1(external.disable(), function (comp, _se) {\r\n              disableAllComponents(resizePanelComponents, comp);\r\n            }),\r\n            run$1(external.enable(), function (comp, _se) {\r\n              enableAllComponents(resizePanelComponents, comp);\r\n            })\r\n          ])])\r\n      });\r\n      var makeValueTransform = function (transform, value) {\r\n        return function (ir) {\r\n          return transform(ir, value);\r\n        };\r\n      };\r\n      var horizontalFlip = makeValueTransform(flip, 'h');\r\n      var verticalFlip = makeValueTransform(flip, 'v');\r\n      var counterclockwiseRotate = makeValueTransform(rotate, -90);\r\n      var clockwiseRotate = makeValueTransform(rotate, 90);\r\n      var flipRotateOnAction = function (comp, operation) {\r\n        emitTempTransform(comp, operation);\r\n      };\r\n      var flipRotateComponents = [\r\n        createBackButton(),\r\n        createSpacer(),\r\n        createIconButton('flip-horizontally', 'Flip horizontally', function (button) {\r\n          flipRotateOnAction(button, horizontalFlip);\r\n        }, false),\r\n        createIconButton('flip-vertically', 'Flip vertically', function (button) {\r\n          flipRotateOnAction(button, verticalFlip);\r\n        }, false),\r\n        createIconButton('rotate-left', 'Rotate counterclockwise', function (button) {\r\n          flipRotateOnAction(button, counterclockwiseRotate);\r\n        }, false),\r\n        createIconButton('rotate-right', 'Rotate clockwise', function (button) {\r\n          flipRotateOnAction(button, clockwiseRotate);\r\n        }, false),\r\n        createSpacer(),\r\n        createApplyButton()\r\n      ];\r\n      var FlipRotatePanel = Container.sketch({\r\n        dom: panelDom,\r\n        components: flipRotateComponents.map(function (mem) {\r\n          return mem.asSpec();\r\n        }),\r\n        containerBehaviours: derive$1([config('image-tools-fliprotate-buttons-events', [\r\n            run$1(external.disable(), function (comp, _se) {\r\n              disableAllComponents(flipRotateComponents, comp);\r\n            }),\r\n            run$1(external.enable(), function (comp, _se) {\r\n              enableAllComponents(flipRotateComponents, comp);\r\n            })\r\n          ])])\r\n      });\r\n      var makeSlider = function (label, onChoose, min, value, max) {\r\n        var labelPart = Slider.parts.label({\r\n          dom: {\r\n            tag: 'label',\r\n            classes: ['tox-label'],\r\n            innerHtml: providersBackstage.translate(label)\r\n          }\r\n        });\r\n        var spectrum = Slider.parts.spectrum({\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-slider__rail'],\r\n            attributes: { role: 'presentation' }\r\n          }\r\n        });\r\n        var thumb = Slider.parts.thumb({\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-slider__handle'],\r\n            attributes: { role: 'presentation' }\r\n          }\r\n        });\r\n        return record(Slider.sketch({\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-slider'],\r\n            attributes: { role: 'presentation' }\r\n          },\r\n          model: {\r\n            mode: 'x',\r\n            minX: min,\r\n            maxX: max,\r\n            getInitialValue: constant$1({ x: value })\r\n          },\r\n          components: [\r\n            labelPart,\r\n            spectrum,\r\n            thumb\r\n          ],\r\n          sliderBehaviours: derive$1([Focusing.config({})]),\r\n          onChoose: onChoose\r\n        }));\r\n      };\r\n      var makeVariableSlider = function (label, transform, min, value, max) {\r\n        var onChoose = function (slider, _thumb, value) {\r\n          var valTransform = makeValueTransform(transform, value.x / 100);\r\n          emitTransform(slider, valTransform);\r\n        };\r\n        return makeSlider(label, onChoose, min, value, max);\r\n      };\r\n      var variableFilterPanelComponents = function (label, transform, min, value, max) {\r\n        return [\r\n          createBackButton(),\r\n          makeVariableSlider(label, transform, min, value, max),\r\n          createApplyButton()\r\n        ];\r\n      };\r\n      var createVariableFilterPanel = function (label, transform, min, value, max) {\r\n        var filterPanelComponents = variableFilterPanelComponents(label, transform, min, value, max);\r\n        return Container.sketch({\r\n          dom: panelDom,\r\n          components: filterPanelComponents.map(function (mem) {\r\n            return mem.asSpec();\r\n          }),\r\n          containerBehaviours: derive$1([config('image-tools-filter-panel-buttons-events', [\r\n              run$1(external.disable(), function (comp, _se) {\r\n                disableAllComponents(filterPanelComponents, comp);\r\n              }),\r\n              run$1(external.enable(), function (comp, _se) {\r\n                enableAllComponents(filterPanelComponents, comp);\r\n              })\r\n            ])])\r\n        });\r\n      };\r\n      var filterPanelComponents = [\r\n        createBackButton(),\r\n        createSpacer(),\r\n        createApplyButton()\r\n      ];\r\n      var FilterPanel = Container.sketch({\r\n        dom: panelDom,\r\n        components: filterPanelComponents.map(function (mem) {\r\n          return mem.asSpec();\r\n        })\r\n      });\r\n      var BrightnessPanel = createVariableFilterPanel('Brightness', brightness, -100, 0, 100);\r\n      var ContrastPanel = createVariableFilterPanel('Contrast', contrast, -100, 0, 100);\r\n      var GammaPanel = createVariableFilterPanel('Gamma', gamma, -100, 0, 100);\r\n      var makeColorTransform = function (red, green, blue) {\r\n        return function (ir) {\r\n          return colorize(ir, red, green, blue);\r\n        };\r\n      };\r\n      var makeColorSlider = function (label) {\r\n        var onChoose = function (slider, _thumb, _value) {\r\n          var redOpt = memRed.getOpt(slider);\r\n          var blueOpt = memBlue.getOpt(slider);\r\n          var greenOpt = memGreen.getOpt(slider);\r\n          redOpt.each(function (red) {\r\n            blueOpt.each(function (blue) {\r\n              greenOpt.each(function (green) {\r\n                var r = Representing.getValue(red).x / 100;\r\n                var g = Representing.getValue(green).x / 100;\r\n                var b = Representing.getValue(blue).x / 100;\r\n                var transform = makeColorTransform(r, g, b);\r\n                emitTransform(slider, transform);\r\n              });\r\n            });\r\n          });\r\n        };\r\n        return makeSlider(label, onChoose, 0, 100, 200);\r\n      };\r\n      var memRed = makeColorSlider('R');\r\n      var memGreen = makeColorSlider('G');\r\n      var memBlue = makeColorSlider('B');\r\n      var colorizePanelComponents = [\r\n        createBackButton(),\r\n        memRed,\r\n        memGreen,\r\n        memBlue,\r\n        createApplyButton()\r\n      ];\r\n      var ColorizePanel = Container.sketch({\r\n        dom: panelDom,\r\n        components: colorizePanelComponents.map(function (mem) {\r\n          return mem.asSpec();\r\n        })\r\n      });\r\n      var getTransformPanelEvent = function (panel, transform, update) {\r\n        return function (button) {\r\n          var swap = function () {\r\n            memContainer.getOpt(button).each(function (container) {\r\n              Replacing.set(container, [panel]);\r\n              update(container);\r\n            });\r\n          };\r\n          emit$1(button, internal.swap(), {\r\n            transform: transform,\r\n            swap: swap\r\n          });\r\n        };\r\n      };\r\n      var cropPanelUpdate = function (_anyInSystem) {\r\n        imagePanel.showCrop();\r\n      };\r\n      var resizePanelUpdate = function (anyInSystem) {\r\n        memSize.getOpt(anyInSystem).each(function (sizeInput) {\r\n          var measurements = imagePanel.getMeasurements();\r\n          var width = measurements.width;\r\n          var height = measurements.height;\r\n          Representing.setValue(sizeInput, {\r\n            width: width,\r\n            height: height\r\n          });\r\n        });\r\n      };\r\n      var sharpenTransform = Optional.some(sharpen);\r\n      var invertTransform = Optional.some(invert);\r\n      var buttonPanelComponents = [\r\n        createIconButton('crop', 'Crop', getTransformPanelEvent(CropPanel, Optional.none(), cropPanelUpdate), false),\r\n        createIconButton('resize', 'Resize', getTransformPanelEvent(ResizePanel, Optional.none(), resizePanelUpdate), false),\r\n        createIconButton('orientation', 'Orientation', getTransformPanelEvent(FlipRotatePanel, Optional.none(), noop$1), false),\r\n        createIconButton('brightness', 'Brightness', getTransformPanelEvent(BrightnessPanel, Optional.none(), noop$1), false),\r\n        createIconButton('sharpen', 'Sharpen', getTransformPanelEvent(FilterPanel, sharpenTransform, noop$1), false),\r\n        createIconButton('contrast', 'Contrast', getTransformPanelEvent(ContrastPanel, Optional.none(), noop$1), false),\r\n        createIconButton('color-levels', 'Color levels', getTransformPanelEvent(ColorizePanel, Optional.none(), noop$1), false),\r\n        createIconButton('gamma', 'Gamma', getTransformPanelEvent(GammaPanel, Optional.none(), noop$1), false),\r\n        createIconButton('invert', 'Invert', getTransformPanelEvent(FilterPanel, invertTransform, noop$1), false)\r\n      ];\r\n      var ButtonPanel = Container.sketch({\r\n        dom: panelDom,\r\n        components: buttonPanelComponents.map(function (mem) {\r\n          return mem.asSpec();\r\n        })\r\n      });\r\n      var container = Container.sketch({\r\n        dom: { tag: 'div' },\r\n        components: [ButtonPanel],\r\n        containerBehaviours: derive$1([Replacing.config({})])\r\n      });\r\n      var memContainer = record(container);\r\n      var getApplyButton = function (anyInSystem) {\r\n        return memContainer.getOpt(anyInSystem).map(function (container) {\r\n          var panel = container.components()[0];\r\n          return panel.components()[panel.components().length - 1];\r\n        });\r\n      };\r\n      return {\r\n        memContainer: memContainer,\r\n        getApplyButton: getApplyButton\r\n      };\r\n    };\r\n\r\n    var global$4 = tinymce.util.Tools.resolve('tinymce.geom.Rect');\r\n\r\n    var global$3 = tinymce.util.Tools.resolve('tinymce.util.Observable');\r\n\r\n    var global$2 = tinymce.util.Tools.resolve('tinymce.util.VK');\r\n\r\n    var getDocumentSize = function (doc) {\r\n      var max = Math.max;\r\n      var documentElement = doc.documentElement;\r\n      var body = doc.body;\r\n      var scrollWidth = max(documentElement.scrollWidth, body.scrollWidth);\r\n      var clientWidth = max(documentElement.clientWidth, body.clientWidth);\r\n      var offsetWidth = max(documentElement.offsetWidth, body.offsetWidth);\r\n      var scrollHeight = max(documentElement.scrollHeight, body.scrollHeight);\r\n      var clientHeight = max(documentElement.clientHeight, body.clientHeight);\r\n      var offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);\r\n      return {\r\n        width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,\r\n        height: scrollHeight < offsetHeight ? clientHeight : scrollHeight\r\n      };\r\n    };\r\n    var isTouchEvent$1 = function (e) {\r\n      return isNonNullable(e.changedTouches);\r\n    };\r\n    var updateWithTouchData = function (e) {\r\n      if (isTouchEvent$1(e)) {\r\n        var keys = 'screenX screenY pageX pageY clientX clientY'.split(' ');\r\n        for (var i = 0; i < keys.length; i++) {\r\n          e[keys[i]] = e.changedTouches[0][keys[i]];\r\n        }\r\n      }\r\n    };\r\n    function DragHelper (id, settings) {\r\n      var _a, _b, _c;\r\n      var eventOverlay;\r\n      var handleEvents = [];\r\n      var overlayEvents = [];\r\n      var doc = (_a = settings.document) !== null && _a !== void 0 ? _a : document;\r\n      var root = (_b = settings.root) !== null && _b !== void 0 ? _b : doc;\r\n      var sugarDoc = SugarElement.fromDom(doc);\r\n      var downButton;\r\n      var startX;\r\n      var startY;\r\n      var handleElement = SugarElement.fromDom(root.getElementById((_c = settings.handle) !== null && _c !== void 0 ? _c : id));\r\n      var start = function (e) {\r\n        var rawEvent = e.raw;\r\n        var docSize = getDocumentSize(doc);\r\n        updateWithTouchData(rawEvent);\r\n        e.prevent();\r\n        downButton = rawEvent.button;\r\n        startX = rawEvent.screenX;\r\n        startY = rawEvent.screenY;\r\n        var cursor = get$c(handleElement, 'cursor');\r\n        eventOverlay = SugarElement.fromTag('div', doc);\r\n        setAll(eventOverlay, {\r\n          'position': 'absolute',\r\n          'top': '0',\r\n          'left': '0',\r\n          'width': docSize.width + 'px',\r\n          'height': docSize.height + 'px',\r\n          'z-index': 2147483647 + '',\r\n          'opacity': '0.0001',\r\n          cursor: cursor\r\n        });\r\n        append$2(getBody(sugarDoc), eventOverlay);\r\n        overlayEvents.push(bind(sugarDoc, 'mousemove', drag), bind(sugarDoc, 'touchmove', drag), bind(sugarDoc, 'mouseup', stop), bind(sugarDoc, 'touchend', stop));\r\n        settings.start(rawEvent);\r\n      };\r\n      var drag = function (e) {\r\n        var rawEvent = e.raw;\r\n        updateWithTouchData(rawEvent);\r\n        if (rawEvent.button !== downButton) {\r\n          return stop(e);\r\n        }\r\n        rawEvent.deltaX = rawEvent.screenX - startX;\r\n        rawEvent.deltaY = rawEvent.screenY - startY;\r\n        e.prevent();\r\n        settings.drag(rawEvent);\r\n      };\r\n      var stop = function (e) {\r\n        updateWithTouchData(e.raw);\r\n        each$1(overlayEvents, function (e) {\r\n          return e.unbind();\r\n        });\r\n        overlayEvents = [];\r\n        remove$5(eventOverlay);\r\n        if (settings.stop) {\r\n          settings.stop(e.raw);\r\n        }\r\n      };\r\n      var destroy = function () {\r\n        each$1(overlayEvents.concat(handleEvents), function (e) {\r\n          return e.unbind();\r\n        });\r\n        overlayEvents = [];\r\n        handleEvents = [];\r\n        if (isNonNullable(eventOverlay)) {\r\n          remove$5(eventOverlay);\r\n        }\r\n      };\r\n      handleEvents.push(bind(handleElement, 'mousedown', start), bind(handleElement, 'touchstart', start));\r\n      return { destroy: destroy };\r\n    }\r\n\r\n    var count = 0;\r\n    var create$1 = function (currentRect, viewPortRect, clampRect, containerElm, action) {\r\n      var dragHelpers;\r\n      var events = [];\r\n      var prefix = 'tox-';\r\n      var id = prefix + 'crid-' + count++;\r\n      var container = SugarElement.fromDom(containerElm);\r\n      var handles = [\r\n        {\r\n          name: 'move',\r\n          xMul: 0,\r\n          yMul: 0,\r\n          deltaX: 1,\r\n          deltaY: 1,\r\n          deltaW: 0,\r\n          deltaH: 0,\r\n          label: 'Crop Mask'\r\n        },\r\n        {\r\n          name: 'nw',\r\n          xMul: 0,\r\n          yMul: 0,\r\n          deltaX: 1,\r\n          deltaY: 1,\r\n          deltaW: -1,\r\n          deltaH: -1,\r\n          label: 'Top Left Crop Handle'\r\n        },\r\n        {\r\n          name: 'ne',\r\n          xMul: 1,\r\n          yMul: 0,\r\n          deltaX: 0,\r\n          deltaY: 1,\r\n          deltaW: 1,\r\n          deltaH: -1,\r\n          label: 'Top Right Crop Handle'\r\n        },\r\n        {\r\n          name: 'sw',\r\n          xMul: 0,\r\n          yMul: 1,\r\n          deltaX: 1,\r\n          deltaY: 0,\r\n          deltaW: -1,\r\n          deltaH: 1,\r\n          label: 'Bottom Left Crop Handle'\r\n        },\r\n        {\r\n          name: 'se',\r\n          xMul: 1,\r\n          yMul: 1,\r\n          deltaX: 0,\r\n          deltaY: 0,\r\n          deltaW: 1,\r\n          deltaH: 1,\r\n          label: 'Bottom Right Crop Handle'\r\n        }\r\n      ];\r\n      var blockers = [\r\n        'top',\r\n        'right',\r\n        'bottom',\r\n        'left'\r\n      ];\r\n      var getAbsoluteRect = function (outerRect, relativeRect) {\r\n        return {\r\n          x: relativeRect.x + outerRect.x,\r\n          y: relativeRect.y + outerRect.y,\r\n          w: relativeRect.w,\r\n          h: relativeRect.h\r\n        };\r\n      };\r\n      var getRelativeRect = function (outerRect, innerRect) {\r\n        return {\r\n          x: innerRect.x - outerRect.x,\r\n          y: innerRect.y - outerRect.y,\r\n          w: innerRect.w,\r\n          h: innerRect.h\r\n        };\r\n      };\r\n      var getInnerRect = function () {\r\n        return getRelativeRect(clampRect, currentRect);\r\n      };\r\n      var moveRect = function (handle, startRect, deltaX, deltaY) {\r\n        var x = startRect.x + deltaX * handle.deltaX;\r\n        var y = startRect.y + deltaY * handle.deltaY;\r\n        var w = Math.max(20, startRect.w + deltaX * handle.deltaW);\r\n        var h = Math.max(20, startRect.h + deltaY * handle.deltaH);\r\n        var rect = currentRect = global$4.clamp({\r\n          x: x,\r\n          y: y,\r\n          w: w,\r\n          h: h\r\n        }, clampRect, handle.name === 'move');\r\n        rect = getRelativeRect(clampRect, rect);\r\n        instance.fire('updateRect', { rect: rect });\r\n        setInnerRect(rect);\r\n      };\r\n      var render = function () {\r\n        var createDragHelper = function (handle) {\r\n          var startRect;\r\n          return DragHelper(id, {\r\n            document: containerElm.ownerDocument,\r\n            root: getRootNode(container).dom,\r\n            handle: id + '-' + handle.name,\r\n            start: function () {\r\n              startRect = currentRect;\r\n            },\r\n            drag: function (e) {\r\n              moveRect(handle, startRect, e.deltaX, e.deltaY);\r\n            }\r\n          });\r\n        };\r\n        var cropContainer = SugarElement.fromTag('div');\r\n        setAll$1(cropContainer, {\r\n          id: id,\r\n          'class': prefix + 'croprect-container',\r\n          'role': 'grid',\r\n          'aria-dropeffect': 'execute'\r\n        });\r\n        append$2(container, cropContainer);\r\n        each$1(blockers, function (blocker) {\r\n          descendant(container, '#' + id).each(function (blockerElm) {\r\n            var cropBlocker = SugarElement.fromTag('div');\r\n            setAll$1(cropBlocker, {\r\n              'id': id + '-' + blocker,\r\n              'class': prefix + 'croprect-block',\r\n              'data-mce-bogus': 'all'\r\n            });\r\n            set$7(cropBlocker, 'display', 'none');\r\n            append$2(blockerElm, cropBlocker);\r\n          });\r\n        });\r\n        each$1(handles, function (handle) {\r\n          descendant(container, '#' + id).each(function (handleElm) {\r\n            var cropHandle = SugarElement.fromTag('div');\r\n            setAll$1(cropHandle, {\r\n              'id': id + '-' + handle.name,\r\n              'aria-label': handle.label,\r\n              'aria-grabbed': 'false',\r\n              'data-mce-bogus': 'all',\r\n              'role': 'gridcell',\r\n              'tabindex': '-1',\r\n              'title': handle.label\r\n            });\r\n            add$1(cropHandle, [\r\n              prefix + 'croprect-handle',\r\n              prefix + 'croprect-handle-' + handle.name\r\n            ]);\r\n            set$7(cropHandle, 'display', 'none');\r\n            append$2(handleElm, cropHandle);\r\n          });\r\n        });\r\n        dragHelpers = map$2(handles, createDragHelper);\r\n        repaint(currentRect);\r\n        var handleFocus = function (e) {\r\n          set$8(e.target, 'aria-grabbed', e.raw.type === 'focus' ? 'true' : 'false');\r\n        };\r\n        var handleKeydown = function (e) {\r\n          var activeHandle;\r\n          each$1(handles, function (handle) {\r\n            if (get$d(e.target, 'id') === id + '-' + handle.name) {\r\n              activeHandle = handle;\r\n              return false;\r\n            }\r\n          });\r\n          var moveAndBlock = function (evt, handle, startRect, deltaX, deltaY) {\r\n            evt.stopPropagation();\r\n            evt.preventDefault();\r\n            moveRect(activeHandle, startRect, deltaX, deltaY);\r\n          };\r\n          switch (e.raw.keyCode) {\r\n          case global$2.LEFT:\r\n            moveAndBlock(e, activeHandle, currentRect, -10, 0);\r\n            break;\r\n          case global$2.RIGHT:\r\n            moveAndBlock(e, activeHandle, currentRect, 10, 0);\r\n            break;\r\n          case global$2.UP:\r\n            moveAndBlock(e, activeHandle, currentRect, 0, -10);\r\n            break;\r\n          case global$2.DOWN:\r\n            moveAndBlock(e, activeHandle, currentRect, 0, 10);\r\n            break;\r\n          case global$2.ENTER:\r\n          case global$2.SPACEBAR:\r\n            e.prevent();\r\n            action();\r\n            break;\r\n          }\r\n        };\r\n        events.push(bind(container, 'focusin', handleFocus), bind(container, 'focusout', handleFocus), bind(container, 'keydown', handleKeydown));\r\n      };\r\n      var toggleVisibility = function (state) {\r\n        var selectors = __spreadArray(__spreadArray([], map$2(handles, function (handle) {\r\n          return '#' + id + '-' + handle.name;\r\n        }), true), map$2(blockers, function (blocker) {\r\n          return '#' + id + '-' + blocker;\r\n        }), true).join(',');\r\n        var elems = descendants(container, selectors);\r\n        if (state) {\r\n          each$1(elems, function (elm) {\r\n            return remove$6(elm, 'display');\r\n          });\r\n        } else {\r\n          each$1(elems, function (elm) {\r\n            return set$7(elm, 'display', 'none');\r\n          });\r\n        }\r\n      };\r\n      var repaint = function (rect) {\r\n        var updateElementRect = function (name, newRect) {\r\n          descendant(container, '#' + id + '-' + name).each(function (elm) {\r\n            setAll(elm, {\r\n              left: newRect.x + 'px',\r\n              top: newRect.y + 'px',\r\n              width: Math.max(0, newRect.w) + 'px',\r\n              height: Math.max(0, newRect.h) + 'px'\r\n            });\r\n          });\r\n        };\r\n        each$1(handles, function (handle) {\r\n          descendant(container, '#' + id + '-' + handle.name).each(function (elm) {\r\n            setAll(elm, {\r\n              left: rect.w * handle.xMul + rect.x + 'px',\r\n              top: rect.h * handle.yMul + rect.y + 'px'\r\n            });\r\n          });\r\n        });\r\n        updateElementRect('top', {\r\n          x: viewPortRect.x,\r\n          y: viewPortRect.y,\r\n          w: viewPortRect.w,\r\n          h: rect.y - viewPortRect.y\r\n        });\r\n        updateElementRect('right', {\r\n          x: rect.x + rect.w,\r\n          y: rect.y,\r\n          w: viewPortRect.w - rect.x - rect.w + viewPortRect.x,\r\n          h: rect.h\r\n        });\r\n        updateElementRect('bottom', {\r\n          x: viewPortRect.x,\r\n          y: rect.y + rect.h,\r\n          w: viewPortRect.w,\r\n          h: viewPortRect.h - rect.y - rect.h + viewPortRect.y\r\n        });\r\n        updateElementRect('left', {\r\n          x: viewPortRect.x,\r\n          y: rect.y,\r\n          w: rect.x - viewPortRect.x,\r\n          h: rect.h\r\n        });\r\n        updateElementRect('move', rect);\r\n      };\r\n      var setRect = function (rect) {\r\n        currentRect = rect;\r\n        repaint(currentRect);\r\n      };\r\n      var setViewPortRect = function (rect) {\r\n        viewPortRect = rect;\r\n        repaint(currentRect);\r\n      };\r\n      var setInnerRect = function (rect) {\r\n        setRect(getAbsoluteRect(clampRect, rect));\r\n      };\r\n      var setClampRect = function (rect) {\r\n        clampRect = rect;\r\n        repaint(currentRect);\r\n      };\r\n      var destroy = function () {\r\n        each$1(dragHelpers, function (helper) {\r\n          return helper.destroy();\r\n        });\r\n        dragHelpers = [];\r\n        each$1(events, function (e) {\r\n          return e.unbind();\r\n        });\r\n        events = [];\r\n      };\r\n      render();\r\n      var instance = __assign(__assign({}, global$3), {\r\n        toggleVisibility: toggleVisibility,\r\n        setClampRect: setClampRect,\r\n        setRect: setRect,\r\n        getInnerRect: getInnerRect,\r\n        setInnerRect: setInnerRect,\r\n        setViewPortRect: setViewPortRect,\r\n        destroy: destroy\r\n      });\r\n      return instance;\r\n    };\r\n    var CropRect = { create: create$1 };\r\n\r\n    var loadImage = function (image) {\r\n      return new global$c(function (resolve) {\r\n        var loaded = function () {\r\n          image.removeEventListener('load', loaded);\r\n          resolve(image);\r\n        };\r\n        if (image.complete) {\r\n          resolve(image);\r\n        } else {\r\n          image.addEventListener('load', loaded);\r\n        }\r\n      });\r\n    };\r\n    var renderImagePanel = function (initialUrl) {\r\n      var memBg = record({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-image-tools__image-bg'],\r\n          attributes: { role: 'presentation' }\r\n        }\r\n      });\r\n      var zoomState = Cell(1);\r\n      var cropRect = api$1();\r\n      var rectState = Cell({\r\n        x: 0,\r\n        y: 0,\r\n        w: 1,\r\n        h: 1\r\n      });\r\n      var viewRectState = Cell({\r\n        x: 0,\r\n        y: 0,\r\n        w: 1,\r\n        h: 1\r\n      });\r\n      var repaintImg = function (anyInSystem, img) {\r\n        memContainer.getOpt(anyInSystem).each(function (panel) {\r\n          var zoom = zoomState.get();\r\n          var panelW = get$a(panel.element);\r\n          var panelH = get$b(panel.element);\r\n          var width = img.dom.naturalWidth * zoom;\r\n          var height = img.dom.naturalHeight * zoom;\r\n          var left = Math.max(0, panelW / 2 - width / 2);\r\n          var top = Math.max(0, panelH / 2 - height / 2);\r\n          var css = {\r\n            left: left.toString() + 'px',\r\n            top: top.toString() + 'px',\r\n            width: width.toString() + 'px',\r\n            height: height.toString() + 'px',\r\n            position: 'absolute'\r\n          };\r\n          setAll(img, css);\r\n          memBg.getOpt(panel).each(function (bg) {\r\n            setAll(bg.element, css);\r\n          });\r\n          cropRect.run(function (cRect) {\r\n            var rect = rectState.get();\r\n            cRect.setRect({\r\n              x: rect.x * zoom + left,\r\n              y: rect.y * zoom + top,\r\n              w: rect.w * zoom,\r\n              h: rect.h * zoom\r\n            });\r\n            cRect.setClampRect({\r\n              x: left,\r\n              y: top,\r\n              w: width,\r\n              h: height\r\n            });\r\n            cRect.setViewPortRect({\r\n              x: 0,\r\n              y: 0,\r\n              w: panelW,\r\n              h: panelH\r\n            });\r\n          });\r\n        });\r\n      };\r\n      var zoomFit = function (anyInSystem, img) {\r\n        memContainer.getOpt(anyInSystem).each(function (panel) {\r\n          var panelW = get$a(panel.element);\r\n          var panelH = get$b(panel.element);\r\n          var width = img.dom.naturalWidth;\r\n          var height = img.dom.naturalHeight;\r\n          var zoom = Math.min(panelW / width, panelH / height);\r\n          if (zoom >= 1) {\r\n            zoomState.set(1);\r\n          } else {\r\n            zoomState.set(zoom);\r\n          }\r\n        });\r\n      };\r\n      var updateSrc = function (anyInSystem, url) {\r\n        var img = SugarElement.fromTag('img');\r\n        set$8(img, 'src', url);\r\n        return loadImage(img.dom).then(function () {\r\n          if (anyInSystem.getSystem().isConnected()) {\r\n            memContainer.getOpt(anyInSystem).map(function (panel) {\r\n              var aImg = external$2({ element: img });\r\n              Replacing.replaceAt(panel, 1, Optional.some(aImg));\r\n              var lastViewRect = viewRectState.get();\r\n              var viewRect = {\r\n                x: 0,\r\n                y: 0,\r\n                w: img.dom.naturalWidth,\r\n                h: img.dom.naturalHeight\r\n              };\r\n              viewRectState.set(viewRect);\r\n              var rect = global$4.inflate(viewRect, -20, -20);\r\n              rectState.set(rect);\r\n              if (lastViewRect.w !== viewRect.w || lastViewRect.h !== viewRect.h) {\r\n                zoomFit(panel, img);\r\n              }\r\n              repaintImg(panel, img);\r\n            });\r\n          }\r\n        });\r\n      };\r\n      var zoom = function (anyInSystem, direction) {\r\n        var currentZoom = zoomState.get();\r\n        var newZoom = direction > 0 ? Math.min(2, currentZoom + 0.1) : Math.max(0.1, currentZoom - 0.1);\r\n        zoomState.set(newZoom);\r\n        memContainer.getOpt(anyInSystem).each(function (panel) {\r\n          var img = panel.components()[1].element;\r\n          repaintImg(panel, img);\r\n        });\r\n      };\r\n      var showCrop = function () {\r\n        cropRect.run(function (cRect) {\r\n          cRect.toggleVisibility(true);\r\n        });\r\n      };\r\n      var hideCrop = function () {\r\n        cropRect.run(function (cRect) {\r\n          cRect.toggleVisibility(false);\r\n        });\r\n      };\r\n      var getRect = function () {\r\n        return rectState.get();\r\n      };\r\n      var container = Container.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-image-tools__image']\r\n        },\r\n        components: [\r\n          memBg.asSpec(),\r\n          {\r\n            dom: {\r\n              tag: 'img',\r\n              attributes: { src: initialUrl }\r\n            }\r\n          },\r\n          {\r\n            dom: { tag: 'div' },\r\n            behaviours: derive$1([config('image-panel-crop-events', [\r\n                runOnAttached(function (comp) {\r\n                  memContainer.getOpt(comp).each(function (container) {\r\n                    var el = container.element.dom;\r\n                    var cRect = CropRect.create({\r\n                      x: 10,\r\n                      y: 10,\r\n                      w: 100,\r\n                      h: 100\r\n                    }, {\r\n                      x: 0,\r\n                      y: 0,\r\n                      w: 200,\r\n                      h: 200\r\n                    }, {\r\n                      x: 0,\r\n                      y: 0,\r\n                      w: 200,\r\n                      h: 200\r\n                    }, el, noop);\r\n                    cRect.toggleVisibility(false);\r\n                    cRect.on('updateRect', function (e) {\r\n                      var rect = e.rect;\r\n                      var zoom = zoomState.get();\r\n                      var newRect = {\r\n                        x: Math.round(rect.x / zoom),\r\n                        y: Math.round(rect.y / zoom),\r\n                        w: Math.round(rect.w / zoom),\r\n                        h: Math.round(rect.h / zoom)\r\n                      };\r\n                      rectState.set(newRect);\r\n                    });\r\n                    cropRect.set(cRect);\r\n                  });\r\n                }),\r\n                runOnDetached(function () {\r\n                  cropRect.clear();\r\n                })\r\n              ])])\r\n          }\r\n        ],\r\n        containerBehaviours: derive$1([\r\n          Replacing.config({}),\r\n          config('image-panel-events', [runOnAttached(function (comp) {\r\n              updateSrc(comp, initialUrl);\r\n            })])\r\n        ])\r\n      });\r\n      var memContainer = record(container);\r\n      var getMeasurements = function () {\r\n        var viewRect = viewRectState.get();\r\n        return {\r\n          width: viewRect.w,\r\n          height: viewRect.h\r\n        };\r\n      };\r\n      return {\r\n        memContainer: memContainer,\r\n        updateSrc: updateSrc,\r\n        zoom: zoom,\r\n        showCrop: showCrop,\r\n        hideCrop: hideCrop,\r\n        getRect: getRect,\r\n        getMeasurements: getMeasurements\r\n      };\r\n    };\r\n\r\n    var createButton = function (innerHtml, icon, disabled, action, providersBackstage) {\r\n      return renderIconButton({\r\n        name: innerHtml,\r\n        icon: Optional.some(icon),\r\n        disabled: disabled,\r\n        tooltip: Optional.some(innerHtml),\r\n        primary: false,\r\n        borderless: false\r\n      }, action, providersBackstage);\r\n    };\r\n    var setButtonEnabled = function (button, enabled) {\r\n      if (enabled) {\r\n        Disabling.enable(button);\r\n      } else {\r\n        Disabling.disable(button);\r\n      }\r\n    };\r\n    var renderSideBar = function (providersBackstage) {\r\n      var updateButtonUndoStates = function (anyInSystem, undoEnabled, redoEnabled) {\r\n        memUndo.getOpt(anyInSystem).each(function (undo) {\r\n          setButtonEnabled(undo, undoEnabled);\r\n        });\r\n        memRedo.getOpt(anyInSystem).each(function (redo) {\r\n          setButtonEnabled(redo, redoEnabled);\r\n        });\r\n      };\r\n      var memUndo = record(createButton('Undo', 'undo', true, function (button) {\r\n        emitWith(button, internal.undo(), { direction: 1 });\r\n      }, providersBackstage));\r\n      var memRedo = record(createButton('Redo', 'redo', true, function (button) {\r\n        emitWith(button, internal.redo(), { direction: 1 });\r\n      }, providersBackstage));\r\n      var container = Container.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [\r\n            'tox-image-tools__toolbar',\r\n            'tox-image-tools__sidebar'\r\n          ]\r\n        },\r\n        components: [\r\n          memUndo.asSpec(),\r\n          memRedo.asSpec(),\r\n          createButton('Zoom in', 'zoom-in', false, function (button) {\r\n            emitWith(button, internal.zoom(), { direction: 1 });\r\n          }, providersBackstage),\r\n          createButton('Zoom out', 'zoom-out', false, function (button) {\r\n            emitWith(button, internal.zoom(), { direction: -1 });\r\n          }, providersBackstage)\r\n        ]\r\n      });\r\n      return {\r\n        container: container,\r\n        updateButtonUndoStates: updateButtonUndoStates\r\n      };\r\n    };\r\n\r\n    function UndoStack () {\r\n      var data = [];\r\n      var index = -1;\r\n      var add = function (state) {\r\n        var removed = data.splice(++index);\r\n        data.push(state);\r\n        return {\r\n          state: state,\r\n          removed: removed\r\n        };\r\n      };\r\n      var undo = function () {\r\n        if (canUndo()) {\r\n          return data[--index];\r\n        }\r\n      };\r\n      var redo = function () {\r\n        if (canRedo()) {\r\n          return data[++index];\r\n        }\r\n      };\r\n      var canUndo = function () {\r\n        return index > 0;\r\n      };\r\n      var canRedo = function () {\r\n        return index !== -1 && index < data.length - 1;\r\n      };\r\n      return {\r\n        data: data,\r\n        add: add,\r\n        undo: undo,\r\n        redo: redo,\r\n        canUndo: canUndo,\r\n        canRedo: canRedo\r\n      };\r\n    }\r\n\r\n    var makeState = function (initialState) {\r\n      var blobState = Cell(initialState);\r\n      var tempState = value$1();\r\n      var undoStack = UndoStack();\r\n      undoStack.add(initialState);\r\n      var getBlobState = function () {\r\n        return blobState.get();\r\n      };\r\n      var setBlobState = function (state) {\r\n        blobState.set(state);\r\n      };\r\n      var getTempState = function () {\r\n        return tempState.get().getOrThunk(blobState.get);\r\n      };\r\n      var updateTempState = function (blob) {\r\n        var newTempState = createState(blob);\r\n        destroyTempState();\r\n        tempState.set(newTempState);\r\n        return newTempState.url;\r\n      };\r\n      var createState = function (blob) {\r\n        return {\r\n          blob: blob,\r\n          url: URL.createObjectURL(blob)\r\n        };\r\n      };\r\n      var destroyState = function (state) {\r\n        URL.revokeObjectURL(state.url);\r\n      };\r\n      var destroyStates = function (states) {\r\n        global$5.each(states, destroyState);\r\n      };\r\n      var destroyTempState = function () {\r\n        tempState.on(destroyState);\r\n        tempState.clear();\r\n      };\r\n      var addBlobState = function (blob) {\r\n        var newState = createState(blob);\r\n        setBlobState(newState);\r\n        var removed = undoStack.add(newState).removed;\r\n        destroyStates(removed);\r\n        return newState.url;\r\n      };\r\n      var addTempState = function (blob) {\r\n        var newState = createState(blob);\r\n        tempState.set(newState);\r\n        return newState.url;\r\n      };\r\n      var applyTempState = function (postApply) {\r\n        return tempState.get().fold(noop, function (temp) {\r\n          addBlobState(temp.blob);\r\n          postApply();\r\n        });\r\n      };\r\n      var undo = function () {\r\n        var currentState = undoStack.undo();\r\n        setBlobState(currentState);\r\n        return currentState.url;\r\n      };\r\n      var redo = function () {\r\n        var currentState = undoStack.redo();\r\n        setBlobState(currentState);\r\n        return currentState.url;\r\n      };\r\n      var getHistoryStates = function () {\r\n        var undoEnabled = undoStack.canUndo();\r\n        var redoEnabled = undoStack.canRedo();\r\n        return {\r\n          undoEnabled: undoEnabled,\r\n          redoEnabled: redoEnabled\r\n        };\r\n      };\r\n      return {\r\n        getBlobState: getBlobState,\r\n        setBlobState: setBlobState,\r\n        addBlobState: addBlobState,\r\n        getTempState: getTempState,\r\n        updateTempState: updateTempState,\r\n        addTempState: addTempState,\r\n        applyTempState: applyTempState,\r\n        destroyTempState: destroyTempState,\r\n        undo: undo,\r\n        redo: redo,\r\n        getHistoryStates: getHistoryStates\r\n      };\r\n    };\r\n\r\n    var renderImageTools = function (detail, providersBackstage) {\r\n      var state = makeState(detail.currentState);\r\n      var zoom = function (anyInSystem, simulatedEvent) {\r\n        var direction = simulatedEvent.event.direction;\r\n        imagePanel.zoom(anyInSystem, direction);\r\n      };\r\n      var updateButtonUndoStates = function (anyInSystem) {\r\n        var historyStates = state.getHistoryStates();\r\n        sideBar.updateButtonUndoStates(anyInSystem, historyStates.undoEnabled, historyStates.redoEnabled);\r\n        emitWith(anyInSystem, external.formActionEvent, {\r\n          name: external.saveState(),\r\n          value: historyStates.undoEnabled\r\n        });\r\n      };\r\n      var disableUndoRedo = function (anyInSystem) {\r\n        sideBar.updateButtonUndoStates(anyInSystem, false, false);\r\n      };\r\n      var undo = function (anyInSystem, _simulatedEvent) {\r\n        var url = state.undo();\r\n        updateSrc(anyInSystem, url).then(function (_oImg) {\r\n          unblock(anyInSystem);\r\n          updateButtonUndoStates(anyInSystem);\r\n        });\r\n      };\r\n      var redo = function (anyInSystem, _simulatedEvent) {\r\n        var url = state.redo();\r\n        updateSrc(anyInSystem, url).then(function (_oImg) {\r\n          unblock(anyInSystem);\r\n          updateButtonUndoStates(anyInSystem);\r\n        });\r\n      };\r\n      var imageResultToBlob = function (ir) {\r\n        return ir.toBlob();\r\n      };\r\n      var block = function (anyInSystem) {\r\n        emitWith(anyInSystem, external.formActionEvent, {\r\n          name: external.disable(),\r\n          value: {}\r\n        });\r\n      };\r\n      var unblock = function (anyInSystem) {\r\n        editPanel.getApplyButton(anyInSystem).each(function (applyButton) {\r\n          Disabling.enable(applyButton);\r\n        });\r\n        emitWith(anyInSystem, external.formActionEvent, {\r\n          name: external.enable(),\r\n          value: {}\r\n        });\r\n      };\r\n      var updateSrc = function (anyInSystem, src) {\r\n        block(anyInSystem);\r\n        return imagePanel.updateSrc(anyInSystem, src);\r\n      };\r\n      var blobManipulate = function (anyInSystem, blob, filter, action, swap) {\r\n        block(anyInSystem);\r\n        blobToImageResult(blob).then(filter).then(imageResultToBlob).then(action).then(function (url) {\r\n          return updateSrc(anyInSystem, url);\r\n        }).then(function () {\r\n          updateButtonUndoStates(anyInSystem);\r\n          swap();\r\n          unblock(anyInSystem);\r\n        }).catch(function (err) {\r\n          console.log(err);\r\n          if (anyInSystem.getSystem().isConnected()) {\r\n            unblock(anyInSystem);\r\n          }\r\n        });\r\n      };\r\n      var manipulate = function (anyInSystem, filter, swap) {\r\n        var blob = state.getBlobState().blob;\r\n        var action = function (blob) {\r\n          return state.updateTempState(blob);\r\n        };\r\n        blobManipulate(anyInSystem, blob, filter, action, swap);\r\n      };\r\n      var tempManipulate = function (anyInSystem, filter) {\r\n        var blob = state.getTempState().blob;\r\n        var action = function (blob) {\r\n          return state.addTempState(blob);\r\n        };\r\n        blobManipulate(anyInSystem, blob, filter, action, noop);\r\n      };\r\n      var manipulateApply = function (anyInSystem, filter, swap) {\r\n        var blob = state.getBlobState().blob;\r\n        var action = function (blob) {\r\n          var url = state.addBlobState(blob);\r\n          destroyTempState(anyInSystem);\r\n          return url;\r\n        };\r\n        blobManipulate(anyInSystem, blob, filter, action, swap);\r\n      };\r\n      var apply = function (anyInSystem, simulatedEvent) {\r\n        var postApply = function () {\r\n          destroyTempState(anyInSystem);\r\n          var swap = simulatedEvent.event.swap;\r\n          swap();\r\n        };\r\n        state.applyTempState(postApply);\r\n      };\r\n      var destroyTempState = function (anyInSystem) {\r\n        var currentUrl = state.getBlobState().url;\r\n        state.destroyTempState();\r\n        updateButtonUndoStates(anyInSystem);\r\n        return currentUrl;\r\n      };\r\n      var cancel = function (anyInSystem) {\r\n        var currentUrl = destroyTempState(anyInSystem);\r\n        updateSrc(anyInSystem, currentUrl).then(function (_oImg) {\r\n          unblock(anyInSystem);\r\n        });\r\n      };\r\n      var back = function (anyInSystem, simulatedEvent) {\r\n        cancel(anyInSystem);\r\n        var swap = simulatedEvent.event.swap;\r\n        swap();\r\n        imagePanel.hideCrop();\r\n      };\r\n      var transform = function (anyInSystem, simulatedEvent) {\r\n        return manipulate(anyInSystem, simulatedEvent.event.transform, noop);\r\n      };\r\n      var tempTransform = function (anyInSystem, simulatedEvent) {\r\n        return tempManipulate(anyInSystem, simulatedEvent.event.transform);\r\n      };\r\n      var transformApply = function (anyInSystem, simulatedEvent) {\r\n        return manipulateApply(anyInSystem, simulatedEvent.event.transform, simulatedEvent.event.swap);\r\n      };\r\n      var imagePanel = renderImagePanel(detail.currentState.url);\r\n      var sideBar = renderSideBar(providersBackstage);\r\n      var editPanel = renderEditPanel(imagePanel, providersBackstage);\r\n      var swap = function (anyInSystem, simulatedEvent) {\r\n        disableUndoRedo(anyInSystem);\r\n        var transform = simulatedEvent.event.transform;\r\n        var swap = simulatedEvent.event.swap;\r\n        transform.fold(function () {\r\n          swap();\r\n        }, function (transform) {\r\n          manipulate(anyInSystem, transform, swap);\r\n        });\r\n      };\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          attributes: { role: 'presentation' }\r\n        },\r\n        components: [\r\n          editPanel.memContainer.asSpec(),\r\n          imagePanel.memContainer.asSpec(),\r\n          sideBar.container\r\n        ],\r\n        behaviours: derive$1([\r\n          Representing.config({\r\n            store: {\r\n              mode: 'manual',\r\n              getValue: function () {\r\n                return state.getBlobState();\r\n              }\r\n            }\r\n          }),\r\n          config('image-tools-events', [\r\n            run$1(internal.undo(), undo),\r\n            run$1(internal.redo(), redo),\r\n            run$1(internal.zoom(), zoom),\r\n            run$1(internal.back(), back),\r\n            run$1(internal.apply(), apply),\r\n            run$1(internal.transform(), transform),\r\n            run$1(internal.tempTransform(), tempTransform),\r\n            run$1(internal.transformApply(), transformApply),\r\n            run$1(internal.swap(), swap)\r\n          ]),\r\n          ComposingConfigs.self()\r\n        ])\r\n      };\r\n    };\r\n\r\n    var renderLabel = function (spec, backstageShared) {\r\n      var label = {\r\n        dom: {\r\n          tag: 'label',\r\n          innerHtml: backstageShared.providers.translate(spec.label),\r\n          classes: ['tox-label']\r\n        }\r\n      };\r\n      var comps = map$2(spec.items, backstageShared.interpreter);\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-form__group']\r\n        },\r\n        components: [label].concat(comps),\r\n        behaviours: derive$1([\r\n          ComposingConfigs.self(),\r\n          Replacing.config({}),\r\n          RepresentingConfigs.domHtml(Optional.none()),\r\n          Keying.config({ mode: 'acyclic' })\r\n        ])\r\n      };\r\n    };\r\n\r\n    var isSingleListItem = function (item) {\r\n      return !has$2(item, 'items');\r\n    };\r\n    var dataAttribute = 'data-value';\r\n    var fetchItems = function (dropdownComp, name, items, selectedValue) {\r\n      return map$2(items, function (item) {\r\n        if (!isSingleListItem(item)) {\r\n          return {\r\n            type: 'nestedmenuitem',\r\n            text: item.text,\r\n            getSubmenuItems: function () {\r\n              return fetchItems(dropdownComp, name, item.items, selectedValue);\r\n            }\r\n          };\r\n        } else {\r\n          return {\r\n            type: 'togglemenuitem',\r\n            text: item.text,\r\n            value: item.value,\r\n            active: item.value === selectedValue,\r\n            onAction: function () {\r\n              Representing.setValue(dropdownComp, item.value);\r\n              emitWith(dropdownComp, formChangeEvent, { name: name });\r\n              Focusing.focus(dropdownComp);\r\n            }\r\n          };\r\n        }\r\n      });\r\n    };\r\n    var findItemByValue = function (items, value) {\r\n      return findMap(items, function (item) {\r\n        if (!isSingleListItem(item)) {\r\n          return findItemByValue(item.items, value);\r\n        } else {\r\n          return someIf(item.value === value, item);\r\n        }\r\n      });\r\n    };\r\n    var renderListBox = function (spec, backstage) {\r\n      var providersBackstage = backstage.shared.providers;\r\n      var initialItem = head(spec.items).filter(isSingleListItem);\r\n      var pLabel = spec.label.map(function (label) {\r\n        return renderLabel$2(label, providersBackstage);\r\n      });\r\n      var pField = FormField.parts.field({\r\n        dom: {},\r\n        factory: {\r\n          sketch: function (sketchSpec) {\r\n            return renderCommonDropdown({\r\n              uid: sketchSpec.uid,\r\n              text: initialItem.map(function (item) {\r\n                return item.text;\r\n              }),\r\n              icon: Optional.none(),\r\n              tooltip: spec.label,\r\n              role: Optional.none(),\r\n              fetch: function (comp, callback) {\r\n                var items = fetchItems(comp, spec.name, spec.items, Representing.getValue(comp));\r\n                callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false));\r\n              },\r\n              onSetup: constant$1(noop),\r\n              getApi: constant$1({}),\r\n              columns: 1,\r\n              presets: 'normal',\r\n              classes: [],\r\n              dropdownBehaviours: [\r\n                Tabstopping.config({}),\r\n                Representing.config({\r\n                  store: {\r\n                    mode: 'manual',\r\n                    initialValue: initialItem.map(function (item) {\r\n                      return item.value;\r\n                    }).getOr(''),\r\n                    getValue: function (comp) {\r\n                      return get$d(comp.element, dataAttribute);\r\n                    },\r\n                    setValue: function (comp, data) {\r\n                      findItemByValue(spec.items, data).each(function (item) {\r\n                        set$8(comp.element, dataAttribute, item.value);\r\n                        emitWith(comp, updateMenuText, { text: item.text });\r\n                      });\r\n                    }\r\n                  }\r\n                })\r\n              ]\r\n            }, 'tox-listbox', backstage.shared);\r\n          }\r\n        }\r\n      });\r\n      var listBoxWrap = {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-listboxfield']\r\n        },\r\n        components: [pField]\r\n      };\r\n      return FormField.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-form__group']\r\n        },\r\n        components: flatten([\r\n          pLabel.toArray(),\r\n          [listBoxWrap]\r\n        ]),\r\n        fieldBehaviours: derive$1([Disabling.config({\r\n            disabled: constant$1(spec.disabled),\r\n            onDisabled: function (comp) {\r\n              FormField.getField(comp).each(Disabling.disable);\r\n            },\r\n            onEnabled: function (comp) {\r\n              FormField.getField(comp).each(Disabling.enable);\r\n            }\r\n          })])\r\n      });\r\n    };\r\n\r\n    var renderPanel = function (spec, backstage) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: spec.classes\r\n        },\r\n        components: map$2(spec.items, backstage.shared.interpreter)\r\n      };\r\n    };\r\n\r\n    var factory$e = function (detail, _spec) {\r\n      var options = map$2(detail.options, function (option) {\r\n        return {\r\n          dom: {\r\n            tag: 'option',\r\n            value: option.value,\r\n            innerHtml: option.text\r\n          }\r\n        };\r\n      });\r\n      var initialValues = detail.data.map(function (v) {\r\n        return wrap$1('initialValue', v);\r\n      }).getOr({});\r\n      return {\r\n        uid: detail.uid,\r\n        dom: {\r\n          tag: 'select',\r\n          classes: detail.selectClasses,\r\n          attributes: detail.selectAttributes\r\n        },\r\n        components: options,\r\n        behaviours: augment(detail.selectBehaviours, [\r\n          Focusing.config({}),\r\n          Representing.config({\r\n            store: __assign({\r\n              mode: 'manual',\r\n              getValue: function (select) {\r\n                return get$5(select.element);\r\n              },\r\n              setValue: function (select, newValue) {\r\n                var found = find$5(detail.options, function (opt) {\r\n                  return opt.value === newValue;\r\n                });\r\n                if (found.isSome()) {\r\n                  set$4(select.element, newValue);\r\n                }\r\n              }\r\n            }, initialValues)\r\n          })\r\n        ])\r\n      };\r\n    };\r\n    var HtmlSelect = single({\r\n      name: 'HtmlSelect',\r\n      configFields: [\r\n        required$1('options'),\r\n        field('selectBehaviours', [\r\n          Focusing,\r\n          Representing\r\n        ]),\r\n        defaulted('selectClasses', []),\r\n        defaulted('selectAttributes', {}),\r\n        option('data')\r\n      ],\r\n      factory: factory$e\r\n    });\r\n\r\n    var renderSelectBox = function (spec, providersBackstage) {\r\n      var translatedOptions = map$2(spec.items, function (item) {\r\n        return {\r\n          text: providersBackstage.translate(item.text),\r\n          value: item.value\r\n        };\r\n      });\r\n      var pLabel = spec.label.map(function (label) {\r\n        return renderLabel$2(label, providersBackstage);\r\n      });\r\n      var pField = FormField.parts.field({\r\n        dom: {},\r\n        selectAttributes: { size: spec.size },\r\n        options: translatedOptions,\r\n        factory: HtmlSelect,\r\n        selectBehaviours: derive$1([\r\n          Disabling.config({\r\n            disabled: function () {\r\n              return spec.disabled || providersBackstage.isDisabled();\r\n            }\r\n          }),\r\n          Tabstopping.config({}),\r\n          config('selectbox-change', [run$1(change(), function (component, _) {\r\n              emitWith(component, formChangeEvent, { name: spec.name });\r\n            })])\r\n        ])\r\n      });\r\n      var chevron = spec.size > 1 ? Optional.none() : Optional.some(render$3('chevron-down', {\r\n        tag: 'div',\r\n        classes: ['tox-selectfield__icon-js']\r\n      }, providersBackstage.icons));\r\n      var selectWrap = {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-selectfield']\r\n        },\r\n        components: flatten([\r\n          [pField],\r\n          chevron.toArray()\r\n        ])\r\n      };\r\n      return FormField.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-form__group']\r\n        },\r\n        components: flatten([\r\n          pLabel.toArray(),\r\n          [selectWrap]\r\n        ]),\r\n        fieldBehaviours: derive$1([\r\n          Disabling.config({\r\n            disabled: function () {\r\n              return spec.disabled || providersBackstage.isDisabled();\r\n            },\r\n            onDisabled: function (comp) {\r\n              FormField.getField(comp).each(Disabling.disable);\r\n            },\r\n            onEnabled: function (comp) {\r\n              FormField.getField(comp).each(Disabling.enable);\r\n            }\r\n          }),\r\n          receivingConfig()\r\n        ])\r\n      });\r\n    };\r\n\r\n    var renderTable = function (spec, providersBackstage) {\r\n      var renderTh = function (text) {\r\n        return {\r\n          dom: {\r\n            tag: 'th',\r\n            innerHtml: providersBackstage.translate(text)\r\n          }\r\n        };\r\n      };\r\n      var renderHeader = function (header) {\r\n        return {\r\n          dom: { tag: 'thead' },\r\n          components: [{\r\n              dom: { tag: 'tr' },\r\n              components: map$2(header, renderTh)\r\n            }]\r\n        };\r\n      };\r\n      var renderTd = function (text) {\r\n        return {\r\n          dom: {\r\n            tag: 'td',\r\n            innerHtml: providersBackstage.translate(text)\r\n          }\r\n        };\r\n      };\r\n      var renderTr = function (row) {\r\n        return {\r\n          dom: { tag: 'tr' },\r\n          components: map$2(row, renderTd)\r\n        };\r\n      };\r\n      var renderRows = function (rows) {\r\n        return {\r\n          dom: { tag: 'tbody' },\r\n          components: map$2(rows, renderTr)\r\n        };\r\n      };\r\n      return {\r\n        dom: {\r\n          tag: 'table',\r\n          classes: ['tox-dialog__table']\r\n        },\r\n        components: [\r\n          renderHeader(spec.header),\r\n          renderRows(spec.cells)\r\n        ],\r\n        behaviours: derive$1([\r\n          Tabstopping.config({}),\r\n          Focusing.config({})\r\n        ])\r\n      };\r\n    };\r\n\r\n    var renderTextField = function (spec, providersBackstage) {\r\n      var pLabel = spec.label.map(function (label) {\r\n        return renderLabel$2(label, providersBackstage);\r\n      });\r\n      var baseInputBehaviours = [\r\n        Disabling.config({\r\n          disabled: function () {\r\n            return spec.disabled || providersBackstage.isDisabled();\r\n          }\r\n        }),\r\n        receivingConfig(),\r\n        Keying.config({\r\n          mode: 'execution',\r\n          useEnter: spec.multiline !== true,\r\n          useControlEnter: spec.multiline === true,\r\n          execute: function (comp) {\r\n            emit(comp, formSubmitEvent);\r\n            return Optional.some(true);\r\n          }\r\n        }),\r\n        config('textfield-change', [\r\n          run$1(input(), function (component, _) {\r\n            emitWith(component, formChangeEvent, { name: spec.name });\r\n          }),\r\n          run$1(postPaste(), function (component, _) {\r\n            emitWith(component, formChangeEvent, { name: spec.name });\r\n          })\r\n        ]),\r\n        Tabstopping.config({})\r\n      ];\r\n      var validatingBehaviours = spec.validation.map(function (vl) {\r\n        return Invalidating.config({\r\n          getRoot: function (input) {\r\n            return parent(input.element);\r\n          },\r\n          invalidClass: 'tox-invalid',\r\n          validator: {\r\n            validate: function (input) {\r\n              var v = Representing.getValue(input);\r\n              var result = vl.validator(v);\r\n              return Future.pure(result === true ? Result.value(v) : Result.error(result));\r\n            },\r\n            validateOnLoad: vl.validateOnLoad\r\n          }\r\n        });\r\n      }).toArray();\r\n      var placeholder = spec.placeholder.fold(constant$1({}), function (p) {\r\n        return { placeholder: providersBackstage.translate(p) };\r\n      });\r\n      var inputMode = spec.inputMode.fold(constant$1({}), function (mode) {\r\n        return { inputmode: mode };\r\n      });\r\n      var inputAttributes = __assign(__assign({}, placeholder), inputMode);\r\n      var pField = FormField.parts.field({\r\n        tag: spec.multiline === true ? 'textarea' : 'input',\r\n        inputAttributes: inputAttributes,\r\n        inputClasses: [spec.classname],\r\n        inputBehaviours: derive$1(flatten([\r\n          baseInputBehaviours,\r\n          validatingBehaviours\r\n        ])),\r\n        selectOnFocus: false,\r\n        factory: Input\r\n      });\r\n      var extraClasses = spec.flex ? ['tox-form__group--stretched'] : [];\r\n      var extraClasses2 = extraClasses.concat(spec.maximized ? ['tox-form-group--maximize'] : []);\r\n      var extraBehaviours = [\r\n        Disabling.config({\r\n          disabled: function () {\r\n            return spec.disabled || providersBackstage.isDisabled();\r\n          },\r\n          onDisabled: function (comp) {\r\n            FormField.getField(comp).each(Disabling.disable);\r\n          },\r\n          onEnabled: function (comp) {\r\n            FormField.getField(comp).each(Disabling.enable);\r\n          }\r\n        }),\r\n        receivingConfig()\r\n      ];\r\n      return renderFormFieldWith(pLabel, pField, extraClasses2, extraBehaviours);\r\n    };\r\n    var renderInput = function (spec, providersBackstage) {\r\n      return renderTextField({\r\n        name: spec.name,\r\n        multiline: false,\r\n        label: spec.label,\r\n        inputMode: spec.inputMode,\r\n        placeholder: spec.placeholder,\r\n        flex: false,\r\n        disabled: spec.disabled,\r\n        classname: 'tox-textfield',\r\n        validation: Optional.none(),\r\n        maximized: spec.maximized\r\n      }, providersBackstage);\r\n    };\r\n    var renderTextarea = function (spec, providersBackstage) {\r\n      return renderTextField({\r\n        name: spec.name,\r\n        multiline: true,\r\n        label: spec.label,\r\n        inputMode: Optional.none(),\r\n        placeholder: spec.placeholder,\r\n        flex: true,\r\n        disabled: spec.disabled,\r\n        classname: 'tox-textarea',\r\n        validation: Optional.none(),\r\n        maximized: spec.maximized\r\n      }, providersBackstage);\r\n    };\r\n\r\n    var events$6 = function (streamConfig, streamState) {\r\n      var streams = streamConfig.stream.streams;\r\n      var processor = streams.setup(streamConfig, streamState);\r\n      return derive$2([\r\n        run$1(streamConfig.event, processor),\r\n        runOnDetached(function () {\r\n          return streamState.cancel();\r\n        })\r\n      ].concat(streamConfig.cancelEvent.map(function (e) {\r\n        return [run$1(e, function () {\r\n            return streamState.cancel();\r\n          })];\r\n      }).getOr([])));\r\n    };\r\n\r\n    var ActiveStreaming = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        events: events$6\r\n    });\r\n\r\n    var throttle = function (_config) {\r\n      var state = Cell(null);\r\n      var readState = function () {\r\n        return { timer: state.get() !== null ? 'set' : 'unset' };\r\n      };\r\n      var setTimer = function (t) {\r\n        state.set(t);\r\n      };\r\n      var cancel = function () {\r\n        var t = state.get();\r\n        if (t !== null) {\r\n          t.cancel();\r\n        }\r\n      };\r\n      return nu$8({\r\n        readState: readState,\r\n        setTimer: setTimer,\r\n        cancel: cancel\r\n      });\r\n    };\r\n    var init$9 = function (spec) {\r\n      return spec.stream.streams.state(spec);\r\n    };\r\n\r\n    var StreamingState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        throttle: throttle,\r\n        init: init$9\r\n    });\r\n\r\n    var setup$c = function (streamInfo, streamState) {\r\n      var sInfo = streamInfo.stream;\r\n      var throttler = last(streamInfo.onStream, sInfo.delay);\r\n      streamState.setTimer(throttler);\r\n      return function (component, simulatedEvent) {\r\n        throttler.throttle(component, simulatedEvent);\r\n        if (sInfo.stopEvent) {\r\n          simulatedEvent.stop();\r\n        }\r\n      };\r\n    };\r\n    var StreamingSchema = [\r\n      requiredOf('stream', choose$1('mode', {\r\n        throttle: [\r\n          required$1('delay'),\r\n          defaulted('stopEvent', true),\r\n          output$1('streams', {\r\n            setup: setup$c,\r\n            state: throttle\r\n          })\r\n        ]\r\n      })),\r\n      defaulted('event', 'input'),\r\n      option('cancelEvent'),\r\n      onStrictHandler('onStream')\r\n    ];\r\n\r\n    var Streaming = create$8({\r\n      fields: StreamingSchema,\r\n      name: 'streaming',\r\n      active: ActiveStreaming,\r\n      state: StreamingState\r\n    });\r\n\r\n    var setValueFromItem = function (model, input, item) {\r\n      var itemData = Representing.getValue(item);\r\n      Representing.setValue(input, itemData);\r\n      setCursorAtEnd(input);\r\n    };\r\n    var setSelectionOn = function (input, f) {\r\n      var el = input.element;\r\n      var value = get$5(el);\r\n      var node = el.dom;\r\n      if (get$d(el, 'type') !== 'number') {\r\n        f(node, value);\r\n      }\r\n    };\r\n    var setCursorAtEnd = function (input) {\r\n      setSelectionOn(input, function (node, value) {\r\n        return node.setSelectionRange(value.length, value.length);\r\n      });\r\n    };\r\n    var setSelectionToEnd = function (input, startOffset) {\r\n      setSelectionOn(input, function (node, value) {\r\n        return node.setSelectionRange(startOffset, value.length);\r\n      });\r\n    };\r\n    var attemptSelectOver = function (model, input, item) {\r\n      if (!model.selectsOver) {\r\n        return Optional.none();\r\n      } else {\r\n        var currentValue = Representing.getValue(input);\r\n        var inputDisplay_1 = model.getDisplayText(currentValue);\r\n        var itemValue = Representing.getValue(item);\r\n        var itemDisplay = model.getDisplayText(itemValue);\r\n        return itemDisplay.indexOf(inputDisplay_1) === 0 ? Optional.some(function () {\r\n          setValueFromItem(model, input, item);\r\n          setSelectionToEnd(input, inputDisplay_1.length);\r\n        }) : Optional.none();\r\n      }\r\n    };\r\n\r\n    var itemExecute = constant$1('alloy.typeahead.itemexecute');\r\n\r\n    var make$3 = function (detail, components, spec, externals) {\r\n      var navigateList = function (comp, simulatedEvent, highlighter) {\r\n        detail.previewing.set(false);\r\n        var sandbox = Coupling.getCoupled(comp, 'sandbox');\r\n        if (Sandboxing.isOpen(sandbox)) {\r\n          Composing.getCurrent(sandbox).each(function (menu) {\r\n            Highlighting.getHighlighted(menu).fold(function () {\r\n              highlighter(menu);\r\n            }, function () {\r\n              dispatchEvent(sandbox, menu.element, 'keydown', simulatedEvent);\r\n            });\r\n          });\r\n        } else {\r\n          var onOpenSync = function (sandbox) {\r\n            Composing.getCurrent(sandbox).each(highlighter);\r\n          };\r\n          open(detail, mapFetch(comp), comp, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);\r\n        }\r\n      };\r\n      var focusBehaviours$1 = focusBehaviours(detail);\r\n      var mapFetch = function (comp) {\r\n        return function (tdata) {\r\n          return tdata.map(function (data) {\r\n            var menus = values(data.menus);\r\n            var items = bind$3(menus, function (menu) {\r\n              return filter$2(menu.items, function (item) {\r\n                return item.type === 'item';\r\n              });\r\n            });\r\n            var repState = Representing.getState(comp);\r\n            repState.update(map$2(items, function (item) {\r\n              return item.data;\r\n            }));\r\n            return data;\r\n          });\r\n        };\r\n      };\r\n      var behaviours = [\r\n        Focusing.config({}),\r\n        Representing.config({\r\n          onSetValue: detail.onSetValue,\r\n          store: __assign({\r\n            mode: 'dataset',\r\n            getDataKey: function (comp) {\r\n              return get$5(comp.element);\r\n            },\r\n            getFallbackEntry: function (itemString) {\r\n              return {\r\n                value: itemString,\r\n                meta: {}\r\n              };\r\n            },\r\n            setValue: function (comp, data) {\r\n              set$4(comp.element, detail.model.getDisplayText(data));\r\n            }\r\n          }, detail.initialData.map(function (d) {\r\n            return wrap$1('initialValue', d);\r\n          }).getOr({}))\r\n        }),\r\n        Streaming.config({\r\n          stream: {\r\n            mode: 'throttle',\r\n            delay: detail.responseTime,\r\n            stopEvent: false\r\n          },\r\n          onStream: function (component, _simulatedEvent) {\r\n            var sandbox = Coupling.getCoupled(component, 'sandbox');\r\n            var focusInInput = Focusing.isFocused(component);\r\n            if (focusInInput) {\r\n              if (get$5(component.element).length >= detail.minChars) {\r\n                var previousValue_1 = Composing.getCurrent(sandbox).bind(function (menu) {\r\n                  return Highlighting.getHighlighted(menu).map(Representing.getValue);\r\n                });\r\n                detail.previewing.set(true);\r\n                var onOpenSync = function (_sandbox) {\r\n                  Composing.getCurrent(sandbox).each(function (menu) {\r\n                    previousValue_1.fold(function () {\r\n                      if (detail.model.selectsOver) {\r\n                        Highlighting.highlightFirst(menu);\r\n                      }\r\n                    }, function (pv) {\r\n                      Highlighting.highlightBy(menu, function (item) {\r\n                        var itemData = Representing.getValue(item);\r\n                        return itemData.value === pv.value;\r\n                      });\r\n                      Highlighting.getHighlighted(menu).orThunk(function () {\r\n                        Highlighting.highlightFirst(menu);\r\n                        return Optional.none();\r\n                      });\r\n                    });\r\n                  });\r\n                };\r\n                open(detail, mapFetch(component), component, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);\r\n              }\r\n            }\r\n          },\r\n          cancelEvent: typeaheadCancel()\r\n        }),\r\n        Keying.config({\r\n          mode: 'special',\r\n          onDown: function (comp, simulatedEvent) {\r\n            navigateList(comp, simulatedEvent, Highlighting.highlightFirst);\r\n            return Optional.some(true);\r\n          },\r\n          onEscape: function (comp) {\r\n            var sandbox = Coupling.getCoupled(comp, 'sandbox');\r\n            if (Sandboxing.isOpen(sandbox)) {\r\n              Sandboxing.close(sandbox);\r\n              return Optional.some(true);\r\n            }\r\n            return Optional.none();\r\n          },\r\n          onUp: function (comp, simulatedEvent) {\r\n            navigateList(comp, simulatedEvent, Highlighting.highlightLast);\r\n            return Optional.some(true);\r\n          },\r\n          onEnter: function (comp) {\r\n            var sandbox = Coupling.getCoupled(comp, 'sandbox');\r\n            var sandboxIsOpen = Sandboxing.isOpen(sandbox);\r\n            if (sandboxIsOpen && !detail.previewing.get()) {\r\n              return Composing.getCurrent(sandbox).bind(function (menu) {\r\n                return Highlighting.getHighlighted(menu);\r\n              }).map(function (item) {\r\n                emitWith(comp, itemExecute(), { item: item });\r\n                return true;\r\n              });\r\n            } else {\r\n              var currentValue = Representing.getValue(comp);\r\n              emit(comp, typeaheadCancel());\r\n              detail.onExecute(sandbox, comp, currentValue);\r\n              if (sandboxIsOpen) {\r\n                Sandboxing.close(sandbox);\r\n              }\r\n              return Optional.some(true);\r\n            }\r\n          }\r\n        }),\r\n        Toggling.config({\r\n          toggleClass: detail.markers.openClass,\r\n          aria: { mode: 'expanded' }\r\n        }),\r\n        Coupling.config({\r\n          others: {\r\n            sandbox: function (hotspot) {\r\n              return makeSandbox$1(detail, hotspot, {\r\n                onOpen: function () {\r\n                  return Toggling.on(hotspot);\r\n                },\r\n                onClose: function () {\r\n                  return Toggling.off(hotspot);\r\n                }\r\n              });\r\n            }\r\n          }\r\n        }),\r\n        config('typeaheadevents', [\r\n          runOnExecute$1(function (comp) {\r\n            var onOpenSync = noop;\r\n            togglePopup(detail, mapFetch(comp), comp, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);\r\n          }),\r\n          run$1(itemExecute(), function (comp, se) {\r\n            var sandbox = Coupling.getCoupled(comp, 'sandbox');\r\n            setValueFromItem(detail.model, comp, se.event.item);\r\n            emit(comp, typeaheadCancel());\r\n            detail.onItemExecute(comp, sandbox, se.event.item, Representing.getValue(comp));\r\n            Sandboxing.close(sandbox);\r\n            setCursorAtEnd(comp);\r\n          })\r\n        ].concat(detail.dismissOnBlur ? [run$1(postBlur(), function (typeahead) {\r\n            var sandbox = Coupling.getCoupled(typeahead, 'sandbox');\r\n            if (search(sandbox.element).isNone()) {\r\n              Sandboxing.close(sandbox);\r\n            }\r\n          })] : []))\r\n      ];\r\n      return {\r\n        uid: detail.uid,\r\n        dom: dom(deepMerge(detail, {\r\n          inputAttributes: {\r\n            'role': 'combobox',\r\n            'aria-autocomplete': 'list',\r\n            'aria-haspopup': 'true'\r\n          }\r\n        })),\r\n        behaviours: __assign(__assign({}, focusBehaviours$1), augment(detail.typeaheadBehaviours, behaviours)),\r\n        eventOrder: detail.eventOrder\r\n      };\r\n    };\r\n\r\n    var schema$g = constant$1([\r\n      option('lazySink'),\r\n      required$1('fetch'),\r\n      defaulted('minChars', 5),\r\n      defaulted('responseTime', 1000),\r\n      onHandler('onOpen'),\r\n      defaulted('getHotspot', Optional.some),\r\n      defaulted('getAnchorOverrides', constant$1({})),\r\n      defaulted('layouts', Optional.none()),\r\n      defaulted('eventOrder', {}),\r\n      defaultedObjOf('model', {}, [\r\n        defaulted('getDisplayText', function (itemData) {\r\n          return itemData.meta !== undefined && itemData.meta.text !== undefined ? itemData.meta.text : itemData.value;\r\n        }),\r\n        defaulted('selectsOver', true),\r\n        defaulted('populateFromBrowse', true)\r\n      ]),\r\n      onHandler('onSetValue'),\r\n      onKeyboardHandler('onExecute'),\r\n      onHandler('onItemExecute'),\r\n      defaulted('inputClasses', []),\r\n      defaulted('inputAttributes', {}),\r\n      defaulted('inputStyles', {}),\r\n      defaulted('matchWidth', true),\r\n      defaulted('useMinWidth', false),\r\n      defaulted('dismissOnBlur', true),\r\n      markers$1(['openClass']),\r\n      option('initialData'),\r\n      field('typeaheadBehaviours', [\r\n        Focusing,\r\n        Representing,\r\n        Streaming,\r\n        Keying,\r\n        Toggling,\r\n        Coupling\r\n      ]),\r\n      customField('previewing', function () {\r\n        return Cell(true);\r\n      })\r\n    ].concat(schema$k()).concat(sandboxFields()));\r\n    var parts$b = constant$1([external$1({\r\n        schema: [tieredMenuMarkers()],\r\n        name: 'menu',\r\n        overrides: function (detail) {\r\n          return {\r\n            fakeFocus: true,\r\n            onHighlight: function (menu, item) {\r\n              if (!detail.previewing.get()) {\r\n                menu.getSystem().getByUid(detail.uid).each(function (input) {\r\n                  if (detail.model.populateFromBrowse) {\r\n                    setValueFromItem(detail.model, input, item);\r\n                  }\r\n                });\r\n              } else {\r\n                menu.getSystem().getByUid(detail.uid).each(function (input) {\r\n                  attemptSelectOver(detail.model, input, item).fold(function () {\r\n                    return Highlighting.dehighlight(menu, item);\r\n                  }, function (fn) {\r\n                    return fn();\r\n                  });\r\n                });\r\n              }\r\n              detail.previewing.set(false);\r\n            },\r\n            onExecute: function (menu, item) {\r\n              return menu.getSystem().getByUid(detail.uid).toOptional().map(function (typeahead) {\r\n                emitWith(typeahead, itemExecute(), { item: item });\r\n                return true;\r\n              });\r\n            },\r\n            onHover: function (menu, item) {\r\n              detail.previewing.set(false);\r\n              menu.getSystem().getByUid(detail.uid).each(function (input) {\r\n                if (detail.model.populateFromBrowse) {\r\n                  setValueFromItem(detail.model, input, item);\r\n                }\r\n              });\r\n            }\r\n          };\r\n        }\r\n      })]);\r\n\r\n    var Typeahead = composite({\r\n      name: 'Typeahead',\r\n      configFields: schema$g(),\r\n      partFields: parts$b(),\r\n      factory: make$3\r\n    });\r\n\r\n    var wrap = function (delegate) {\r\n      var toCached = function () {\r\n        return wrap(delegate.toCached());\r\n      };\r\n      var bindFuture = function (f) {\r\n        return wrap(delegate.bind(function (resA) {\r\n          return resA.fold(function (err) {\r\n            return Future.pure(Result.error(err));\r\n          }, function (a) {\r\n            return f(a);\r\n          });\r\n        }));\r\n      };\r\n      var bindResult = function (f) {\r\n        return wrap(delegate.map(function (resA) {\r\n          return resA.bind(f);\r\n        }));\r\n      };\r\n      var mapResult = function (f) {\r\n        return wrap(delegate.map(function (resA) {\r\n          return resA.map(f);\r\n        }));\r\n      };\r\n      var mapError = function (f) {\r\n        return wrap(delegate.map(function (resA) {\r\n          return resA.mapError(f);\r\n        }));\r\n      };\r\n      var foldResult = function (whenError, whenValue) {\r\n        return delegate.map(function (res) {\r\n          return res.fold(whenError, whenValue);\r\n        });\r\n      };\r\n      var withTimeout = function (timeout, errorThunk) {\r\n        return wrap(Future.nu(function (callback) {\r\n          var timedOut = false;\r\n          var timer = setTimeout(function () {\r\n            timedOut = true;\r\n            callback(Result.error(errorThunk()));\r\n          }, timeout);\r\n          delegate.get(function (result) {\r\n            if (!timedOut) {\r\n              clearTimeout(timer);\r\n              callback(result);\r\n            }\r\n          });\r\n        }));\r\n      };\r\n      return __assign(__assign({}, delegate), {\r\n        toCached: toCached,\r\n        bindFuture: bindFuture,\r\n        bindResult: bindResult,\r\n        mapResult: mapResult,\r\n        mapError: mapError,\r\n        foldResult: foldResult,\r\n        withTimeout: withTimeout\r\n      });\r\n    };\r\n    var nu$1 = function (worker) {\r\n      return wrap(Future.nu(worker));\r\n    };\r\n    var value = function (value) {\r\n      return wrap(Future.pure(Result.value(value)));\r\n    };\r\n    var error = function (error) {\r\n      return wrap(Future.pure(Result.error(error)));\r\n    };\r\n    var fromResult = function (result) {\r\n      return wrap(Future.pure(result));\r\n    };\r\n    var fromFuture = function (future) {\r\n      return wrap(future.map(Result.value));\r\n    };\r\n    var fromPromise = function (promise) {\r\n      return nu$1(function (completer) {\r\n        promise.then(function (value) {\r\n          completer(Result.value(value));\r\n        }, function (error) {\r\n          completer(Result.error(error));\r\n        });\r\n      });\r\n    };\r\n    var FutureResult = {\r\n      nu: nu$1,\r\n      wrap: wrap,\r\n      pure: value,\r\n      value: value,\r\n      error: error,\r\n      fromResult: fromResult,\r\n      fromFuture: fromFuture,\r\n      fromPromise: fromPromise\r\n    };\r\n\r\n    var separator$1 = { type: 'separator' };\r\n    var toMenuItem = function (target) {\r\n      return {\r\n        type: 'menuitem',\r\n        value: target.url,\r\n        text: target.title,\r\n        meta: { attach: target.attach },\r\n        onAction: noop\r\n      };\r\n    };\r\n    var staticMenuItem = function (title, url) {\r\n      return {\r\n        type: 'menuitem',\r\n        value: url,\r\n        text: title,\r\n        meta: { attach: undefined },\r\n        onAction: noop\r\n      };\r\n    };\r\n    var toMenuItems = function (targets) {\r\n      return map$2(targets, toMenuItem);\r\n    };\r\n    var filterLinkTargets = function (type, targets) {\r\n      return filter$2(targets, function (target) {\r\n        return target.type === type;\r\n      });\r\n    };\r\n    var filteredTargets = function (type, targets) {\r\n      return toMenuItems(filterLinkTargets(type, targets));\r\n    };\r\n    var headerTargets = function (linkInfo) {\r\n      return filteredTargets('header', linkInfo.targets);\r\n    };\r\n    var anchorTargets = function (linkInfo) {\r\n      return filteredTargets('anchor', linkInfo.targets);\r\n    };\r\n    var anchorTargetTop = function (linkInfo) {\r\n      return Optional.from(linkInfo.anchorTop).map(function (url) {\r\n        return staticMenuItem('<top>', url);\r\n      }).toArray();\r\n    };\r\n    var anchorTargetBottom = function (linkInfo) {\r\n      return Optional.from(linkInfo.anchorBottom).map(function (url) {\r\n        return staticMenuItem('<bottom>', url);\r\n      }).toArray();\r\n    };\r\n    var historyTargets = function (history) {\r\n      return map$2(history, function (url) {\r\n        return staticMenuItem(url, url);\r\n      });\r\n    };\r\n    var joinMenuLists = function (items) {\r\n      return foldl(items, function (a, b) {\r\n        var bothEmpty = a.length === 0 || b.length === 0;\r\n        return bothEmpty ? a.concat(b) : a.concat(separator$1, b);\r\n      }, []);\r\n    };\r\n    var filterByQuery = function (term, menuItems) {\r\n      var lowerCaseTerm = term.toLowerCase();\r\n      return filter$2(menuItems, function (item) {\r\n        var text = item.meta !== undefined && item.meta.text !== undefined ? item.meta.text : item.text;\r\n        return contains$1(text.toLowerCase(), lowerCaseTerm) || contains$1(item.value.toLowerCase(), lowerCaseTerm);\r\n      });\r\n    };\r\n\r\n    var getItems = function (fileType, input, urlBackstage) {\r\n      var urlInputValue = Representing.getValue(input);\r\n      var term = urlInputValue.meta.text !== undefined ? urlInputValue.meta.text : urlInputValue.value;\r\n      var info = urlBackstage.getLinkInformation();\r\n      return info.fold(function () {\r\n        return [];\r\n      }, function (linkInfo) {\r\n        var history = filterByQuery(term, historyTargets(urlBackstage.getHistory(fileType)));\r\n        return fileType === 'file' ? joinMenuLists([\r\n          history,\r\n          filterByQuery(term, headerTargets(linkInfo)),\r\n          filterByQuery(term, flatten([\r\n            anchorTargetTop(linkInfo),\r\n            anchorTargets(linkInfo),\r\n            anchorTargetBottom(linkInfo)\r\n          ]))\r\n        ]) : history;\r\n      });\r\n    };\r\n    var errorId = generate$6('aria-invalid');\r\n    var renderUrlInput = function (spec, backstage, urlBackstage) {\r\n      var _a;\r\n      var providersBackstage = backstage.shared.providers;\r\n      var updateHistory = function (component) {\r\n        var urlEntry = Representing.getValue(component);\r\n        urlBackstage.addToHistory(urlEntry.value, spec.filetype);\r\n      };\r\n      var pField = FormField.parts.field({\r\n        factory: Typeahead,\r\n        dismissOnBlur: true,\r\n        inputClasses: ['tox-textfield'],\r\n        sandboxClasses: ['tox-dialog__popups'],\r\n        inputAttributes: {\r\n          'aria-errormessage': errorId,\r\n          'type': 'url'\r\n        },\r\n        minChars: 0,\r\n        responseTime: 0,\r\n        fetch: function (input) {\r\n          var items = getItems(spec.filetype, input, urlBackstage);\r\n          var tdata = build(items, ItemResponse$1.BUBBLE_TO_SANDBOX, backstage, false);\r\n          return Future.pure(tdata);\r\n        },\r\n        getHotspot: function (comp) {\r\n          return memUrlBox.getOpt(comp);\r\n        },\r\n        onSetValue: function (comp, _newValue) {\r\n          if (comp.hasConfigured(Invalidating)) {\r\n            Invalidating.run(comp).get(noop);\r\n          }\r\n        },\r\n        typeaheadBehaviours: derive$1(flatten([\r\n          urlBackstage.getValidationHandler().map(function (handler) {\r\n            return Invalidating.config({\r\n              getRoot: function (comp) {\r\n                return parent(comp.element);\r\n              },\r\n              invalidClass: 'tox-control-wrap--status-invalid',\r\n              notify: {\r\n                onInvalid: function (comp, err) {\r\n                  memInvalidIcon.getOpt(comp).each(function (invalidComp) {\r\n                    set$8(invalidComp.element, 'title', providersBackstage.translate(err));\r\n                  });\r\n                }\r\n              },\r\n              validator: {\r\n                validate: function (input) {\r\n                  var urlEntry = Representing.getValue(input);\r\n                  return FutureResult.nu(function (completer) {\r\n                    handler({\r\n                      type: spec.filetype,\r\n                      url: urlEntry.value\r\n                    }, function (validation) {\r\n                      if (validation.status === 'invalid') {\r\n                        var err = Result.error(validation.message);\r\n                        completer(err);\r\n                      } else {\r\n                        var val = Result.value(validation.message);\r\n                        completer(val);\r\n                      }\r\n                    });\r\n                  });\r\n                },\r\n                validateOnLoad: false\r\n              }\r\n            });\r\n          }).toArray(),\r\n          [\r\n            Disabling.config({\r\n              disabled: function () {\r\n                return spec.disabled || providersBackstage.isDisabled();\r\n              }\r\n            }),\r\n            Tabstopping.config({}),\r\n            config('urlinput-events', flatten([\r\n              spec.filetype === 'file' ? [run$1(input(), function (comp) {\r\n                  emitWith(comp, formChangeEvent, { name: spec.name });\r\n                })] : [],\r\n              [\r\n                run$1(change(), function (comp) {\r\n                  emitWith(comp, formChangeEvent, { name: spec.name });\r\n                  updateHistory(comp);\r\n                }),\r\n                run$1(postPaste(), function (comp) {\r\n                  emitWith(comp, formChangeEvent, { name: spec.name });\r\n                  updateHistory(comp);\r\n                })\r\n              ]\r\n            ]))\r\n          ]\r\n        ])),\r\n        eventOrder: (_a = {}, _a[input()] = [\r\n          'streaming',\r\n          'urlinput-events',\r\n          'invalidating'\r\n        ], _a),\r\n        model: {\r\n          getDisplayText: function (itemData) {\r\n            return itemData.value;\r\n          },\r\n          selectsOver: false,\r\n          populateFromBrowse: false\r\n        },\r\n        markers: { openClass: 'tox-textfield--popup-open' },\r\n        lazySink: backstage.shared.getSink,\r\n        parts: { menu: part(false, 1, 'normal') },\r\n        onExecute: function (_menu, component, _entry) {\r\n          emitWith(component, formSubmitEvent, {});\r\n        },\r\n        onItemExecute: function (typeahead, _sandbox, _item, _value) {\r\n          updateHistory(typeahead);\r\n          emitWith(typeahead, formChangeEvent, { name: spec.name });\r\n        }\r\n      });\r\n      var pLabel = spec.label.map(function (label) {\r\n        return renderLabel$2(label, providersBackstage);\r\n      });\r\n      var makeIcon = function (name, errId, icon, label) {\r\n        if (icon === void 0) {\r\n          icon = name;\r\n        }\r\n        if (label === void 0) {\r\n          label = name;\r\n        }\r\n        return render$3(icon, {\r\n          tag: 'div',\r\n          classes: [\r\n            'tox-icon',\r\n            'tox-control-wrap__status-icon-' + name\r\n          ],\r\n          attributes: __assign({\r\n            'title': providersBackstage.translate(label),\r\n            'aria-live': 'polite'\r\n          }, errId.fold(function () {\r\n            return {};\r\n          }, function (id) {\r\n            return { id: id };\r\n          }))\r\n        }, providersBackstage.icons);\r\n      };\r\n      var memInvalidIcon = record(makeIcon('invalid', Optional.some(errorId), 'warning'));\r\n      var memStatus = record({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-control-wrap__status-icon-wrap']\r\n        },\r\n        components: [memInvalidIcon.asSpec()]\r\n      });\r\n      var optUrlPicker = urlBackstage.getUrlPicker(spec.filetype);\r\n      var browseUrlEvent = generate$6('browser.url.event');\r\n      var memUrlBox = record({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-control-wrap']\r\n        },\r\n        components: [\r\n          pField,\r\n          memStatus.asSpec()\r\n        ],\r\n        behaviours: derive$1([Disabling.config({\r\n            disabled: function () {\r\n              return spec.disabled || providersBackstage.isDisabled();\r\n            }\r\n          })])\r\n      });\r\n      var memUrlPickerButton = record(renderButton({\r\n        name: spec.name,\r\n        icon: Optional.some('browse'),\r\n        text: spec.label.getOr(''),\r\n        disabled: spec.disabled,\r\n        primary: false,\r\n        borderless: true\r\n      }, function (component) {\r\n        return emit(component, browseUrlEvent);\r\n      }, providersBackstage, [], ['tox-browse-url']));\r\n      var controlHWrapper = function () {\r\n        return {\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-form__controls-h-stack']\r\n          },\r\n          components: flatten([\r\n            [memUrlBox.asSpec()],\r\n            optUrlPicker.map(function () {\r\n              return memUrlPickerButton.asSpec();\r\n            }).toArray()\r\n          ])\r\n        };\r\n      };\r\n      var openUrlPicker = function (comp) {\r\n        Composing.getCurrent(comp).each(function (field) {\r\n          var componentData = Representing.getValue(field);\r\n          var urlData = __assign({ fieldname: spec.name }, componentData);\r\n          optUrlPicker.each(function (picker) {\r\n            picker(urlData).get(function (chosenData) {\r\n              Representing.setValue(field, chosenData);\r\n              emitWith(comp, formChangeEvent, { name: spec.name });\r\n            });\r\n          });\r\n        });\r\n      };\r\n      return FormField.sketch({\r\n        dom: renderFormFieldDom(),\r\n        components: pLabel.toArray().concat([controlHWrapper()]),\r\n        fieldBehaviours: derive$1([\r\n          Disabling.config({\r\n            disabled: function () {\r\n              return spec.disabled || providersBackstage.isDisabled();\r\n            },\r\n            onDisabled: function (comp) {\r\n              FormField.getField(comp).each(Disabling.disable);\r\n              memUrlPickerButton.getOpt(comp).each(Disabling.disable);\r\n            },\r\n            onEnabled: function (comp) {\r\n              FormField.getField(comp).each(Disabling.enable);\r\n              memUrlPickerButton.getOpt(comp).each(Disabling.enable);\r\n            }\r\n          }),\r\n          receivingConfig(),\r\n          config('url-input-events', [run$1(browseUrlEvent, openUrlPicker)])\r\n        ])\r\n      });\r\n    };\r\n\r\n    var renderAlertBanner = function (spec, providersBackstage) {\r\n      return Container.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          attributes: { role: 'alert' },\r\n          classes: [\r\n            'tox-notification',\r\n            'tox-notification--in',\r\n            'tox-notification--' + spec.level\r\n          ]\r\n        },\r\n        components: [\r\n          {\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-notification__icon']\r\n            },\r\n            components: [Button.sketch({\r\n                dom: {\r\n                  tag: 'button',\r\n                  classes: [\r\n                    'tox-button',\r\n                    'tox-button--naked',\r\n                    'tox-button--icon'\r\n                  ],\r\n                  innerHtml: get$1(spec.icon, providersBackstage.icons),\r\n                  attributes: { title: providersBackstage.translate(spec.iconTooltip) }\r\n                },\r\n                action: function (comp) {\r\n                  emitWith(comp, formActionEvent, {\r\n                    name: 'alert-banner',\r\n                    value: spec.url\r\n                  });\r\n                },\r\n                buttonBehaviours: derive$1([addFocusableBehaviour()])\r\n              })]\r\n          },\r\n          {\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-notification__body'],\r\n              innerHtml: providersBackstage.translate(spec.text)\r\n            }\r\n          }\r\n        ]\r\n      });\r\n    };\r\n\r\n    var renderCheckbox = function (spec, providerBackstage) {\r\n      var repBehaviour = Representing.config({\r\n        store: {\r\n          mode: 'manual',\r\n          getValue: function (comp) {\r\n            var el = comp.element.dom;\r\n            return el.checked;\r\n          },\r\n          setValue: function (comp, value) {\r\n            var el = comp.element.dom;\r\n            el.checked = value;\r\n          }\r\n        }\r\n      });\r\n      var toggleCheckboxHandler = function (comp) {\r\n        comp.element.dom.click();\r\n        return Optional.some(true);\r\n      };\r\n      var pField = FormField.parts.field({\r\n        factory: { sketch: identity$1 },\r\n        dom: {\r\n          tag: 'input',\r\n          classes: ['tox-checkbox__input'],\r\n          attributes: { type: 'checkbox' }\r\n        },\r\n        behaviours: derive$1([\r\n          ComposingConfigs.self(),\r\n          Disabling.config({\r\n            disabled: function () {\r\n              return spec.disabled || providerBackstage.isDisabled();\r\n            }\r\n          }),\r\n          Tabstopping.config({}),\r\n          Focusing.config({}),\r\n          repBehaviour,\r\n          Keying.config({\r\n            mode: 'special',\r\n            onEnter: toggleCheckboxHandler,\r\n            onSpace: toggleCheckboxHandler,\r\n            stopSpaceKeyup: true\r\n          }),\r\n          config('checkbox-events', [run$1(change(), function (component, _) {\r\n              emitWith(component, formChangeEvent, { name: spec.name });\r\n            })])\r\n        ])\r\n      });\r\n      var pLabel = FormField.parts.label({\r\n        dom: {\r\n          tag: 'span',\r\n          classes: ['tox-checkbox__label'],\r\n          innerHtml: providerBackstage.translate(spec.label)\r\n        },\r\n        behaviours: derive$1([Unselecting.config({})])\r\n      });\r\n      var makeIcon = function (className) {\r\n        var iconName = className === 'checked' ? 'selected' : 'unselected';\r\n        return render$3(iconName, {\r\n          tag: 'span',\r\n          classes: [\r\n            'tox-icon',\r\n            'tox-checkbox-icon__' + className\r\n          ]\r\n        }, providerBackstage.icons);\r\n      };\r\n      var memIcons = record({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-checkbox__icons']\r\n        },\r\n        components: [\r\n          makeIcon('checked'),\r\n          makeIcon('unchecked')\r\n        ]\r\n      });\r\n      return FormField.sketch({\r\n        dom: {\r\n          tag: 'label',\r\n          classes: ['tox-checkbox']\r\n        },\r\n        components: [\r\n          pField,\r\n          memIcons.asSpec(),\r\n          pLabel\r\n        ],\r\n        fieldBehaviours: derive$1([\r\n          Disabling.config({\r\n            disabled: function () {\r\n              return spec.disabled || providerBackstage.isDisabled();\r\n            },\r\n            disableClass: 'tox-checkbox--disabled',\r\n            onDisabled: function (comp) {\r\n              FormField.getField(comp).each(Disabling.disable);\r\n            },\r\n            onEnabled: function (comp) {\r\n              FormField.getField(comp).each(Disabling.enable);\r\n            }\r\n          }),\r\n          receivingConfig()\r\n        ])\r\n      });\r\n    };\r\n\r\n    var renderHtmlPanel = function (spec) {\r\n      if (spec.presets === 'presentation') {\r\n        return Container.sketch({\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-form__group'],\r\n            innerHtml: spec.html\r\n          }\r\n        });\r\n      } else {\r\n        return Container.sketch({\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-form__group'],\r\n            innerHtml: spec.html,\r\n            attributes: { role: 'document' }\r\n          },\r\n          containerBehaviours: derive$1([\r\n            Tabstopping.config({}),\r\n            Focusing.config({})\r\n          ])\r\n        });\r\n      }\r\n    };\r\n\r\n    var make$2 = function (render) {\r\n      return function (parts, spec, backstage) {\r\n        return get$e(spec, 'name').fold(function () {\r\n          return render(spec, backstage);\r\n        }, function (fieldName) {\r\n          return parts.field(fieldName, render(spec, backstage));\r\n        });\r\n      };\r\n    };\r\n    var makeIframe = function (render) {\r\n      return function (parts, spec, backstage) {\r\n        var iframeSpec = deepMerge(spec, { source: 'dynamic' });\r\n        return make$2(render)(parts, iframeSpec, backstage);\r\n      };\r\n    };\r\n    var factories = {\r\n      bar: make$2(function (spec, backstage) {\r\n        return renderBar(spec, backstage.shared);\r\n      }),\r\n      collection: make$2(function (spec, backstage) {\r\n        return renderCollection(spec, backstage.shared.providers);\r\n      }),\r\n      alertbanner: make$2(function (spec, backstage) {\r\n        return renderAlertBanner(spec, backstage.shared.providers);\r\n      }),\r\n      input: make$2(function (spec, backstage) {\r\n        return renderInput(spec, backstage.shared.providers);\r\n      }),\r\n      textarea: make$2(function (spec, backstage) {\r\n        return renderTextarea(spec, backstage.shared.providers);\r\n      }),\r\n      label: make$2(function (spec, backstage) {\r\n        return renderLabel(spec, backstage.shared);\r\n      }),\r\n      iframe: makeIframe(function (spec, backstage) {\r\n        return renderIFrame(spec, backstage.shared.providers);\r\n      }),\r\n      button: make$2(function (spec, backstage) {\r\n        return renderDialogButton(spec, backstage.shared.providers);\r\n      }),\r\n      checkbox: make$2(function (spec, backstage) {\r\n        return renderCheckbox(spec, backstage.shared.providers);\r\n      }),\r\n      colorinput: make$2(function (spec, backstage) {\r\n        return renderColorInput(spec, backstage.shared, backstage.colorinput);\r\n      }),\r\n      colorpicker: make$2(renderColorPicker),\r\n      dropzone: make$2(function (spec, backstage) {\r\n        return renderDropZone(spec, backstage.shared.providers);\r\n      }),\r\n      grid: make$2(function (spec, backstage) {\r\n        return renderGrid(spec, backstage.shared);\r\n      }),\r\n      listbox: make$2(function (spec, backstage) {\r\n        return renderListBox(spec, backstage);\r\n      }),\r\n      selectbox: make$2(function (spec, backstage) {\r\n        return renderSelectBox(spec, backstage.shared.providers);\r\n      }),\r\n      sizeinput: make$2(function (spec, backstage) {\r\n        return renderSizeInput(spec, backstage.shared.providers);\r\n      }),\r\n      urlinput: make$2(function (spec, backstage) {\r\n        return renderUrlInput(spec, backstage, backstage.urlinput);\r\n      }),\r\n      customeditor: make$2(renderCustomEditor),\r\n      htmlpanel: make$2(renderHtmlPanel),\r\n      imagetools: make$2(function (spec, backstage) {\r\n        return renderImageTools(spec, backstage.shared.providers);\r\n      }),\r\n      table: make$2(function (spec, backstage) {\r\n        return renderTable(spec, backstage.shared.providers);\r\n      }),\r\n      panel: make$2(function (spec, backstage) {\r\n        return renderPanel(spec, backstage);\r\n      })\r\n    };\r\n    var noFormParts = {\r\n      field: function (_name, spec) {\r\n        return spec;\r\n      }\r\n    };\r\n    var interpretInForm = function (parts, spec, oldBackstage) {\r\n      var newBackstage = deepMerge(oldBackstage, {\r\n        shared: {\r\n          interpreter: function (childSpec) {\r\n            return interpretParts(parts, childSpec, newBackstage);\r\n          }\r\n        }\r\n      });\r\n      return interpretParts(parts, spec, newBackstage);\r\n    };\r\n    var interpretParts = function (parts, spec, backstage) {\r\n      return get$e(factories, spec.type).fold(function () {\r\n        console.error('Unknown factory type \"' + spec.type + '\", defaulting to container: ', spec);\r\n        return spec;\r\n      }, function (factory) {\r\n        return factory(parts, spec, backstage);\r\n      });\r\n    };\r\n    var interpretWithoutForm = function (spec, backstage) {\r\n      var parts = noFormParts;\r\n      return interpretParts(parts, spec, backstage);\r\n    };\r\n\r\n    var bubbleAlignments$2 = {\r\n      valignCentre: [],\r\n      alignCentre: [],\r\n      alignLeft: [],\r\n      alignRight: [],\r\n      right: [],\r\n      left: [],\r\n      bottom: [],\r\n      top: []\r\n    };\r\n    var getInlineDialogAnchor = function (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) {\r\n      var bubbleSize = 12;\r\n      var overrides = { maxHeightFunction: expandable$1() };\r\n      var editableAreaAnchor = function () {\r\n        return {\r\n          type: 'node',\r\n          root: getContentContainer(contentAreaElement()),\r\n          node: Optional.from(contentAreaElement()),\r\n          bubble: nu$5(bubbleSize, bubbleSize, bubbleAlignments$2),\r\n          layouts: {\r\n            onRtl: function () {\r\n              return [northeast];\r\n            },\r\n            onLtr: function () {\r\n              return [northwest];\r\n            }\r\n          },\r\n          overrides: overrides\r\n        };\r\n      };\r\n      var standardAnchor = function () {\r\n        return {\r\n          type: 'hotspot',\r\n          hotspot: lazyAnchorbar(),\r\n          bubble: nu$5(-bubbleSize, bubbleSize, bubbleAlignments$2),\r\n          layouts: {\r\n            onRtl: function () {\r\n              return [southeast$2];\r\n            },\r\n            onLtr: function () {\r\n              return [southwest$2];\r\n            }\r\n          },\r\n          overrides: overrides\r\n        };\r\n      };\r\n      return function () {\r\n        return lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();\r\n      };\r\n    };\r\n    var getBannerAnchor = function (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) {\r\n      var editableAreaAnchor = function () {\r\n        return {\r\n          type: 'node',\r\n          root: getContentContainer(contentAreaElement()),\r\n          node: Optional.from(contentAreaElement()),\r\n          layouts: {\r\n            onRtl: function () {\r\n              return [north];\r\n            },\r\n            onLtr: function () {\r\n              return [north];\r\n            }\r\n          }\r\n        };\r\n      };\r\n      var standardAnchor = function () {\r\n        return {\r\n          type: 'hotspot',\r\n          hotspot: lazyAnchorbar(),\r\n          layouts: {\r\n            onRtl: function () {\r\n              return [south$2];\r\n            },\r\n            onLtr: function () {\r\n              return [south$2];\r\n            }\r\n          }\r\n        };\r\n      };\r\n      return function () {\r\n        return lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();\r\n      };\r\n    };\r\n    var getCursorAnchor = function (editor, bodyElement) {\r\n      return function () {\r\n        return {\r\n          type: 'selection',\r\n          root: bodyElement(),\r\n          getSelection: function () {\r\n            var rng = editor.selection.getRng();\r\n            return Optional.some(SimSelection.range(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\r\n          }\r\n        };\r\n      };\r\n    };\r\n    var getNodeAnchor$1 = function (bodyElement) {\r\n      return function (element) {\r\n        return {\r\n          type: 'node',\r\n          root: bodyElement(),\r\n          node: element\r\n        };\r\n      };\r\n    };\r\n    var getAnchors = function (editor, lazyAnchorbar, isToolbarTop) {\r\n      var useFixedToolbarContainer = useFixedContainer(editor);\r\n      var bodyElement = function () {\r\n        return SugarElement.fromDom(editor.getBody());\r\n      };\r\n      var contentAreaElement = function () {\r\n        return SugarElement.fromDom(editor.getContentAreaContainer());\r\n      };\r\n      var lazyUseEditableAreaAnchor = function () {\r\n        return useFixedToolbarContainer || !isToolbarTop();\r\n      };\r\n      return {\r\n        inlineDialog: getInlineDialogAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),\r\n        banner: getBannerAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),\r\n        cursor: getCursorAnchor(editor, bodyElement),\r\n        node: getNodeAnchor$1(bodyElement)\r\n      };\r\n    };\r\n\r\n    var colorPicker = function (editor) {\r\n      return function (callback, value) {\r\n        var dialog = colorPickerDialog(editor);\r\n        dialog(callback, value);\r\n      };\r\n    };\r\n    var hasCustomColors = function (editor) {\r\n      return function () {\r\n        return hasCustomColors$1(editor);\r\n      };\r\n    };\r\n    var getColors = function (editor) {\r\n      return function () {\r\n        return getColors$2(editor);\r\n      };\r\n    };\r\n    var getColorCols = function (editor) {\r\n      return function () {\r\n        return getColorCols$1(editor);\r\n      };\r\n    };\r\n    var ColorInputBackstage = function (editor) {\r\n      return {\r\n        colorPicker: colorPicker(editor),\r\n        hasCustomColors: hasCustomColors(editor),\r\n        getColors: getColors(editor),\r\n        getColorCols: getColorCols(editor)\r\n      };\r\n    };\r\n\r\n    var isDraggableModal = function (editor) {\r\n      return function () {\r\n        return isDraggableModal$1(editor);\r\n      };\r\n    };\r\n    var DialogBackstage = function (editor) {\r\n      return { isDraggableModal: isDraggableModal(editor) };\r\n    };\r\n\r\n    var HeaderBackstage = function (editor) {\r\n      var mode = Cell(isToolbarLocationBottom(editor) ? 'bottom' : 'top');\r\n      return {\r\n        isPositionedAtTop: function () {\r\n          return mode.get() === 'top';\r\n        },\r\n        getDockingMode: mode.get,\r\n        setDockingMode: mode.set\r\n      };\r\n    };\r\n\r\n    var defaultStyleFormats = [\r\n      {\r\n        title: 'Headings',\r\n        items: [\r\n          {\r\n            title: 'Heading 1',\r\n            format: 'h1'\r\n          },\r\n          {\r\n            title: 'Heading 2',\r\n            format: 'h2'\r\n          },\r\n          {\r\n            title: 'Heading 3',\r\n            format: 'h3'\r\n          },\r\n          {\r\n            title: 'Heading 4',\r\n            format: 'h4'\r\n          },\r\n          {\r\n            title: 'Heading 5',\r\n            format: 'h5'\r\n          },\r\n          {\r\n            title: 'Heading 6',\r\n            format: 'h6'\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        title: 'Inline',\r\n        items: [\r\n          {\r\n            title: 'Bold',\r\n            format: 'bold'\r\n          },\r\n          {\r\n            title: 'Italic',\r\n            format: 'italic'\r\n          },\r\n          {\r\n            title: 'Underline',\r\n            format: 'underline'\r\n          },\r\n          {\r\n            title: 'Strikethrough',\r\n            format: 'strikethrough'\r\n          },\r\n          {\r\n            title: 'Superscript',\r\n            format: 'superscript'\r\n          },\r\n          {\r\n            title: 'Subscript',\r\n            format: 'subscript'\r\n          },\r\n          {\r\n            title: 'Code',\r\n            format: 'code'\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        title: 'Blocks',\r\n        items: [\r\n          {\r\n            title: 'Paragraph',\r\n            format: 'p'\r\n          },\r\n          {\r\n            title: 'Blockquote',\r\n            format: 'blockquote'\r\n          },\r\n          {\r\n            title: 'Div',\r\n            format: 'div'\r\n          },\r\n          {\r\n            title: 'Pre',\r\n            format: 'pre'\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        title: 'Align',\r\n        items: [\r\n          {\r\n            title: 'Left',\r\n            format: 'alignleft'\r\n          },\r\n          {\r\n            title: 'Center',\r\n            format: 'aligncenter'\r\n          },\r\n          {\r\n            title: 'Right',\r\n            format: 'alignright'\r\n          },\r\n          {\r\n            title: 'Justify',\r\n            format: 'alignjustify'\r\n          }\r\n        ]\r\n      }\r\n    ];\r\n    var isNestedFormat = function (format) {\r\n      return has$2(format, 'items');\r\n    };\r\n    var isBlockFormat = function (format) {\r\n      return has$2(format, 'block');\r\n    };\r\n    var isInlineFormat = function (format) {\r\n      return has$2(format, 'inline');\r\n    };\r\n    var isSelectorFormat = function (format) {\r\n      return has$2(format, 'selector');\r\n    };\r\n    var mapFormats = function (userFormats) {\r\n      return foldl(userFormats, function (acc, fmt) {\r\n        if (isNestedFormat(fmt)) {\r\n          var result = mapFormats(fmt.items);\r\n          return {\r\n            customFormats: acc.customFormats.concat(result.customFormats),\r\n            formats: acc.formats.concat([{\r\n                title: fmt.title,\r\n                items: result.formats\r\n              }])\r\n          };\r\n        } else if (isInlineFormat(fmt) || isBlockFormat(fmt) || isSelectorFormat(fmt)) {\r\n          var formatName = isString(fmt.name) ? fmt.name : fmt.title.toLowerCase();\r\n          var formatNameWithPrefix = 'custom-' + formatName;\r\n          return {\r\n            customFormats: acc.customFormats.concat([{\r\n                name: formatNameWithPrefix,\r\n                format: fmt\r\n              }]),\r\n            formats: acc.formats.concat([{\r\n                title: fmt.title,\r\n                format: formatNameWithPrefix,\r\n                icon: fmt.icon\r\n              }])\r\n          };\r\n        } else {\r\n          return __assign(__assign({}, acc), { formats: acc.formats.concat(fmt) });\r\n        }\r\n      }, {\r\n        customFormats: [],\r\n        formats: []\r\n      });\r\n    };\r\n    var registerCustomFormats = function (editor, userFormats) {\r\n      var result = mapFormats(userFormats);\r\n      var registerFormats = function (customFormats) {\r\n        each$1(customFormats, function (fmt) {\r\n          if (!editor.formatter.has(fmt.name)) {\r\n            editor.formatter.register(fmt.name, fmt.format);\r\n          }\r\n        });\r\n      };\r\n      if (editor.formatter) {\r\n        registerFormats(result.customFormats);\r\n      } else {\r\n        editor.on('init', function () {\r\n          registerFormats(result.customFormats);\r\n        });\r\n      }\r\n      return result.formats;\r\n    };\r\n    var getStyleFormats = function (editor) {\r\n      return getUserStyleFormats(editor).map(function (userFormats) {\r\n        var registeredUserFormats = registerCustomFormats(editor, userFormats);\r\n        return isMergeStyleFormats(editor) ? defaultStyleFormats.concat(registeredUserFormats) : registeredUserFormats;\r\n      }).getOr(defaultStyleFormats);\r\n    };\r\n\r\n    var processBasic = function (item, isSelectedFor, getPreviewFor) {\r\n      var formatterSpec = {\r\n        type: 'formatter',\r\n        isSelected: isSelectedFor(item.format),\r\n        getStylePreview: getPreviewFor(item.format)\r\n      };\r\n      return deepMerge(item, formatterSpec);\r\n    };\r\n    var register$8 = function (editor, formats, isSelectedFor, getPreviewFor) {\r\n      var enrichSupported = function (item) {\r\n        return processBasic(item, isSelectedFor, getPreviewFor);\r\n      };\r\n      var enrichMenu = function (item) {\r\n        var submenuSpec = { type: 'submenu' };\r\n        return deepMerge(item, submenuSpec);\r\n      };\r\n      var enrichCustom = function (item) {\r\n        var formatName = isString(item.name) ? item.name : generate$6(item.title);\r\n        var formatNameWithPrefix = 'custom-' + formatName;\r\n        var customSpec = {\r\n          type: 'formatter',\r\n          format: formatNameWithPrefix,\r\n          isSelected: isSelectedFor(formatNameWithPrefix),\r\n          getStylePreview: getPreviewFor(formatNameWithPrefix)\r\n        };\r\n        var newItem = deepMerge(item, customSpec);\r\n        editor.formatter.register(formatName, newItem);\r\n        return newItem;\r\n      };\r\n      var doEnrich = function (items) {\r\n        return map$2(items, function (item) {\r\n          var keys$1 = keys(item);\r\n          if (hasNonNullableKey(item, 'items')) {\r\n            var newItems = doEnrich(item.items);\r\n            return deepMerge(enrichMenu(item), { getStyleItems: constant$1(newItems) });\r\n          } else if (hasNonNullableKey(item, 'format')) {\r\n            return enrichSupported(item);\r\n          } else if (keys$1.length === 1 && contains$2(keys$1, 'title')) {\r\n            return deepMerge(item, { type: 'separator' });\r\n          } else {\r\n            return enrichCustom(item);\r\n          }\r\n        });\r\n      };\r\n      return doEnrich(formats);\r\n    };\r\n\r\n    var init$8 = function (editor) {\r\n      var isSelectedFor = function (format) {\r\n        return function () {\r\n          return editor.formatter.match(format);\r\n        };\r\n      };\r\n      var getPreviewFor = function (format) {\r\n        return function () {\r\n          var fmt = editor.formatter.get(format);\r\n          return fmt !== undefined ? Optional.some({\r\n            tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',\r\n            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))\r\n          }) : Optional.none();\r\n        };\r\n      };\r\n      var flatten = function (fmt) {\r\n        var subs = fmt.items;\r\n        return subs !== undefined && subs.length > 0 ? bind$3(subs, flatten) : [fmt.format];\r\n      };\r\n      var settingsFormats = Cell([]);\r\n      var settingsFlattenedFormats = Cell([]);\r\n      var eventsFormats = Cell([]);\r\n      var eventsFlattenedFormats = Cell([]);\r\n      var replaceSettings = Cell(false);\r\n      editor.on('PreInit', function (_e) {\r\n        var formats = getStyleFormats(editor);\r\n        var enriched = register$8(editor, formats, isSelectedFor, getPreviewFor);\r\n        settingsFormats.set(enriched);\r\n        settingsFlattenedFormats.set(bind$3(enriched, flatten));\r\n      });\r\n      editor.on('addStyleModifications', function (e) {\r\n        var modifications = register$8(editor, e.items, isSelectedFor, getPreviewFor);\r\n        eventsFormats.set(modifications);\r\n        replaceSettings.set(e.replace);\r\n        eventsFlattenedFormats.set(bind$3(modifications, flatten));\r\n      });\r\n      var getData = function () {\r\n        var fromSettings = replaceSettings.get() ? [] : settingsFormats.get();\r\n        var fromEvents = eventsFormats.get();\r\n        return fromSettings.concat(fromEvents);\r\n      };\r\n      var getFlattenedKeys = function () {\r\n        var fromSettings = replaceSettings.get() ? [] : settingsFlattenedFormats.get();\r\n        var fromEvents = eventsFlattenedFormats.get();\r\n        return fromSettings.concat(fromEvents);\r\n      };\r\n      return {\r\n        getData: getData,\r\n        getFlattenedKeys: getFlattenedKeys\r\n      };\r\n    };\r\n\r\n    var isElement = function (node) {\r\n      return isNonNullable(node) && node.nodeType === 1;\r\n    };\r\n    var trim = global$5.trim;\r\n    var hasContentEditableState = function (value) {\r\n      return function (node) {\r\n        if (isElement(node)) {\r\n          if (node.contentEditable === value) {\r\n            return true;\r\n          }\r\n          if (node.getAttribute('data-mce-contenteditable') === value) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n    };\r\n    var isContentEditableTrue = hasContentEditableState('true');\r\n    var isContentEditableFalse = hasContentEditableState('false');\r\n    var create = function (type, title, url, level, attach) {\r\n      return {\r\n        type: type,\r\n        title: title,\r\n        url: url,\r\n        level: level,\r\n        attach: attach\r\n      };\r\n    };\r\n    var isChildOfContentEditableTrue = function (node) {\r\n      while (node = node.parentNode) {\r\n        var value = node.contentEditable;\r\n        if (value && value !== 'inherit') {\r\n          return isContentEditableTrue(node);\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var select = function (selector, root) {\r\n      return map$2(descendants(SugarElement.fromDom(root), selector), function (element) {\r\n        return element.dom;\r\n      });\r\n    };\r\n    var getElementText = function (elm) {\r\n      return elm.innerText || elm.textContent;\r\n    };\r\n    var getOrGenerateId = function (elm) {\r\n      return elm.id ? elm.id : generate$6('h');\r\n    };\r\n    var isAnchor = function (elm) {\r\n      return elm && elm.nodeName === 'A' && (elm.id || elm.name) !== undefined;\r\n    };\r\n    var isValidAnchor = function (elm) {\r\n      return isAnchor(elm) && isEditable(elm);\r\n    };\r\n    var isHeader = function (elm) {\r\n      return elm && /^(H[1-6])$/.test(elm.nodeName);\r\n    };\r\n    var isEditable = function (elm) {\r\n      return isChildOfContentEditableTrue(elm) && !isContentEditableFalse(elm);\r\n    };\r\n    var isValidHeader = function (elm) {\r\n      return isHeader(elm) && isEditable(elm);\r\n    };\r\n    var getLevel = function (elm) {\r\n      return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;\r\n    };\r\n    var headerTarget = function (elm) {\r\n      var headerId = getOrGenerateId(elm);\r\n      var attach = function () {\r\n        elm.id = headerId;\r\n      };\r\n      return create('header', getElementText(elm), '#' + headerId, getLevel(elm), attach);\r\n    };\r\n    var anchorTarget = function (elm) {\r\n      var anchorId = elm.id || elm.name;\r\n      var anchorText = getElementText(elm);\r\n      return create('anchor', anchorText ? anchorText : '#' + anchorId, '#' + anchorId, 0, noop);\r\n    };\r\n    var getHeaderTargets = function (elms) {\r\n      return map$2(filter$2(elms, isValidHeader), headerTarget);\r\n    };\r\n    var getAnchorTargets = function (elms) {\r\n      return map$2(filter$2(elms, isValidAnchor), anchorTarget);\r\n    };\r\n    var getTargetElements = function (elm) {\r\n      var elms = select('h1,h2,h3,h4,h5,h6,a:not([href])', elm);\r\n      return elms;\r\n    };\r\n    var hasTitle = function (target) {\r\n      return trim(target.title).length > 0;\r\n    };\r\n    var find = function (elm) {\r\n      var elms = getTargetElements(elm);\r\n      return filter$2(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);\r\n    };\r\n    var LinkTargets = { find: find };\r\n\r\n    var STORAGE_KEY = 'tinymce-url-history';\r\n    var HISTORY_LENGTH = 5;\r\n    var isHttpUrl = function (url) {\r\n      return isString(url) && /^https?/.test(url);\r\n    };\r\n    var isArrayOfUrl = function (a) {\r\n      return isArray(a) && a.length <= HISTORY_LENGTH && forall(a, isHttpUrl);\r\n    };\r\n    var isRecordOfUrlArray = function (r) {\r\n      return isObject(r) && find$4(r, function (value) {\r\n        return !isArrayOfUrl(value);\r\n      }).isNone();\r\n    };\r\n    var getAllHistory = function () {\r\n      var unparsedHistory = global$8.getItem(STORAGE_KEY);\r\n      if (unparsedHistory === null) {\r\n        return {};\r\n      }\r\n      var history;\r\n      try {\r\n        history = JSON.parse(unparsedHistory);\r\n      } catch (e) {\r\n        if (e instanceof SyntaxError) {\r\n          console.log('Local storage ' + STORAGE_KEY + ' was not valid JSON', e);\r\n          return {};\r\n        }\r\n        throw e;\r\n      }\r\n      if (!isRecordOfUrlArray(history)) {\r\n        console.log('Local storage ' + STORAGE_KEY + ' was not valid format', history);\r\n        return {};\r\n      }\r\n      return history;\r\n    };\r\n    var setAllHistory = function (history) {\r\n      if (!isRecordOfUrlArray(history)) {\r\n        throw new Error('Bad format for history:\\n' + JSON.stringify(history));\r\n      }\r\n      global$8.setItem(STORAGE_KEY, JSON.stringify(history));\r\n    };\r\n    var getHistory = function (fileType) {\r\n      var history = getAllHistory();\r\n      return get$e(history, fileType).getOr([]);\r\n    };\r\n    var addToHistory = function (url, fileType) {\r\n      if (!isHttpUrl(url)) {\r\n        return;\r\n      }\r\n      var history = getAllHistory();\r\n      var items = get$e(history, fileType).getOr([]);\r\n      var itemsWithoutUrl = filter$2(items, function (item) {\r\n        return item !== url;\r\n      });\r\n      history[fileType] = [url].concat(itemsWithoutUrl).slice(0, HISTORY_LENGTH);\r\n      setAllHistory(history);\r\n    };\r\n\r\n    var isTruthy = function (value) {\r\n      return !!value;\r\n    };\r\n    var makeMap = function (value) {\r\n      return map$1(global$5.makeMap(value, /[, ]/), isTruthy);\r\n    };\r\n    var getPicker = function (editor) {\r\n      return Optional.from(getFilePickerCallback(editor)).filter(isFunction);\r\n    };\r\n    var getPickerTypes = function (editor) {\r\n      var optFileTypes = Optional.some(getFilePickerTypes(editor)).filter(isTruthy);\r\n      var optLegacyTypes = Optional.some(getFileBrowserCallbackTypes(editor)).filter(isTruthy);\r\n      var optTypes = optFileTypes.or(optLegacyTypes).map(makeMap);\r\n      return getPicker(editor).fold(never, function (_picker) {\r\n        return optTypes.fold(always, function (types) {\r\n          return keys(types).length > 0 ? types : false;\r\n        });\r\n      });\r\n    };\r\n    var getPickerSetting = function (editor, filetype) {\r\n      var pickerTypes = getPickerTypes(editor);\r\n      if (isBoolean(pickerTypes)) {\r\n        return pickerTypes ? getPicker(editor) : Optional.none();\r\n      } else {\r\n        return pickerTypes[filetype] ? getPicker(editor) : Optional.none();\r\n      }\r\n    };\r\n    var getUrlPicker = function (editor, filetype) {\r\n      return getPickerSetting(editor, filetype).map(function (picker) {\r\n        return function (entry) {\r\n          return Future.nu(function (completer) {\r\n            var handler = function (value, meta) {\r\n              if (!isString(value)) {\r\n                throw new Error('Expected value to be string');\r\n              }\r\n              if (meta !== undefined && !isObject(meta)) {\r\n                throw new Error('Expected meta to be a object');\r\n              }\r\n              var r = {\r\n                value: value,\r\n                meta: meta\r\n              };\r\n              completer(r);\r\n            };\r\n            var meta = __assign({\r\n              filetype: filetype,\r\n              fieldname: entry.fieldname\r\n            }, Optional.from(entry.meta).getOr({}));\r\n            picker.call(editor, handler, entry.value, meta);\r\n          });\r\n        };\r\n      });\r\n    };\r\n    var getTextSetting = function (value) {\r\n      return Optional.from(value).filter(isString).getOrUndefined();\r\n    };\r\n    var getLinkInformation = function (editor) {\r\n      if (noTypeaheadUrls(editor)) {\r\n        return Optional.none();\r\n      }\r\n      return Optional.some({\r\n        targets: LinkTargets.find(editor.getBody()),\r\n        anchorTop: getTextSetting(getAnchorTop(editor)),\r\n        anchorBottom: getTextSetting(getAnchorBottom(editor))\r\n      });\r\n    };\r\n    var getValidationHandler = function (editor) {\r\n      return Optional.from(getFilePickerValidatorHandler(editor));\r\n    };\r\n    var UrlInputBackstage = function (editor) {\r\n      return {\r\n        getHistory: getHistory,\r\n        addToHistory: addToHistory,\r\n        getLinkInformation: function () {\r\n          return getLinkInformation(editor);\r\n        },\r\n        getValidationHandler: function () {\r\n          return getValidationHandler(editor);\r\n        },\r\n        getUrlPicker: function (filetype) {\r\n          return getUrlPicker(editor, filetype);\r\n        }\r\n      };\r\n    };\r\n\r\n    var init$7 = function (sink, editor, lazyAnchorbar) {\r\n      var contextMenuState = Cell(false);\r\n      var toolbar = HeaderBackstage(editor);\r\n      var backstage = {\r\n        shared: {\r\n          providers: {\r\n            icons: function () {\r\n              return editor.ui.registry.getAll().icons;\r\n            },\r\n            menuItems: function () {\r\n              return editor.ui.registry.getAll().menuItems;\r\n            },\r\n            translate: global$e.translate,\r\n            isDisabled: function () {\r\n              return editor.mode.isReadOnly() || editor.ui.isDisabled();\r\n            },\r\n            getSetting: editor.getParam.bind(editor)\r\n          },\r\n          interpreter: function (s) {\r\n            return interpretWithoutForm(s, backstage);\r\n          },\r\n          anchors: getAnchors(editor, lazyAnchorbar, toolbar.isPositionedAtTop),\r\n          header: toolbar,\r\n          getSink: function () {\r\n            return Result.value(sink);\r\n          }\r\n        },\r\n        urlinput: UrlInputBackstage(editor),\r\n        styleselect: init$8(editor),\r\n        colorinput: ColorInputBackstage(editor),\r\n        dialog: DialogBackstage(editor),\r\n        isContextMenuOpen: function () {\r\n          return contextMenuState.get();\r\n        },\r\n        setContextMenuState: function (state) {\r\n          return contextMenuState.set(state);\r\n        }\r\n      };\r\n      return backstage;\r\n    };\r\n\r\n    var setup$b = function (editor, mothership, uiMothership) {\r\n      var broadcastEvent = function (name, evt) {\r\n        each$1([\r\n          mothership,\r\n          uiMothership\r\n        ], function (ship) {\r\n          ship.broadcastEvent(name, evt);\r\n        });\r\n      };\r\n      var broadcastOn = function (channel, message) {\r\n        each$1([\r\n          mothership,\r\n          uiMothership\r\n        ], function (ship) {\r\n          ship.broadcastOn([channel], message);\r\n        });\r\n      };\r\n      var fireDismissPopups = function (evt) {\r\n        return broadcastOn(dismissPopups(), { target: evt.target });\r\n      };\r\n      var doc = getDocument();\r\n      var onTouchstart = bind(doc, 'touchstart', fireDismissPopups);\r\n      var onTouchmove = bind(doc, 'touchmove', function (evt) {\r\n        return broadcastEvent(documentTouchmove(), evt);\r\n      });\r\n      var onTouchend = bind(doc, 'touchend', function (evt) {\r\n        return broadcastEvent(documentTouchend(), evt);\r\n      });\r\n      var onMousedown = bind(doc, 'mousedown', fireDismissPopups);\r\n      var onMouseup = bind(doc, 'mouseup', function (evt) {\r\n        if (evt.raw.button === 0) {\r\n          broadcastOn(mouseReleased(), { target: evt.target });\r\n        }\r\n      });\r\n      var onContentClick = function (raw) {\r\n        return broadcastOn(dismissPopups(), { target: SugarElement.fromDom(raw.target) });\r\n      };\r\n      var onContentMouseup = function (raw) {\r\n        if (raw.button === 0) {\r\n          broadcastOn(mouseReleased(), { target: SugarElement.fromDom(raw.target) });\r\n        }\r\n      };\r\n      var onContentMousedown = function () {\r\n        each$1(editor.editorManager.get(), function (loopEditor) {\r\n          if (editor !== loopEditor) {\r\n            loopEditor.fire('DismissPopups', { relatedTarget: editor });\r\n          }\r\n        });\r\n      };\r\n      var onWindowScroll = function (evt) {\r\n        return broadcastEvent(windowScroll(), fromRawEvent(evt));\r\n      };\r\n      var onWindowResize = function (evt) {\r\n        broadcastOn(repositionPopups(), {});\r\n        broadcastEvent(windowResize(), fromRawEvent(evt));\r\n      };\r\n      var onEditorResize = function () {\r\n        return broadcastOn(repositionPopups(), {});\r\n      };\r\n      var onEditorProgress = function (evt) {\r\n        if (evt.state) {\r\n          broadcastOn(dismissPopups(), { target: SugarElement.fromDom(editor.getContainer()) });\r\n        }\r\n      };\r\n      var onDismissPopups = function (event) {\r\n        broadcastOn(dismissPopups(), { target: SugarElement.fromDom(event.relatedTarget.getContainer()) });\r\n      };\r\n      editor.on('PostRender', function () {\r\n        editor.on('click', onContentClick);\r\n        editor.on('tap', onContentClick);\r\n        editor.on('mouseup', onContentMouseup);\r\n        editor.on('mousedown', onContentMousedown);\r\n        editor.on('ScrollWindow', onWindowScroll);\r\n        editor.on('ResizeWindow', onWindowResize);\r\n        editor.on('ResizeEditor', onEditorResize);\r\n        editor.on('AfterProgressState', onEditorProgress);\r\n        editor.on('DismissPopups', onDismissPopups);\r\n      });\r\n      editor.on('remove', function () {\r\n        editor.off('click', onContentClick);\r\n        editor.off('tap', onContentClick);\r\n        editor.off('mouseup', onContentMouseup);\r\n        editor.off('mousedown', onContentMousedown);\r\n        editor.off('ScrollWindow', onWindowScroll);\r\n        editor.off('ResizeWindow', onWindowResize);\r\n        editor.off('ResizeEditor', onEditorResize);\r\n        editor.off('AfterProgressState', onEditorProgress);\r\n        editor.off('DismissPopups', onDismissPopups);\r\n        onMousedown.unbind();\r\n        onTouchstart.unbind();\r\n        onTouchmove.unbind();\r\n        onTouchend.unbind();\r\n        onMouseup.unbind();\r\n      });\r\n      editor.on('detach', function () {\r\n        detachSystem(mothership);\r\n        detachSystem(uiMothership);\r\n        mothership.destroy();\r\n        uiMothership.destroy();\r\n      });\r\n    };\r\n\r\n    var parts$a = AlloyParts;\r\n    var partType = PartType;\r\n\r\n    var schema$f = constant$1([\r\n      defaulted('shell', false),\r\n      required$1('makeItem'),\r\n      defaulted('setupItem', noop),\r\n      SketchBehaviours.field('listBehaviours', [Replacing])\r\n    ]);\r\n    var customListDetail = function () {\r\n      return { behaviours: derive$1([Replacing.config({})]) };\r\n    };\r\n    var itemsPart = optional({\r\n      name: 'items',\r\n      overrides: customListDetail\r\n    });\r\n    var parts$9 = constant$1([itemsPart]);\r\n    var name = constant$1('CustomList');\r\n\r\n    var factory$d = function (detail, components, _spec, _external) {\r\n      var setItems = function (list, items) {\r\n        getListContainer(list).fold(function () {\r\n          console.error('Custom List was defined to not be a shell, but no item container was specified in components');\r\n          throw new Error('Custom List was defined to not be a shell, but no item container was specified in components');\r\n        }, function (container) {\r\n          var itemComps = Replacing.contents(container);\r\n          var numListsRequired = items.length;\r\n          var numListsToAdd = numListsRequired - itemComps.length;\r\n          var itemsToAdd = numListsToAdd > 0 ? range$2(numListsToAdd, function () {\r\n            return detail.makeItem();\r\n          }) : [];\r\n          var itemsToRemove = itemComps.slice(numListsRequired);\r\n          each$1(itemsToRemove, function (item) {\r\n            return Replacing.remove(container, item);\r\n          });\r\n          each$1(itemsToAdd, function (item) {\r\n            return Replacing.append(container, item);\r\n          });\r\n          var builtLists = Replacing.contents(container);\r\n          each$1(builtLists, function (item, i) {\r\n            detail.setupItem(list, item, items[i], i);\r\n          });\r\n        });\r\n      };\r\n      var extra = detail.shell ? {\r\n        behaviours: [Replacing.config({})],\r\n        components: []\r\n      } : {\r\n        behaviours: [],\r\n        components: components\r\n      };\r\n      var getListContainer = function (component) {\r\n        return detail.shell ? Optional.some(component) : getPart(component, detail, 'items');\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: extra.components,\r\n        behaviours: augment(detail.listBehaviours, extra.behaviours),\r\n        apis: { setItems: setItems }\r\n      };\r\n    };\r\n    var CustomList = composite({\r\n      name: name(),\r\n      configFields: schema$f(),\r\n      partFields: parts$9(),\r\n      factory: factory$d,\r\n      apis: {\r\n        setItems: function (apis, list, items) {\r\n          apis.setItems(list, items);\r\n        }\r\n      }\r\n    });\r\n\r\n    var schema$e = constant$1([\r\n      required$1('dom'),\r\n      defaulted('shell', true),\r\n      field('toolbarBehaviours', [Replacing])\r\n    ]);\r\n    var enhanceGroups = function () {\r\n      return { behaviours: derive$1([Replacing.config({})]) };\r\n    };\r\n    var parts$8 = constant$1([optional({\r\n        name: 'groups',\r\n        overrides: enhanceGroups\r\n      })]);\r\n\r\n    var factory$c = function (detail, components, _spec, _externals) {\r\n      var setGroups = function (toolbar, groups) {\r\n        getGroupContainer(toolbar).fold(function () {\r\n          console.error('Toolbar was defined to not be a shell, but no groups container was specified in components');\r\n          throw new Error('Toolbar was defined to not be a shell, but no groups container was specified in components');\r\n        }, function (container) {\r\n          Replacing.set(container, groups);\r\n        });\r\n      };\r\n      var getGroupContainer = function (component) {\r\n        return detail.shell ? Optional.some(component) : getPart(component, detail, 'groups');\r\n      };\r\n      var extra = detail.shell ? {\r\n        behaviours: [Replacing.config({})],\r\n        components: []\r\n      } : {\r\n        behaviours: [],\r\n        components: components\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: extra.components,\r\n        behaviours: augment(detail.toolbarBehaviours, extra.behaviours),\r\n        apis: { setGroups: setGroups },\r\n        domModification: { attributes: { role: 'group' } }\r\n      };\r\n    };\r\n    var Toolbar = composite({\r\n      name: 'Toolbar',\r\n      configFields: schema$e(),\r\n      partFields: parts$8(),\r\n      factory: factory$c,\r\n      apis: {\r\n        setGroups: function (apis, toolbar, groups) {\r\n          apis.setGroups(toolbar, groups);\r\n        }\r\n      }\r\n    });\r\n\r\n    var setup$a = noop;\r\n    var isDocked$2 = never;\r\n    var getBehaviours$1 = constant$1([]);\r\n\r\n    var StaticHeader = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        setup: setup$a,\r\n        isDocked: isDocked$2,\r\n        getBehaviours: getBehaviours$1\r\n    });\r\n\r\n    var getOffsetParent = function (element) {\r\n      var isFixed = is$1(getRaw(element, 'position'), 'fixed');\r\n      var offsetParent$1 = isFixed ? Optional.none() : offsetParent(element);\r\n      return offsetParent$1.orThunk(function () {\r\n        var marker = SugarElement.fromTag('span');\r\n        return parent(element).bind(function (parent) {\r\n          append$2(parent, marker);\r\n          var offsetParent$1 = offsetParent(marker);\r\n          remove$5(marker);\r\n          return offsetParent$1;\r\n        });\r\n      });\r\n    };\r\n    var getOrigin = function (element) {\r\n      return getOffsetParent(element).map(absolute$3).getOrThunk(function () {\r\n        return SugarPosition(0, 0);\r\n      });\r\n    };\r\n\r\n    var morphAdt = Adt.generate([\r\n      { static: [] },\r\n      { absolute: ['positionCss'] },\r\n      { fixed: ['positionCss'] }\r\n    ]);\r\n    var appear = function (component, contextualInfo) {\r\n      var elem = component.element;\r\n      add$2(elem, contextualInfo.transitionClass);\r\n      remove$2(elem, contextualInfo.fadeOutClass);\r\n      add$2(elem, contextualInfo.fadeInClass);\r\n      contextualInfo.onShow(component);\r\n    };\r\n    var disappear = function (component, contextualInfo) {\r\n      var elem = component.element;\r\n      add$2(elem, contextualInfo.transitionClass);\r\n      remove$2(elem, contextualInfo.fadeInClass);\r\n      add$2(elem, contextualInfo.fadeOutClass);\r\n      contextualInfo.onHide(component);\r\n    };\r\n    var isPartiallyVisible = function (box, viewport) {\r\n      return box.y < viewport.bottom && box.bottom > viewport.y;\r\n    };\r\n    var isTopCompletelyVisible = function (box, viewport) {\r\n      return box.y >= viewport.y;\r\n    };\r\n    var isBottomCompletelyVisible = function (box, viewport) {\r\n      return box.bottom <= viewport.bottom;\r\n    };\r\n    var isVisibleForModes = function (modes, box, viewport) {\r\n      return forall(modes, function (mode) {\r\n        switch (mode) {\r\n        case 'bottom':\r\n          return isBottomCompletelyVisible(box, viewport);\r\n        case 'top':\r\n          return isTopCompletelyVisible(box, viewport);\r\n        }\r\n      });\r\n    };\r\n    var getPrior = function (elem, state) {\r\n      return state.getInitialPos().map(function (pos) {\r\n        return bounds(pos.bounds.x, pos.bounds.y, get$a(elem), get$b(elem));\r\n      });\r\n    };\r\n    var storePrior = function (elem, box, state) {\r\n      state.setInitialPos({\r\n        style: getAllRaw(elem),\r\n        position: get$c(elem, 'position') || 'static',\r\n        bounds: box\r\n      });\r\n    };\r\n    var revertToOriginal = function (elem, box, state) {\r\n      return state.getInitialPos().bind(function (position) {\r\n        state.clearInitialPos();\r\n        switch (position.position) {\r\n        case 'static':\r\n          return Optional.some(morphAdt.static());\r\n        case 'absolute':\r\n          var offsetBox_1 = getOffsetParent(elem).map(box$1).getOrThunk(function () {\r\n            return box$1(body());\r\n          });\r\n          return Optional.some(morphAdt.absolute(NuPositionCss('absolute', get$e(position.style, 'left').map(function (_left) {\r\n            return box.x - offsetBox_1.x;\r\n          }), get$e(position.style, 'top').map(function (_top) {\r\n            return box.y - offsetBox_1.y;\r\n          }), get$e(position.style, 'right').map(function (_right) {\r\n            return offsetBox_1.right - box.right;\r\n          }), get$e(position.style, 'bottom').map(function (_bottom) {\r\n            return offsetBox_1.bottom - box.bottom;\r\n          }))));\r\n        default:\r\n          return Optional.none();\r\n        }\r\n      });\r\n    };\r\n    var morphToOriginal = function (elem, viewport, state) {\r\n      return getPrior(elem, state).filter(function (box) {\r\n        return isVisibleForModes(state.getModes(), box, viewport);\r\n      }).bind(function (box) {\r\n        return revertToOriginal(elem, box, state);\r\n      });\r\n    };\r\n    var morphToFixed = function (elem, viewport, state) {\r\n      var box = box$1(elem);\r\n      if (!isVisibleForModes(state.getModes(), box, viewport)) {\r\n        storePrior(elem, box, state);\r\n        var winBox = win();\r\n        var left = box.x - winBox.x;\r\n        var top_1 = viewport.y - winBox.y;\r\n        var bottom = winBox.bottom - viewport.bottom;\r\n        var isTop = box.y <= viewport.y;\r\n        return Optional.some(morphAdt.fixed(NuPositionCss('fixed', Optional.some(left), isTop ? Optional.some(top_1) : Optional.none(), Optional.none(), !isTop ? Optional.some(bottom) : Optional.none())));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var getMorph = function (component, viewport, state) {\r\n      var elem = component.element;\r\n      var isDocked = is$1(getRaw(elem, 'position'), 'fixed');\r\n      return isDocked ? morphToOriginal(elem, viewport, state) : morphToFixed(elem, viewport, state);\r\n    };\r\n    var getMorphToOriginal = function (component, state) {\r\n      var elem = component.element;\r\n      return getPrior(elem, state).bind(function (box) {\r\n        return revertToOriginal(elem, box, state);\r\n      });\r\n    };\r\n\r\n    var morphToStatic = function (component, config, state) {\r\n      state.setDocked(false);\r\n      each$1([\r\n        'left',\r\n        'right',\r\n        'top',\r\n        'bottom',\r\n        'position'\r\n      ], function (prop) {\r\n        return remove$6(component.element, prop);\r\n      });\r\n      config.onUndocked(component);\r\n    };\r\n    var morphToCoord = function (component, config, state, position) {\r\n      var isDocked = position.position === 'fixed';\r\n      state.setDocked(isDocked);\r\n      applyPositionCss(component.element, position);\r\n      var method = isDocked ? config.onDocked : config.onUndocked;\r\n      method(component);\r\n    };\r\n    var updateVisibility = function (component, config, state, viewport, morphToDocked) {\r\n      if (morphToDocked === void 0) {\r\n        morphToDocked = false;\r\n      }\r\n      config.contextual.each(function (contextInfo) {\r\n        contextInfo.lazyContext(component).each(function (box) {\r\n          var isVisible = isPartiallyVisible(box, viewport);\r\n          if (isVisible !== state.isVisible()) {\r\n            state.setVisible(isVisible);\r\n            if (morphToDocked && !isVisible) {\r\n              add$1(component.element, [contextInfo.fadeOutClass]);\r\n              contextInfo.onHide(component);\r\n            } else {\r\n              var method = isVisible ? appear : disappear;\r\n              method(component, contextInfo);\r\n            }\r\n          }\r\n        });\r\n      });\r\n    };\r\n    var refreshInternal = function (component, config, state) {\r\n      var viewport = config.lazyViewport(component);\r\n      var isDocked = state.isDocked();\r\n      if (isDocked) {\r\n        updateVisibility(component, config, state, viewport);\r\n      }\r\n      getMorph(component, viewport, state).each(function (morph) {\r\n        morph.fold(function () {\r\n          return morphToStatic(component, config, state);\r\n        }, function (position) {\r\n          return morphToCoord(component, config, state, position);\r\n        }, function (position) {\r\n          updateVisibility(component, config, state, viewport, true);\r\n          morphToCoord(component, config, state, position);\r\n        });\r\n      });\r\n    };\r\n    var resetInternal = function (component, config, state) {\r\n      var elem = component.element;\r\n      state.setDocked(false);\r\n      getMorphToOriginal(component, state).each(function (morph) {\r\n        morph.fold(function () {\r\n          return morphToStatic(component, config, state);\r\n        }, function (position) {\r\n          return morphToCoord(component, config, state, position);\r\n        }, noop);\r\n      });\r\n      state.setVisible(true);\r\n      config.contextual.each(function (contextInfo) {\r\n        remove$1(elem, [\r\n          contextInfo.fadeInClass,\r\n          contextInfo.fadeOutClass,\r\n          contextInfo.transitionClass\r\n        ]);\r\n        contextInfo.onShow(component);\r\n      });\r\n      refresh$4(component, config, state);\r\n    };\r\n    var refresh$4 = function (component, config, state) {\r\n      if (component.getSystem().isConnected()) {\r\n        refreshInternal(component, config, state);\r\n      }\r\n    };\r\n    var reset = function (component, config, state) {\r\n      if (state.isDocked()) {\r\n        resetInternal(component, config, state);\r\n      }\r\n    };\r\n    var isDocked$1 = function (component, config, state) {\r\n      return state.isDocked();\r\n    };\r\n    var setModes = function (component, config, state, modes) {\r\n      return state.setModes(modes);\r\n    };\r\n    var getModes = function (component, config, state) {\r\n      return state.getModes();\r\n    };\r\n\r\n    var DockingApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        refresh: refresh$4,\r\n        reset: reset,\r\n        isDocked: isDocked$1,\r\n        getModes: getModes,\r\n        setModes: setModes\r\n    });\r\n\r\n    var events$5 = function (dockInfo, dockState) {\r\n      return derive$2([\r\n        runOnSource(transitionend(), function (component, simulatedEvent) {\r\n          dockInfo.contextual.each(function (contextInfo) {\r\n            if (has(component.element, contextInfo.transitionClass)) {\r\n              remove$1(component.element, [\r\n                contextInfo.transitionClass,\r\n                contextInfo.fadeInClass\r\n              ]);\r\n              var notify = dockState.isVisible() ? contextInfo.onShown : contextInfo.onHidden;\r\n              notify(component);\r\n            }\r\n            simulatedEvent.stop();\r\n          });\r\n        }),\r\n        run$1(windowScroll(), function (component, _) {\r\n          refresh$4(component, dockInfo, dockState);\r\n        }),\r\n        run$1(windowResize(), function (component, _) {\r\n          reset(component, dockInfo, dockState);\r\n        })\r\n      ]);\r\n    };\r\n\r\n    var ActiveDocking = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        events: events$5\r\n    });\r\n\r\n    var DockingSchema = [\r\n      optionObjOf('contextual', [\r\n        requiredString('fadeInClass'),\r\n        requiredString('fadeOutClass'),\r\n        requiredString('transitionClass'),\r\n        requiredFunction('lazyContext'),\r\n        onHandler('onShow'),\r\n        onHandler('onShown'),\r\n        onHandler('onHide'),\r\n        onHandler('onHidden')\r\n      ]),\r\n      defaultedFunction('lazyViewport', win),\r\n      defaultedArrayOf('modes', [\r\n        'top',\r\n        'bottom'\r\n      ], string),\r\n      onHandler('onDocked'),\r\n      onHandler('onUndocked')\r\n    ];\r\n\r\n    var init$6 = function (spec) {\r\n      var docked = Cell(false);\r\n      var visible = Cell(true);\r\n      var initialBounds = value$1();\r\n      var modes = Cell(spec.modes);\r\n      var readState = function () {\r\n        return 'docked:  ' + docked.get() + ', visible: ' + visible.get() + ', modes: ' + modes.get().join(',');\r\n      };\r\n      return nu$8({\r\n        isDocked: docked.get,\r\n        setDocked: docked.set,\r\n        getInitialPos: initialBounds.get,\r\n        setInitialPos: initialBounds.set,\r\n        clearInitialPos: initialBounds.clear,\r\n        isVisible: visible.get,\r\n        setVisible: visible.set,\r\n        getModes: modes.get,\r\n        setModes: modes.set,\r\n        readState: readState\r\n      });\r\n    };\r\n\r\n    var DockingState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        init: init$6\r\n    });\r\n\r\n    var Docking = create$8({\r\n      fields: DockingSchema,\r\n      name: 'docking',\r\n      active: ActiveDocking,\r\n      apis: DockingApis,\r\n      state: DockingState\r\n    });\r\n\r\n    var toolbarHeightChange = constant$1(generate$6('toolbar-height-change'));\r\n\r\n    var visibility = {\r\n      fadeInClass: 'tox-editor-dock-fadein',\r\n      fadeOutClass: 'tox-editor-dock-fadeout',\r\n      transitionClass: 'tox-editor-dock-transition'\r\n    };\r\n    var editorStickyOnClass = 'tox-tinymce--toolbar-sticky-on';\r\n    var editorStickyOffClass = 'tox-tinymce--toolbar-sticky-off';\r\n    var scrollFromBehindHeader = function (e, containerHeader) {\r\n      var doc = owner$4(containerHeader);\r\n      var viewHeight = doc.dom.defaultView.innerHeight;\r\n      var scrollPos = get$9(doc);\r\n      var markerElement = SugarElement.fromDom(e.elm);\r\n      var markerPos = absolute$2(markerElement);\r\n      var markerHeight = get$b(markerElement);\r\n      var markerTop = markerPos.y;\r\n      var markerBottom = markerTop + markerHeight;\r\n      var editorHeaderPos = absolute$3(containerHeader);\r\n      var editorHeaderHeight = get$b(containerHeader);\r\n      var editorHeaderTop = editorHeaderPos.top;\r\n      var editorHeaderBottom = editorHeaderTop + editorHeaderHeight;\r\n      var editorHeaderDockedAtTop = Math.abs(editorHeaderTop - scrollPos.top) < 2;\r\n      var editorHeaderDockedAtBottom = Math.abs(editorHeaderBottom - (scrollPos.top + viewHeight)) < 2;\r\n      if (editorHeaderDockedAtTop && markerTop < editorHeaderBottom) {\r\n        to(scrollPos.left, markerTop - editorHeaderHeight, doc);\r\n      } else if (editorHeaderDockedAtBottom && markerBottom > editorHeaderTop) {\r\n        var y = markerTop - viewHeight + markerHeight + editorHeaderHeight;\r\n        to(scrollPos.left, y, doc);\r\n      }\r\n    };\r\n    var isDockedMode = function (header, mode) {\r\n      return contains$2(Docking.getModes(header), mode);\r\n    };\r\n    var updateIframeContentFlow = function (header) {\r\n      var getOccupiedHeight = function (elm) {\r\n        return getOuter$2(elm) + (parseInt(get$c(elm, 'margin-top'), 10) || 0) + (parseInt(get$c(elm, 'margin-bottom'), 10) || 0);\r\n      };\r\n      var elm = header.element;\r\n      parent(elm).each(function (parentElem) {\r\n        var padding = 'padding-' + Docking.getModes(header)[0];\r\n        if (Docking.isDocked(header)) {\r\n          var parentWidth = get$a(parentElem);\r\n          set$7(elm, 'width', parentWidth + 'px');\r\n          set$7(parentElem, padding, getOccupiedHeight(elm) + 'px');\r\n        } else {\r\n          remove$6(elm, 'width');\r\n          remove$6(parentElem, padding);\r\n        }\r\n      });\r\n    };\r\n    var updateSinkVisibility = function (sinkElem, visible) {\r\n      if (visible) {\r\n        remove$2(sinkElem, visibility.fadeOutClass);\r\n        add$1(sinkElem, [\r\n          visibility.transitionClass,\r\n          visibility.fadeInClass\r\n        ]);\r\n      } else {\r\n        remove$2(sinkElem, visibility.fadeInClass);\r\n        add$1(sinkElem, [\r\n          visibility.fadeOutClass,\r\n          visibility.transitionClass\r\n        ]);\r\n      }\r\n    };\r\n    var updateEditorClasses = function (editor, docked) {\r\n      var editorContainer = SugarElement.fromDom(editor.getContainer());\r\n      if (docked) {\r\n        add$2(editorContainer, editorStickyOnClass);\r\n        remove$2(editorContainer, editorStickyOffClass);\r\n      } else {\r\n        add$2(editorContainer, editorStickyOffClass);\r\n        remove$2(editorContainer, editorStickyOnClass);\r\n      }\r\n    };\r\n    var restoreFocus = function (headerElem, focusedElem) {\r\n      var ownerDoc = owner$4(focusedElem);\r\n      active(ownerDoc).filter(function (activeElm) {\r\n        return !eq(focusedElem, activeElm);\r\n      }).filter(function (activeElm) {\r\n        return eq(activeElm, SugarElement.fromDom(ownerDoc.dom.body)) || contains(headerElem, activeElm);\r\n      }).each(function () {\r\n        return focus$3(focusedElem);\r\n      });\r\n    };\r\n    var findFocusedElem = function (rootElm, lazySink) {\r\n      return search(rootElm).orThunk(function () {\r\n        return lazySink().toOptional().bind(function (sink) {\r\n          return search(sink.element);\r\n        });\r\n      });\r\n    };\r\n    var setup$9 = function (editor, sharedBackstage, lazyHeader) {\r\n      if (!editor.inline) {\r\n        if (!sharedBackstage.header.isPositionedAtTop()) {\r\n          editor.on('ResizeEditor', function () {\r\n            lazyHeader().each(Docking.reset);\r\n          });\r\n        }\r\n        editor.on('ResizeWindow ResizeEditor', function () {\r\n          lazyHeader().each(updateIframeContentFlow);\r\n        });\r\n        editor.on('SkinLoaded', function () {\r\n          lazyHeader().each(function (comp) {\r\n            Docking.isDocked(comp) ? Docking.reset(comp) : Docking.refresh(comp);\r\n          });\r\n        });\r\n        editor.on('FullscreenStateChanged', function () {\r\n          lazyHeader().each(Docking.reset);\r\n        });\r\n      }\r\n      editor.on('AfterScrollIntoView', function (e) {\r\n        lazyHeader().each(function (header) {\r\n          Docking.refresh(header);\r\n          var headerElem = header.element;\r\n          if (isVisible(headerElem)) {\r\n            scrollFromBehindHeader(e, headerElem);\r\n          }\r\n        });\r\n      });\r\n      editor.on('PostRender', function () {\r\n        updateEditorClasses(editor, false);\r\n      });\r\n    };\r\n    var isDocked = function (lazyHeader) {\r\n      return lazyHeader().map(Docking.isDocked).getOr(false);\r\n    };\r\n    var getIframeBehaviours = function () {\r\n      var _a;\r\n      return [Receiving.config({ channels: (_a = {}, _a[toolbarHeightChange()] = { onReceive: updateIframeContentFlow }, _a) })];\r\n    };\r\n    var getBehaviours = function (editor, sharedBackstage) {\r\n      var focusedElm = value$1();\r\n      var lazySink = sharedBackstage.getSink;\r\n      var runOnSinkElement = function (f) {\r\n        lazySink().each(function (sink) {\r\n          return f(sink.element);\r\n        });\r\n      };\r\n      var onDockingSwitch = function (comp) {\r\n        if (!editor.inline) {\r\n          updateIframeContentFlow(comp);\r\n        }\r\n        updateEditorClasses(editor, Docking.isDocked(comp));\r\n        comp.getSystem().broadcastOn([repositionPopups()], {});\r\n        lazySink().each(function (sink) {\r\n          return sink.getSystem().broadcastOn([repositionPopups()], {});\r\n        });\r\n      };\r\n      var additionalBehaviours = editor.inline ? [] : getIframeBehaviours();\r\n      return __spreadArray([\r\n        Focusing.config({}),\r\n        Docking.config({\r\n          contextual: __assign({\r\n            lazyContext: function (comp) {\r\n              var headerHeight = getOuter$2(comp.element);\r\n              var container = editor.inline ? editor.getContentAreaContainer() : editor.getContainer();\r\n              var box = box$1(SugarElement.fromDom(container));\r\n              var boxHeight = box.height - headerHeight;\r\n              var topBound = box.y + (isDockedMode(comp, 'top') ? 0 : headerHeight);\r\n              return Optional.some(bounds(box.x, topBound, box.width, boxHeight));\r\n            },\r\n            onShow: function () {\r\n              runOnSinkElement(function (elem) {\r\n                return updateSinkVisibility(elem, true);\r\n              });\r\n            },\r\n            onShown: function (comp) {\r\n              runOnSinkElement(function (elem) {\r\n                return remove$1(elem, [\r\n                  visibility.transitionClass,\r\n                  visibility.fadeInClass\r\n                ]);\r\n              });\r\n              focusedElm.get().each(function (elem) {\r\n                restoreFocus(comp.element, elem);\r\n                focusedElm.clear();\r\n              });\r\n            },\r\n            onHide: function (comp) {\r\n              findFocusedElem(comp.element, lazySink).fold(focusedElm.clear, focusedElm.set);\r\n              runOnSinkElement(function (elem) {\r\n                return updateSinkVisibility(elem, false);\r\n              });\r\n            },\r\n            onHidden: function () {\r\n              runOnSinkElement(function (elem) {\r\n                return remove$1(elem, [visibility.transitionClass]);\r\n              });\r\n            }\r\n          }, visibility),\r\n          lazyViewport: function (comp) {\r\n            var win$1 = win();\r\n            var offset = getStickyToolbarOffset(editor);\r\n            var top = win$1.y + (isDockedMode(comp, 'top') ? offset : 0);\r\n            var height = win$1.height - (isDockedMode(comp, 'bottom') ? offset : 0);\r\n            return bounds(win$1.x, top, win$1.width, height);\r\n          },\r\n          modes: [sharedBackstage.header.getDockingMode()],\r\n          onDocked: onDockingSwitch,\r\n          onUndocked: onDockingSwitch\r\n        })\r\n      ], additionalBehaviours, true);\r\n    };\r\n\r\n    var StickyHeader = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        setup: setup$9,\r\n        isDocked: isDocked,\r\n        getBehaviours: getBehaviours\r\n    });\r\n\r\n    var renderHeader = function (spec) {\r\n      var editor = spec.editor;\r\n      var getBehaviours$2 = spec.sticky ? getBehaviours : getBehaviours$1;\r\n      return {\r\n        uid: spec.uid,\r\n        dom: spec.dom,\r\n        components: spec.components,\r\n        behaviours: derive$1(getBehaviours$2(editor, spec.sharedBackstage))\r\n      };\r\n    };\r\n\r\n    var groupToolbarButtonSchema = objOf([\r\n      requiredString('type'),\r\n      requiredOf('items', oneOf([\r\n        arrOfObj([\r\n          requiredString('name'),\r\n          requiredArrayOf('items', string)\r\n        ]),\r\n        string\r\n      ]))\r\n    ].concat(baseToolbarButtonFields));\r\n    var createGroupToolbarButton = function (spec) {\r\n      return asRaw('GroupToolbarButton', groupToolbarButtonSchema, spec);\r\n    };\r\n\r\n    var baseMenuButtonFields = [\r\n      optionString('text'),\r\n      optionString('tooltip'),\r\n      optionString('icon'),\r\n      requiredFunction('fetch'),\r\n      defaultedFunction('onSetup', function () {\r\n        return noop;\r\n      })\r\n    ];\r\n\r\n    var MenuButtonSchema = objOf(__spreadArray([requiredString('type')], baseMenuButtonFields, true));\r\n    var createMenuButton = function (spec) {\r\n      return asRaw('menubutton', MenuButtonSchema, spec);\r\n    };\r\n\r\n    var splitButtonSchema = objOf([\r\n      requiredString('type'),\r\n      optionString('tooltip'),\r\n      optionString('icon'),\r\n      optionString('text'),\r\n      optionFunction('select'),\r\n      requiredFunction('fetch'),\r\n      defaultedFunction('onSetup', function () {\r\n        return noop;\r\n      }),\r\n      defaultedStringEnum('presets', 'normal', [\r\n        'normal',\r\n        'color',\r\n        'listpreview'\r\n      ]),\r\n      defaulted('columns', 1),\r\n      requiredFunction('onAction'),\r\n      requiredFunction('onItemAction')\r\n    ]);\r\n    var createSplitButton = function (spec) {\r\n      return asRaw('SplitButton', splitButtonSchema, spec);\r\n    };\r\n\r\n    var factory$b = function (detail, spec) {\r\n      var setMenus = function (comp, menus) {\r\n        var newMenus = map$2(menus, function (m) {\r\n          var buttonSpec = {\r\n            type: 'menubutton',\r\n            text: m.text,\r\n            fetch: function (callback) {\r\n              callback(m.getItems());\r\n            }\r\n          };\r\n          var internal = createMenuButton(buttonSpec).mapError(function (errInfo) {\r\n            return formatError(errInfo);\r\n          }).getOrDie();\r\n          return renderMenuButton(internal, 'tox-mbtn', spec.backstage, Optional.some('menuitem'));\r\n        });\r\n        Replacing.set(comp, newMenus);\r\n      };\r\n      var apis = {\r\n        focus: Keying.focusIn,\r\n        setMenus: setMenus\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: [],\r\n        behaviours: derive$1([\r\n          Replacing.config({}),\r\n          config('menubar-events', [\r\n            runOnAttached(function (component) {\r\n              detail.onSetup(component);\r\n            }),\r\n            run$1(mouseover(), function (comp, se) {\r\n              descendant(comp.element, '.' + 'tox-mbtn--active').each(function (activeButton) {\r\n                closest$1(se.event.target, '.' + 'tox-mbtn').each(function (hoveredButton) {\r\n                  if (!eq(activeButton, hoveredButton)) {\r\n                    comp.getSystem().getByDom(activeButton).each(function (activeComp) {\r\n                      comp.getSystem().getByDom(hoveredButton).each(function (hoveredComp) {\r\n                        Dropdown.expand(hoveredComp);\r\n                        Dropdown.close(activeComp);\r\n                        Focusing.focus(hoveredComp);\r\n                      });\r\n                    });\r\n                  }\r\n                });\r\n              });\r\n            }),\r\n            run$1(focusShifted(), function (comp, se) {\r\n              se.event.prevFocus.bind(function (prev) {\r\n                return comp.getSystem().getByDom(prev).toOptional();\r\n              }).each(function (prev) {\r\n                se.event.newFocus.bind(function (nu) {\r\n                  return comp.getSystem().getByDom(nu).toOptional();\r\n                }).each(function (nu) {\r\n                  if (Dropdown.isOpen(prev)) {\r\n                    Dropdown.expand(nu);\r\n                    Dropdown.close(prev);\r\n                  }\r\n                });\r\n              });\r\n            })\r\n          ]),\r\n          Keying.config({\r\n            mode: 'flow',\r\n            selector: '.' + 'tox-mbtn',\r\n            onEscape: function (comp) {\r\n              detail.onEscape(comp);\r\n              return Optional.some(true);\r\n            }\r\n          }),\r\n          Tabstopping.config({})\r\n        ]),\r\n        apis: apis,\r\n        domModification: { attributes: { role: 'menubar' } }\r\n      };\r\n    };\r\n    var SilverMenubar = single({\r\n      factory: factory$b,\r\n      name: 'silver.Menubar',\r\n      configFields: [\r\n        required$1('dom'),\r\n        required$1('uid'),\r\n        required$1('onEscape'),\r\n        required$1('backstage'),\r\n        defaulted('onSetup', noop)\r\n      ],\r\n      apis: {\r\n        focus: function (apis, comp) {\r\n          apis.focus(comp);\r\n        },\r\n        setMenus: function (apis, comp, menus) {\r\n          apis.setMenus(comp, menus);\r\n        }\r\n      }\r\n    });\r\n\r\n    var getAnimationRoot = function (component, slideConfig) {\r\n      return slideConfig.getAnimationRoot.fold(function () {\r\n        return component.element;\r\n      }, function (get) {\r\n        return get(component);\r\n      });\r\n    };\r\n\r\n    var getDimensionProperty = function (slideConfig) {\r\n      return slideConfig.dimension.property;\r\n    };\r\n    var getDimension = function (slideConfig, elem) {\r\n      return slideConfig.dimension.getDimension(elem);\r\n    };\r\n    var disableTransitions = function (component, slideConfig) {\r\n      var root = getAnimationRoot(component, slideConfig);\r\n      remove$1(root, [\r\n        slideConfig.shrinkingClass,\r\n        slideConfig.growingClass\r\n      ]);\r\n    };\r\n    var setShrunk = function (component, slideConfig) {\r\n      remove$2(component.element, slideConfig.openClass);\r\n      add$2(component.element, slideConfig.closedClass);\r\n      set$7(component.element, getDimensionProperty(slideConfig), '0px');\r\n      reflow(component.element);\r\n    };\r\n    var setGrown = function (component, slideConfig) {\r\n      remove$2(component.element, slideConfig.closedClass);\r\n      add$2(component.element, slideConfig.openClass);\r\n      remove$6(component.element, getDimensionProperty(slideConfig));\r\n    };\r\n    var doImmediateShrink = function (component, slideConfig, slideState, _calculatedSize) {\r\n      slideState.setCollapsed();\r\n      set$7(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));\r\n      reflow(component.element);\r\n      disableTransitions(component, slideConfig);\r\n      setShrunk(component, slideConfig);\r\n      slideConfig.onStartShrink(component);\r\n      slideConfig.onShrunk(component);\r\n    };\r\n    var doStartShrink = function (component, slideConfig, slideState, calculatedSize) {\r\n      var size = calculatedSize.getOrThunk(function () {\r\n        return getDimension(slideConfig, component.element);\r\n      });\r\n      slideState.setCollapsed();\r\n      set$7(component.element, getDimensionProperty(slideConfig), size);\r\n      reflow(component.element);\r\n      var root = getAnimationRoot(component, slideConfig);\r\n      remove$2(root, slideConfig.growingClass);\r\n      add$2(root, slideConfig.shrinkingClass);\r\n      setShrunk(component, slideConfig);\r\n      slideConfig.onStartShrink(component);\r\n    };\r\n    var doStartSmartShrink = function (component, slideConfig, slideState) {\r\n      var size = getDimension(slideConfig, component.element);\r\n      var shrinker = size === '0px' ? doImmediateShrink : doStartShrink;\r\n      shrinker(component, slideConfig, slideState, Optional.some(size));\r\n    };\r\n    var doStartGrow = function (component, slideConfig, slideState) {\r\n      var root = getAnimationRoot(component, slideConfig);\r\n      var wasShrinking = has(root, slideConfig.shrinkingClass);\r\n      var beforeSize = getDimension(slideConfig, component.element);\r\n      setGrown(component, slideConfig);\r\n      var fullSize = getDimension(slideConfig, component.element);\r\n      var startPartialGrow = function () {\r\n        set$7(component.element, getDimensionProperty(slideConfig), beforeSize);\r\n        reflow(component.element);\r\n      };\r\n      var startCompleteGrow = function () {\r\n        setShrunk(component, slideConfig);\r\n      };\r\n      var setStartSize = wasShrinking ? startPartialGrow : startCompleteGrow;\r\n      setStartSize();\r\n      remove$2(root, slideConfig.shrinkingClass);\r\n      add$2(root, slideConfig.growingClass);\r\n      setGrown(component, slideConfig);\r\n      set$7(component.element, getDimensionProperty(slideConfig), fullSize);\r\n      slideState.setExpanded();\r\n      slideConfig.onStartGrow(component);\r\n    };\r\n    var refresh$3 = function (component, slideConfig, slideState) {\r\n      if (slideState.isExpanded()) {\r\n        remove$6(component.element, getDimensionProperty(slideConfig));\r\n        var fullSize = getDimension(slideConfig, component.element);\r\n        set$7(component.element, getDimensionProperty(slideConfig), fullSize);\r\n      }\r\n    };\r\n    var grow = function (component, slideConfig, slideState) {\r\n      if (!slideState.isExpanded()) {\r\n        doStartGrow(component, slideConfig, slideState);\r\n      }\r\n    };\r\n    var shrink = function (component, slideConfig, slideState) {\r\n      if (slideState.isExpanded()) {\r\n        doStartSmartShrink(component, slideConfig, slideState);\r\n      }\r\n    };\r\n    var immediateShrink = function (component, slideConfig, slideState) {\r\n      if (slideState.isExpanded()) {\r\n        doImmediateShrink(component, slideConfig, slideState);\r\n      }\r\n    };\r\n    var hasGrown = function (component, slideConfig, slideState) {\r\n      return slideState.isExpanded();\r\n    };\r\n    var hasShrunk = function (component, slideConfig, slideState) {\r\n      return slideState.isCollapsed();\r\n    };\r\n    var isGrowing = function (component, slideConfig, _slideState) {\r\n      var root = getAnimationRoot(component, slideConfig);\r\n      return has(root, slideConfig.growingClass) === true;\r\n    };\r\n    var isShrinking = function (component, slideConfig, _slideState) {\r\n      var root = getAnimationRoot(component, slideConfig);\r\n      return has(root, slideConfig.shrinkingClass) === true;\r\n    };\r\n    var isTransitioning = function (component, slideConfig, slideState) {\r\n      return isGrowing(component, slideConfig) || isShrinking(component, slideConfig);\r\n    };\r\n    var toggleGrow = function (component, slideConfig, slideState) {\r\n      var f = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;\r\n      f(component, slideConfig, slideState);\r\n    };\r\n\r\n    var SlidingApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        refresh: refresh$3,\r\n        grow: grow,\r\n        shrink: shrink,\r\n        immediateShrink: immediateShrink,\r\n        hasGrown: hasGrown,\r\n        hasShrunk: hasShrunk,\r\n        isGrowing: isGrowing,\r\n        isShrinking: isShrinking,\r\n        isTransitioning: isTransitioning,\r\n        toggleGrow: toggleGrow,\r\n        disableTransitions: disableTransitions\r\n    });\r\n\r\n    var exhibit = function (base, slideConfig, _slideState) {\r\n      var expanded = slideConfig.expanded;\r\n      return expanded ? nu$7({\r\n        classes: [slideConfig.openClass],\r\n        styles: {}\r\n      }) : nu$7({\r\n        classes: [slideConfig.closedClass],\r\n        styles: wrap$1(slideConfig.dimension.property, '0px')\r\n      });\r\n    };\r\n    var events$4 = function (slideConfig, slideState) {\r\n      return derive$2([runOnSource(transitionend(), function (component, simulatedEvent) {\r\n          var raw = simulatedEvent.event.raw;\r\n          if (raw.propertyName === slideConfig.dimension.property) {\r\n            disableTransitions(component, slideConfig);\r\n            if (slideState.isExpanded()) {\r\n              remove$6(component.element, slideConfig.dimension.property);\r\n            }\r\n            var notify = slideState.isExpanded() ? slideConfig.onGrown : slideConfig.onShrunk;\r\n            notify(component);\r\n          }\r\n        })]);\r\n    };\r\n\r\n    var ActiveSliding = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        exhibit: exhibit,\r\n        events: events$4\r\n    });\r\n\r\n    var SlidingSchema = [\r\n      required$1('closedClass'),\r\n      required$1('openClass'),\r\n      required$1('shrinkingClass'),\r\n      required$1('growingClass'),\r\n      option('getAnimationRoot'),\r\n      onHandler('onShrunk'),\r\n      onHandler('onStartShrink'),\r\n      onHandler('onGrown'),\r\n      onHandler('onStartGrow'),\r\n      defaulted('expanded', false),\r\n      requiredOf('dimension', choose$1('property', {\r\n        width: [\r\n          output$1('property', 'width'),\r\n          output$1('getDimension', function (elem) {\r\n            return get$a(elem) + 'px';\r\n          })\r\n        ],\r\n        height: [\r\n          output$1('property', 'height'),\r\n          output$1('getDimension', function (elem) {\r\n            return get$b(elem) + 'px';\r\n          })\r\n        ]\r\n      }))\r\n    ];\r\n\r\n    var init$5 = function (spec) {\r\n      var state = Cell(spec.expanded);\r\n      var readState = function () {\r\n        return 'expanded: ' + state.get();\r\n      };\r\n      return nu$8({\r\n        isExpanded: function () {\r\n          return state.get() === true;\r\n        },\r\n        isCollapsed: function () {\r\n          return state.get() === false;\r\n        },\r\n        setCollapsed: curry(state.set, false),\r\n        setExpanded: curry(state.set, true),\r\n        readState: readState\r\n      });\r\n    };\r\n\r\n    var SlidingState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        init: init$5\r\n    });\r\n\r\n    var Sliding = create$8({\r\n      fields: SlidingSchema,\r\n      name: 'sliding',\r\n      active: ActiveSliding,\r\n      apis: SlidingApis,\r\n      state: SlidingState\r\n    });\r\n\r\n    var owner = 'container';\r\n    var schema$d = [field('slotBehaviours', [])];\r\n    var getPartName = function (name) {\r\n      return '<alloy.field.' + name + '>';\r\n    };\r\n    var sketch = function (sSpec) {\r\n      var parts = function () {\r\n        var record = [];\r\n        var slot = function (name, config) {\r\n          record.push(name);\r\n          return generateOne$1(owner, getPartName(name), config);\r\n        };\r\n        return {\r\n          slot: slot,\r\n          record: constant$1(record)\r\n        };\r\n      }();\r\n      var spec = sSpec(parts);\r\n      var partNames = parts.record();\r\n      var fieldParts = map$2(partNames, function (n) {\r\n        return required({\r\n          name: n,\r\n          pname: getPartName(n)\r\n        });\r\n      });\r\n      return composite$1(owner, schema$d, fieldParts, make$1, spec);\r\n    };\r\n    var make$1 = function (detail, components) {\r\n      var getSlotNames = function (_) {\r\n        return getAllPartNames(detail);\r\n      };\r\n      var getSlot = function (container, key) {\r\n        return getPart(container, detail, key);\r\n      };\r\n      var onSlot = function (f, def) {\r\n        return function (container, key) {\r\n          return getPart(container, detail, key).map(function (slot) {\r\n            return f(slot, key);\r\n          }).getOr(def);\r\n        };\r\n      };\r\n      var onSlots = function (f) {\r\n        return function (container, keys) {\r\n          each$1(keys, function (key) {\r\n            return f(container, key);\r\n          });\r\n        };\r\n      };\r\n      var doShowing = function (comp, _key) {\r\n        return get$d(comp.element, 'aria-hidden') !== 'true';\r\n      };\r\n      var doShow = function (comp, key) {\r\n        if (!doShowing(comp)) {\r\n          var element = comp.element;\r\n          remove$6(element, 'display');\r\n          remove$7(element, 'aria-hidden');\r\n          emitWith(comp, slotVisibility(), {\r\n            name: key,\r\n            visible: true\r\n          });\r\n        }\r\n      };\r\n      var doHide = function (comp, key) {\r\n        if (doShowing(comp)) {\r\n          var element = comp.element;\r\n          set$7(element, 'display', 'none');\r\n          set$8(element, 'aria-hidden', 'true');\r\n          emitWith(comp, slotVisibility(), {\r\n            name: key,\r\n            visible: false\r\n          });\r\n        }\r\n      };\r\n      var isShowing = onSlot(doShowing, false);\r\n      var hideSlot = onSlot(doHide);\r\n      var hideSlots = onSlots(hideSlot);\r\n      var hideAllSlots = function (container) {\r\n        return hideSlots(container, getSlotNames());\r\n      };\r\n      var showSlot = onSlot(doShow);\r\n      var apis = {\r\n        getSlotNames: getSlotNames,\r\n        getSlot: getSlot,\r\n        isShowing: isShowing,\r\n        hideSlot: hideSlot,\r\n        hideAllSlots: hideAllSlots,\r\n        showSlot: showSlot\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        behaviours: get$2(detail.slotBehaviours),\r\n        apis: apis\r\n      };\r\n    };\r\n    var slotApis = map$1({\r\n      getSlotNames: function (apis, c) {\r\n        return apis.getSlotNames(c);\r\n      },\r\n      getSlot: function (apis, c, key) {\r\n        return apis.getSlot(c, key);\r\n      },\r\n      isShowing: function (apis, c, key) {\r\n        return apis.isShowing(c, key);\r\n      },\r\n      hideSlot: function (apis, c, key) {\r\n        return apis.hideSlot(c, key);\r\n      },\r\n      hideAllSlots: function (apis, c) {\r\n        return apis.hideAllSlots(c);\r\n      },\r\n      showSlot: function (apis, c, key) {\r\n        return apis.showSlot(c, key);\r\n      }\r\n    }, function (value) {\r\n      return makeApi(value);\r\n    });\r\n    var SlotContainer = __assign(__assign({}, slotApis), { sketch: sketch });\r\n\r\n    var sidebarSchema = objOf([\r\n      optionString('icon'),\r\n      optionString('tooltip'),\r\n      defaultedFunction('onShow', noop),\r\n      defaultedFunction('onHide', noop),\r\n      defaultedFunction('onSetup', function () {\r\n        return noop;\r\n      })\r\n    ]);\r\n    var createSidebar = function (spec) {\r\n      return asRaw('sidebar', sidebarSchema, spec);\r\n    };\r\n\r\n    var setup$8 = function (editor) {\r\n      var sidebars = editor.ui.registry.getAll().sidebars;\r\n      each$1(keys(sidebars), function (name) {\r\n        var spec = sidebars[name];\r\n        var isActive = function () {\r\n          return is$1(Optional.from(editor.queryCommandValue('ToggleSidebar')), name);\r\n        };\r\n        editor.ui.registry.addToggleButton(name, {\r\n          icon: spec.icon,\r\n          tooltip: spec.tooltip,\r\n          onAction: function (buttonApi) {\r\n            editor.execCommand('ToggleSidebar', false, name);\r\n            buttonApi.setActive(isActive());\r\n          },\r\n          onSetup: function (buttonApi) {\r\n            var handleToggle = function () {\r\n              return buttonApi.setActive(isActive());\r\n            };\r\n            editor.on('ToggleSidebar', handleToggle);\r\n            return function () {\r\n              editor.off('ToggleSidebar', handleToggle);\r\n            };\r\n          }\r\n        });\r\n      });\r\n    };\r\n    var getApi = function (comp) {\r\n      return {\r\n        element: function () {\r\n          return comp.element.dom;\r\n        }\r\n      };\r\n    };\r\n    var makePanels = function (parts, panelConfigs) {\r\n      var specs = map$2(keys(panelConfigs), function (name) {\r\n        var spec = panelConfigs[name];\r\n        var bridged = getOrDie(createSidebar(spec));\r\n        return {\r\n          name: name,\r\n          getApi: getApi,\r\n          onSetup: bridged.onSetup,\r\n          onShow: bridged.onShow,\r\n          onHide: bridged.onHide\r\n        };\r\n      });\r\n      return map$2(specs, function (spec) {\r\n        var editorOffCell = Cell(noop);\r\n        return parts.slot(spec.name, {\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-sidebar__pane']\r\n          },\r\n          behaviours: SimpleBehaviours.unnamedEvents([\r\n            onControlAttached(spec, editorOffCell),\r\n            onControlDetached(spec, editorOffCell),\r\n            run$1(slotVisibility(), function (sidepanel, se) {\r\n              var data = se.event;\r\n              var optSidePanelSpec = find$5(specs, function (config) {\r\n                return config.name === data.name;\r\n              });\r\n              optSidePanelSpec.each(function (sidePanelSpec) {\r\n                var handler = data.visible ? sidePanelSpec.onShow : sidePanelSpec.onHide;\r\n                handler(sidePanelSpec.getApi(sidepanel));\r\n              });\r\n            })\r\n          ])\r\n        });\r\n      });\r\n    };\r\n    var makeSidebar = function (panelConfigs) {\r\n      return SlotContainer.sketch(function (parts) {\r\n        return {\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-sidebar__pane-container']\r\n          },\r\n          components: makePanels(parts, panelConfigs),\r\n          slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached(function (slotContainer) {\r\n              return SlotContainer.hideAllSlots(slotContainer);\r\n            })])\r\n        };\r\n      });\r\n    };\r\n    var setSidebar = function (sidebar, panelConfigs) {\r\n      var optSlider = Composing.getCurrent(sidebar);\r\n      optSlider.each(function (slider) {\r\n        return Replacing.set(slider, [makeSidebar(panelConfigs)]);\r\n      });\r\n    };\r\n    var toggleSidebar = function (sidebar, name) {\r\n      var optSlider = Composing.getCurrent(sidebar);\r\n      optSlider.each(function (slider) {\r\n        var optSlotContainer = Composing.getCurrent(slider);\r\n        optSlotContainer.each(function (slotContainer) {\r\n          if (Sliding.hasGrown(slider)) {\r\n            if (SlotContainer.isShowing(slotContainer, name)) {\r\n              Sliding.shrink(slider);\r\n            } else {\r\n              SlotContainer.hideAllSlots(slotContainer);\r\n              SlotContainer.showSlot(slotContainer, name);\r\n            }\r\n          } else {\r\n            SlotContainer.hideAllSlots(slotContainer);\r\n            SlotContainer.showSlot(slotContainer, name);\r\n            Sliding.grow(slider);\r\n          }\r\n        });\r\n      });\r\n    };\r\n    var whichSidebar = function (sidebar) {\r\n      var optSlider = Composing.getCurrent(sidebar);\r\n      return optSlider.bind(function (slider) {\r\n        var sidebarOpen = Sliding.isGrowing(slider) || Sliding.hasGrown(slider);\r\n        if (sidebarOpen) {\r\n          var optSlotContainer = Composing.getCurrent(slider);\r\n          return optSlotContainer.bind(function (slotContainer) {\r\n            return find$5(SlotContainer.getSlotNames(slotContainer), function (name) {\r\n              return SlotContainer.isShowing(slotContainer, name);\r\n            });\r\n          });\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      });\r\n    };\r\n    var fixSize = generate$6('FixSizeEvent');\r\n    var autoSize = generate$6('AutoSizeEvent');\r\n    var renderSidebar = function (spec) {\r\n      return {\r\n        uid: spec.uid,\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-sidebar'],\r\n          attributes: { role: 'complementary' }\r\n        },\r\n        components: [{\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-sidebar__slider']\r\n            },\r\n            components: [],\r\n            behaviours: derive$1([\r\n              Tabstopping.config({}),\r\n              Focusing.config({}),\r\n              Sliding.config({\r\n                dimension: { property: 'width' },\r\n                closedClass: 'tox-sidebar--sliding-closed',\r\n                openClass: 'tox-sidebar--sliding-open',\r\n                shrinkingClass: 'tox-sidebar--sliding-shrinking',\r\n                growingClass: 'tox-sidebar--sliding-growing',\r\n                onShrunk: function (slider) {\r\n                  var optSlotContainer = Composing.getCurrent(slider);\r\n                  optSlotContainer.each(SlotContainer.hideAllSlots);\r\n                  emit(slider, autoSize);\r\n                },\r\n                onGrown: function (slider) {\r\n                  emit(slider, autoSize);\r\n                },\r\n                onStartGrow: function (slider) {\r\n                  emitWith(slider, fixSize, { width: getRaw(slider.element, 'width').getOr('') });\r\n                },\r\n                onStartShrink: function (slider) {\r\n                  emitWith(slider, fixSize, { width: get$a(slider.element) + 'px' });\r\n                }\r\n              }),\r\n              Replacing.config({}),\r\n              Composing.config({\r\n                find: function (comp) {\r\n                  var children = Replacing.contents(comp);\r\n                  return head(children);\r\n                }\r\n              })\r\n            ])\r\n          }],\r\n        behaviours: derive$1([\r\n          ComposingConfigs.childAt(0),\r\n          config('sidebar-sliding-events', [\r\n            run$1(fixSize, function (comp, se) {\r\n              set$7(comp.element, 'width', se.event.width);\r\n            }),\r\n            run$1(autoSize, function (comp, _se) {\r\n              remove$6(comp.element, 'width');\r\n            })\r\n          ])\r\n        ])\r\n      };\r\n    };\r\n\r\n    var block = function (component, config, state, getBusySpec) {\r\n      set$8(component.element, 'aria-busy', true);\r\n      var root = config.getRoot(component).getOr(component);\r\n      var blockerBehaviours = derive$1([\r\n        Keying.config({\r\n          mode: 'special',\r\n          onTab: function () {\r\n            return Optional.some(true);\r\n          },\r\n          onShiftTab: function () {\r\n            return Optional.some(true);\r\n          }\r\n        }),\r\n        Focusing.config({})\r\n      ]);\r\n      var blockSpec = getBusySpec(root, blockerBehaviours);\r\n      var blocker = root.getSystem().build(blockSpec);\r\n      Replacing.append(root, premade(blocker));\r\n      if (blocker.hasConfigured(Keying) && config.focus) {\r\n        Keying.focusIn(blocker);\r\n      }\r\n      if (!state.isBlocked()) {\r\n        config.onBlock(component);\r\n      }\r\n      state.blockWith(function () {\r\n        return Replacing.remove(root, blocker);\r\n      });\r\n    };\r\n    var unblock = function (component, config, state) {\r\n      remove$7(component.element, 'aria-busy');\r\n      if (state.isBlocked()) {\r\n        config.onUnblock(component);\r\n      }\r\n      state.clear();\r\n    };\r\n\r\n    var BlockingApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        block: block,\r\n        unblock: unblock\r\n    });\r\n\r\n    var BlockingSchema = [\r\n      defaultedFunction('getRoot', Optional.none),\r\n      defaultedBoolean('focus', true),\r\n      onHandler('onBlock'),\r\n      onHandler('onUnblock')\r\n    ];\r\n\r\n    var init$4 = function () {\r\n      var blocker = destroyable();\r\n      var blockWith = function (destroy) {\r\n        blocker.set({ destroy: destroy });\r\n      };\r\n      return nu$8({\r\n        readState: blocker.isSet,\r\n        blockWith: blockWith,\r\n        clear: blocker.clear,\r\n        isBlocked: blocker.isSet\r\n      });\r\n    };\r\n\r\n    var BlockingState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        init: init$4\r\n    });\r\n\r\n    var Blocking = create$8({\r\n      fields: BlockingSchema,\r\n      name: 'blocking',\r\n      apis: BlockingApis,\r\n      state: BlockingState\r\n    });\r\n\r\n    var getBusySpec$1 = function (providerBackstage) {\r\n      return function (_root, _behaviours) {\r\n        return {\r\n          dom: {\r\n            tag: 'div',\r\n            attributes: {\r\n              'aria-label': providerBackstage.translate('Loading...'),\r\n              'tabindex': '0'\r\n            },\r\n            classes: ['tox-throbber__busy-spinner']\r\n          },\r\n          components: [{ dom: fromHtml('<div class=\"tox-spinner\"><div></div><div></div><div></div></div>') }]\r\n        };\r\n      };\r\n    };\r\n    var focusBusyComponent = function (throbber) {\r\n      return Composing.getCurrent(throbber).each(function (comp) {\r\n        return focus$3(comp.element);\r\n      });\r\n    };\r\n    var toggleEditorTabIndex = function (editor, state) {\r\n      var tabIndexAttr = 'tabindex';\r\n      var dataTabIndexAttr = 'data-mce-' + tabIndexAttr;\r\n      Optional.from(editor.iframeElement).map(SugarElement.fromDom).each(function (iframe) {\r\n        if (state) {\r\n          getOpt(iframe, tabIndexAttr).each(function (tabIndex) {\r\n            return set$8(iframe, dataTabIndexAttr, tabIndex);\r\n          });\r\n          set$8(iframe, tabIndexAttr, -1);\r\n        } else {\r\n          remove$7(iframe, tabIndexAttr);\r\n          getOpt(iframe, dataTabIndexAttr).each(function (tabIndex) {\r\n            set$8(iframe, tabIndexAttr, tabIndex);\r\n            remove$7(iframe, dataTabIndexAttr);\r\n          });\r\n        }\r\n      });\r\n    };\r\n    var toggleThrobber = function (editor, comp, state, providerBackstage) {\r\n      var element = comp.element;\r\n      toggleEditorTabIndex(editor, state);\r\n      if (state) {\r\n        Blocking.block(comp, getBusySpec$1(providerBackstage));\r\n        remove$6(element, 'display');\r\n        remove$7(element, 'aria-hidden');\r\n        if (editor.hasFocus()) {\r\n          focusBusyComponent(comp);\r\n        }\r\n      } else {\r\n        var throbberFocus = Composing.getCurrent(comp).exists(function (busyComp) {\r\n          return hasFocus(busyComp.element);\r\n        });\r\n        Blocking.unblock(comp);\r\n        set$7(element, 'display', 'none');\r\n        set$8(element, 'aria-hidden', 'true');\r\n        if (throbberFocus) {\r\n          editor.focus();\r\n        }\r\n      }\r\n    };\r\n    var renderThrobber = function (spec) {\r\n      return {\r\n        uid: spec.uid,\r\n        dom: {\r\n          tag: 'div',\r\n          attributes: { 'aria-hidden': 'true' },\r\n          classes: ['tox-throbber'],\r\n          styles: { display: 'none' }\r\n        },\r\n        behaviours: derive$1([\r\n          Replacing.config({}),\r\n          Blocking.config({ focus: false }),\r\n          Composing.config({\r\n            find: function (comp) {\r\n              return head(comp.components());\r\n            }\r\n          })\r\n        ]),\r\n        components: []\r\n      };\r\n    };\r\n    var isFocusEvent = function (event) {\r\n      return event.type === 'focusin';\r\n    };\r\n    var isPasteBinTarget = function (event) {\r\n      if (isFocusEvent(event)) {\r\n        var node = event.composed ? head(event.composedPath()) : Optional.from(event.target);\r\n        return node.map(SugarElement.fromDom).filter(isElement$2).exists(function (targetElm) {\r\n          return has(targetElm, 'mce-pastebin');\r\n        });\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var setup$7 = function (editor, lazyThrobber, sharedBackstage) {\r\n      var throbberState = Cell(false);\r\n      var timer = value$1();\r\n      var stealFocus = function (e) {\r\n        if (throbberState.get() && !isPasteBinTarget(e)) {\r\n          e.preventDefault();\r\n          focusBusyComponent(lazyThrobber());\r\n          editor.editorManager.setActive(editor);\r\n        }\r\n      };\r\n      if (!editor.inline) {\r\n        editor.on('PreInit', function () {\r\n          editor.dom.bind(editor.getWin(), 'focusin', stealFocus);\r\n          editor.on('BeforeExecCommand', function (e) {\r\n            if (e.command.toLowerCase() === 'mcefocus' && e.value !== true) {\r\n              stealFocus(e);\r\n            }\r\n          });\r\n        });\r\n      }\r\n      var toggle = function (state) {\r\n        if (state !== throbberState.get()) {\r\n          throbberState.set(state);\r\n          toggleThrobber(editor, lazyThrobber(), state, sharedBackstage.providers);\r\n          editor.fire('AfterProgressState', { state: state });\r\n        }\r\n      };\r\n      editor.on('ProgressState', function (e) {\r\n        timer.on(global$f.clearTimeout);\r\n        if (isNumber(e.time)) {\r\n          var timerId = global$f.setEditorTimeout(editor, function () {\r\n            return toggle(e.state);\r\n          }, e.time);\r\n          timer.set(timerId);\r\n        } else {\r\n          toggle(e.state);\r\n          timer.clear();\r\n        }\r\n      });\r\n    };\r\n\r\n    var generate$1 = function (xs, f) {\r\n      var init = {\r\n        len: 0,\r\n        list: []\r\n      };\r\n      var r = foldl(xs, function (b, a) {\r\n        var value = f(a, b.len);\r\n        return value.fold(constant$1(b), function (v) {\r\n          return {\r\n            len: v.finish,\r\n            list: b.list.concat([v])\r\n          };\r\n        });\r\n      }, init);\r\n      return r.list;\r\n    };\r\n\r\n    var output = function (within, extra, withinWidth) {\r\n      return {\r\n        within: within,\r\n        extra: extra,\r\n        withinWidth: withinWidth\r\n      };\r\n    };\r\n    var apportion = function (units, total, len) {\r\n      var parray = generate$1(units, function (unit, current) {\r\n        var width = len(unit);\r\n        return Optional.some({\r\n          element: unit,\r\n          start: current,\r\n          finish: current + width,\r\n          width: width\r\n        });\r\n      });\r\n      var within = filter$2(parray, function (unit) {\r\n        return unit.finish <= total;\r\n      });\r\n      var withinWidth = foldr(within, function (acc, el) {\r\n        return acc + el.width;\r\n      }, 0);\r\n      var extra = parray.slice(within.length);\r\n      return {\r\n        within: within,\r\n        extra: extra,\r\n        withinWidth: withinWidth\r\n      };\r\n    };\r\n    var toUnit = function (parray) {\r\n      return map$2(parray, function (unit) {\r\n        return unit.element;\r\n      });\r\n    };\r\n    var fitLast = function (within, extra, withinWidth) {\r\n      var fits = toUnit(within.concat(extra));\r\n      return output(fits, [], withinWidth);\r\n    };\r\n    var overflow = function (within, extra, overflower, withinWidth) {\r\n      var fits = toUnit(within).concat([overflower]);\r\n      return output(fits, toUnit(extra), withinWidth);\r\n    };\r\n    var fitAll = function (within, extra, withinWidth) {\r\n      return output(toUnit(within), [], withinWidth);\r\n    };\r\n    var tryFit = function (total, units, len) {\r\n      var divide = apportion(units, total, len);\r\n      return divide.extra.length === 0 ? Optional.some(divide) : Optional.none();\r\n    };\r\n    var partition = function (total, units, len, overflower) {\r\n      var divide = tryFit(total, units, len).getOrThunk(function () {\r\n        return apportion(units, total - len(overflower), len);\r\n      });\r\n      var within = divide.within;\r\n      var extra = divide.extra;\r\n      var withinWidth = divide.withinWidth;\r\n      if (extra.length === 1 && extra[0].width <= len(overflower)) {\r\n        return fitLast(within, extra, withinWidth);\r\n      } else if (extra.length >= 1) {\r\n        return overflow(within, extra, overflower, withinWidth);\r\n      } else {\r\n        return fitAll(within, extra, withinWidth);\r\n      }\r\n    };\r\n\r\n    var setGroups$1 = function (toolbar, storedGroups) {\r\n      var bGroups = map$2(storedGroups, function (g) {\r\n        return premade(g);\r\n      });\r\n      Toolbar.setGroups(toolbar, bGroups);\r\n    };\r\n    var findFocusedComp = function (comps) {\r\n      return findMap(comps, function (comp) {\r\n        return search(comp.element).bind(function (focusedElm) {\r\n          return comp.getSystem().getByDom(focusedElm).toOptional();\r\n        });\r\n      });\r\n    };\r\n    var refresh$2 = function (toolbar, detail, setOverflow) {\r\n      var builtGroups = detail.builtGroups.get();\r\n      if (builtGroups.length === 0) {\r\n        return;\r\n      }\r\n      var primary = getPartOrDie(toolbar, detail, 'primary');\r\n      var overflowGroup = Coupling.getCoupled(toolbar, 'overflowGroup');\r\n      set$7(primary.element, 'visibility', 'hidden');\r\n      var groups = builtGroups.concat([overflowGroup]);\r\n      var focusedComp = findFocusedComp(groups);\r\n      setOverflow([]);\r\n      setGroups$1(primary, groups);\r\n      var availableWidth = get$a(primary.element);\r\n      var overflows = partition(availableWidth, detail.builtGroups.get(), function (comp) {\r\n        return get$a(comp.element);\r\n      }, overflowGroup);\r\n      if (overflows.extra.length === 0) {\r\n        Replacing.remove(primary, overflowGroup);\r\n        setOverflow([]);\r\n      } else {\r\n        setGroups$1(primary, overflows.within);\r\n        setOverflow(overflows.extra);\r\n      }\r\n      remove$6(primary.element, 'visibility');\r\n      reflow(primary.element);\r\n      focusedComp.each(Focusing.focus);\r\n    };\r\n\r\n    var schema$c = constant$1([\r\n      field('splitToolbarBehaviours', [Coupling]),\r\n      customField('builtGroups', function () {\r\n        return Cell([]);\r\n      })\r\n    ]);\r\n\r\n    var schema$b = constant$1([\r\n      markers$1(['overflowToggledClass']),\r\n      optionFunction('getOverflowBounds'),\r\n      required$1('lazySink'),\r\n      customField('overflowGroups', function () {\r\n        return Cell([]);\r\n      })\r\n    ].concat(schema$c()));\r\n    var parts$7 = constant$1([\r\n      required({\r\n        factory: Toolbar,\r\n        schema: schema$e(),\r\n        name: 'primary'\r\n      }),\r\n      external$1({\r\n        schema: schema$e(),\r\n        name: 'overflow'\r\n      }),\r\n      external$1({ name: 'overflow-button' }),\r\n      external$1({ name: 'overflow-group' })\r\n    ]);\r\n\r\n    var expandable = constant$1(function (element, available) {\r\n      setMax(element, Math.floor(available));\r\n    });\r\n\r\n    var schema$a = constant$1([\r\n      markers$1(['toggledClass']),\r\n      required$1('lazySink'),\r\n      requiredFunction('fetch'),\r\n      optionFunction('getBounds'),\r\n      optionObjOf('fireDismissalEventInstead', [defaulted('event', dismissRequested())]),\r\n      schema$y()\r\n    ]);\r\n    var parts$6 = constant$1([\r\n      external$1({\r\n        name: 'button',\r\n        overrides: function (detail) {\r\n          return {\r\n            dom: { attributes: { 'aria-haspopup': 'true' } },\r\n            buttonBehaviours: derive$1([Toggling.config({\r\n                toggleClass: detail.markers.toggledClass,\r\n                aria: { mode: 'expanded' },\r\n                toggleOnExecute: false\r\n              })])\r\n          };\r\n        }\r\n      }),\r\n      external$1({\r\n        factory: Toolbar,\r\n        schema: schema$e(),\r\n        name: 'toolbar',\r\n        overrides: function (detail) {\r\n          return {\r\n            toolbarBehaviours: derive$1([Keying.config({\r\n                mode: 'cyclic',\r\n                onEscape: function (comp) {\r\n                  getPart(comp, detail, 'button').each(Focusing.focus);\r\n                  return Optional.none();\r\n                }\r\n              })])\r\n          };\r\n        }\r\n      })\r\n    ]);\r\n\r\n    var toggle = function (button, externals) {\r\n      var toolbarSandbox = Coupling.getCoupled(button, 'toolbarSandbox');\r\n      if (Sandboxing.isOpen(toolbarSandbox)) {\r\n        Sandboxing.close(toolbarSandbox);\r\n      } else {\r\n        Sandboxing.open(toolbarSandbox, externals.toolbar());\r\n      }\r\n    };\r\n    var position = function (button, toolbar, detail, layouts) {\r\n      var bounds = detail.getBounds.map(function (bounder) {\r\n        return bounder();\r\n      });\r\n      var sink = detail.lazySink(button).getOrDie();\r\n      Positioning.positionWithinBounds(sink, toolbar, {\r\n        anchor: {\r\n          type: 'hotspot',\r\n          hotspot: button,\r\n          layouts: layouts,\r\n          overrides: { maxWidthFunction: expandable() }\r\n        }\r\n      }, bounds);\r\n    };\r\n    var setGroups = function (button, toolbar, detail, layouts, groups) {\r\n      Toolbar.setGroups(toolbar, groups);\r\n      position(button, toolbar, detail, layouts);\r\n      Toggling.on(button);\r\n    };\r\n    var makeSandbox = function (button, spec, detail) {\r\n      var ariaOwner = manager();\r\n      var onOpen = function (sandbox, toolbar) {\r\n        detail.fetch().get(function (groups) {\r\n          setGroups(button, toolbar, detail, spec.layouts, groups);\r\n          ariaOwner.link(button.element);\r\n          Keying.focusIn(toolbar);\r\n        });\r\n      };\r\n      var onClose = function () {\r\n        Toggling.off(button);\r\n        Focusing.focus(button);\r\n        ariaOwner.unlink(button.element);\r\n      };\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          attributes: { id: ariaOwner.id }\r\n        },\r\n        behaviours: derive$1([\r\n          Keying.config({\r\n            mode: 'special',\r\n            onEscape: function (comp) {\r\n              Sandboxing.close(comp);\r\n              return Optional.some(true);\r\n            }\r\n          }),\r\n          Sandboxing.config({\r\n            onOpen: onOpen,\r\n            onClose: onClose,\r\n            isPartOf: function (container, data, queryElem) {\r\n              return isPartOf$1(data, queryElem) || isPartOf$1(button, queryElem);\r\n            },\r\n            getAttachPoint: function () {\r\n              return detail.lazySink(button).getOrDie();\r\n            }\r\n          }),\r\n          Receiving.config({\r\n            channels: __assign(__assign({}, receivingChannel$1(__assign({ isExtraPart: never }, detail.fireDismissalEventInstead.map(function (fe) {\r\n              return { fireEventInstead: { event: fe.event } };\r\n            }).getOr({})))), receivingChannel({\r\n              doReposition: function () {\r\n                Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(function (toolbar) {\r\n                  position(button, toolbar, detail, spec.layouts);\r\n                });\r\n              }\r\n            }))\r\n          })\r\n        ])\r\n      };\r\n    };\r\n    var factory$a = function (detail, components, spec, externals) {\r\n      return __assign(__assign({}, Button.sketch(__assign(__assign({}, externals.button()), {\r\n        action: function (button) {\r\n          toggle(button, externals);\r\n        },\r\n        buttonBehaviours: SketchBehaviours.augment({ dump: externals.button().buttonBehaviours }, [Coupling.config({\r\n            others: {\r\n              toolbarSandbox: function (button) {\r\n                return makeSandbox(button, spec, detail);\r\n              }\r\n            }\r\n          })])\r\n      }))), {\r\n        apis: {\r\n          setGroups: function (button, groups) {\r\n            Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(function (toolbar) {\r\n              setGroups(button, toolbar, detail, spec.layouts, groups);\r\n            });\r\n          },\r\n          reposition: function (button) {\r\n            Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(function (toolbar) {\r\n              position(button, toolbar, detail, spec.layouts);\r\n            });\r\n          },\r\n          toggle: function (button) {\r\n            toggle(button, externals);\r\n          },\r\n          getToolbar: function (button) {\r\n            return Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox'));\r\n          },\r\n          isOpen: function (button) {\r\n            return Sandboxing.isOpen(Coupling.getCoupled(button, 'toolbarSandbox'));\r\n          }\r\n        }\r\n      });\r\n    };\r\n    var FloatingToolbarButton = composite({\r\n      name: 'FloatingToolbarButton',\r\n      factory: factory$a,\r\n      configFields: schema$a(),\r\n      partFields: parts$6(),\r\n      apis: {\r\n        setGroups: function (apis, button, groups) {\r\n          apis.setGroups(button, groups);\r\n        },\r\n        reposition: function (apis, button) {\r\n          apis.reposition(button);\r\n        },\r\n        toggle: function (apis, button) {\r\n          apis.toggle(button);\r\n        },\r\n        getToolbar: function (apis, button) {\r\n          return apis.getToolbar(button);\r\n        },\r\n        isOpen: function (apis, button) {\r\n          return apis.isOpen(button);\r\n        }\r\n      }\r\n    });\r\n\r\n    var schema$9 = constant$1([\r\n      required$1('items'),\r\n      markers$1(['itemSelector']),\r\n      field('tgroupBehaviours', [Keying])\r\n    ]);\r\n    var parts$5 = constant$1([group({\r\n        name: 'items',\r\n        unit: 'item'\r\n      })]);\r\n\r\n    var factory$9 = function (detail, components, _spec, _externals) {\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        behaviours: augment(detail.tgroupBehaviours, [Keying.config({\r\n            mode: 'flow',\r\n            selector: detail.markers.itemSelector\r\n          })]),\r\n        domModification: { attributes: { role: 'toolbar' } }\r\n      };\r\n    };\r\n    var ToolbarGroup = composite({\r\n      name: 'ToolbarGroup',\r\n      configFields: schema$9(),\r\n      partFields: parts$5(),\r\n      factory: factory$9\r\n    });\r\n\r\n    var buildGroups = function (comps) {\r\n      return map$2(comps, function (g) {\r\n        return premade(g);\r\n      });\r\n    };\r\n    var refresh$1 = function (toolbar, memFloatingToolbarButton, detail) {\r\n      refresh$2(toolbar, detail, function (overflowGroups) {\r\n        detail.overflowGroups.set(overflowGroups);\r\n        memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {\r\n          FloatingToolbarButton.setGroups(floatingToolbarButton, buildGroups(overflowGroups));\r\n        });\r\n      });\r\n    };\r\n    var factory$8 = function (detail, components, spec, externals) {\r\n      var memFloatingToolbarButton = record(FloatingToolbarButton.sketch({\r\n        fetch: function () {\r\n          return Future.nu(function (resolve) {\r\n            resolve(buildGroups(detail.overflowGroups.get()));\r\n          });\r\n        },\r\n        layouts: {\r\n          onLtr: function () {\r\n            return [\r\n              southwest$2,\r\n              southeast$2\r\n            ];\r\n          },\r\n          onRtl: function () {\r\n            return [\r\n              southeast$2,\r\n              southwest$2\r\n            ];\r\n          },\r\n          onBottomLtr: function () {\r\n            return [\r\n              northwest$2,\r\n              northeast$2\r\n            ];\r\n          },\r\n          onBottomRtl: function () {\r\n            return [\r\n              northeast$2,\r\n              northwest$2\r\n            ];\r\n          }\r\n        },\r\n        getBounds: spec.getOverflowBounds,\r\n        lazySink: detail.lazySink,\r\n        fireDismissalEventInstead: {},\r\n        markers: { toggledClass: detail.markers.overflowToggledClass },\r\n        parts: {\r\n          button: externals['overflow-button'](),\r\n          toolbar: externals.overflow()\r\n        }\r\n      }));\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        behaviours: augment(detail.splitToolbarBehaviours, [Coupling.config({\r\n            others: {\r\n              overflowGroup: function () {\r\n                return ToolbarGroup.sketch(__assign(__assign({}, externals['overflow-group']()), { items: [memFloatingToolbarButton.asSpec()] }));\r\n              }\r\n            }\r\n          })]),\r\n        apis: {\r\n          setGroups: function (toolbar, groups) {\r\n            detail.builtGroups.set(map$2(groups, toolbar.getSystem().build));\r\n            refresh$1(toolbar, memFloatingToolbarButton, detail);\r\n          },\r\n          refresh: function (toolbar) {\r\n            return refresh$1(toolbar, memFloatingToolbarButton, detail);\r\n          },\r\n          toggle: function (toolbar) {\r\n            memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {\r\n              FloatingToolbarButton.toggle(floatingToolbarButton);\r\n            });\r\n          },\r\n          isOpen: function (toolbar) {\r\n            return memFloatingToolbarButton.getOpt(toolbar).map(FloatingToolbarButton.isOpen).getOr(false);\r\n          },\r\n          reposition: function (toolbar) {\r\n            memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {\r\n              FloatingToolbarButton.reposition(floatingToolbarButton);\r\n            });\r\n          },\r\n          getOverflow: function (toolbar) {\r\n            return memFloatingToolbarButton.getOpt(toolbar).bind(FloatingToolbarButton.getToolbar);\r\n          }\r\n        },\r\n        domModification: { attributes: { role: 'group' } }\r\n      };\r\n    };\r\n    var SplitFloatingToolbar = composite({\r\n      name: 'SplitFloatingToolbar',\r\n      configFields: schema$b(),\r\n      partFields: parts$7(),\r\n      factory: factory$8,\r\n      apis: {\r\n        setGroups: function (apis, toolbar, groups) {\r\n          apis.setGroups(toolbar, groups);\r\n        },\r\n        refresh: function (apis, toolbar) {\r\n          apis.refresh(toolbar);\r\n        },\r\n        reposition: function (apis, toolbar) {\r\n          apis.reposition(toolbar);\r\n        },\r\n        toggle: function (apis, toolbar) {\r\n          apis.toggle(toolbar);\r\n        },\r\n        isOpen: function (apis, toolbar) {\r\n          return apis.isOpen(toolbar);\r\n        },\r\n        getOverflow: function (apis, toolbar) {\r\n          return apis.getOverflow(toolbar);\r\n        }\r\n      }\r\n    });\r\n\r\n    var schema$8 = constant$1([\r\n      markers$1([\r\n        'closedClass',\r\n        'openClass',\r\n        'shrinkingClass',\r\n        'growingClass',\r\n        'overflowToggledClass'\r\n      ]),\r\n      onHandler('onOpened'),\r\n      onHandler('onClosed')\r\n    ].concat(schema$c()));\r\n    var parts$4 = constant$1([\r\n      required({\r\n        factory: Toolbar,\r\n        schema: schema$e(),\r\n        name: 'primary'\r\n      }),\r\n      required({\r\n        factory: Toolbar,\r\n        schema: schema$e(),\r\n        name: 'overflow',\r\n        overrides: function (detail) {\r\n          return {\r\n            toolbarBehaviours: derive$1([\r\n              Sliding.config({\r\n                dimension: { property: 'height' },\r\n                closedClass: detail.markers.closedClass,\r\n                openClass: detail.markers.openClass,\r\n                shrinkingClass: detail.markers.shrinkingClass,\r\n                growingClass: detail.markers.growingClass,\r\n                onShrunk: function (comp) {\r\n                  getPart(comp, detail, 'overflow-button').each(function (button) {\r\n                    Toggling.off(button);\r\n                    Focusing.focus(button);\r\n                  });\r\n                  detail.onClosed(comp);\r\n                },\r\n                onGrown: function (comp) {\r\n                  Keying.focusIn(comp);\r\n                  detail.onOpened(comp);\r\n                },\r\n                onStartGrow: function (comp) {\r\n                  getPart(comp, detail, 'overflow-button').each(Toggling.on);\r\n                }\r\n              }),\r\n              Keying.config({\r\n                mode: 'acyclic',\r\n                onEscape: function (comp) {\r\n                  getPart(comp, detail, 'overflow-button').each(Focusing.focus);\r\n                  return Optional.some(true);\r\n                }\r\n              })\r\n            ])\r\n          };\r\n        }\r\n      }),\r\n      external$1({\r\n        name: 'overflow-button',\r\n        overrides: function (detail) {\r\n          return {\r\n            buttonBehaviours: derive$1([Toggling.config({\r\n                toggleClass: detail.markers.overflowToggledClass,\r\n                aria: { mode: 'pressed' },\r\n                toggleOnExecute: false\r\n              })])\r\n          };\r\n        }\r\n      }),\r\n      external$1({ name: 'overflow-group' })\r\n    ]);\r\n\r\n    var isOpen = function (toolbar, detail) {\r\n      return getPart(toolbar, detail, 'overflow').map(Sliding.hasGrown).getOr(false);\r\n    };\r\n    var toggleToolbar = function (toolbar, detail) {\r\n      getPart(toolbar, detail, 'overflow-button').bind(function () {\r\n        return getPart(toolbar, detail, 'overflow');\r\n      }).each(function (overf) {\r\n        refresh(toolbar, detail);\r\n        Sliding.toggleGrow(overf);\r\n      });\r\n    };\r\n    var refresh = function (toolbar, detail) {\r\n      getPart(toolbar, detail, 'overflow').each(function (overflow) {\r\n        refresh$2(toolbar, detail, function (groups) {\r\n          var builtGroups = map$2(groups, function (g) {\r\n            return premade(g);\r\n          });\r\n          Toolbar.setGroups(overflow, builtGroups);\r\n        });\r\n        getPart(toolbar, detail, 'overflow-button').each(function (button) {\r\n          if (Sliding.hasGrown(overflow)) {\r\n            Toggling.on(button);\r\n          }\r\n        });\r\n        Sliding.refresh(overflow);\r\n      });\r\n    };\r\n    var factory$7 = function (detail, components, spec, externals) {\r\n      var toolbarToggleEvent = 'alloy.toolbar.toggle';\r\n      var doSetGroups = function (toolbar, groups) {\r\n        var built = map$2(groups, toolbar.getSystem().build);\r\n        detail.builtGroups.set(built);\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        behaviours: augment(detail.splitToolbarBehaviours, [\r\n          Coupling.config({\r\n            others: {\r\n              overflowGroup: function (toolbar) {\r\n                return ToolbarGroup.sketch(__assign(__assign({}, externals['overflow-group']()), {\r\n                  items: [Button.sketch(__assign(__assign({}, externals['overflow-button']()), {\r\n                      action: function (_button) {\r\n                        emit(toolbar, toolbarToggleEvent);\r\n                      }\r\n                    }))]\r\n                }));\r\n              }\r\n            }\r\n          }),\r\n          config('toolbar-toggle-events', [run$1(toolbarToggleEvent, function (toolbar) {\r\n              toggleToolbar(toolbar, detail);\r\n            })])\r\n        ]),\r\n        apis: {\r\n          setGroups: function (toolbar, groups) {\r\n            doSetGroups(toolbar, groups);\r\n            refresh(toolbar, detail);\r\n          },\r\n          refresh: function (toolbar) {\r\n            return refresh(toolbar, detail);\r\n          },\r\n          toggle: function (toolbar) {\r\n            return toggleToolbar(toolbar, detail);\r\n          },\r\n          isOpen: function (toolbar) {\r\n            return isOpen(toolbar, detail);\r\n          }\r\n        },\r\n        domModification: { attributes: { role: 'group' } }\r\n      };\r\n    };\r\n    var SplitSlidingToolbar = composite({\r\n      name: 'SplitSlidingToolbar',\r\n      configFields: schema$8(),\r\n      partFields: parts$4(),\r\n      factory: factory$7,\r\n      apis: {\r\n        setGroups: function (apis, toolbar, groups) {\r\n          apis.setGroups(toolbar, groups);\r\n        },\r\n        refresh: function (apis, toolbar) {\r\n          apis.refresh(toolbar);\r\n        },\r\n        toggle: function (apis, toolbar) {\r\n          apis.toggle(toolbar);\r\n        },\r\n        isOpen: function (apis, toolbar) {\r\n          return apis.isOpen(toolbar);\r\n        }\r\n      }\r\n    });\r\n\r\n    var renderToolbarGroupCommon = function (toolbarGroup) {\r\n      var attributes = toolbarGroup.title.fold(function () {\r\n        return {};\r\n      }, function (title) {\r\n        return { attributes: { title: title } };\r\n      });\r\n      return {\r\n        dom: __assign({\r\n          tag: 'div',\r\n          classes: ['tox-toolbar__group']\r\n        }, attributes),\r\n        components: [ToolbarGroup.parts.items({})],\r\n        items: toolbarGroup.items,\r\n        markers: { itemSelector: '*:not(.tox-split-button) > .tox-tbtn:not([disabled]), ' + '.tox-split-button:not([disabled]), ' + '.tox-toolbar-nav-js:not([disabled])' },\r\n        tgroupBehaviours: derive$1([\r\n          Tabstopping.config({}),\r\n          Focusing.config({})\r\n        ])\r\n      };\r\n    };\r\n    var renderToolbarGroup = function (toolbarGroup) {\r\n      return ToolbarGroup.sketch(renderToolbarGroupCommon(toolbarGroup));\r\n    };\r\n    var getToolbarbehaviours = function (toolbarSpec, modeName) {\r\n      var onAttached = runOnAttached(function (component) {\r\n        var groups = map$2(toolbarSpec.initGroups, renderToolbarGroup);\r\n        Toolbar.setGroups(component, groups);\r\n      });\r\n      return derive$1([\r\n        DisablingConfigs.toolbarButton(toolbarSpec.providers.isDisabled),\r\n        receivingConfig(),\r\n        Keying.config({\r\n          mode: modeName,\r\n          onEscape: toolbarSpec.onEscape,\r\n          selector: '.tox-toolbar__group'\r\n        }),\r\n        config('toolbar-events', [onAttached])\r\n      ]);\r\n    };\r\n    var renderMoreToolbarCommon = function (toolbarSpec) {\r\n      var modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';\r\n      return {\r\n        uid: toolbarSpec.uid,\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-toolbar-overlord']\r\n        },\r\n        parts: {\r\n          'overflow-group': renderToolbarGroupCommon({\r\n            title: Optional.none(),\r\n            items: []\r\n          }),\r\n          'overflow-button': renderIconButtonSpec({\r\n            name: 'more',\r\n            icon: Optional.some('more-drawer'),\r\n            disabled: false,\r\n            tooltip: Optional.some('More...'),\r\n            primary: false,\r\n            borderless: false\r\n          }, Optional.none(), toolbarSpec.providers)\r\n        },\r\n        splitToolbarBehaviours: getToolbarbehaviours(toolbarSpec, modeName)\r\n      };\r\n    };\r\n    var renderFloatingMoreToolbar = function (toolbarSpec) {\r\n      var baseSpec = renderMoreToolbarCommon(toolbarSpec);\r\n      var overflowXOffset = 4;\r\n      var primary = SplitFloatingToolbar.parts.primary({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-toolbar__primary']\r\n        }\r\n      });\r\n      return SplitFloatingToolbar.sketch(__assign(__assign({}, baseSpec), {\r\n        lazySink: toolbarSpec.getSink,\r\n        getOverflowBounds: function () {\r\n          var headerElem = toolbarSpec.moreDrawerData.lazyHeader().element;\r\n          var headerBounds = absolute$2(headerElem);\r\n          var docElem = documentElement(headerElem);\r\n          var docBounds = absolute$2(docElem);\r\n          var height = Math.max(docElem.dom.scrollHeight, docBounds.height);\r\n          return bounds(headerBounds.x + overflowXOffset, docBounds.y, headerBounds.width - overflowXOffset * 2, height);\r\n        },\r\n        parts: __assign(__assign({}, baseSpec.parts), {\r\n          overflow: {\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-toolbar__overflow'],\r\n              attributes: toolbarSpec.attributes\r\n            }\r\n          }\r\n        }),\r\n        components: [primary],\r\n        markers: { overflowToggledClass: 'tox-tbtn--enabled' }\r\n      }));\r\n    };\r\n    var renderSlidingMoreToolbar = function (toolbarSpec) {\r\n      var primary = SplitSlidingToolbar.parts.primary({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-toolbar__primary']\r\n        }\r\n      });\r\n      var overflow = SplitSlidingToolbar.parts.overflow({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-toolbar__overflow']\r\n        }\r\n      });\r\n      var baseSpec = renderMoreToolbarCommon(toolbarSpec);\r\n      return SplitSlidingToolbar.sketch(__assign(__assign({}, baseSpec), {\r\n        components: [\r\n          primary,\r\n          overflow\r\n        ],\r\n        markers: {\r\n          openClass: 'tox-toolbar__overflow--open',\r\n          closedClass: 'tox-toolbar__overflow--closed',\r\n          growingClass: 'tox-toolbar__overflow--growing',\r\n          shrinkingClass: 'tox-toolbar__overflow--shrinking',\r\n          overflowToggledClass: 'tox-tbtn--enabled'\r\n        },\r\n        onOpened: function (comp) {\r\n          comp.getSystem().broadcastOn([toolbarHeightChange()], { type: 'opened' });\r\n        },\r\n        onClosed: function (comp) {\r\n          comp.getSystem().broadcastOn([toolbarHeightChange()], { type: 'closed' });\r\n        }\r\n      }));\r\n    };\r\n    var renderToolbar = function (toolbarSpec) {\r\n      var modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';\r\n      return Toolbar.sketch({\r\n        uid: toolbarSpec.uid,\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-toolbar'].concat(toolbarSpec.type === ToolbarMode.scrolling ? ['tox-toolbar--scrolling'] : [])\r\n        },\r\n        components: [Toolbar.parts.groups({})],\r\n        toolbarBehaviours: getToolbarbehaviours(toolbarSpec, modeName)\r\n      });\r\n    };\r\n\r\n    var factory$6 = function (detail, components, _spec) {\r\n      var apis = {\r\n        getSocket: function (comp) {\r\n          return parts$a.getPart(comp, detail, 'socket');\r\n        },\r\n        setSidebar: function (comp, panelConfigs) {\r\n          parts$a.getPart(comp, detail, 'sidebar').each(function (sidebar) {\r\n            return setSidebar(sidebar, panelConfigs);\r\n          });\r\n        },\r\n        toggleSidebar: function (comp, name) {\r\n          parts$a.getPart(comp, detail, 'sidebar').each(function (sidebar) {\r\n            return toggleSidebar(sidebar, name);\r\n          });\r\n        },\r\n        whichSidebar: function (comp) {\r\n          return parts$a.getPart(comp, detail, 'sidebar').bind(whichSidebar).getOrNull();\r\n        },\r\n        getHeader: function (comp) {\r\n          return parts$a.getPart(comp, detail, 'header');\r\n        },\r\n        getToolbar: function (comp) {\r\n          return parts$a.getPart(comp, detail, 'toolbar');\r\n        },\r\n        setToolbar: function (comp, groups) {\r\n          parts$a.getPart(comp, detail, 'toolbar').each(function (toolbar) {\r\n            toolbar.getApis().setGroups(toolbar, groups);\r\n          });\r\n        },\r\n        setToolbars: function (comp, toolbars) {\r\n          parts$a.getPart(comp, detail, 'multiple-toolbar').each(function (mToolbar) {\r\n            CustomList.setItems(mToolbar, toolbars);\r\n          });\r\n        },\r\n        refreshToolbar: function (comp) {\r\n          var toolbar = parts$a.getPart(comp, detail, 'toolbar');\r\n          toolbar.each(function (toolbar) {\r\n            return toolbar.getApis().refresh(toolbar);\r\n          });\r\n        },\r\n        toggleToolbarDrawer: function (comp) {\r\n          parts$a.getPart(comp, detail, 'toolbar').each(function (toolbar) {\r\n            mapFrom(toolbar.getApis().toggle, function (toggle) {\r\n              return toggle(toolbar);\r\n            });\r\n          });\r\n        },\r\n        isToolbarDrawerToggled: function (comp) {\r\n          return parts$a.getPart(comp, detail, 'toolbar').bind(function (toolbar) {\r\n            return Optional.from(toolbar.getApis().isOpen).map(function (isOpen) {\r\n              return isOpen(toolbar);\r\n            });\r\n          }).getOr(false);\r\n        },\r\n        getThrobber: function (comp) {\r\n          return parts$a.getPart(comp, detail, 'throbber');\r\n        },\r\n        focusToolbar: function (comp) {\r\n          var optToolbar = parts$a.getPart(comp, detail, 'toolbar').orThunk(function () {\r\n            return parts$a.getPart(comp, detail, 'multiple-toolbar');\r\n          });\r\n          optToolbar.each(function (toolbar) {\r\n            Keying.focusIn(toolbar);\r\n          });\r\n        },\r\n        setMenubar: function (comp, menus) {\r\n          parts$a.getPart(comp, detail, 'menubar').each(function (menubar) {\r\n            SilverMenubar.setMenus(menubar, menus);\r\n          });\r\n        },\r\n        focusMenubar: function (comp) {\r\n          parts$a.getPart(comp, detail, 'menubar').each(function (menubar) {\r\n            SilverMenubar.focus(menubar);\r\n          });\r\n        }\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        apis: apis,\r\n        behaviours: detail.behaviours\r\n      };\r\n    };\r\n    var partMenubar = partType.optional({\r\n      factory: SilverMenubar,\r\n      name: 'menubar',\r\n      schema: [required$1('backstage')]\r\n    });\r\n    var toolbarFactory = function (spec) {\r\n      if (spec.type === ToolbarMode.sliding) {\r\n        return renderSlidingMoreToolbar;\r\n      } else if (spec.type === ToolbarMode.floating) {\r\n        return renderFloatingMoreToolbar;\r\n      } else {\r\n        return renderToolbar;\r\n      }\r\n    };\r\n    var partMultipleToolbar = partType.optional({\r\n      factory: {\r\n        sketch: function (spec) {\r\n          return CustomList.sketch({\r\n            uid: spec.uid,\r\n            dom: spec.dom,\r\n            listBehaviours: derive$1([Keying.config({\r\n                mode: 'acyclic',\r\n                selector: '.tox-toolbar'\r\n              })]),\r\n            makeItem: function () {\r\n              return renderToolbar({\r\n                type: spec.type,\r\n                uid: generate$6('multiple-toolbar-item'),\r\n                cyclicKeying: false,\r\n                initGroups: [],\r\n                providers: spec.providers,\r\n                onEscape: function () {\r\n                  spec.onEscape();\r\n                  return Optional.some(true);\r\n                }\r\n              });\r\n            },\r\n            setupItem: function (_mToolbar, tc, data, _index) {\r\n              Toolbar.setGroups(tc, data);\r\n            },\r\n            shell: true\r\n          });\r\n        }\r\n      },\r\n      name: 'multiple-toolbar',\r\n      schema: [\r\n        required$1('dom'),\r\n        required$1('onEscape')\r\n      ]\r\n    });\r\n    var partToolbar = partType.optional({\r\n      factory: {\r\n        sketch: function (spec) {\r\n          var renderer = toolbarFactory(spec);\r\n          var toolbarSpec = {\r\n            type: spec.type,\r\n            uid: spec.uid,\r\n            onEscape: function () {\r\n              spec.onEscape();\r\n              return Optional.some(true);\r\n            },\r\n            cyclicKeying: false,\r\n            initGroups: [],\r\n            getSink: spec.getSink,\r\n            providers: spec.providers,\r\n            moreDrawerData: {\r\n              lazyToolbar: spec.lazyToolbar,\r\n              lazyMoreButton: spec.lazyMoreButton,\r\n              lazyHeader: spec.lazyHeader\r\n            },\r\n            attributes: spec.attributes\r\n          };\r\n          return renderer(toolbarSpec);\r\n        }\r\n      },\r\n      name: 'toolbar',\r\n      schema: [\r\n        required$1('dom'),\r\n        required$1('onEscape'),\r\n        required$1('getSink')\r\n      ]\r\n    });\r\n    var partHeader = partType.optional({\r\n      factory: { sketch: renderHeader },\r\n      name: 'header',\r\n      schema: [required$1('dom')]\r\n    });\r\n    var partSocket = partType.optional({\r\n      name: 'socket',\r\n      schema: [required$1('dom')]\r\n    });\r\n    var partSidebar = partType.optional({\r\n      factory: { sketch: renderSidebar },\r\n      name: 'sidebar',\r\n      schema: [required$1('dom')]\r\n    });\r\n    var partThrobber = partType.optional({\r\n      factory: { sketch: renderThrobber },\r\n      name: 'throbber',\r\n      schema: [required$1('dom')]\r\n    });\r\n    var OuterContainer = composite({\r\n      name: 'OuterContainer',\r\n      factory: factory$6,\r\n      configFields: [\r\n        required$1('dom'),\r\n        required$1('behaviours')\r\n      ],\r\n      partFields: [\r\n        partHeader,\r\n        partMenubar,\r\n        partToolbar,\r\n        partMultipleToolbar,\r\n        partSocket,\r\n        partSidebar,\r\n        partThrobber\r\n      ],\r\n      apis: {\r\n        getSocket: function (apis, comp) {\r\n          return apis.getSocket(comp);\r\n        },\r\n        setSidebar: function (apis, comp, panelConfigs) {\r\n          apis.setSidebar(comp, panelConfigs);\r\n        },\r\n        toggleSidebar: function (apis, comp, name) {\r\n          apis.toggleSidebar(comp, name);\r\n        },\r\n        whichSidebar: function (apis, comp) {\r\n          return apis.whichSidebar(comp);\r\n        },\r\n        getHeader: function (apis, comp) {\r\n          return apis.getHeader(comp);\r\n        },\r\n        getToolbar: function (apis, comp) {\r\n          return apis.getToolbar(comp);\r\n        },\r\n        setToolbar: function (apis, comp, grps) {\r\n          var groups = map$2(grps, function (grp) {\r\n            return renderToolbarGroup(grp);\r\n          });\r\n          apis.setToolbar(comp, groups);\r\n        },\r\n        setToolbars: function (apis, comp, ts) {\r\n          var renderedToolbars = map$2(ts, function (g) {\r\n            return map$2(g, renderToolbarGroup);\r\n          });\r\n          apis.setToolbars(comp, renderedToolbars);\r\n        },\r\n        refreshToolbar: function (apis, comp) {\r\n          return apis.refreshToolbar(comp);\r\n        },\r\n        toggleToolbarDrawer: function (apis, comp) {\r\n          apis.toggleToolbarDrawer(comp);\r\n        },\r\n        isToolbarDrawerToggled: function (apis, comp) {\r\n          return apis.isToolbarDrawerToggled(comp);\r\n        },\r\n        getThrobber: function (apis, comp) {\r\n          return apis.getThrobber(comp);\r\n        },\r\n        setMenubar: function (apis, comp, menus) {\r\n          apis.setMenubar(comp, menus);\r\n        },\r\n        focusMenubar: function (apis, comp) {\r\n          apis.focusMenubar(comp);\r\n        },\r\n        focusToolbar: function (apis, comp) {\r\n          apis.focusToolbar(comp);\r\n        }\r\n      }\r\n    });\r\n\r\n    var defaultMenubar = 'file edit view insert format tools table help';\r\n    var defaultMenus = {\r\n      file: {\r\n        title: 'File',\r\n        items: 'newdocument restoredraft | preview | export print | deleteallconversations'\r\n      },\r\n      edit: {\r\n        title: 'Edit',\r\n        items: 'undo redo | cut copy paste pastetext | selectall | searchreplace'\r\n      },\r\n      view: {\r\n        title: 'View',\r\n        items: 'code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments'\r\n      },\r\n      insert: {\r\n        title: 'Insert',\r\n        items: 'image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor toc | insertdatetime'\r\n      },\r\n      format: {\r\n        title: 'Format',\r\n        items: 'bold italic underline strikethrough superscript subscript codeformat | formats blockformats fontformats fontsizes align lineheight | forecolor backcolor | language | removeformat'\r\n      },\r\n      tools: {\r\n        title: 'Tools',\r\n        items: 'spellchecker spellcheckerlanguage | a11ycheck code wordcount'\r\n      },\r\n      table: {\r\n        title: 'Table',\r\n        items: 'inserttable | cell row column | advtablesort | tableprops deletetable'\r\n      },\r\n      help: {\r\n        title: 'Help',\r\n        items: 'help'\r\n      }\r\n    };\r\n    var make = function (menu, registry, editor) {\r\n      var removedMenuItems = getRemovedMenuItems(editor).split(/[ ,]/);\r\n      return {\r\n        text: menu.title,\r\n        getItems: function () {\r\n          return bind$3(menu.items, function (i) {\r\n            var itemName = i.toLowerCase();\r\n            if (itemName.trim().length === 0) {\r\n              return [];\r\n            } else if (exists(removedMenuItems, function (removedMenuItem) {\r\n                return removedMenuItem === itemName;\r\n              })) {\r\n              return [];\r\n            } else if (itemName === 'separator' || itemName === '|') {\r\n              return [{ type: 'separator' }];\r\n            } else if (registry.menuItems[itemName]) {\r\n              return [registry.menuItems[itemName]];\r\n            } else {\r\n              return [];\r\n            }\r\n          });\r\n        }\r\n      };\r\n    };\r\n    var parseItemsString = function (items) {\r\n      if (typeof items === 'string') {\r\n        return items.split(' ');\r\n      }\r\n      return items;\r\n    };\r\n    var identifyMenus = function (editor, registry) {\r\n      var rawMenuData = __assign(__assign({}, defaultMenus), registry.menus);\r\n      var userDefinedMenus = keys(registry.menus).length > 0;\r\n      var menubar = registry.menubar === undefined || registry.menubar === true ? parseItemsString(defaultMenubar) : parseItemsString(registry.menubar === false ? '' : registry.menubar);\r\n      var validMenus = filter$2(menubar, function (menuName) {\r\n        var isDefaultMenu = has$2(defaultMenus, menuName);\r\n        if (userDefinedMenus) {\r\n          return isDefaultMenu || get$e(registry.menus, menuName).exists(function (menu) {\r\n            return has$2(menu, 'items');\r\n          });\r\n        } else {\r\n          return isDefaultMenu;\r\n        }\r\n      });\r\n      var menus = map$2(validMenus, function (menuName) {\r\n        var menuData = rawMenuData[menuName];\r\n        return make({\r\n          title: menuData.title,\r\n          items: parseItemsString(menuData.items)\r\n        }, registry, editor);\r\n      });\r\n      return filter$2(menus, function (menu) {\r\n        var isNotSeparator = function (item) {\r\n          return item.type !== 'separator';\r\n        };\r\n        return menu.getItems().length > 0 && exists(menu.getItems(), isNotSeparator);\r\n      });\r\n    };\r\n\r\n    var fireSkinLoaded = function (editor) {\r\n      var done = function () {\r\n        editor._skinLoaded = true;\r\n        fireSkinLoaded$1(editor);\r\n      };\r\n      return function () {\r\n        if (editor.initialized) {\r\n          done();\r\n        } else {\r\n          editor.on('init', done);\r\n        }\r\n      };\r\n    };\r\n    var fireSkinLoadError = function (editor, err) {\r\n      return function () {\r\n        return fireSkinLoadError$1(editor, { message: err });\r\n      };\r\n    };\r\n\r\n    var loadStylesheet = function (editor, stylesheetUrl, styleSheetLoader) {\r\n      return new global$c(function (resolve, reject) {\r\n        styleSheetLoader.load(stylesheetUrl, resolve, reject);\r\n        editor.on('remove', function () {\r\n          return styleSheetLoader.unload(stylesheetUrl);\r\n        });\r\n      });\r\n    };\r\n    var loadUiSkins = function (editor, skinUrl) {\r\n      var skinUiCss = skinUrl + '/skin.min.css';\r\n      return loadStylesheet(editor, skinUiCss, editor.ui.styleSheetLoader);\r\n    };\r\n    var loadShadowDomUiSkins = function (editor, skinUrl) {\r\n      var isInShadowRoot$1 = isInShadowRoot(SugarElement.fromDom(editor.getElement()));\r\n      if (isInShadowRoot$1) {\r\n        var shadowDomSkinCss = skinUrl + '/skin.shadowdom.min.css';\r\n        return loadStylesheet(editor, shadowDomSkinCss, global$b.DOM.styleSheetLoader);\r\n      } else {\r\n        return global$c.resolve();\r\n      }\r\n    };\r\n    var loadSkin = function (isInline, editor) {\r\n      var skinUrl = getSkinUrl(editor);\r\n      if (skinUrl) {\r\n        editor.contentCSS.push(skinUrl + (isInline ? '/content.inline' : '/content') + '.min.css');\r\n      }\r\n      if (isSkinDisabled(editor) === false && isString(skinUrl)) {\r\n        global$c.all([\r\n          loadUiSkins(editor, skinUrl),\r\n          loadShadowDomUiSkins(editor, skinUrl)\r\n        ]).then(fireSkinLoaded(editor), fireSkinLoadError(editor, 'Skin could not be loaded'));\r\n      } else {\r\n        fireSkinLoaded(editor)();\r\n      }\r\n    };\r\n    var iframe = curry(loadSkin, false);\r\n    var inline = curry(loadSkin, true);\r\n\r\n    var onSetupFormatToggle = function (editor, name) {\r\n      return function (api) {\r\n        var boundCallback = unbindable();\r\n        var init = function () {\r\n          api.setActive(editor.formatter.match(name));\r\n          var binding = editor.formatter.formatChanged(name, api.setActive);\r\n          boundCallback.set(binding);\r\n        };\r\n        editor.initialized ? init() : editor.once('init', init);\r\n        return function () {\r\n          editor.off('init', init);\r\n          boundCallback.clear();\r\n        };\r\n      };\r\n    };\r\n    var onSetupEvent = function (editor, event, f) {\r\n      return function (api) {\r\n        var handleEvent = function () {\r\n          return f(api);\r\n        };\r\n        var init = function () {\r\n          f(api);\r\n          editor.on(event, handleEvent);\r\n        };\r\n        editor.initialized ? init() : editor.once('init', init);\r\n        return function () {\r\n          editor.off('init', init);\r\n          editor.off(event, handleEvent);\r\n        };\r\n      };\r\n    };\r\n    var onActionToggleFormat$1 = function (editor) {\r\n      return function (rawItem) {\r\n        return function () {\r\n          editor.undoManager.transact(function () {\r\n            editor.focus();\r\n            editor.execCommand('mceToggleFormat', false, rawItem.format);\r\n          });\r\n        };\r\n      };\r\n    };\r\n    var onActionExecCommand = function (editor, command) {\r\n      return function () {\r\n        return editor.execCommand(command);\r\n      };\r\n    };\r\n\r\n    var generateSelectItems = function (_editor, backstage, spec) {\r\n      var generateItem = function (rawItem, response, disabled, value) {\r\n        var translatedText = backstage.shared.providers.translate(rawItem.title);\r\n        if (rawItem.type === 'separator') {\r\n          return Optional.some({\r\n            type: 'separator',\r\n            text: translatedText\r\n          });\r\n        } else if (rawItem.type === 'submenu') {\r\n          var items = bind$3(rawItem.getStyleItems(), function (si) {\r\n            return validate(si, response, value);\r\n          });\r\n          if (response === 0 && items.length <= 0) {\r\n            return Optional.none();\r\n          } else {\r\n            return Optional.some({\r\n              type: 'nestedmenuitem',\r\n              text: translatedText,\r\n              disabled: items.length <= 0,\r\n              getSubmenuItems: function () {\r\n                return bind$3(rawItem.getStyleItems(), function (si) {\r\n                  return validate(si, response, value);\r\n                });\r\n              }\r\n            });\r\n          }\r\n        } else {\r\n          return Optional.some(__assign({\r\n            type: 'togglemenuitem',\r\n            text: translatedText,\r\n            icon: rawItem.icon,\r\n            active: rawItem.isSelected(value),\r\n            disabled: disabled,\r\n            onAction: spec.onAction(rawItem)\r\n          }, rawItem.getStylePreview().fold(function () {\r\n            return {};\r\n          }, function (preview) {\r\n            return { meta: { style: preview } };\r\n          })));\r\n        }\r\n      };\r\n      var validate = function (item, response, value) {\r\n        var invalid = item.type === 'formatter' && spec.isInvalid(item);\r\n        if (response === 0) {\r\n          return invalid ? [] : generateItem(item, response, false, value).toArray();\r\n        } else {\r\n          return generateItem(item, response, invalid, value).toArray();\r\n        }\r\n      };\r\n      var validateItems = function (preItems) {\r\n        var value = spec.getCurrentValue();\r\n        var response = spec.shouldHide ? 0 : 1;\r\n        return bind$3(preItems, function (item) {\r\n          return validate(item, response, value);\r\n        });\r\n      };\r\n      var getFetch = function (backstage, getStyleItems) {\r\n        return function (comp, callback) {\r\n          var preItems = getStyleItems();\r\n          var items = validateItems(preItems);\r\n          var menu = build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false);\r\n          callback(menu);\r\n        };\r\n      };\r\n      return {\r\n        validateItems: validateItems,\r\n        getFetch: getFetch\r\n      };\r\n    };\r\n    var createMenuItems = function (editor, backstage, spec) {\r\n      var dataset = spec.dataset;\r\n      var getStyleItems = dataset.type === 'basic' ? function () {\r\n        return map$2(dataset.data, function (d) {\r\n          return processBasic(d, spec.isSelectedFor, spec.getPreviewFor);\r\n        });\r\n      } : dataset.getData;\r\n      return {\r\n        items: generateSelectItems(editor, backstage, spec),\r\n        getStyleItems: getStyleItems\r\n      };\r\n    };\r\n    var createSelectButton = function (editor, backstage, spec) {\r\n      var _a = createMenuItems(editor, backstage, spec), items = _a.items, getStyleItems = _a.getStyleItems;\r\n      var getApi = function (comp) {\r\n        return { getComponent: constant$1(comp) };\r\n      };\r\n      var onSetup = onSetupEvent(editor, 'NodeChange', function (api) {\r\n        var comp = api.getComponent();\r\n        spec.updateText(comp);\r\n      });\r\n      return renderCommonDropdown({\r\n        text: spec.icon.isSome() ? Optional.none() : spec.text,\r\n        icon: spec.icon,\r\n        tooltip: Optional.from(spec.tooltip),\r\n        role: Optional.none(),\r\n        fetch: items.getFetch(backstage, getStyleItems),\r\n        onSetup: onSetup,\r\n        getApi: getApi,\r\n        columns: 1,\r\n        presets: 'normal',\r\n        classes: spec.icon.isSome() ? [] : ['bespoke'],\r\n        dropdownBehaviours: []\r\n      }, 'tox-tbtn', backstage.shared);\r\n    };\r\n\r\n    var process = function (rawFormats) {\r\n      return map$2(rawFormats, function (item) {\r\n        var title = item, format = item;\r\n        var values = item.split('=');\r\n        if (values.length > 1) {\r\n          title = values[0];\r\n          format = values[1];\r\n        }\r\n        return {\r\n          title: title,\r\n          format: format\r\n        };\r\n      });\r\n    };\r\n    var buildBasicStaticDataset = function (data) {\r\n      return {\r\n        type: 'basic',\r\n        data: data\r\n      };\r\n    };\r\n    var Delimiter;\r\n    (function (Delimiter) {\r\n      Delimiter[Delimiter['SemiColon'] = 0] = 'SemiColon';\r\n      Delimiter[Delimiter['Space'] = 1] = 'Space';\r\n    }(Delimiter || (Delimiter = {})));\r\n    var split = function (rawFormats, delimiter) {\r\n      if (delimiter === Delimiter.SemiColon) {\r\n        return rawFormats.replace(/;$/, '').split(';');\r\n      } else {\r\n        return rawFormats.split(' ');\r\n      }\r\n    };\r\n    var buildBasicSettingsDataset = function (editor, settingName, defaults, delimiter) {\r\n      var rawFormats = editor.getParam(settingName, defaults, 'string');\r\n      var data = process(split(rawFormats, delimiter));\r\n      return {\r\n        type: 'basic',\r\n        data: data\r\n      };\r\n    };\r\n\r\n    var alignMenuItems = [\r\n      {\r\n        title: 'Left',\r\n        icon: 'align-left',\r\n        format: 'alignleft',\r\n        command: 'JustifyLeft'\r\n      },\r\n      {\r\n        title: 'Center',\r\n        icon: 'align-center',\r\n        format: 'aligncenter',\r\n        command: 'JustifyCenter'\r\n      },\r\n      {\r\n        title: 'Right',\r\n        icon: 'align-right',\r\n        format: 'alignright',\r\n        command: 'JustifyRight'\r\n      },\r\n      {\r\n        title: 'Justify',\r\n        icon: 'align-justify',\r\n        format: 'alignjustify',\r\n        command: 'JustifyFull'\r\n      }\r\n    ];\r\n    var getSpec$4 = function (editor) {\r\n      var getMatchingValue = function () {\r\n        return find$5(alignMenuItems, function (item) {\r\n          return editor.formatter.match(item.format);\r\n        });\r\n      };\r\n      var isSelectedFor = function (format) {\r\n        return function () {\r\n          return editor.formatter.match(format);\r\n        };\r\n      };\r\n      var getPreviewFor = function (_format) {\r\n        return Optional.none;\r\n      };\r\n      var updateSelectMenuIcon = function (comp) {\r\n        var match = getMatchingValue();\r\n        var alignment = match.fold(constant$1('left'), function (item) {\r\n          return item.title.toLowerCase();\r\n        });\r\n        emitWith(comp, updateMenuIcon, { icon: 'align-' + alignment });\r\n      };\r\n      var dataset = buildBasicStaticDataset(alignMenuItems);\r\n      var onAction = function (rawItem) {\r\n        return function () {\r\n          return find$5(alignMenuItems, function (item) {\r\n            return item.format === rawItem.format;\r\n          }).each(function (item) {\r\n            return editor.execCommand(item.command);\r\n          });\r\n        };\r\n      };\r\n      return {\r\n        tooltip: 'Align',\r\n        text: Optional.none(),\r\n        icon: Optional.some('align-left'),\r\n        isSelectedFor: isSelectedFor,\r\n        getCurrentValue: Optional.none,\r\n        getPreviewFor: getPreviewFor,\r\n        onAction: onAction,\r\n        updateText: updateSelectMenuIcon,\r\n        dataset: dataset,\r\n        shouldHide: false,\r\n        isInvalid: function (item) {\r\n          return !editor.formatter.canApply(item.format);\r\n        }\r\n      };\r\n    };\r\n    var createAlignSelect = function (editor, backstage) {\r\n      return createSelectButton(editor, backstage, getSpec$4(editor));\r\n    };\r\n    var alignSelectMenu = function (editor, backstage) {\r\n      var menuItems = createMenuItems(editor, backstage, getSpec$4(editor));\r\n      editor.ui.registry.addNestedMenuItem('align', {\r\n        text: backstage.shared.providers.translate('Align'),\r\n        getSubmenuItems: function () {\r\n          return menuItems.items.validateItems(menuItems.getStyleItems());\r\n        }\r\n      });\r\n    };\r\n\r\n    var defaultFontsFormats = 'Andale Mono=andale mono,monospace;' + 'Arial=arial,helvetica,sans-serif;' + 'Arial Black=arial black,sans-serif;' + 'Book Antiqua=book antiqua,palatino,serif;' + 'Comic Sans MS=comic sans ms,sans-serif;' + 'Courier New=courier new,courier,monospace;' + 'Georgia=georgia,palatino,serif;' + 'Helvetica=helvetica,arial,sans-serif;' + 'Impact=impact,sans-serif;' + 'Symbol=symbol;' + 'Tahoma=tahoma,arial,helvetica,sans-serif;' + 'Terminal=terminal,monaco,monospace;' + 'Times New Roman=times new roman,times,serif;' + 'Trebuchet MS=trebuchet ms,geneva,sans-serif;' + 'Verdana=verdana,geneva,sans-serif;' + 'Webdings=webdings;' + 'Wingdings=wingdings,zapf dingbats';\r\n    var systemStackFonts = [\r\n      '-apple-system',\r\n      'Segoe UI',\r\n      'Roboto',\r\n      'Helvetica Neue',\r\n      'sans-serif'\r\n    ];\r\n    var splitFonts = function (fontFamily) {\r\n      var fonts = fontFamily.split(/\\s*,\\s*/);\r\n      return map$2(fonts, function (font) {\r\n        return font.replace(/^['\"]+|['\"]+$/g, '');\r\n      });\r\n    };\r\n    var isSystemFontStack = function (fontFamily) {\r\n      var matchesSystemStack = function () {\r\n        var fonts = splitFonts(fontFamily.toLowerCase());\r\n        return forall(systemStackFonts, function (font) {\r\n          return fonts.indexOf(font.toLowerCase()) > -1;\r\n        });\r\n      };\r\n      return fontFamily.indexOf('-apple-system') === 0 && matchesSystemStack();\r\n    };\r\n    var getSpec$3 = function (editor) {\r\n      var systemFont = 'System Font';\r\n      var getMatchingValue = function () {\r\n        var getFirstFont = function (fontFamily) {\r\n          return fontFamily ? splitFonts(fontFamily)[0] : '';\r\n        };\r\n        var fontFamily = editor.queryCommandValue('FontName');\r\n        var items = dataset.data;\r\n        var font = fontFamily ? fontFamily.toLowerCase() : '';\r\n        var matchOpt = find$5(items, function (item) {\r\n          var format = item.format;\r\n          return format.toLowerCase() === font || getFirstFont(format).toLowerCase() === getFirstFont(font).toLowerCase();\r\n        }).orThunk(function () {\r\n          return someIf(isSystemFontStack(font), {\r\n            title: systemFont,\r\n            format: font\r\n          });\r\n        });\r\n        return {\r\n          matchOpt: matchOpt,\r\n          font: fontFamily\r\n        };\r\n      };\r\n      var isSelectedFor = function (item) {\r\n        return function (valueOpt) {\r\n          return valueOpt.exists(function (value) {\r\n            return value.format === item;\r\n          });\r\n        };\r\n      };\r\n      var getCurrentValue = function () {\r\n        var matchOpt = getMatchingValue().matchOpt;\r\n        return matchOpt;\r\n      };\r\n      var getPreviewFor = function (item) {\r\n        return function () {\r\n          return Optional.some({\r\n            tag: 'div',\r\n            styles: item.indexOf('dings') === -1 ? { 'font-family': item } : {}\r\n          });\r\n        };\r\n      };\r\n      var onAction = function (rawItem) {\r\n        return function () {\r\n          editor.undoManager.transact(function () {\r\n            editor.focus();\r\n            editor.execCommand('FontName', false, rawItem.format);\r\n          });\r\n        };\r\n      };\r\n      var updateSelectMenuText = function (comp) {\r\n        var _a = getMatchingValue(), matchOpt = _a.matchOpt, font = _a.font;\r\n        var text = matchOpt.fold(constant$1(font), function (item) {\r\n          return item.title;\r\n        });\r\n        emitWith(comp, updateMenuText, { text: text });\r\n      };\r\n      var dataset = buildBasicSettingsDataset(editor, 'font_formats', defaultFontsFormats, Delimiter.SemiColon);\r\n      return {\r\n        tooltip: 'Fonts',\r\n        text: Optional.some(systemFont),\r\n        icon: Optional.none(),\r\n        isSelectedFor: isSelectedFor,\r\n        getCurrentValue: getCurrentValue,\r\n        getPreviewFor: getPreviewFor,\r\n        onAction: onAction,\r\n        updateText: updateSelectMenuText,\r\n        dataset: dataset,\r\n        shouldHide: false,\r\n        isInvalid: never\r\n      };\r\n    };\r\n    var createFontSelect = function (editor, backstage) {\r\n      return createSelectButton(editor, backstage, getSpec$3(editor));\r\n    };\r\n    var fontSelectMenu = function (editor, backstage) {\r\n      var menuItems = createMenuItems(editor, backstage, getSpec$3(editor));\r\n      editor.ui.registry.addNestedMenuItem('fontformats', {\r\n        text: backstage.shared.providers.translate('Fonts'),\r\n        getSubmenuItems: function () {\r\n          return menuItems.items.validateItems(menuItems.getStyleItems());\r\n        }\r\n      });\r\n    };\r\n\r\n    var defaultFontsizeFormats = '8pt 10pt 12pt 14pt 18pt 24pt 36pt';\r\n    var legacyFontSizes = {\r\n      '8pt': '1',\r\n      '10pt': '2',\r\n      '12pt': '3',\r\n      '14pt': '4',\r\n      '18pt': '5',\r\n      '24pt': '6',\r\n      '36pt': '7'\r\n    };\r\n    var keywordFontSizes = {\r\n      'xx-small': '7pt',\r\n      'x-small': '8pt',\r\n      'small': '10pt',\r\n      'medium': '12pt',\r\n      'large': '14pt',\r\n      'x-large': '18pt',\r\n      'xx-large': '24pt'\r\n    };\r\n    var round = function (number, precision) {\r\n      var factor = Math.pow(10, precision);\r\n      return Math.round(number * factor) / factor;\r\n    };\r\n    var toPt = function (fontSize, precision) {\r\n      if (/[0-9.]+px$/.test(fontSize)) {\r\n        return round(parseInt(fontSize, 10) * 72 / 96, precision || 0) + 'pt';\r\n      } else {\r\n        return get$e(keywordFontSizes, fontSize).getOr(fontSize);\r\n      }\r\n    };\r\n    var toLegacy = function (fontSize) {\r\n      return get$e(legacyFontSizes, fontSize).getOr('');\r\n    };\r\n    var getSpec$2 = function (editor) {\r\n      var getMatchingValue = function () {\r\n        var matchOpt = Optional.none();\r\n        var items = dataset.data;\r\n        var fontSize = editor.queryCommandValue('FontSize');\r\n        if (fontSize) {\r\n          var _loop_1 = function (precision) {\r\n            var pt = toPt(fontSize, precision);\r\n            var legacy = toLegacy(pt);\r\n            matchOpt = find$5(items, function (item) {\r\n              return item.format === fontSize || item.format === pt || item.format === legacy;\r\n            });\r\n          };\r\n          for (var precision = 3; matchOpt.isNone() && precision >= 0; precision--) {\r\n            _loop_1(precision);\r\n          }\r\n        }\r\n        return {\r\n          matchOpt: matchOpt,\r\n          size: fontSize\r\n        };\r\n      };\r\n      var isSelectedFor = function (item) {\r\n        return function (valueOpt) {\r\n          return valueOpt.exists(function (value) {\r\n            return value.format === item;\r\n          });\r\n        };\r\n      };\r\n      var getCurrentValue = function () {\r\n        var matchOpt = getMatchingValue().matchOpt;\r\n        return matchOpt;\r\n      };\r\n      var getPreviewFor = constant$1(Optional.none);\r\n      var onAction = function (rawItem) {\r\n        return function () {\r\n          editor.undoManager.transact(function () {\r\n            editor.focus();\r\n            editor.execCommand('FontSize', false, rawItem.format);\r\n          });\r\n        };\r\n      };\r\n      var updateSelectMenuText = function (comp) {\r\n        var _a = getMatchingValue(), matchOpt = _a.matchOpt, size = _a.size;\r\n        var text = matchOpt.fold(constant$1(size), function (match) {\r\n          return match.title;\r\n        });\r\n        emitWith(comp, updateMenuText, { text: text });\r\n      };\r\n      var dataset = buildBasicSettingsDataset(editor, 'fontsize_formats', defaultFontsizeFormats, Delimiter.Space);\r\n      return {\r\n        tooltip: 'Font sizes',\r\n        text: Optional.some('12pt'),\r\n        icon: Optional.none(),\r\n        isSelectedFor: isSelectedFor,\r\n        getPreviewFor: getPreviewFor,\r\n        getCurrentValue: getCurrentValue,\r\n        onAction: onAction,\r\n        updateText: updateSelectMenuText,\r\n        dataset: dataset,\r\n        shouldHide: false,\r\n        isInvalid: never\r\n      };\r\n    };\r\n    var createFontsizeSelect = function (editor, backstage) {\r\n      return createSelectButton(editor, backstage, getSpec$2(editor));\r\n    };\r\n    var fontsizeSelectMenu = function (editor, backstage) {\r\n      var menuItems = createMenuItems(editor, backstage, getSpec$2(editor));\r\n      editor.ui.registry.addNestedMenuItem('fontsizes', {\r\n        text: 'Font sizes',\r\n        getSubmenuItems: function () {\r\n          return menuItems.items.validateItems(menuItems.getStyleItems());\r\n        }\r\n      });\r\n    };\r\n\r\n    var findNearest = function (editor, getStyles) {\r\n      var styles = getStyles();\r\n      var formats = map$2(styles, function (style) {\r\n        return style.format;\r\n      });\r\n      return Optional.from(editor.formatter.closest(formats)).bind(function (fmt) {\r\n        return find$5(styles, function (data) {\r\n          return data.format === fmt;\r\n        });\r\n      }).orThunk(function () {\r\n        return someIf(editor.formatter.match('p'), {\r\n          title: 'Paragraph',\r\n          format: 'p'\r\n        });\r\n      });\r\n    };\r\n\r\n    var defaultBlocks = 'Paragraph=p;' + 'Heading 1=h1;' + 'Heading 2=h2;' + 'Heading 3=h3;' + 'Heading 4=h4;' + 'Heading 5=h5;' + 'Heading 6=h6;' + 'Preformatted=pre';\r\n    var getSpec$1 = function (editor) {\r\n      var fallbackFormat = 'Paragraph';\r\n      var isSelectedFor = function (format) {\r\n        return function () {\r\n          return editor.formatter.match(format);\r\n        };\r\n      };\r\n      var getPreviewFor = function (format) {\r\n        return function () {\r\n          var fmt = editor.formatter.get(format);\r\n          return Optional.some({\r\n            tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',\r\n            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))\r\n          });\r\n        };\r\n      };\r\n      var updateSelectMenuText = function (comp) {\r\n        var detectedFormat = findNearest(editor, function () {\r\n          return dataset.data;\r\n        });\r\n        var text = detectedFormat.fold(constant$1(fallbackFormat), function (fmt) {\r\n          return fmt.title;\r\n        });\r\n        emitWith(comp, updateMenuText, { text: text });\r\n      };\r\n      var dataset = buildBasicSettingsDataset(editor, 'block_formats', defaultBlocks, Delimiter.SemiColon);\r\n      return {\r\n        tooltip: 'Blocks',\r\n        text: Optional.some(fallbackFormat),\r\n        icon: Optional.none(),\r\n        isSelectedFor: isSelectedFor,\r\n        getCurrentValue: Optional.none,\r\n        getPreviewFor: getPreviewFor,\r\n        onAction: onActionToggleFormat$1(editor),\r\n        updateText: updateSelectMenuText,\r\n        dataset: dataset,\r\n        shouldHide: false,\r\n        isInvalid: function (item) {\r\n          return !editor.formatter.canApply(item.format);\r\n        }\r\n      };\r\n    };\r\n    var createFormatSelect = function (editor, backstage) {\r\n      return createSelectButton(editor, backstage, getSpec$1(editor));\r\n    };\r\n    var formatSelectMenu = function (editor, backstage) {\r\n      var menuItems = createMenuItems(editor, backstage, getSpec$1(editor));\r\n      editor.ui.registry.addNestedMenuItem('blockformats', {\r\n        text: 'Blocks',\r\n        getSubmenuItems: function () {\r\n          return menuItems.items.validateItems(menuItems.getStyleItems());\r\n        }\r\n      });\r\n    };\r\n\r\n    var getSpec = function (editor, dataset) {\r\n      var fallbackFormat = 'Paragraph';\r\n      var isSelectedFor = function (format) {\r\n        return function () {\r\n          return editor.formatter.match(format);\r\n        };\r\n      };\r\n      var getPreviewFor = function (format) {\r\n        return function () {\r\n          var fmt = editor.formatter.get(format);\r\n          return fmt !== undefined ? Optional.some({\r\n            tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',\r\n            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))\r\n          }) : Optional.none();\r\n        };\r\n      };\r\n      var updateSelectMenuText = function (comp) {\r\n        var getFormatItems = function (fmt) {\r\n          var subs = fmt.items;\r\n          return subs !== undefined && subs.length > 0 ? bind$3(subs, getFormatItems) : [{\r\n              title: fmt.title,\r\n              format: fmt.format\r\n            }];\r\n        };\r\n        var flattenedItems = bind$3(getStyleFormats(editor), getFormatItems);\r\n        var detectedFormat = findNearest(editor, constant$1(flattenedItems));\r\n        var text = detectedFormat.fold(constant$1(fallbackFormat), function (fmt) {\r\n          return fmt.title;\r\n        });\r\n        emitWith(comp, updateMenuText, { text: text });\r\n      };\r\n      return {\r\n        tooltip: 'Formats',\r\n        text: Optional.some(fallbackFormat),\r\n        icon: Optional.none(),\r\n        isSelectedFor: isSelectedFor,\r\n        getCurrentValue: Optional.none,\r\n        getPreviewFor: getPreviewFor,\r\n        onAction: onActionToggleFormat$1(editor),\r\n        updateText: updateSelectMenuText,\r\n        shouldHide: editor.getParam('style_formats_autohide', false, 'boolean'),\r\n        isInvalid: function (item) {\r\n          return !editor.formatter.canApply(item.format);\r\n        },\r\n        dataset: dataset\r\n      };\r\n    };\r\n    var createStyleSelect = function (editor, backstage) {\r\n      var dataset = __assign({ type: 'advanced' }, backstage.styleselect);\r\n      return createSelectButton(editor, backstage, getSpec(editor, dataset));\r\n    };\r\n    var styleSelectMenu = function (editor, backstage) {\r\n      var dataset = __assign({ type: 'advanced' }, backstage.styleselect);\r\n      var menuItems = createMenuItems(editor, backstage, getSpec(editor, dataset));\r\n      editor.ui.registry.addNestedMenuItem('formats', {\r\n        text: 'Formats',\r\n        getSubmenuItems: function () {\r\n          return menuItems.items.validateItems(menuItems.getStyleItems());\r\n        }\r\n      });\r\n    };\r\n\r\n    var events$3 = function (reflectingConfig, reflectingState) {\r\n      var update = function (component, data) {\r\n        reflectingConfig.updateState.each(function (updateState) {\r\n          var newState = updateState(component, data);\r\n          reflectingState.set(newState);\r\n        });\r\n        reflectingConfig.renderComponents.each(function (renderComponents) {\r\n          var newComponents = renderComponents(data, reflectingState.get());\r\n          var newChildren = map$2(newComponents, component.getSystem().build);\r\n          replaceChildren(component, newChildren);\r\n        });\r\n      };\r\n      return derive$2([\r\n        run$1(receive(), function (component, message) {\r\n          var receivingData = message;\r\n          if (!receivingData.universal) {\r\n            var channel = reflectingConfig.channel;\r\n            if (contains$2(receivingData.channels, channel)) {\r\n              update(component, receivingData.data);\r\n            }\r\n          }\r\n        }),\r\n        runOnAttached(function (comp, _se) {\r\n          reflectingConfig.initialData.each(function (rawData) {\r\n            update(comp, rawData);\r\n          });\r\n        })\r\n      ]);\r\n    };\r\n\r\n    var ActiveReflecting = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        events: events$3\r\n    });\r\n\r\n    var getState = function (component, replaceConfig, reflectState) {\r\n      return reflectState;\r\n    };\r\n\r\n    var ReflectingApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        getState: getState\r\n    });\r\n\r\n    var ReflectingSchema = [\r\n      required$1('channel'),\r\n      option('renderComponents'),\r\n      option('updateState'),\r\n      option('initialData')\r\n    ];\r\n\r\n    var init$3 = function () {\r\n      var cell = Cell(Optional.none());\r\n      var clear = function () {\r\n        return cell.set(Optional.none());\r\n      };\r\n      var readState = function () {\r\n        return cell.get().getOr('none');\r\n      };\r\n      return {\r\n        readState: readState,\r\n        get: cell.get,\r\n        set: cell.set,\r\n        clear: clear\r\n      };\r\n    };\r\n\r\n    var ReflectingState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        init: init$3\r\n    });\r\n\r\n    var Reflecting = create$8({\r\n      fields: ReflectingSchema,\r\n      name: 'reflecting',\r\n      active: ActiveReflecting,\r\n      apis: ReflectingApis,\r\n      state: ReflectingState\r\n    });\r\n\r\n    var schema$7 = constant$1([\r\n      required$1('toggleClass'),\r\n      required$1('fetch'),\r\n      onStrictHandler('onExecute'),\r\n      defaulted('getHotspot', Optional.some),\r\n      defaulted('getAnchorOverrides', constant$1({})),\r\n      schema$y(),\r\n      onStrictHandler('onItemExecute'),\r\n      option('lazySink'),\r\n      required$1('dom'),\r\n      onHandler('onOpen'),\r\n      field('splitDropdownBehaviours', [\r\n        Coupling,\r\n        Keying,\r\n        Focusing\r\n      ]),\r\n      defaulted('matchWidth', false),\r\n      defaulted('useMinWidth', false),\r\n      defaulted('eventOrder', {}),\r\n      option('role')\r\n    ].concat(sandboxFields()));\r\n    var arrowPart = required({\r\n      factory: Button,\r\n      schema: [required$1('dom')],\r\n      name: 'arrow',\r\n      defaults: function () {\r\n        return { buttonBehaviours: derive$1([Focusing.revoke()]) };\r\n      },\r\n      overrides: function (detail) {\r\n        return {\r\n          dom: {\r\n            tag: 'span',\r\n            attributes: { role: 'presentation' }\r\n          },\r\n          action: function (arrow) {\r\n            arrow.getSystem().getByUid(detail.uid).each(emitExecute);\r\n          },\r\n          buttonBehaviours: derive$1([Toggling.config({\r\n              toggleOnExecute: false,\r\n              toggleClass: detail.toggleClass\r\n            })])\r\n        };\r\n      }\r\n    });\r\n    var buttonPart = required({\r\n      factory: Button,\r\n      schema: [required$1('dom')],\r\n      name: 'button',\r\n      defaults: function () {\r\n        return { buttonBehaviours: derive$1([Focusing.revoke()]) };\r\n      },\r\n      overrides: function (detail) {\r\n        return {\r\n          dom: {\r\n            tag: 'span',\r\n            attributes: { role: 'presentation' }\r\n          },\r\n          action: function (btn) {\r\n            btn.getSystem().getByUid(detail.uid).each(function (splitDropdown) {\r\n              detail.onExecute(splitDropdown, btn);\r\n            });\r\n          }\r\n        };\r\n      }\r\n    });\r\n    var parts$3 = constant$1([\r\n      arrowPart,\r\n      buttonPart,\r\n      optional({\r\n        factory: {\r\n          sketch: function (spec) {\r\n            return {\r\n              uid: spec.uid,\r\n              dom: {\r\n                tag: 'span',\r\n                styles: { display: 'none' },\r\n                attributes: { 'aria-hidden': 'true' },\r\n                innerHtml: spec.text\r\n              }\r\n            };\r\n          }\r\n        },\r\n        schema: [required$1('text')],\r\n        name: 'aria-descriptor'\r\n      }),\r\n      external$1({\r\n        schema: [tieredMenuMarkers()],\r\n        name: 'menu',\r\n        defaults: function (detail) {\r\n          return {\r\n            onExecute: function (tmenu, item) {\r\n              tmenu.getSystem().getByUid(detail.uid).each(function (splitDropdown) {\r\n                detail.onItemExecute(splitDropdown, tmenu, item);\r\n              });\r\n            }\r\n          };\r\n        }\r\n      }),\r\n      partType$1()\r\n    ]);\r\n\r\n    var factory$5 = function (detail, components, spec, externals) {\r\n      var _a;\r\n      var switchToMenu = function (sandbox) {\r\n        Composing.getCurrent(sandbox).each(function (current) {\r\n          Highlighting.highlightFirst(current);\r\n          Keying.focusIn(current);\r\n        });\r\n      };\r\n      var action = function (component) {\r\n        var onOpenSync = switchToMenu;\r\n        togglePopup(detail, identity$1, component, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);\r\n      };\r\n      var openMenu = function (comp) {\r\n        action(comp);\r\n        return Optional.some(true);\r\n      };\r\n      var executeOnButton = function (comp) {\r\n        var button = getPartOrDie(comp, detail, 'button');\r\n        emitExecute(button);\r\n        return Optional.some(true);\r\n      };\r\n      var buttonEvents = __assign(__assign({}, derive$2([runOnAttached(function (component, _simulatedEvent) {\r\n          var ariaDescriptor = getPart(component, detail, 'aria-descriptor');\r\n          ariaDescriptor.each(function (descriptor) {\r\n            var descriptorId = generate$6('aria');\r\n            set$8(descriptor.element, 'id', descriptorId);\r\n            set$8(component.element, 'aria-describedby', descriptorId);\r\n          });\r\n        })])), events$a(Optional.some(action)));\r\n      var apis = {\r\n        repositionMenus: function (comp) {\r\n          if (Toggling.isOn(comp)) {\r\n            repositionMenus(comp);\r\n          }\r\n        }\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        apis: apis,\r\n        eventOrder: __assign(__assign({}, detail.eventOrder), (_a = {}, _a[execute$5()] = [\r\n          'disabling',\r\n          'toggling',\r\n          'alloy.base.behaviour'\r\n        ], _a)),\r\n        events: buttonEvents,\r\n        behaviours: augment(detail.splitDropdownBehaviours, [\r\n          Coupling.config({\r\n            others: {\r\n              sandbox: function (hotspot) {\r\n                var arrow = getPartOrDie(hotspot, detail, 'arrow');\r\n                var extras = {\r\n                  onOpen: function () {\r\n                    Toggling.on(arrow);\r\n                    Toggling.on(hotspot);\r\n                  },\r\n                  onClose: function () {\r\n                    Toggling.off(arrow);\r\n                    Toggling.off(hotspot);\r\n                  }\r\n                };\r\n                return makeSandbox$1(detail, hotspot, extras);\r\n              }\r\n            }\r\n          }),\r\n          Keying.config({\r\n            mode: 'special',\r\n            onSpace: executeOnButton,\r\n            onEnter: executeOnButton,\r\n            onDown: openMenu\r\n          }),\r\n          Focusing.config({}),\r\n          Toggling.config({\r\n            toggleOnExecute: false,\r\n            aria: { mode: 'expanded' }\r\n          })\r\n        ]),\r\n        domModification: {\r\n          attributes: {\r\n            'role': detail.role.getOr('button'),\r\n            'aria-haspopup': true\r\n          }\r\n        }\r\n      };\r\n    };\r\n    var SplitDropdown = composite({\r\n      name: 'SplitDropdown',\r\n      configFields: schema$7(),\r\n      partFields: parts$3(),\r\n      factory: factory$5,\r\n      apis: {\r\n        repositionMenus: function (apis, comp) {\r\n          return apis.repositionMenus(comp);\r\n        }\r\n      }\r\n    });\r\n\r\n    var getButtonApi = function (component) {\r\n      return {\r\n        isDisabled: function () {\r\n          return Disabling.isDisabled(component);\r\n        },\r\n        setDisabled: function (state) {\r\n          return Disabling.set(component, state);\r\n        }\r\n      };\r\n    };\r\n    var getToggleApi = function (component) {\r\n      return {\r\n        setActive: function (state) {\r\n          Toggling.set(component, state);\r\n        },\r\n        isActive: function () {\r\n          return Toggling.isOn(component);\r\n        },\r\n        isDisabled: function () {\r\n          return Disabling.isDisabled(component);\r\n        },\r\n        setDisabled: function (state) {\r\n          return Disabling.set(component, state);\r\n        }\r\n      };\r\n    };\r\n    var getTooltipAttributes = function (tooltip, providersBackstage) {\r\n      return tooltip.map(function (tooltip) {\r\n        return {\r\n          'aria-label': providersBackstage.translate(tooltip),\r\n          'title': providersBackstage.translate(tooltip)\r\n        };\r\n      }).getOr({});\r\n    };\r\n    var focusButtonEvent = generate$6('focus-button');\r\n    var renderCommonStructure = function (icon, text, tooltip, receiver, behaviours, providersBackstage) {\r\n      var _d;\r\n      return {\r\n        dom: {\r\n          tag: 'button',\r\n          classes: ['tox-tbtn'].concat(text.isSome() ? ['tox-tbtn--select'] : []),\r\n          attributes: getTooltipAttributes(tooltip, providersBackstage)\r\n        },\r\n        components: componentRenderPipeline([\r\n          icon.map(function (iconName) {\r\n            return renderIconFromPack(iconName, providersBackstage.icons);\r\n          }),\r\n          text.map(function (text) {\r\n            return renderLabel$1(text, 'tox-tbtn', providersBackstage);\r\n          })\r\n        ]),\r\n        eventOrder: (_d = {}, _d[mousedown()] = [\r\n          'focusing',\r\n          'alloy.base.behaviour',\r\n          'common-button-display-events'\r\n        ], _d),\r\n        buttonBehaviours: derive$1([\r\n          DisablingConfigs.toolbarButton(providersBackstage.isDisabled),\r\n          receivingConfig(),\r\n          config('common-button-display-events', [run$1(mousedown(), function (button, se) {\r\n              se.event.prevent();\r\n              emit(button, focusButtonEvent);\r\n            })])\r\n        ].concat(receiver.map(function (r) {\r\n          return Reflecting.config({\r\n            channel: r,\r\n            initialData: {\r\n              icon: icon,\r\n              text: text\r\n            },\r\n            renderComponents: function (data, _state) {\r\n              return componentRenderPipeline([\r\n                data.icon.map(function (iconName) {\r\n                  return renderIconFromPack(iconName, providersBackstage.icons);\r\n                }),\r\n                data.text.map(function (text) {\r\n                  return renderLabel$1(text, 'tox-tbtn', providersBackstage);\r\n                })\r\n              ]);\r\n            }\r\n          });\r\n        }).toArray()).concat(behaviours.getOr([])))\r\n      };\r\n    };\r\n    var renderFloatingToolbarButton = function (spec, backstage, identifyButtons, attributes) {\r\n      var sharedBackstage = backstage.shared;\r\n      return FloatingToolbarButton.sketch({\r\n        lazySink: sharedBackstage.getSink,\r\n        fetch: function () {\r\n          return Future.nu(function (resolve) {\r\n            resolve(map$2(identifyButtons(spec.items), renderToolbarGroup));\r\n          });\r\n        },\r\n        markers: { toggledClass: 'tox-tbtn--enabled' },\r\n        parts: {\r\n          button: renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), Optional.none(), sharedBackstage.providers),\r\n          toolbar: {\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-toolbar__overflow'],\r\n              attributes: attributes\r\n            }\r\n          }\r\n        }\r\n      });\r\n    };\r\n    var renderCommonToolbarButton = function (spec, specialisation, providersBackstage) {\r\n      var editorOffCell = Cell(noop);\r\n      var structure = renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), Optional.none(), providersBackstage);\r\n      return Button.sketch({\r\n        dom: structure.dom,\r\n        components: structure.components,\r\n        eventOrder: toolbarButtonEventOrder,\r\n        buttonBehaviours: derive$1([\r\n          config('toolbar-button-events', [\r\n            onToolbarButtonExecute({\r\n              onAction: spec.onAction,\r\n              getApi: specialisation.getApi\r\n            }),\r\n            onControlAttached(specialisation, editorOffCell),\r\n            onControlDetached(specialisation, editorOffCell)\r\n          ]),\r\n          DisablingConfigs.toolbarButton(function () {\r\n            return spec.disabled || providersBackstage.isDisabled();\r\n          }),\r\n          receivingConfig()\r\n        ].concat(specialisation.toolbarButtonBehaviours))\r\n      });\r\n    };\r\n    var renderToolbarButton = function (spec, providersBackstage) {\r\n      return renderToolbarButtonWith(spec, providersBackstage, []);\r\n    };\r\n    var renderToolbarButtonWith = function (spec, providersBackstage, bonusEvents) {\r\n      return renderCommonToolbarButton(spec, {\r\n        toolbarButtonBehaviours: [].concat(bonusEvents.length > 0 ? [config('toolbarButtonWith', bonusEvents)] : []),\r\n        getApi: getButtonApi,\r\n        onSetup: spec.onSetup\r\n      }, providersBackstage);\r\n    };\r\n    var renderToolbarToggleButton = function (spec, providersBackstage) {\r\n      return renderToolbarToggleButtonWith(spec, providersBackstage, []);\r\n    };\r\n    var renderToolbarToggleButtonWith = function (spec, providersBackstage, bonusEvents) {\r\n      return deepMerge(renderCommonToolbarButton(spec, {\r\n        toolbarButtonBehaviours: [\r\n          Replacing.config({}),\r\n          Toggling.config({\r\n            toggleClass: 'tox-tbtn--enabled',\r\n            aria: { mode: 'pressed' },\r\n            toggleOnExecute: false\r\n          })\r\n        ].concat(bonusEvents.length > 0 ? [config('toolbarToggleButtonWith', bonusEvents)] : []),\r\n        getApi: getToggleApi,\r\n        onSetup: spec.onSetup\r\n      }, providersBackstage));\r\n    };\r\n    var fetchChoices = function (getApi, spec, providersBackstage) {\r\n      return function (comp) {\r\n        return Future.nu(function (callback) {\r\n          return spec.fetch(callback);\r\n        }).map(function (items) {\r\n          return Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, function (value) {\r\n            spec.onItemAction(getApi(comp), value);\r\n          }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), providersBackstage), {\r\n            movement: deriveMenuMovement(spec.columns, spec.presets),\r\n            menuBehaviours: SimpleBehaviours.unnamedEvents(spec.columns !== 'auto' ? [] : [runOnAttached(function (comp, _se) {\r\n                detectSize(comp, 4, classForPreset(spec.presets)).each(function (_d) {\r\n                  var numRows = _d.numRows, numColumns = _d.numColumns;\r\n                  Keying.setGridSize(comp, numRows, numColumns);\r\n                });\r\n              })])\r\n          })));\r\n        });\r\n      };\r\n    };\r\n    var renderSplitButton = function (spec, sharedBackstage) {\r\n      var _d;\r\n      var displayChannel = generate$6('channel-update-split-dropdown-display');\r\n      var getApi = function (comp) {\r\n        return {\r\n          isDisabled: function () {\r\n            return Disabling.isDisabled(comp);\r\n          },\r\n          setDisabled: function (state) {\r\n            return Disabling.set(comp, state);\r\n          },\r\n          setIconFill: function (id, value) {\r\n            descendant(comp.element, 'svg path[id=\"' + id + '\"], rect[id=\"' + id + '\"]').each(function (underlinePath) {\r\n              set$8(underlinePath, 'fill', value);\r\n            });\r\n          },\r\n          setIconStroke: function (id, value) {\r\n            descendant(comp.element, 'svg path[id=\"' + id + '\"], rect[id=\"' + id + '\"]').each(function (underlinePath) {\r\n              set$8(underlinePath, 'stroke', value);\r\n            });\r\n          },\r\n          setActive: function (state) {\r\n            set$8(comp.element, 'aria-pressed', state);\r\n            descendant(comp.element, 'span').each(function (button) {\r\n              comp.getSystem().getByDom(button).each(function (buttonComp) {\r\n                return Toggling.set(buttonComp, state);\r\n              });\r\n            });\r\n          },\r\n          isActive: function () {\r\n            return descendant(comp.element, 'span').exists(function (button) {\r\n              return comp.getSystem().getByDom(button).exists(Toggling.isOn);\r\n            });\r\n          }\r\n        };\r\n      };\r\n      var editorOffCell = Cell(noop);\r\n      var specialisation = {\r\n        getApi: getApi,\r\n        onSetup: spec.onSetup\r\n      };\r\n      return SplitDropdown.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-split-button'],\r\n          attributes: __assign({ 'aria-pressed': false }, getTooltipAttributes(spec.tooltip, sharedBackstage.providers))\r\n        },\r\n        onExecute: function (button) {\r\n          spec.onAction(getApi(button));\r\n        },\r\n        onItemExecute: function (_a, _b, _c) {\r\n        },\r\n        splitDropdownBehaviours: derive$1([\r\n          DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),\r\n          receivingConfig(),\r\n          config('split-dropdown-events', [\r\n            run$1(focusButtonEvent, Focusing.focus),\r\n            onControlAttached(specialisation, editorOffCell),\r\n            onControlDetached(specialisation, editorOffCell)\r\n          ]),\r\n          Unselecting.config({})\r\n        ]),\r\n        eventOrder: (_d = {}, _d[attachedToDom()] = [\r\n          'alloy.base.behaviour',\r\n          'split-dropdown-events'\r\n        ], _d),\r\n        toggleClass: 'tox-tbtn--enabled',\r\n        lazySink: sharedBackstage.getSink,\r\n        fetch: fetchChoices(getApi, spec, sharedBackstage.providers),\r\n        parts: { menu: part(false, spec.columns, spec.presets) },\r\n        components: [\r\n          SplitDropdown.parts.button(renderCommonStructure(spec.icon, spec.text, Optional.none(), Optional.some(displayChannel), Optional.some([Toggling.config({\r\n              toggleClass: 'tox-tbtn--enabled',\r\n              toggleOnExecute: false\r\n            })]), sharedBackstage.providers)),\r\n          SplitDropdown.parts.arrow({\r\n            dom: {\r\n              tag: 'button',\r\n              classes: [\r\n                'tox-tbtn',\r\n                'tox-split-button__chevron'\r\n              ],\r\n              innerHtml: get$1('chevron-down', sharedBackstage.providers.icons)\r\n            },\r\n            buttonBehaviours: derive$1([\r\n              DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),\r\n              receivingConfig(),\r\n              addFocusableBehaviour()\r\n            ])\r\n          }),\r\n          SplitDropdown.parts['aria-descriptor']({ text: sharedBackstage.providers.translate('To open the popup, press Shift+Enter') })\r\n        ]\r\n      });\r\n    };\r\n\r\n    var defaultToolbar = [\r\n      {\r\n        name: 'history',\r\n        items: [\r\n          'undo',\r\n          'redo'\r\n        ]\r\n      },\r\n      {\r\n        name: 'styles',\r\n        items: ['styleselect']\r\n      },\r\n      {\r\n        name: 'formatting',\r\n        items: [\r\n          'bold',\r\n          'italic'\r\n        ]\r\n      },\r\n      {\r\n        name: 'alignment',\r\n        items: [\r\n          'alignleft',\r\n          'aligncenter',\r\n          'alignright',\r\n          'alignjustify'\r\n        ]\r\n      },\r\n      {\r\n        name: 'indentation',\r\n        items: [\r\n          'outdent',\r\n          'indent'\r\n        ]\r\n      },\r\n      {\r\n        name: 'permanent pen',\r\n        items: ['permanentpen']\r\n      },\r\n      {\r\n        name: 'comments',\r\n        items: ['addcomment']\r\n      }\r\n    ];\r\n    var renderFromBridge = function (bridgeBuilder, render) {\r\n      return function (spec, extras, editor) {\r\n        var internal = bridgeBuilder(spec).mapError(function (errInfo) {\r\n          return formatError(errInfo);\r\n        }).getOrDie();\r\n        return render(internal, extras, editor);\r\n      };\r\n    };\r\n    var types = {\r\n      button: renderFromBridge(createToolbarButton, function (s, extras) {\r\n        return renderToolbarButton(s, extras.backstage.shared.providers);\r\n      }),\r\n      togglebutton: renderFromBridge(createToggleButton, function (s, extras) {\r\n        return renderToolbarToggleButton(s, extras.backstage.shared.providers);\r\n      }),\r\n      menubutton: renderFromBridge(createMenuButton, function (s, extras) {\r\n        return renderMenuButton(s, 'tox-tbtn', extras.backstage, Optional.none());\r\n      }),\r\n      splitbutton: renderFromBridge(createSplitButton, function (s, extras) {\r\n        return renderSplitButton(s, extras.backstage.shared);\r\n      }),\r\n      grouptoolbarbutton: renderFromBridge(createGroupToolbarButton, function (s, extras, editor) {\r\n        var _a;\r\n        var buttons = editor.ui.registry.getAll().buttons;\r\n        var identify = function (toolbar) {\r\n          return identifyButtons(editor, {\r\n            buttons: buttons,\r\n            toolbar: toolbar,\r\n            allowToolbarGroups: false\r\n          }, extras, Optional.none());\r\n        };\r\n        var attributes = (_a = {}, _a[Attribute] = extras.backstage.shared.header.isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop, _a);\r\n        switch (getToolbarMode(editor)) {\r\n        case ToolbarMode.floating:\r\n          return renderFloatingToolbarButton(s, extras.backstage, identify, attributes);\r\n        default:\r\n          throw new Error('Toolbar groups are only supported when using floating toolbar mode');\r\n        }\r\n      }),\r\n      styleSelectButton: function (editor, extras) {\r\n        return createStyleSelect(editor, extras.backstage);\r\n      },\r\n      fontsizeSelectButton: function (editor, extras) {\r\n        return createFontsizeSelect(editor, extras.backstage);\r\n      },\r\n      fontSelectButton: function (editor, extras) {\r\n        return createFontSelect(editor, extras.backstage);\r\n      },\r\n      formatButton: function (editor, extras) {\r\n        return createFormatSelect(editor, extras.backstage);\r\n      },\r\n      alignMenuButton: function (editor, extras) {\r\n        return createAlignSelect(editor, extras.backstage);\r\n      }\r\n    };\r\n    var extractFrom = function (spec, extras, editor) {\r\n      return get$e(types, spec.type).fold(function () {\r\n        console.error('skipping button defined by', spec);\r\n        return Optional.none();\r\n      }, function (render) {\r\n        return Optional.some(render(spec, extras, editor));\r\n      });\r\n    };\r\n    var bespokeButtons = {\r\n      styleselect: types.styleSelectButton,\r\n      fontsizeselect: types.fontsizeSelectButton,\r\n      fontselect: types.fontSelectButton,\r\n      formatselect: types.formatButton,\r\n      align: types.alignMenuButton\r\n    };\r\n    var removeUnusedDefaults = function (buttons) {\r\n      var filteredItemGroups = map$2(defaultToolbar, function (group) {\r\n        var items = filter$2(group.items, function (subItem) {\r\n          return has$2(buttons, subItem) || has$2(bespokeButtons, subItem);\r\n        });\r\n        return {\r\n          name: group.name,\r\n          items: items\r\n        };\r\n      });\r\n      return filter$2(filteredItemGroups, function (group) {\r\n        return group.items.length > 0;\r\n      });\r\n    };\r\n    var convertStringToolbar = function (strToolbar) {\r\n      var groupsStrings = strToolbar.split('|');\r\n      return map$2(groupsStrings, function (g) {\r\n        return { items: g.trim().split(' ') };\r\n      });\r\n    };\r\n    var isToolbarGroupSettingArray = function (toolbar) {\r\n      return isArrayOf(toolbar, function (t) {\r\n        return has$2(t, 'name') && has$2(t, 'items');\r\n      });\r\n    };\r\n    var createToolbar = function (toolbarConfig) {\r\n      var toolbar = toolbarConfig.toolbar;\r\n      var buttons = toolbarConfig.buttons;\r\n      if (toolbar === false) {\r\n        return [];\r\n      } else if (toolbar === undefined || toolbar === true) {\r\n        return removeUnusedDefaults(buttons);\r\n      } else if (isString(toolbar)) {\r\n        return convertStringToolbar(toolbar);\r\n      } else if (isToolbarGroupSettingArray(toolbar)) {\r\n        return toolbar;\r\n      } else {\r\n        console.error('Toolbar type should be string, string[], boolean or ToolbarGroup[]');\r\n        return [];\r\n      }\r\n    };\r\n    var lookupButton = function (editor, buttons, toolbarItem, allowToolbarGroups, extras, prefixes) {\r\n      return get$e(buttons, toolbarItem.toLowerCase()).orThunk(function () {\r\n        return prefixes.bind(function (ps) {\r\n          return findMap(ps, function (prefix) {\r\n            return get$e(buttons, prefix + toolbarItem.toLowerCase());\r\n          });\r\n        });\r\n      }).fold(function () {\r\n        return get$e(bespokeButtons, toolbarItem.toLowerCase()).map(function (r) {\r\n          return r(editor, extras);\r\n        }).orThunk(function () {\r\n          return Optional.none();\r\n        });\r\n      }, function (spec) {\r\n        if (spec.type === 'grouptoolbarbutton' && !allowToolbarGroups) {\r\n          console.warn('Ignoring the \\'' + toolbarItem + '\\' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.');\r\n          return Optional.none();\r\n        } else {\r\n          return extractFrom(spec, extras, editor);\r\n        }\r\n      });\r\n    };\r\n    var identifyButtons = function (editor, toolbarConfig, extras, prefixes) {\r\n      var toolbarGroups = createToolbar(toolbarConfig);\r\n      var groups = map$2(toolbarGroups, function (group) {\r\n        var items = bind$3(group.items, function (toolbarItem) {\r\n          return toolbarItem.trim().length === 0 ? [] : lookupButton(editor, toolbarConfig.buttons, toolbarItem, toolbarConfig.allowToolbarGroups, extras, prefixes).toArray();\r\n        });\r\n        return {\r\n          title: Optional.from(editor.translate(group.name)),\r\n          items: items\r\n        };\r\n      });\r\n      return filter$2(groups, function (group) {\r\n        return group.items.length > 0;\r\n      });\r\n    };\r\n\r\n    var setToolbar = function (editor, uiComponents, rawUiConfig, backstage) {\r\n      var comp = uiComponents.outerContainer;\r\n      var toolbarConfig = rawUiConfig.toolbar;\r\n      var toolbarButtonsConfig = rawUiConfig.buttons;\r\n      if (isArrayOf(toolbarConfig, isString)) {\r\n        var toolbars = toolbarConfig.map(function (t) {\r\n          var config = {\r\n            toolbar: t,\r\n            buttons: toolbarButtonsConfig,\r\n            allowToolbarGroups: rawUiConfig.allowToolbarGroups\r\n          };\r\n          return identifyButtons(editor, config, { backstage: backstage }, Optional.none());\r\n        });\r\n        OuterContainer.setToolbars(comp, toolbars);\r\n      } else {\r\n        OuterContainer.setToolbar(comp, identifyButtons(editor, rawUiConfig, { backstage: backstage }, Optional.none()));\r\n      }\r\n    };\r\n\r\n    var detection = detect$1();\r\n    var isiOS12 = detection.os.isiOS() && detection.os.version.major <= 12;\r\n    var setupEvents$1 = function (editor, uiComponents) {\r\n      var dom = editor.dom;\r\n      var contentWindow = editor.getWin();\r\n      var initialDocEle = editor.getDoc().documentElement;\r\n      var lastWindowDimensions = Cell(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));\r\n      var lastDocumentDimensions = Cell(SugarPosition(initialDocEle.offsetWidth, initialDocEle.offsetHeight));\r\n      var resizeWindow = function () {\r\n        var outer = lastWindowDimensions.get();\r\n        if (outer.left !== contentWindow.innerWidth || outer.top !== contentWindow.innerHeight) {\r\n          lastWindowDimensions.set(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));\r\n          fireResizeContent(editor);\r\n        }\r\n      };\r\n      var resizeDocument = function () {\r\n        var docEle = editor.getDoc().documentElement;\r\n        var inner = lastDocumentDimensions.get();\r\n        if (inner.left !== docEle.offsetWidth || inner.top !== docEle.offsetHeight) {\r\n          lastDocumentDimensions.set(SugarPosition(docEle.offsetWidth, docEle.offsetHeight));\r\n          fireResizeContent(editor);\r\n        }\r\n      };\r\n      var scroll = function (e) {\r\n        return fireScrollContent(editor, e);\r\n      };\r\n      dom.bind(contentWindow, 'resize', resizeWindow);\r\n      dom.bind(contentWindow, 'scroll', scroll);\r\n      var elementLoad = capture(SugarElement.fromDom(editor.getBody()), 'load', resizeDocument);\r\n      var mothership = uiComponents.uiMothership.element;\r\n      editor.on('hide', function () {\r\n        set$7(mothership, 'display', 'none');\r\n      });\r\n      editor.on('show', function () {\r\n        remove$6(mothership, 'display');\r\n      });\r\n      editor.on('NodeChange', resizeDocument);\r\n      editor.on('remove', function () {\r\n        elementLoad.unbind();\r\n        dom.unbind(contentWindow, 'resize', resizeWindow);\r\n        dom.unbind(contentWindow, 'scroll', scroll);\r\n        contentWindow = null;\r\n      });\r\n    };\r\n    var render$1 = function (editor, uiComponents, rawUiConfig, backstage, args) {\r\n      var lastToolbarWidth = Cell(0);\r\n      var outerContainer = uiComponents.outerContainer;\r\n      iframe(editor);\r\n      var eTargetNode = SugarElement.fromDom(args.targetNode);\r\n      var uiRoot = getContentContainer(getRootNode(eTargetNode));\r\n      attachSystemAfter(eTargetNode, uiComponents.mothership);\r\n      attachSystem(uiRoot, uiComponents.uiMothership);\r\n      editor.on('PostRender', function () {\r\n        setToolbar(editor, uiComponents, rawUiConfig, backstage);\r\n        lastToolbarWidth.set(editor.getWin().innerWidth);\r\n        OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));\r\n        OuterContainer.setSidebar(outerContainer, rawUiConfig.sidebar);\r\n        setupEvents$1(editor, uiComponents);\r\n      });\r\n      var socket = OuterContainer.getSocket(outerContainer).getOrDie('Could not find expected socket element');\r\n      if (isiOS12) {\r\n        setAll(socket.element, {\r\n          'overflow': 'scroll',\r\n          '-webkit-overflow-scrolling': 'touch'\r\n        });\r\n        var limit = first(function () {\r\n          editor.fire('ScrollContent');\r\n        }, 20);\r\n        var unbinder = bind(socket.element, 'scroll', limit.throttle);\r\n        editor.on('remove', unbinder.unbind);\r\n      }\r\n      setupReadonlyModeSwitch(editor, uiComponents);\r\n      editor.addCommand('ToggleSidebar', function (_ui, value) {\r\n        OuterContainer.toggleSidebar(outerContainer, value);\r\n        editor.fire('ToggleSidebar');\r\n      });\r\n      editor.addQueryValueHandler('ToggleSidebar', function () {\r\n        return OuterContainer.whichSidebar(outerContainer);\r\n      });\r\n      var toolbarMode = getToolbarMode(editor);\r\n      var refreshDrawer = function () {\r\n        OuterContainer.refreshToolbar(uiComponents.outerContainer);\r\n      };\r\n      if (toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating) {\r\n        editor.on('ResizeWindow ResizeEditor ResizeContent', function () {\r\n          var width = editor.getWin().innerWidth;\r\n          if (width !== lastToolbarWidth.get()) {\r\n            refreshDrawer();\r\n            lastToolbarWidth.set(width);\r\n          }\r\n        });\r\n      }\r\n      var api = {\r\n        enable: function () {\r\n          broadcastReadonly(uiComponents, false);\r\n        },\r\n        disable: function () {\r\n          broadcastReadonly(uiComponents, true);\r\n        },\r\n        isDisabled: function () {\r\n          return Disabling.isDisabled(outerContainer);\r\n        }\r\n      };\r\n      return {\r\n        iframeContainer: socket.element.dom,\r\n        editorContainer: outerContainer.element.dom,\r\n        api: api\r\n      };\r\n    };\r\n\r\n    var Iframe = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        render: render$1\r\n    });\r\n\r\n    var parseToInt = function (val) {\r\n      var re = /^[0-9\\.]+(|px)$/i;\r\n      if (re.test('' + val)) {\r\n        return Optional.some(parseInt('' + val, 10));\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var numToPx = function (val) {\r\n      return isNumber(val) ? val + 'px' : val;\r\n    };\r\n    var calcCappedSize = function (size, minSize, maxSize) {\r\n      var minOverride = minSize.filter(function (min) {\r\n        return size < min;\r\n      });\r\n      var maxOverride = maxSize.filter(function (max) {\r\n        return size > max;\r\n      });\r\n      return minOverride.or(maxOverride).getOr(size);\r\n    };\r\n\r\n    var getHeight = function (editor) {\r\n      var baseHeight = getHeightSetting(editor);\r\n      var minHeight = getMinHeightSetting(editor);\r\n      var maxHeight = getMaxHeightSetting(editor);\r\n      return parseToInt(baseHeight).map(function (height) {\r\n        return calcCappedSize(height, minHeight, maxHeight);\r\n      });\r\n    };\r\n    var getHeightWithFallback = function (editor) {\r\n      var height = getHeight(editor);\r\n      return height.getOr(getHeightSetting(editor));\r\n    };\r\n    var getWidth = function (editor) {\r\n      var baseWidth = getWidthSetting(editor);\r\n      var minWidth = getMinWidthSetting(editor);\r\n      var maxWidth = getMaxWidthSetting(editor);\r\n      return parseToInt(baseWidth).map(function (width) {\r\n        return calcCappedSize(width, minWidth, maxWidth);\r\n      });\r\n    };\r\n    var getWidthWithFallback = function (editor) {\r\n      var width = getWidth(editor);\r\n      return width.getOr(getWidthSetting(editor));\r\n    };\r\n\r\n    var InlineHeader = function (editor, targetElm, uiComponents, backstage, floatContainer) {\r\n      var uiMothership = uiComponents.uiMothership, outerContainer = uiComponents.outerContainer;\r\n      var DOM = global$b.DOM;\r\n      var useFixedToolbarContainer = useFixedContainer(editor);\r\n      var isSticky = isStickyToolbar(editor);\r\n      var editorMaxWidthOpt = getMaxWidthSetting(editor).or(getWidth(editor));\r\n      var headerBackstage = backstage.shared.header;\r\n      var isPositionedAtTop = headerBackstage.isPositionedAtTop;\r\n      var toolbarMode = getToolbarMode(editor);\r\n      var isSplitToolbar = toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating;\r\n      var visible = Cell(false);\r\n      var isVisible = function () {\r\n        return visible.get() && !editor.removed;\r\n      };\r\n      var calcToolbarOffset = function (toolbar) {\r\n        return isSplitToolbar ? toolbar.fold(constant$1(0), function (tbar) {\r\n          return tbar.components().length > 1 ? get$b(tbar.components()[1].element) : 0;\r\n        }) : 0;\r\n      };\r\n      var calcMode = function (container) {\r\n        switch (getToolbarLocation(editor)) {\r\n        case ToolbarLocation.auto:\r\n          var toolbar_1 = OuterContainer.getToolbar(outerContainer);\r\n          var offset = calcToolbarOffset(toolbar_1);\r\n          var toolbarHeight = get$b(container.element) - offset;\r\n          var targetBounds = box$1(targetElm);\r\n          var roomAtTop = targetBounds.y > toolbarHeight;\r\n          if (roomAtTop) {\r\n            return 'top';\r\n          } else {\r\n            var doc = documentElement(targetElm);\r\n            var docHeight = Math.max(doc.dom.scrollHeight, get$b(doc));\r\n            var roomAtBottom = targetBounds.bottom < docHeight - toolbarHeight;\r\n            if (roomAtBottom) {\r\n              return 'bottom';\r\n            } else {\r\n              var winBounds = win();\r\n              var isRoomAtBottomViewport = winBounds.bottom < targetBounds.bottom - toolbarHeight;\r\n              return isRoomAtBottomViewport ? 'bottom' : 'top';\r\n            }\r\n          }\r\n        case ToolbarLocation.bottom:\r\n          return 'bottom';\r\n        case ToolbarLocation.top:\r\n        default:\r\n          return 'top';\r\n        }\r\n      };\r\n      var setupMode = function (mode) {\r\n        var container = floatContainer.get();\r\n        Docking.setModes(container, [mode]);\r\n        headerBackstage.setDockingMode(mode);\r\n        var verticalDir = isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop;\r\n        set$8(container.element, Attribute, verticalDir);\r\n      };\r\n      var updateChromeWidth = function () {\r\n        var maxWidth = editorMaxWidthOpt.getOrThunk(function () {\r\n          var bodyMargin = parseToInt(get$c(body(), 'margin-left')).getOr(0);\r\n          return get$a(body()) - absolute$3(targetElm).left + bodyMargin;\r\n        });\r\n        set$7(floatContainer.get().element, 'max-width', maxWidth + 'px');\r\n      };\r\n      var updateChromePosition = function () {\r\n        var toolbar = OuterContainer.getToolbar(outerContainer);\r\n        var offset = calcToolbarOffset(toolbar);\r\n        var targetBounds = box$1(targetElm);\r\n        var top = isPositionedAtTop() ? Math.max(targetBounds.y - get$b(floatContainer.get().element) + offset, 0) : targetBounds.bottom;\r\n        setAll(outerContainer.element, {\r\n          position: 'absolute',\r\n          top: Math.round(top) + 'px',\r\n          left: Math.round(targetBounds.x) + 'px'\r\n        });\r\n      };\r\n      var repositionPopups$1 = function () {\r\n        uiMothership.broadcastOn([repositionPopups()], {});\r\n      };\r\n      var updateChromeUi = function (resetDocking) {\r\n        if (resetDocking === void 0) {\r\n          resetDocking = false;\r\n        }\r\n        if (!isVisible()) {\r\n          return;\r\n        }\r\n        if (!useFixedToolbarContainer) {\r\n          updateChromeWidth();\r\n        }\r\n        if (isSplitToolbar) {\r\n          OuterContainer.refreshToolbar(outerContainer);\r\n        }\r\n        if (!useFixedToolbarContainer) {\r\n          updateChromePosition();\r\n        }\r\n        if (isSticky) {\r\n          var floatContainerComp = floatContainer.get();\r\n          resetDocking ? Docking.reset(floatContainerComp) : Docking.refresh(floatContainerComp);\r\n        }\r\n        repositionPopups$1();\r\n      };\r\n      var updateMode = function (updateUi) {\r\n        if (updateUi === void 0) {\r\n          updateUi = true;\r\n        }\r\n        if (useFixedToolbarContainer || !isSticky || !isVisible()) {\r\n          return;\r\n        }\r\n        var currentMode = headerBackstage.getDockingMode();\r\n        var newMode = calcMode(floatContainer.get());\r\n        if (newMode !== currentMode) {\r\n          setupMode(newMode);\r\n          if (updateUi) {\r\n            updateChromeUi(true);\r\n          }\r\n        }\r\n      };\r\n      var show = function () {\r\n        visible.set(true);\r\n        set$7(outerContainer.element, 'display', 'flex');\r\n        DOM.addClass(editor.getBody(), 'mce-edit-focus');\r\n        remove$6(uiMothership.element, 'display');\r\n        updateMode(false);\r\n        updateChromeUi();\r\n      };\r\n      var hide = function () {\r\n        visible.set(false);\r\n        if (uiComponents.outerContainer) {\r\n          set$7(outerContainer.element, 'display', 'none');\r\n          DOM.removeClass(editor.getBody(), 'mce-edit-focus');\r\n        }\r\n        set$7(uiMothership.element, 'display', 'none');\r\n      };\r\n      return {\r\n        isVisible: isVisible,\r\n        isPositionedAtTop: isPositionedAtTop,\r\n        show: show,\r\n        hide: hide,\r\n        update: updateChromeUi,\r\n        updateMode: updateMode,\r\n        repositionPopups: repositionPopups$1\r\n      };\r\n    };\r\n\r\n    var getTargetPosAndBounds = function (targetElm, isToolbarTop) {\r\n      var bounds = box$1(targetElm);\r\n      return {\r\n        pos: isToolbarTop ? bounds.y : bounds.bottom,\r\n        bounds: bounds\r\n      };\r\n    };\r\n    var setupEvents = function (editor, targetElm, ui, toolbarPersist) {\r\n      var prevPosAndBounds = Cell(getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()));\r\n      var resizeContent = function (e) {\r\n        var _a = getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()), pos = _a.pos, bounds = _a.bounds;\r\n        var _b = prevPosAndBounds.get(), prevPos = _b.pos, prevBounds = _b.bounds;\r\n        var hasResized = bounds.height !== prevBounds.height || bounds.width !== prevBounds.width;\r\n        prevPosAndBounds.set({\r\n          pos: pos,\r\n          bounds: bounds\r\n        });\r\n        if (hasResized) {\r\n          fireResizeContent(editor, e);\r\n        }\r\n        if (ui.isVisible()) {\r\n          if (prevPos !== pos) {\r\n            ui.update(true);\r\n          } else if (hasResized) {\r\n            ui.updateMode();\r\n            ui.repositionPopups();\r\n          }\r\n        }\r\n      };\r\n      if (!toolbarPersist) {\r\n        editor.on('activate', ui.show);\r\n        editor.on('deactivate', ui.hide);\r\n      }\r\n      editor.on('SkinLoaded ResizeWindow', function () {\r\n        return ui.update(true);\r\n      });\r\n      editor.on('NodeChange keydown', function (e) {\r\n        global$f.requestAnimationFrame(function () {\r\n          return resizeContent(e);\r\n        });\r\n      });\r\n      editor.on('ScrollWindow', function () {\r\n        return ui.updateMode();\r\n      });\r\n      var elementLoad = unbindable();\r\n      elementLoad.set(capture(SugarElement.fromDom(editor.getBody()), 'load', resizeContent));\r\n      editor.on('remove', function () {\r\n        elementLoad.clear();\r\n      });\r\n    };\r\n    var render = function (editor, uiComponents, rawUiConfig, backstage, args) {\r\n      var mothership = uiComponents.mothership, uiMothership = uiComponents.uiMothership, outerContainer = uiComponents.outerContainer;\r\n      var floatContainer = Cell(null);\r\n      var targetElm = SugarElement.fromDom(args.targetNode);\r\n      var ui = InlineHeader(editor, targetElm, uiComponents, backstage, floatContainer);\r\n      var toolbarPersist = isToolbarPersist(editor);\r\n      inline(editor);\r\n      var render = function () {\r\n        if (floatContainer.get()) {\r\n          ui.show();\r\n          return;\r\n        }\r\n        floatContainer.set(OuterContainer.getHeader(outerContainer).getOrDie());\r\n        var uiContainer = getUiContainer(editor);\r\n        attachSystem(uiContainer, mothership);\r\n        attachSystem(uiContainer, uiMothership);\r\n        setToolbar(editor, uiComponents, rawUiConfig, backstage);\r\n        OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));\r\n        ui.show();\r\n        setupEvents(editor, targetElm, ui, toolbarPersist);\r\n        editor.nodeChanged();\r\n      };\r\n      editor.on('show', render);\r\n      editor.on('hide', ui.hide);\r\n      if (!toolbarPersist) {\r\n        editor.on('focus', render);\r\n        editor.on('blur', ui.hide);\r\n      }\r\n      editor.on('init', function () {\r\n        if (editor.hasFocus() || toolbarPersist) {\r\n          render();\r\n        }\r\n      });\r\n      setupReadonlyModeSwitch(editor, uiComponents);\r\n      var api = {\r\n        show: function () {\r\n          ui.show();\r\n        },\r\n        hide: function () {\r\n          ui.hide();\r\n        },\r\n        enable: function () {\r\n          broadcastReadonly(uiComponents, false);\r\n        },\r\n        disable: function () {\r\n          broadcastReadonly(uiComponents, true);\r\n        },\r\n        isDisabled: function () {\r\n          return Disabling.isDisabled(outerContainer);\r\n        }\r\n      };\r\n      return {\r\n        editorContainer: outerContainer.element.dom,\r\n        api: api\r\n      };\r\n    };\r\n\r\n    var Inline = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        render: render\r\n    });\r\n\r\n    var showContextToolbarEvent = 'contexttoolbar-show';\r\n    var hideContextToolbarEvent = 'contexttoolbar-hide';\r\n\r\n    var getFormApi = function (input) {\r\n      return {\r\n        hide: function () {\r\n          return emit(input, sandboxClose());\r\n        },\r\n        getValue: function () {\r\n          return Representing.getValue(input);\r\n        }\r\n      };\r\n    };\r\n    var runOnExecute = function (memInput, original) {\r\n      return run$1(internalToolbarButtonExecute, function (comp, se) {\r\n        var input = memInput.get(comp);\r\n        var formApi = getFormApi(input);\r\n        original.onAction(formApi, se.event.buttonApi);\r\n      });\r\n    };\r\n    var renderContextButton = function (memInput, button, extras) {\r\n      var _a = button.original; _a.primary; var rest = __rest(_a, ['primary']);\r\n      var bridged = getOrDie(createToolbarButton(__assign(__assign({}, rest), {\r\n        type: 'button',\r\n        onAction: noop\r\n      })));\r\n      return renderToolbarButtonWith(bridged, extras.backstage.shared.providers, [runOnExecute(memInput, button)]);\r\n    };\r\n    var renderContextToggleButton = function (memInput, button, extras) {\r\n      var _a = button.original; _a.primary; var rest = __rest(_a, ['primary']);\r\n      var bridged = getOrDie(createToggleButton(__assign(__assign({}, rest), {\r\n        type: 'togglebutton',\r\n        onAction: noop\r\n      })));\r\n      return renderToolbarToggleButtonWith(bridged, extras.backstage.shared.providers, [runOnExecute(memInput, button)]);\r\n    };\r\n    var generateOne = function (memInput, button, providersBackstage) {\r\n      var extras = { backstage: { shared: { providers: providersBackstage } } };\r\n      if (button.type === 'contextformtogglebutton') {\r\n        return renderContextToggleButton(memInput, button, extras);\r\n      } else {\r\n        return renderContextButton(memInput, button, extras);\r\n      }\r\n    };\r\n    var generate = function (memInput, buttons, providersBackstage) {\r\n      var mementos = map$2(buttons, function (button) {\r\n        return record(generateOne(memInput, button, providersBackstage));\r\n      });\r\n      var asSpecs = function () {\r\n        return map$2(mementos, function (mem) {\r\n          return mem.asSpec();\r\n        });\r\n      };\r\n      var findPrimary = function (compInSystem) {\r\n        return findMap(buttons, function (button, i) {\r\n          if (button.primary) {\r\n            return Optional.from(mementos[i]).bind(function (mem) {\r\n              return mem.getOpt(compInSystem);\r\n            }).filter(not(Disabling.isDisabled));\r\n          } else {\r\n            return Optional.none();\r\n          }\r\n        });\r\n      };\r\n      return {\r\n        asSpecs: asSpecs,\r\n        findPrimary: findPrimary\r\n      };\r\n    };\r\n\r\n    var buildInitGroups = function (ctx, providers) {\r\n      var inputAttributes = ctx.label.fold(function () {\r\n        return {};\r\n      }, function (label) {\r\n        return { 'aria-label': label };\r\n      });\r\n      var memInput = record(Input.sketch({\r\n        inputClasses: [\r\n          'tox-toolbar-textfield',\r\n          'tox-toolbar-nav-js'\r\n        ],\r\n        data: ctx.initValue(),\r\n        inputAttributes: inputAttributes,\r\n        selectOnFocus: true,\r\n        inputBehaviours: derive$1([Keying.config({\r\n            mode: 'special',\r\n            onEnter: function (input) {\r\n              return commands.findPrimary(input).map(function (primary) {\r\n                emitExecute(primary);\r\n                return true;\r\n              });\r\n            },\r\n            onLeft: function (comp, se) {\r\n              se.cut();\r\n              return Optional.none();\r\n            },\r\n            onRight: function (comp, se) {\r\n              se.cut();\r\n              return Optional.none();\r\n            }\r\n          })])\r\n      }));\r\n      var commands = generate(memInput, ctx.commands, providers);\r\n      return [\r\n        {\r\n          title: Optional.none(),\r\n          items: [memInput.asSpec()]\r\n        },\r\n        {\r\n          title: Optional.none(),\r\n          items: commands.asSpecs()\r\n        }\r\n      ];\r\n    };\r\n    var renderContextForm = function (toolbarType, ctx, providers) {\r\n      return renderToolbar({\r\n        type: toolbarType,\r\n        uid: generate$6('context-toolbar'),\r\n        initGroups: buildInitGroups(ctx, providers),\r\n        onEscape: Optional.none,\r\n        cyclicKeying: true,\r\n        providers: providers\r\n      });\r\n    };\r\n    var ContextForm = {\r\n      renderContextForm: renderContextForm,\r\n      buildInitGroups: buildInitGroups\r\n    };\r\n\r\n    var isVerticalOverlap = function (a, b, threshold) {\r\n      if (threshold === void 0) {\r\n        threshold = 0.01;\r\n      }\r\n      return b.bottom - a.y >= threshold && a.bottom - b.y >= threshold;\r\n    };\r\n    var getRangeRect = function (rng) {\r\n      var rect = rng.getBoundingClientRect();\r\n      if (rect.height <= 0 && rect.width <= 0) {\r\n        var leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset).element;\r\n        var elm = isText$1(leaf$1) ? parent(leaf$1) : Optional.some(leaf$1);\r\n        return elm.filter(isElement$2).map(function (e) {\r\n          return e.dom.getBoundingClientRect();\r\n        }).getOr(rect);\r\n      } else {\r\n        return rect;\r\n      }\r\n    };\r\n    var getSelectionBounds = function (editor) {\r\n      var rng = editor.selection.getRng();\r\n      var rect = getRangeRect(rng);\r\n      if (editor.inline) {\r\n        var scroll_1 = get$9();\r\n        return bounds(scroll_1.left + rect.left, scroll_1.top + rect.top, rect.width, rect.height);\r\n      } else {\r\n        var bodyPos = absolute$2(SugarElement.fromDom(editor.getBody()));\r\n        return bounds(bodyPos.x + rect.left, bodyPos.y + rect.top, rect.width, rect.height);\r\n      }\r\n    };\r\n    var getAnchorElementBounds = function (editor, lastElement) {\r\n      return lastElement.filter(inBody).map(absolute$2).getOrThunk(function () {\r\n        return getSelectionBounds(editor);\r\n      });\r\n    };\r\n    var getHorizontalBounds = function (contentAreaBox, viewportBounds, margin) {\r\n      var x = Math.max(contentAreaBox.x + margin, viewportBounds.x);\r\n      var right = Math.min(contentAreaBox.right - margin, viewportBounds.right);\r\n      return {\r\n        x: x,\r\n        width: right - x\r\n      };\r\n    };\r\n    var getVerticalBounds = function (editor, contentAreaBox, viewportBounds, isToolbarLocationTop, toolbarType, margin) {\r\n      var container = SugarElement.fromDom(editor.getContainer());\r\n      var header = descendant(container, '.tox-editor-header').getOr(container);\r\n      var headerBox = box$1(header);\r\n      var isToolbarBelowContentArea = headerBox.y >= contentAreaBox.bottom;\r\n      var isToolbarAbove = isToolbarLocationTop && !isToolbarBelowContentArea;\r\n      if (editor.inline && isToolbarAbove) {\r\n        return {\r\n          y: Math.max(headerBox.bottom + margin, viewportBounds.y),\r\n          bottom: viewportBounds.bottom\r\n        };\r\n      }\r\n      if (editor.inline && !isToolbarAbove) {\r\n        return {\r\n          y: viewportBounds.y,\r\n          bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)\r\n        };\r\n      }\r\n      var containerBounds = toolbarType === 'line' ? box$1(container) : contentAreaBox;\r\n      if (isToolbarAbove) {\r\n        return {\r\n          y: Math.max(headerBox.bottom + margin, viewportBounds.y),\r\n          bottom: Math.min(containerBounds.bottom - margin, viewportBounds.bottom)\r\n        };\r\n      }\r\n      return {\r\n        y: Math.max(containerBounds.y + margin, viewportBounds.y),\r\n        bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)\r\n      };\r\n    };\r\n    var getContextToolbarBounds = function (editor, sharedBackstage, toolbarType, margin) {\r\n      if (margin === void 0) {\r\n        margin = 0;\r\n      }\r\n      var viewportBounds = getBounds$3(window);\r\n      var contentAreaBox = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));\r\n      var toolbarOrMenubarEnabled = isMenubarEnabled(editor) || isToolbarEnabled(editor) || isMultipleToolbars(editor);\r\n      var _a = getHorizontalBounds(contentAreaBox, viewportBounds, margin), x = _a.x, width = _a.width;\r\n      if (editor.inline && !toolbarOrMenubarEnabled) {\r\n        return bounds(x, viewportBounds.y, width, viewportBounds.height);\r\n      } else {\r\n        var isToolbarTop = sharedBackstage.header.isPositionedAtTop();\r\n        var _b = getVerticalBounds(editor, contentAreaBox, viewportBounds, isToolbarTop, toolbarType, margin), y = _b.y, bottom = _b.bottom;\r\n        return bounds(x, y, width, bottom - y);\r\n      }\r\n    };\r\n\r\n    var bubbleSize$1 = 12;\r\n    var bubbleAlignments$1 = {\r\n      valignCentre: [],\r\n      alignCentre: [],\r\n      alignLeft: ['tox-pop--align-left'],\r\n      alignRight: ['tox-pop--align-right'],\r\n      right: ['tox-pop--right'],\r\n      left: ['tox-pop--left'],\r\n      bottom: ['tox-pop--bottom'],\r\n      top: ['tox-pop--top'],\r\n      inset: ['tox-pop--inset']\r\n    };\r\n    var anchorOverrides = {\r\n      maxHeightFunction: expandable$1(),\r\n      maxWidthFunction: expandable()\r\n    };\r\n    var isEntireElementSelected = function (editor, elem) {\r\n      var rng = editor.selection.getRng();\r\n      var leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset);\r\n      return rng.startContainer === rng.endContainer && rng.startOffset === rng.endOffset - 1 && eq(leaf$1.element, elem);\r\n    };\r\n    var preservePosition = function (elem, position, f) {\r\n      var currentPosition = getRaw(elem, 'position');\r\n      set$7(elem, 'position', position);\r\n      var result = f(elem);\r\n      currentPosition.each(function (pos) {\r\n        return set$7(elem, 'position', pos);\r\n      });\r\n      return result;\r\n    };\r\n    var shouldUseInsetLayouts = function (position) {\r\n      return position === 'node';\r\n    };\r\n    var determineInsetLayout = function (editor, contextbar, elem, data, bounds) {\r\n      var selectionBounds = getSelectionBounds(editor);\r\n      var isSameAnchorElement = data.lastElement().exists(function (prev) {\r\n        return eq(elem, prev);\r\n      });\r\n      if (isEntireElementSelected(editor, elem)) {\r\n        return isSameAnchorElement ? preserve : north;\r\n      } else if (isSameAnchorElement) {\r\n        return preservePosition(contextbar, data.getMode(), function () {\r\n          var isOverlapping = isVerticalOverlap(selectionBounds, box$1(contextbar));\r\n          return isOverlapping && !data.isReposition() ? flip$2 : preserve;\r\n        });\r\n      } else {\r\n        var yBounds = data.getMode() === 'fixed' ? bounds.y + get$9().top : bounds.y;\r\n        var contextbarHeight = get$b(contextbar) + bubbleSize$1;\r\n        return yBounds + contextbarHeight <= selectionBounds.y ? north : south;\r\n      }\r\n    };\r\n    var getAnchorSpec$2 = function (editor, mobile, data, position) {\r\n      var smartInsetLayout = function (elem) {\r\n        return function (anchor, element, bubbles, placee, bounds) {\r\n          var layout = determineInsetLayout(editor, placee, elem, data, bounds);\r\n          var newAnchor = __assign(__assign({}, anchor), {\r\n            y: bounds.y,\r\n            height: bounds.height\r\n          });\r\n          return __assign(__assign({}, layout(newAnchor, element, bubbles, placee, bounds)), { alwaysFit: true });\r\n        };\r\n      };\r\n      var getInsetLayouts = function (elem) {\r\n        return shouldUseInsetLayouts(position) ? [smartInsetLayout(elem)] : [];\r\n      };\r\n      var desktopAnchorSpecLayouts = {\r\n        onLtr: function (elem) {\r\n          return [\r\n            north$2,\r\n            south$2,\r\n            northeast$2,\r\n            southeast$2,\r\n            northwest$2,\r\n            southwest$2\r\n          ].concat(getInsetLayouts(elem));\r\n        },\r\n        onRtl: function (elem) {\r\n          return [\r\n            north$2,\r\n            south$2,\r\n            northwest$2,\r\n            southwest$2,\r\n            northeast$2,\r\n            southeast$2\r\n          ].concat(getInsetLayouts(elem));\r\n        }\r\n      };\r\n      var mobileAnchorSpecLayouts = {\r\n        onLtr: function (elem) {\r\n          return [\r\n            south$2,\r\n            southeast$2,\r\n            southwest$2,\r\n            northeast$2,\r\n            northwest$2,\r\n            north$2\r\n          ].concat(getInsetLayouts(elem));\r\n        },\r\n        onRtl: function (elem) {\r\n          return [\r\n            south$2,\r\n            southwest$2,\r\n            southeast$2,\r\n            northwest$2,\r\n            northeast$2,\r\n            north$2\r\n          ].concat(getInsetLayouts(elem));\r\n        }\r\n      };\r\n      return mobile ? mobileAnchorSpecLayouts : desktopAnchorSpecLayouts;\r\n    };\r\n    var getAnchorLayout = function (editor, position, isTouch, data) {\r\n      if (position === 'line') {\r\n        return {\r\n          bubble: nu$5(bubbleSize$1, 0, bubbleAlignments$1),\r\n          layouts: {\r\n            onLtr: function () {\r\n              return [east$2];\r\n            },\r\n            onRtl: function () {\r\n              return [west$2];\r\n            }\r\n          },\r\n          overrides: anchorOverrides\r\n        };\r\n      } else {\r\n        return {\r\n          bubble: nu$5(0, bubbleSize$1, bubbleAlignments$1, 1 / bubbleSize$1),\r\n          layouts: getAnchorSpec$2(editor, isTouch, data, position),\r\n          overrides: anchorOverrides\r\n        };\r\n      }\r\n    };\r\n\r\n    var matchTargetWith = function (elem, candidates) {\r\n      var ctxs = filter$2(candidates, function (toolbarApi) {\r\n        return toolbarApi.predicate(elem.dom);\r\n      });\r\n      var _a = partition$3(ctxs, function (t) {\r\n          return t.type === 'contexttoolbar';\r\n        }), pass = _a.pass, fail = _a.fail;\r\n      return {\r\n        contextToolbars: pass,\r\n        contextForms: fail\r\n      };\r\n    };\r\n    var filterByPositionForStartNode = function (toolbars) {\r\n      if (toolbars.length <= 1) {\r\n        return toolbars;\r\n      } else {\r\n        var doesPositionExist = function (value) {\r\n          return exists(toolbars, function (t) {\r\n            return t.position === value;\r\n          });\r\n        };\r\n        var filterToolbarsByPosition = function (value) {\r\n          return filter$2(toolbars, function (t) {\r\n            return t.position === value;\r\n          });\r\n        };\r\n        var hasSelectionToolbars = doesPositionExist('selection');\r\n        var hasNodeToolbars = doesPositionExist('node');\r\n        if (hasSelectionToolbars || hasNodeToolbars) {\r\n          if (hasNodeToolbars && hasSelectionToolbars) {\r\n            var nodeToolbars = filterToolbarsByPosition('node');\r\n            var selectionToolbars = map$2(filterToolbarsByPosition('selection'), function (t) {\r\n              return __assign(__assign({}, t), { position: 'node' });\r\n            });\r\n            return nodeToolbars.concat(selectionToolbars);\r\n          } else {\r\n            return hasSelectionToolbars ? filterToolbarsByPosition('selection') : filterToolbarsByPosition('node');\r\n          }\r\n        } else {\r\n          return filterToolbarsByPosition('line');\r\n        }\r\n      }\r\n    };\r\n    var filterByPositionForAncestorNode = function (toolbars) {\r\n      if (toolbars.length <= 1) {\r\n        return toolbars;\r\n      } else {\r\n        var findPosition_1 = function (value) {\r\n          return find$5(toolbars, function (t) {\r\n            return t.position === value;\r\n          });\r\n        };\r\n        var basePosition = findPosition_1('selection').orThunk(function () {\r\n          return findPosition_1('node');\r\n        }).orThunk(function () {\r\n          return findPosition_1('line');\r\n        }).map(function (t) {\r\n          return t.position;\r\n        });\r\n        return basePosition.fold(function () {\r\n          return [];\r\n        }, function (pos) {\r\n          return filter$2(toolbars, function (t) {\r\n            return t.position === pos;\r\n          });\r\n        });\r\n      }\r\n    };\r\n    var matchStartNode = function (elem, nodeCandidates, editorCandidates) {\r\n      var nodeMatches = matchTargetWith(elem, nodeCandidates);\r\n      if (nodeMatches.contextForms.length > 0) {\r\n        return Optional.some({\r\n          elem: elem,\r\n          toolbars: [nodeMatches.contextForms[0]]\r\n        });\r\n      } else {\r\n        var editorMatches = matchTargetWith(elem, editorCandidates);\r\n        if (editorMatches.contextForms.length > 0) {\r\n          return Optional.some({\r\n            elem: elem,\r\n            toolbars: [editorMatches.contextForms[0]]\r\n          });\r\n        } else if (nodeMatches.contextToolbars.length > 0 || editorMatches.contextToolbars.length > 0) {\r\n          var toolbars = filterByPositionForStartNode(nodeMatches.contextToolbars.concat(editorMatches.contextToolbars));\r\n          return Optional.some({\r\n            elem: elem,\r\n            toolbars: toolbars\r\n          });\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      }\r\n    };\r\n    var matchAncestor = function (isRoot, startNode, scopes) {\r\n      if (isRoot(startNode)) {\r\n        return Optional.none();\r\n      } else {\r\n        return ancestor$2(startNode, function (ancestorElem) {\r\n          if (isElement$2(ancestorElem)) {\r\n            var _a = matchTargetWith(ancestorElem, scopes.inNodeScope), contextToolbars = _a.contextToolbars, contextForms = _a.contextForms;\r\n            var toolbars = contextForms.length > 0 ? contextForms : filterByPositionForAncestorNode(contextToolbars);\r\n            return toolbars.length > 0 ? Optional.some({\r\n              elem: ancestorElem,\r\n              toolbars: toolbars\r\n            }) : Optional.none();\r\n          } else {\r\n            return Optional.none();\r\n          }\r\n        }, isRoot);\r\n      }\r\n    };\r\n    var lookup$1 = function (scopes, editor) {\r\n      var rootElem = SugarElement.fromDom(editor.getBody());\r\n      var isRoot = function (elem) {\r\n        return eq(elem, rootElem);\r\n      };\r\n      var isOutsideRoot = function (startNode) {\r\n        return !isRoot(startNode) && !contains(rootElem, startNode);\r\n      };\r\n      var startNode = SugarElement.fromDom(editor.selection.getNode());\r\n      if (isOutsideRoot(startNode)) {\r\n        return Optional.none();\r\n      }\r\n      return matchStartNode(startNode, scopes.inNodeScope, scopes.inEditorScope).orThunk(function () {\r\n        return matchAncestor(isRoot, startNode, scopes);\r\n      });\r\n    };\r\n\r\n    var categorise = function (contextToolbars, navigate) {\r\n      var forms = {};\r\n      var inNodeScope = [];\r\n      var inEditorScope = [];\r\n      var formNavigators = {};\r\n      var lookupTable = {};\r\n      var registerForm = function (key, toolbarSpec) {\r\n        var contextForm = getOrDie(createContextForm(toolbarSpec));\r\n        forms[key] = contextForm;\r\n        contextForm.launch.map(function (launch) {\r\n          formNavigators['form:' + key + ''] = __assign(__assign({}, toolbarSpec.launch), {\r\n            type: launch.type === 'contextformtogglebutton' ? 'togglebutton' : 'button',\r\n            onAction: function () {\r\n              navigate(contextForm);\r\n            }\r\n          });\r\n        });\r\n        if (contextForm.scope === 'editor') {\r\n          inEditorScope.push(contextForm);\r\n        } else {\r\n          inNodeScope.push(contextForm);\r\n        }\r\n        lookupTable[key] = contextForm;\r\n      };\r\n      var registerToolbar = function (key, toolbarSpec) {\r\n        createContextToolbar(toolbarSpec).each(function (contextToolbar) {\r\n          if (toolbarSpec.scope === 'editor') {\r\n            inEditorScope.push(contextToolbar);\r\n          } else {\r\n            inNodeScope.push(contextToolbar);\r\n          }\r\n          lookupTable[key] = contextToolbar;\r\n        });\r\n      };\r\n      var keys$1 = keys(contextToolbars);\r\n      each$1(keys$1, function (key) {\r\n        var toolbarApi = contextToolbars[key];\r\n        if (toolbarApi.type === 'contextform') {\r\n          registerForm(key, toolbarApi);\r\n        } else if (toolbarApi.type === 'contexttoolbar') {\r\n          registerToolbar(key, toolbarApi);\r\n        }\r\n      });\r\n      return {\r\n        forms: forms,\r\n        inNodeScope: inNodeScope,\r\n        inEditorScope: inEditorScope,\r\n        lookupTable: lookupTable,\r\n        formNavigators: formNavigators\r\n      };\r\n    };\r\n\r\n    var forwardSlideEvent = generate$6('forward-slide');\r\n    var backSlideEvent = generate$6('backward-slide');\r\n    var changeSlideEvent = generate$6('change-slide-event');\r\n    var resizingClass = 'tox-pop--resizing';\r\n    var renderContextToolbar = function (spec) {\r\n      var stack = Cell([]);\r\n      return InlineView.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-pop']\r\n        },\r\n        fireDismissalEventInstead: { event: 'doNotDismissYet' },\r\n        onShow: function (comp) {\r\n          stack.set([]);\r\n          InlineView.getContent(comp).each(function (c) {\r\n            remove$6(c.element, 'visibility');\r\n          });\r\n          remove$2(comp.element, resizingClass);\r\n          remove$6(comp.element, 'width');\r\n        },\r\n        inlineBehaviours: derive$1([\r\n          config('context-toolbar-events', [\r\n            runOnSource(transitionend(), function (comp, se) {\r\n              if (se.event.raw.propertyName === 'width') {\r\n                remove$2(comp.element, resizingClass);\r\n                remove$6(comp.element, 'width');\r\n              }\r\n            }),\r\n            run$1(changeSlideEvent, function (comp, se) {\r\n              var elem = comp.element;\r\n              remove$6(elem, 'width');\r\n              var currentWidth = get$a(elem);\r\n              InlineView.setContent(comp, se.event.contents);\r\n              add$2(elem, resizingClass);\r\n              var newWidth = get$a(elem);\r\n              set$7(elem, 'width', currentWidth + 'px');\r\n              InlineView.getContent(comp).each(function (newContents) {\r\n                se.event.focus.bind(function (f) {\r\n                  focus$3(f);\r\n                  return search(elem);\r\n                }).orThunk(function () {\r\n                  Keying.focusIn(newContents);\r\n                  return active(getRootNode(elem));\r\n                });\r\n              });\r\n              global$f.setTimeout(function () {\r\n                set$7(comp.element, 'width', newWidth + 'px');\r\n              }, 0);\r\n            }),\r\n            run$1(forwardSlideEvent, function (comp, se) {\r\n              InlineView.getContent(comp).each(function (oldContents) {\r\n                stack.set(stack.get().concat([{\r\n                    bar: oldContents,\r\n                    focus: active(getRootNode(comp.element))\r\n                  }]));\r\n              });\r\n              emitWith(comp, changeSlideEvent, {\r\n                contents: se.event.forwardContents,\r\n                focus: Optional.none()\r\n              });\r\n            }),\r\n            run$1(backSlideEvent, function (comp, _se) {\r\n              last$2(stack.get()).each(function (last) {\r\n                stack.set(stack.get().slice(0, stack.get().length - 1));\r\n                emitWith(comp, changeSlideEvent, {\r\n                  contents: premade(last.bar),\r\n                  focus: last.focus\r\n                });\r\n              });\r\n            })\r\n          ]),\r\n          Keying.config({\r\n            mode: 'special',\r\n            onEscape: function (comp) {\r\n              return last$2(stack.get()).fold(function () {\r\n                return spec.onEscape();\r\n              }, function (_) {\r\n                emit(comp, backSlideEvent);\r\n                return Optional.some(true);\r\n              });\r\n            }\r\n          })\r\n        ]),\r\n        lazySink: function () {\r\n          return Result.value(spec.sink);\r\n        }\r\n      });\r\n    };\r\n\r\n    var transitionClass = 'tox-pop--transition';\r\n    var register$7 = function (editor, registryContextToolbars, sink, extras) {\r\n      var backstage = extras.backstage;\r\n      var sharedBackstage = backstage.shared;\r\n      var isTouch = detect$1().deviceType.isTouch;\r\n      var lastElement = value$1();\r\n      var lastTrigger = value$1();\r\n      var lastContextPosition = value$1();\r\n      var contextbar = build$1(renderContextToolbar({\r\n        sink: sink,\r\n        onEscape: function () {\r\n          editor.focus();\r\n          return Optional.some(true);\r\n        }\r\n      }));\r\n      var getBounds = function () {\r\n        var position = lastContextPosition.get().getOr('node');\r\n        var margin = shouldUseInsetLayouts(position) ? 1 : 0;\r\n        return getContextToolbarBounds(editor, sharedBackstage, position, margin);\r\n      };\r\n      var canLaunchToolbar = function () {\r\n        return !editor.removed && !(isTouch() && backstage.isContextMenuOpen());\r\n      };\r\n      var isSameLaunchElement = function (elem) {\r\n        return is$1(lift2(elem, lastElement.get(), eq), true);\r\n      };\r\n      var shouldContextToolbarHide = function () {\r\n        if (!canLaunchToolbar()) {\r\n          return true;\r\n        } else {\r\n          var contextToolbarBounds = getBounds();\r\n          var anchorBounds = is$1(lastContextPosition.get(), 'node') ? getAnchorElementBounds(editor, lastElement.get()) : getSelectionBounds(editor);\r\n          return contextToolbarBounds.height <= 0 || !isVerticalOverlap(anchorBounds, contextToolbarBounds);\r\n        }\r\n      };\r\n      var close = function () {\r\n        lastElement.clear();\r\n        lastTrigger.clear();\r\n        lastContextPosition.clear();\r\n        InlineView.hide(contextbar);\r\n      };\r\n      var hideOrRepositionIfNecessary = function () {\r\n        if (InlineView.isOpen(contextbar)) {\r\n          var contextBarEle = contextbar.element;\r\n          remove$6(contextBarEle, 'display');\r\n          if (shouldContextToolbarHide()) {\r\n            set$7(contextBarEle, 'display', 'none');\r\n          } else {\r\n            lastTrigger.set(0);\r\n            InlineView.reposition(contextbar);\r\n          }\r\n        }\r\n      };\r\n      var wrapInPopDialog = function (toolbarSpec) {\r\n        return {\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-pop__dialog']\r\n          },\r\n          components: [toolbarSpec],\r\n          behaviours: derive$1([\r\n            Keying.config({ mode: 'acyclic' }),\r\n            config('pop-dialog-wrap-events', [\r\n              runOnAttached(function (comp) {\r\n                editor.shortcuts.add('ctrl+F9', 'focus statusbar', function () {\r\n                  return Keying.focusIn(comp);\r\n                });\r\n              }),\r\n              runOnDetached(function (_comp) {\r\n                editor.shortcuts.remove('ctrl+F9');\r\n              })\r\n            ])\r\n          ])\r\n        };\r\n      };\r\n      var getScopes = cached(function () {\r\n        return categorise(registryContextToolbars, function (toolbarApi) {\r\n          var alloySpec = buildToolbar([toolbarApi]);\r\n          emitWith(contextbar, forwardSlideEvent, { forwardContents: wrapInPopDialog(alloySpec) });\r\n        });\r\n      });\r\n      var buildContextToolbarGroups = function (allButtons, ctx) {\r\n        return identifyButtons(editor, {\r\n          buttons: allButtons,\r\n          toolbar: ctx.items,\r\n          allowToolbarGroups: false\r\n        }, extras, Optional.some(['form:']));\r\n      };\r\n      var buildContextFormGroups = function (ctx, providers) {\r\n        return ContextForm.buildInitGroups(ctx, providers);\r\n      };\r\n      var buildToolbar = function (toolbars) {\r\n        var buttons = editor.ui.registry.getAll().buttons;\r\n        var scopes = getScopes();\r\n        var allButtons = __assign(__assign({}, buttons), scopes.formNavigators);\r\n        var toolbarType = getToolbarMode(editor) === ToolbarMode.scrolling ? ToolbarMode.scrolling : ToolbarMode.default;\r\n        var initGroups = flatten(map$2(toolbars, function (ctx) {\r\n          return ctx.type === 'contexttoolbar' ? buildContextToolbarGroups(allButtons, ctx) : buildContextFormGroups(ctx, sharedBackstage.providers);\r\n        }));\r\n        return renderToolbar({\r\n          type: toolbarType,\r\n          uid: generate$6('context-toolbar'),\r\n          initGroups: initGroups,\r\n          onEscape: Optional.none,\r\n          cyclicKeying: true,\r\n          providers: sharedBackstage.providers\r\n        });\r\n      };\r\n      var getAnchor = function (position, element) {\r\n        var anchorage = position === 'node' ? sharedBackstage.anchors.node(element) : sharedBackstage.anchors.cursor();\r\n        var anchorLayout = getAnchorLayout(editor, position, isTouch(), {\r\n          lastElement: lastElement.get,\r\n          isReposition: function () {\r\n            return is$1(lastTrigger.get(), 0);\r\n          },\r\n          getMode: function () {\r\n            return Positioning.getMode(sink);\r\n          }\r\n        });\r\n        return deepMerge(anchorage, anchorLayout);\r\n      };\r\n      var launchContext = function (toolbarApi, elem) {\r\n        launchContextToolbar.cancel();\r\n        if (!canLaunchToolbar()) {\r\n          return;\r\n        }\r\n        var toolbarSpec = buildToolbar(toolbarApi);\r\n        var position = toolbarApi[0].position;\r\n        var anchor = getAnchor(position, elem);\r\n        lastContextPosition.set(position);\r\n        lastTrigger.set(1);\r\n        var contextBarEle = contextbar.element;\r\n        remove$6(contextBarEle, 'display');\r\n        if (!isSameLaunchElement(elem)) {\r\n          remove$2(contextBarEle, transitionClass);\r\n          Positioning.reset(sink, contextbar);\r\n        }\r\n        InlineView.showWithinBounds(contextbar, wrapInPopDialog(toolbarSpec), {\r\n          anchor: anchor,\r\n          transition: {\r\n            classes: [transitionClass],\r\n            mode: 'placement'\r\n          }\r\n        }, function () {\r\n          return Optional.some(getBounds());\r\n        });\r\n        elem.fold(lastElement.clear, lastElement.set);\r\n        if (shouldContextToolbarHide()) {\r\n          set$7(contextBarEle, 'display', 'none');\r\n        }\r\n      };\r\n      var launchContextToolbar = last(function () {\r\n        if (!editor.hasFocus() || editor.removed) {\r\n          return;\r\n        }\r\n        if (has(contextbar.element, transitionClass)) {\r\n          launchContextToolbar.throttle();\r\n        } else {\r\n          var scopes = getScopes();\r\n          lookup$1(scopes, editor).fold(close, function (info) {\r\n            launchContext(info.toolbars, Optional.some(info.elem));\r\n          });\r\n        }\r\n      }, 17);\r\n      editor.on('init', function () {\r\n        editor.on('remove', close);\r\n        editor.on('ScrollContent ScrollWindow ObjectResized ResizeEditor longpress', hideOrRepositionIfNecessary);\r\n        editor.on('click keyup focus SetContent', launchContextToolbar.throttle);\r\n        editor.on(hideContextToolbarEvent, close);\r\n        editor.on(showContextToolbarEvent, function (e) {\r\n          var scopes = getScopes();\r\n          get$e(scopes.lookupTable, e.toolbarKey).each(function (ctx) {\r\n            launchContext([ctx], someIf(e.target !== editor, e.target));\r\n            InlineView.getContent(contextbar).each(Keying.focusIn);\r\n          });\r\n        });\r\n        editor.on('focusout', function (_e) {\r\n          global$f.setEditorTimeout(editor, function () {\r\n            if (search(sink.element).isNone() && search(contextbar.element).isNone()) {\r\n              close();\r\n            }\r\n          }, 0);\r\n        });\r\n        editor.on('SwitchMode', function () {\r\n          if (editor.mode.isReadOnly()) {\r\n            close();\r\n          }\r\n        });\r\n        editor.on('AfterProgressState', function (event) {\r\n          if (event.state) {\r\n            close();\r\n          } else if (editor.hasFocus()) {\r\n            launchContextToolbar.throttle();\r\n          }\r\n        });\r\n        editor.on('NodeChange', function (_e) {\r\n          search(contextbar.element).fold(launchContextToolbar.throttle, noop);\r\n        });\r\n      });\r\n    };\r\n\r\n    var register$6 = function (editor) {\r\n      var alignToolbarButtons = [\r\n        {\r\n          name: 'alignleft',\r\n          text: 'Align left',\r\n          cmd: 'JustifyLeft',\r\n          icon: 'align-left'\r\n        },\r\n        {\r\n          name: 'aligncenter',\r\n          text: 'Align center',\r\n          cmd: 'JustifyCenter',\r\n          icon: 'align-center'\r\n        },\r\n        {\r\n          name: 'alignright',\r\n          text: 'Align right',\r\n          cmd: 'JustifyRight',\r\n          icon: 'align-right'\r\n        },\r\n        {\r\n          name: 'alignjustify',\r\n          text: 'Justify',\r\n          cmd: 'JustifyFull',\r\n          icon: 'align-justify'\r\n        }\r\n      ];\r\n      each$1(alignToolbarButtons, function (item) {\r\n        editor.ui.registry.addToggleButton(item.name, {\r\n          tooltip: item.text,\r\n          icon: item.icon,\r\n          onAction: onActionExecCommand(editor, item.cmd),\r\n          onSetup: onSetupFormatToggle(editor, item.name)\r\n        });\r\n      });\r\n      editor.ui.registry.addButton('alignnone', {\r\n        tooltip: 'No alignment',\r\n        icon: 'align-none',\r\n        onAction: onActionExecCommand(editor, 'JustifyNone')\r\n      });\r\n    };\r\n\r\n    var units = {\r\n      unsupportedLength: [\r\n        'em',\r\n        'ex',\r\n        'cap',\r\n        'ch',\r\n        'ic',\r\n        'rem',\r\n        'lh',\r\n        'rlh',\r\n        'vw',\r\n        'vh',\r\n        'vi',\r\n        'vb',\r\n        'vmin',\r\n        'vmax',\r\n        'cm',\r\n        'mm',\r\n        'Q',\r\n        'in',\r\n        'pc',\r\n        'pt',\r\n        'px'\r\n      ],\r\n      fixed: [\r\n        'px',\r\n        'pt'\r\n      ],\r\n      relative: ['%'],\r\n      empty: ['']\r\n    };\r\n    var pattern = function () {\r\n      var decimalDigits = '[0-9]+';\r\n      var signedInteger = '[+-]?' + decimalDigits;\r\n      var exponentPart = '[eE]' + signedInteger;\r\n      var dot = '\\\\.';\r\n      var opt = function (input) {\r\n        return '(?:' + input + ')?';\r\n      };\r\n      var unsignedDecimalLiteral = [\r\n        'Infinity',\r\n        decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),\r\n        dot + decimalDigits + opt(exponentPart),\r\n        decimalDigits + opt(exponentPart)\r\n      ].join('|');\r\n      var float = '[+-]?(?:' + unsignedDecimalLiteral + ')';\r\n      return new RegExp('^(' + float + ')(.*)$');\r\n    }();\r\n    var isUnit = function (unit, accepted) {\r\n      return exists(accepted, function (acc) {\r\n        return exists(units[acc], function (check) {\r\n          return unit === check;\r\n        });\r\n      });\r\n    };\r\n    var parse = function (input, accepted) {\r\n      var match = Optional.from(pattern.exec(input));\r\n      return match.bind(function (array) {\r\n        var value = Number(array[1]);\r\n        var unitRaw = array[2];\r\n        if (isUnit(unitRaw, accepted)) {\r\n          return Optional.some({\r\n            value: value,\r\n            unit: unitRaw\r\n          });\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      });\r\n    };\r\n    var normalise = function (input, accepted) {\r\n      return parse(input, accepted).map(function (_a) {\r\n        var value = _a.value, unit = _a.unit;\r\n        return value + unit;\r\n      });\r\n    };\r\n\r\n    var registerController = function (editor, spec) {\r\n      var getMenuItems = function () {\r\n        var options = spec.getOptions(editor);\r\n        var initial = spec.getCurrent(editor).map(spec.hash);\r\n        var current = value$1();\r\n        return map$2(options, function (value) {\r\n          return {\r\n            type: 'togglemenuitem',\r\n            text: spec.display(value),\r\n            onSetup: function (api) {\r\n              var setActive = function (active) {\r\n                if (active) {\r\n                  current.on(function (oldApi) {\r\n                    return oldApi.setActive(false);\r\n                  });\r\n                  current.set(api);\r\n                }\r\n                api.setActive(active);\r\n              };\r\n              setActive(is$1(initial, spec.hash(value)));\r\n              var unbindWatcher = spec.watcher(editor, value, setActive);\r\n              return function () {\r\n                current.clear();\r\n                unbindWatcher();\r\n              };\r\n            },\r\n            onAction: function () {\r\n              return spec.setCurrent(editor, value);\r\n            }\r\n          };\r\n        });\r\n      };\r\n      editor.ui.registry.addMenuButton(spec.name, {\r\n        tooltip: spec.text,\r\n        icon: spec.icon,\r\n        fetch: function (callback) {\r\n          return callback(getMenuItems());\r\n        },\r\n        onSetup: spec.onToolbarSetup\r\n      });\r\n      editor.ui.registry.addNestedMenuItem(spec.name, {\r\n        type: 'nestedmenuitem',\r\n        text: spec.text,\r\n        getSubmenuItems: getMenuItems,\r\n        onSetup: spec.onMenuSetup\r\n      });\r\n    };\r\n    var lineHeightSpec = {\r\n      name: 'lineheight',\r\n      text: 'Line height',\r\n      icon: 'line-height',\r\n      getOptions: getLineHeightFormats,\r\n      hash: function (input) {\r\n        return normalise(input, [\r\n          'fixed',\r\n          'relative',\r\n          'empty'\r\n        ]).getOr(input);\r\n      },\r\n      display: identity$1,\r\n      watcher: function (editor, value, callback) {\r\n        return editor.formatter.formatChanged('lineheight', callback, false, { value: value }).unbind;\r\n      },\r\n      getCurrent: function (editor) {\r\n        return Optional.from(editor.queryCommandValue('LineHeight'));\r\n      },\r\n      setCurrent: function (editor, value) {\r\n        return editor.execCommand('LineHeight', false, value);\r\n      }\r\n    };\r\n    var languageSpec = function (editor) {\r\n      var settingsOpt = Optional.from(getContentLanguages(editor));\r\n      return settingsOpt.map(function (settings) {\r\n        return {\r\n          name: 'language',\r\n          text: 'Language',\r\n          icon: 'language',\r\n          getOptions: constant$1(settings),\r\n          hash: function (input) {\r\n            return isUndefined(input.customCode) ? input.code : input.code + '/' + input.customCode;\r\n          },\r\n          display: function (input) {\r\n            return input.title;\r\n          },\r\n          watcher: function (editor, value, callback) {\r\n            return editor.formatter.formatChanged('lang', callback, false, {\r\n              value: value.code,\r\n              customValue: value.customCode\r\n            }).unbind;\r\n          },\r\n          getCurrent: function (editor) {\r\n            var node = SugarElement.fromDom(editor.selection.getNode());\r\n            return closest$4(node, function (n) {\r\n              return Optional.some(n).filter(isElement$2).bind(function (ele) {\r\n                var codeOpt = getOpt(ele, 'lang');\r\n                return codeOpt.map(function (code) {\r\n                  var customCode = getOpt(ele, 'data-mce-lang').getOrUndefined();\r\n                  return {\r\n                    code: code,\r\n                    customCode: customCode,\r\n                    title: ''\r\n                  };\r\n                });\r\n              });\r\n            });\r\n          },\r\n          setCurrent: function (editor, lang) {\r\n            return editor.execCommand('Lang', false, lang);\r\n          },\r\n          onToolbarSetup: function (api) {\r\n            var unbinder = unbindable();\r\n            api.setActive(editor.formatter.match('lang', {}, undefined, true));\r\n            unbinder.set(editor.formatter.formatChanged('lang', api.setActive, true));\r\n            return unbinder.clear;\r\n          }\r\n        };\r\n      });\r\n    };\r\n    var register$5 = function (editor) {\r\n      registerController(editor, lineHeightSpec);\r\n      languageSpec(editor).each(function (spec) {\r\n        return registerController(editor, spec);\r\n      });\r\n    };\r\n\r\n    var register$4 = function (editor, backstage) {\r\n      alignSelectMenu(editor, backstage);\r\n      fontSelectMenu(editor, backstage);\r\n      styleSelectMenu(editor, backstage);\r\n      formatSelectMenu(editor, backstage);\r\n      fontsizeSelectMenu(editor, backstage);\r\n    };\r\n\r\n    var onSetupOutdentState = function (editor) {\r\n      return onSetupEvent(editor, 'NodeChange', function (api) {\r\n        api.setDisabled(!editor.queryCommandState('outdent'));\r\n      });\r\n    };\r\n    var registerButtons$2 = function (editor) {\r\n      editor.ui.registry.addButton('outdent', {\r\n        tooltip: 'Decrease indent',\r\n        icon: 'outdent',\r\n        onSetup: onSetupOutdentState(editor),\r\n        onAction: onActionExecCommand(editor, 'outdent')\r\n      });\r\n      editor.ui.registry.addButton('indent', {\r\n        tooltip: 'Increase indent',\r\n        icon: 'indent',\r\n        onAction: onActionExecCommand(editor, 'indent')\r\n      });\r\n    };\r\n    var register$3 = function (editor) {\r\n      registerButtons$2(editor);\r\n    };\r\n\r\n    var onActionToggleFormat = function (editor, fmt) {\r\n      return function () {\r\n        editor.execCommand('mceToggleFormat', false, fmt);\r\n      };\r\n    };\r\n    var registerFormatButtons = function (editor) {\r\n      global$5.each([\r\n        {\r\n          name: 'bold',\r\n          text: 'Bold',\r\n          icon: 'bold'\r\n        },\r\n        {\r\n          name: 'italic',\r\n          text: 'Italic',\r\n          icon: 'italic'\r\n        },\r\n        {\r\n          name: 'underline',\r\n          text: 'Underline',\r\n          icon: 'underline'\r\n        },\r\n        {\r\n          name: 'strikethrough',\r\n          text: 'Strikethrough',\r\n          icon: 'strike-through'\r\n        },\r\n        {\r\n          name: 'subscript',\r\n          text: 'Subscript',\r\n          icon: 'subscript'\r\n        },\r\n        {\r\n          name: 'superscript',\r\n          text: 'Superscript',\r\n          icon: 'superscript'\r\n        }\r\n      ], function (btn, _idx) {\r\n        editor.ui.registry.addToggleButton(btn.name, {\r\n          tooltip: btn.text,\r\n          icon: btn.icon,\r\n          onSetup: onSetupFormatToggle(editor, btn.name),\r\n          onAction: onActionToggleFormat(editor, btn.name)\r\n        });\r\n      });\r\n      for (var i = 1; i <= 6; i++) {\r\n        var name_1 = 'h' + i;\r\n        editor.ui.registry.addToggleButton(name_1, {\r\n          text: name_1.toUpperCase(),\r\n          tooltip: 'Heading ' + i,\r\n          onSetup: onSetupFormatToggle(editor, name_1),\r\n          onAction: onActionToggleFormat(editor, name_1)\r\n        });\r\n      }\r\n    };\r\n    var registerCommandButtons = function (editor) {\r\n      global$5.each([\r\n        {\r\n          name: 'cut',\r\n          text: 'Cut',\r\n          action: 'Cut',\r\n          icon: 'cut'\r\n        },\r\n        {\r\n          name: 'copy',\r\n          text: 'Copy',\r\n          action: 'Copy',\r\n          icon: 'copy'\r\n        },\r\n        {\r\n          name: 'paste',\r\n          text: 'Paste',\r\n          action: 'Paste',\r\n          icon: 'paste'\r\n        },\r\n        {\r\n          name: 'help',\r\n          text: 'Help',\r\n          action: 'mceHelp',\r\n          icon: 'help'\r\n        },\r\n        {\r\n          name: 'selectall',\r\n          text: 'Select all',\r\n          action: 'SelectAll',\r\n          icon: 'select-all'\r\n        },\r\n        {\r\n          name: 'newdocument',\r\n          text: 'New document',\r\n          action: 'mceNewDocument',\r\n          icon: 'new-document'\r\n        },\r\n        {\r\n          name: 'removeformat',\r\n          text: 'Clear formatting',\r\n          action: 'RemoveFormat',\r\n          icon: 'remove-formatting'\r\n        },\r\n        {\r\n          name: 'remove',\r\n          text: 'Remove',\r\n          action: 'Delete',\r\n          icon: 'remove'\r\n        }\r\n      ], function (btn) {\r\n        editor.ui.registry.addButton(btn.name, {\r\n          tooltip: btn.text,\r\n          icon: btn.icon,\r\n          onAction: onActionExecCommand(editor, btn.action)\r\n        });\r\n      });\r\n    };\r\n    var registerCommandToggleButtons = function (editor) {\r\n      global$5.each([{\r\n          name: 'blockquote',\r\n          text: 'Blockquote',\r\n          action: 'mceBlockQuote',\r\n          icon: 'quote'\r\n        }], function (btn) {\r\n        editor.ui.registry.addToggleButton(btn.name, {\r\n          tooltip: btn.text,\r\n          icon: btn.icon,\r\n          onAction: onActionExecCommand(editor, btn.action),\r\n          onSetup: onSetupFormatToggle(editor, btn.name)\r\n        });\r\n      });\r\n    };\r\n    var registerButtons$1 = function (editor) {\r\n      registerFormatButtons(editor);\r\n      registerCommandButtons(editor);\r\n      registerCommandToggleButtons(editor);\r\n    };\r\n    var registerMenuItems$2 = function (editor) {\r\n      global$5.each([\r\n        {\r\n          name: 'bold',\r\n          text: 'Bold',\r\n          action: 'Bold',\r\n          icon: 'bold',\r\n          shortcut: 'Meta+B'\r\n        },\r\n        {\r\n          name: 'italic',\r\n          text: 'Italic',\r\n          action: 'Italic',\r\n          icon: 'italic',\r\n          shortcut: 'Meta+I'\r\n        },\r\n        {\r\n          name: 'underline',\r\n          text: 'Underline',\r\n          action: 'Underline',\r\n          icon: 'underline',\r\n          shortcut: 'Meta+U'\r\n        },\r\n        {\r\n          name: 'strikethrough',\r\n          text: 'Strikethrough',\r\n          action: 'Strikethrough',\r\n          icon: 'strike-through',\r\n          shortcut: ''\r\n        },\r\n        {\r\n          name: 'subscript',\r\n          text: 'Subscript',\r\n          action: 'Subscript',\r\n          icon: 'subscript',\r\n          shortcut: ''\r\n        },\r\n        {\r\n          name: 'superscript',\r\n          text: 'Superscript',\r\n          action: 'Superscript',\r\n          icon: 'superscript',\r\n          shortcut: ''\r\n        },\r\n        {\r\n          name: 'removeformat',\r\n          text: 'Clear formatting',\r\n          action: 'RemoveFormat',\r\n          icon: 'remove-formatting',\r\n          shortcut: ''\r\n        },\r\n        {\r\n          name: 'newdocument',\r\n          text: 'New document',\r\n          action: 'mceNewDocument',\r\n          icon: 'new-document',\r\n          shortcut: ''\r\n        },\r\n        {\r\n          name: 'cut',\r\n          text: 'Cut',\r\n          action: 'Cut',\r\n          icon: 'cut',\r\n          shortcut: 'Meta+X'\r\n        },\r\n        {\r\n          name: 'copy',\r\n          text: 'Copy',\r\n          action: 'Copy',\r\n          icon: 'copy',\r\n          shortcut: 'Meta+C'\r\n        },\r\n        {\r\n          name: 'paste',\r\n          text: 'Paste',\r\n          action: 'Paste',\r\n          icon: 'paste',\r\n          shortcut: 'Meta+V'\r\n        },\r\n        {\r\n          name: 'selectall',\r\n          text: 'Select all',\r\n          action: 'SelectAll',\r\n          icon: 'select-all',\r\n          shortcut: 'Meta+A'\r\n        }\r\n      ], function (btn) {\r\n        editor.ui.registry.addMenuItem(btn.name, {\r\n          text: btn.text,\r\n          icon: btn.icon,\r\n          shortcut: btn.shortcut,\r\n          onAction: onActionExecCommand(editor, btn.action)\r\n        });\r\n      });\r\n      editor.ui.registry.addMenuItem('codeformat', {\r\n        text: 'Code',\r\n        icon: 'sourcecode',\r\n        onAction: onActionToggleFormat(editor, 'code')\r\n      });\r\n    };\r\n    var register$2 = function (editor) {\r\n      registerButtons$1(editor);\r\n      registerMenuItems$2(editor);\r\n    };\r\n\r\n    var onSetupUndoRedoState = function (editor, type) {\r\n      return onSetupEvent(editor, 'Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', function (api) {\r\n        api.setDisabled(editor.mode.isReadOnly() || !editor.undoManager[type]());\r\n      });\r\n    };\r\n    var registerMenuItems$1 = function (editor) {\r\n      editor.ui.registry.addMenuItem('undo', {\r\n        text: 'Undo',\r\n        icon: 'undo',\r\n        shortcut: 'Meta+Z',\r\n        onSetup: onSetupUndoRedoState(editor, 'hasUndo'),\r\n        onAction: onActionExecCommand(editor, 'undo')\r\n      });\r\n      editor.ui.registry.addMenuItem('redo', {\r\n        text: 'Redo',\r\n        icon: 'redo',\r\n        shortcut: 'Meta+Y',\r\n        onSetup: onSetupUndoRedoState(editor, 'hasRedo'),\r\n        onAction: onActionExecCommand(editor, 'redo')\r\n      });\r\n    };\r\n    var registerButtons = function (editor) {\r\n      editor.ui.registry.addButton('undo', {\r\n        tooltip: 'Undo',\r\n        icon: 'undo',\r\n        disabled: true,\r\n        onSetup: onSetupUndoRedoState(editor, 'hasUndo'),\r\n        onAction: onActionExecCommand(editor, 'undo')\r\n      });\r\n      editor.ui.registry.addButton('redo', {\r\n        tooltip: 'Redo',\r\n        icon: 'redo',\r\n        disabled: true,\r\n        onSetup: onSetupUndoRedoState(editor, 'hasRedo'),\r\n        onAction: onActionExecCommand(editor, 'redo')\r\n      });\r\n    };\r\n    var register$1 = function (editor) {\r\n      registerMenuItems$1(editor);\r\n      registerButtons(editor);\r\n    };\r\n\r\n    var onSetupVisualAidState = function (editor) {\r\n      return onSetupEvent(editor, 'VisualAid', function (api) {\r\n        api.setActive(editor.hasVisual);\r\n      });\r\n    };\r\n    var registerMenuItems = function (editor) {\r\n      editor.ui.registry.addToggleMenuItem('visualaid', {\r\n        text: 'Visual aids',\r\n        onSetup: onSetupVisualAidState(editor),\r\n        onAction: onActionExecCommand(editor, 'mceToggleVisualAid')\r\n      });\r\n    };\r\n    var registerToolbarButton = function (editor) {\r\n      editor.ui.registry.addButton('visualaid', {\r\n        tooltip: 'Visual aids',\r\n        text: 'Visual aids',\r\n        onAction: onActionExecCommand(editor, 'mceToggleVisualAid')\r\n      });\r\n    };\r\n    var register = function (editor) {\r\n      registerToolbarButton(editor);\r\n      registerMenuItems(editor);\r\n    };\r\n\r\n    var setup$6 = function (editor, backstage) {\r\n      register$6(editor);\r\n      register$2(editor);\r\n      register$4(editor, backstage);\r\n      register$1(editor);\r\n      register$a(editor);\r\n      register(editor);\r\n      register$3(editor);\r\n      register$5(editor);\r\n    };\r\n\r\n    var nu = function (x, y) {\r\n      return {\r\n        type: 'makeshift',\r\n        x: x,\r\n        y: y\r\n      };\r\n    };\r\n    var transpose = function (pos, dx, dy) {\r\n      return nu(pos.x + dx, pos.y + dy);\r\n    };\r\n    var isTouchEvent = function (e) {\r\n      return e.type === 'longpress' || e.type.indexOf('touch') === 0;\r\n    };\r\n    var fromPageXY = function (e) {\r\n      if (isTouchEvent(e)) {\r\n        var touch = e.touches[0];\r\n        return nu(touch.pageX, touch.pageY);\r\n      } else {\r\n        return nu(e.pageX, e.pageY);\r\n      }\r\n    };\r\n    var fromClientXY = function (e) {\r\n      if (isTouchEvent(e)) {\r\n        var touch = e.touches[0];\r\n        return nu(touch.clientX, touch.clientY);\r\n      } else {\r\n        return nu(e.clientX, e.clientY);\r\n      }\r\n    };\r\n    var transposeContentAreaContainer = function (element, pos) {\r\n      var containerPos = global$b.DOM.getPos(element);\r\n      return transpose(pos, containerPos.x, containerPos.y);\r\n    };\r\n    var getPointAnchor = function (editor, e) {\r\n      if (e.type === 'contextmenu' || e.type === 'longpress') {\r\n        if (editor.inline) {\r\n          return fromPageXY(e);\r\n        } else {\r\n          return transposeContentAreaContainer(editor.getContentAreaContainer(), fromClientXY(e));\r\n        }\r\n      } else {\r\n        return getSelectionAnchor(editor);\r\n      }\r\n    };\r\n    var getSelectionAnchor = function (editor) {\r\n      return {\r\n        type: 'selection',\r\n        root: SugarElement.fromDom(editor.selection.getNode())\r\n      };\r\n    };\r\n    var getNodeAnchor = function (editor) {\r\n      return {\r\n        type: 'node',\r\n        node: Optional.some(SugarElement.fromDom(editor.selection.getNode())),\r\n        root: SugarElement.fromDom(editor.getBody())\r\n      };\r\n    };\r\n    var getAnchorSpec$1 = function (editor, e, anchorType) {\r\n      switch (anchorType) {\r\n      case 'node':\r\n        return getNodeAnchor(editor);\r\n      case 'point':\r\n        return getPointAnchor(editor, e);\r\n      case 'selection':\r\n        return getSelectionAnchor(editor);\r\n      }\r\n    };\r\n\r\n    var initAndShow$1 = function (editor, e, buildMenu, backstage, contextmenu, anchorType) {\r\n      var items = buildMenu();\r\n      var anchorSpec = getAnchorSpec$1(editor, e, anchorType);\r\n      build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false).map(function (menuData) {\r\n        e.preventDefault();\r\n        InlineView.showMenuAt(contextmenu, { anchor: anchorSpec }, {\r\n          menu: { markers: markers('normal') },\r\n          data: menuData\r\n        });\r\n      });\r\n    };\r\n\r\n    var layouts = {\r\n      onLtr: function () {\r\n        return [\r\n          south$2,\r\n          southeast$2,\r\n          southwest$2,\r\n          northeast$2,\r\n          northwest$2,\r\n          north$2,\r\n          north,\r\n          south,\r\n          northeast,\r\n          southeast,\r\n          northwest,\r\n          southwest\r\n        ];\r\n      },\r\n      onRtl: function () {\r\n        return [\r\n          south$2,\r\n          southwest$2,\r\n          southeast$2,\r\n          northwest$2,\r\n          northeast$2,\r\n          north$2,\r\n          north,\r\n          south,\r\n          northwest,\r\n          southwest,\r\n          northeast,\r\n          southeast\r\n        ];\r\n      }\r\n    };\r\n    var bubbleSize = 12;\r\n    var bubbleAlignments = {\r\n      valignCentre: [],\r\n      alignCentre: [],\r\n      alignLeft: ['tox-pop--align-left'],\r\n      alignRight: ['tox-pop--align-right'],\r\n      right: ['tox-pop--right'],\r\n      left: ['tox-pop--left'],\r\n      bottom: ['tox-pop--bottom'],\r\n      top: ['tox-pop--top']\r\n    };\r\n    var isTouchWithinSelection = function (editor, e) {\r\n      var selection = editor.selection;\r\n      if (selection.isCollapsed() || e.touches.length < 1) {\r\n        return false;\r\n      } else {\r\n        var touch_1 = e.touches[0];\r\n        var rng = selection.getRng();\r\n        var rngRectOpt = getFirstRect(editor.getWin(), SimSelection.domRange(rng));\r\n        return rngRectOpt.exists(function (rngRect) {\r\n          return rngRect.left <= touch_1.clientX && rngRect.right >= touch_1.clientX && rngRect.top <= touch_1.clientY && rngRect.bottom >= touch_1.clientY;\r\n        });\r\n      }\r\n    };\r\n    var setupiOSOverrides = function (editor) {\r\n      var originalSelection = editor.selection.getRng();\r\n      var selectionReset = function () {\r\n        global$f.setEditorTimeout(editor, function () {\r\n          editor.selection.setRng(originalSelection);\r\n        }, 10);\r\n        unbindEventListeners();\r\n      };\r\n      editor.once('touchend', selectionReset);\r\n      var preventMousedown = function (e) {\r\n        e.preventDefault();\r\n        e.stopImmediatePropagation();\r\n      };\r\n      editor.on('mousedown', preventMousedown, true);\r\n      var clearSelectionReset = function () {\r\n        return unbindEventListeners();\r\n      };\r\n      editor.once('longpresscancel', clearSelectionReset);\r\n      var unbindEventListeners = function () {\r\n        editor.off('touchend', selectionReset);\r\n        editor.off('longpresscancel', clearSelectionReset);\r\n        editor.off('mousedown', preventMousedown);\r\n      };\r\n    };\r\n    var getAnchorSpec = function (editor, e, anchorType) {\r\n      var anchorSpec = getAnchorSpec$1(editor, e, anchorType);\r\n      var bubbleYOffset = anchorType === 'point' ? bubbleSize : 0;\r\n      return __assign({\r\n        bubble: nu$5(0, bubbleYOffset, bubbleAlignments),\r\n        layouts: layouts,\r\n        overrides: {\r\n          maxWidthFunction: expandable(),\r\n          maxHeightFunction: expandable$1()\r\n        }\r\n      }, anchorSpec);\r\n    };\r\n    var show = function (editor, e, items, backstage, contextmenu, anchorType, highlightImmediately) {\r\n      var anchorSpec = getAnchorSpec(editor, e, anchorType);\r\n      build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, true).map(function (menuData) {\r\n        e.preventDefault();\r\n        InlineView.showMenuWithinBounds(contextmenu, { anchor: anchorSpec }, {\r\n          menu: {\r\n            markers: markers('normal'),\r\n            highlightImmediately: highlightImmediately\r\n          },\r\n          data: menuData,\r\n          type: 'horizontal'\r\n        }, function () {\r\n          return Optional.some(getContextToolbarBounds(editor, backstage.shared, anchorType === 'node' ? 'node' : 'selection'));\r\n        });\r\n        editor.fire(hideContextToolbarEvent);\r\n      });\r\n    };\r\n    var initAndShow = function (editor, e, buildMenu, backstage, contextmenu, anchorType) {\r\n      var detection = detect$1();\r\n      var isiOS = detection.os.isiOS();\r\n      var isOSX = detection.os.isOSX();\r\n      var isAndroid = detection.os.isAndroid();\r\n      var isTouch = detection.deviceType.isTouch();\r\n      var shouldHighlightImmediately = function () {\r\n        return !(isAndroid || isiOS || isOSX && isTouch);\r\n      };\r\n      var open = function () {\r\n        var items = buildMenu();\r\n        show(editor, e, items, backstage, contextmenu, anchorType, shouldHighlightImmediately());\r\n      };\r\n      if ((isOSX || isiOS) && anchorType !== 'node') {\r\n        var openiOS_1 = function () {\r\n          setupiOSOverrides(editor);\r\n          open();\r\n        };\r\n        if (isTouchWithinSelection(editor, e)) {\r\n          openiOS_1();\r\n        } else {\r\n          editor.once('selectionchange', openiOS_1);\r\n          editor.once('touchend', function () {\r\n            return editor.off('selectionchange', openiOS_1);\r\n          });\r\n        }\r\n      } else {\r\n        open();\r\n      }\r\n    };\r\n\r\n    var patchPipeConfig = function (config) {\r\n      return typeof config === 'string' ? config.split(/[ ,]/) : config;\r\n    };\r\n    var shouldNeverUseNative = function (editor) {\r\n      return editor.getParam('contextmenu_never_use_native', false, 'boolean');\r\n    };\r\n    var getMenuItems = function (editor, name, defaultItems) {\r\n      var contextMenus = editor.ui.registry.getAll().contextMenus;\r\n      return Optional.from(editor.getParam(name)).map(patchPipeConfig).getOrThunk(function () {\r\n        return filter$2(patchPipeConfig(defaultItems), function (item) {\r\n          return has$2(contextMenus, item);\r\n        });\r\n      });\r\n    };\r\n    var isContextMenuDisabled = function (editor) {\r\n      return editor.getParam('contextmenu') === false;\r\n    };\r\n    var getContextMenu = function (editor) {\r\n      return getMenuItems(editor, 'contextmenu', 'link linkchecker image imagetools table spellchecker configurepermanentpen');\r\n    };\r\n    var getAvoidOverlapSelector = function (editor) {\r\n      return editor.getParam('contextmenu_avoid_overlap', '', 'string');\r\n    };\r\n\r\n    var isSeparator = function (item) {\r\n      return isString(item) ? item === '|' : item.type === 'separator';\r\n    };\r\n    var separator = { type: 'separator' };\r\n    var makeContextItem = function (item) {\r\n      var commonMenuItem = function (item) {\r\n        return {\r\n          text: item.text,\r\n          icon: item.icon,\r\n          disabled: item.disabled,\r\n          shortcut: item.shortcut\r\n        };\r\n      };\r\n      if (isString(item)) {\r\n        return item;\r\n      } else {\r\n        switch (item.type) {\r\n        case 'separator':\r\n          return separator;\r\n        case 'submenu':\r\n          return __assign(__assign({ type: 'nestedmenuitem' }, commonMenuItem(item)), {\r\n            getSubmenuItems: function () {\r\n              var items = item.getSubmenuItems();\r\n              if (isString(items)) {\r\n                return items;\r\n              } else {\r\n                return map$2(items, makeContextItem);\r\n              }\r\n            }\r\n          });\r\n        default:\r\n          return __assign(__assign({ type: 'menuitem' }, commonMenuItem(item)), { onAction: noarg(item.onAction) });\r\n        }\r\n      }\r\n    };\r\n    var addContextMenuGroup = function (xs, groupItems) {\r\n      if (groupItems.length === 0) {\r\n        return xs;\r\n      }\r\n      var lastMenuItem = last$2(xs).filter(function (item) {\r\n        return !isSeparator(item);\r\n      });\r\n      var before = lastMenuItem.fold(function () {\r\n        return [];\r\n      }, function (_) {\r\n        return [separator];\r\n      });\r\n      return xs.concat(before).concat(groupItems).concat([separator]);\r\n    };\r\n    var generateContextMenu = function (contextMenus, menuConfig, selectedElement) {\r\n      var sections = foldl(menuConfig, function (acc, name) {\r\n        return get$e(contextMenus, name.toLowerCase()).map(function (menu) {\r\n          var items = menu.update(selectedElement);\r\n          if (isString(items)) {\r\n            return addContextMenuGroup(acc, items.split(' '));\r\n          } else if (items.length > 0) {\r\n            var allItems = map$2(items, makeContextItem);\r\n            return addContextMenuGroup(acc, allItems);\r\n          } else {\r\n            return acc;\r\n          }\r\n        }).getOrThunk(function () {\r\n          return acc.concat([name]);\r\n        });\r\n      }, []);\r\n      if (sections.length > 0 && isSeparator(sections[sections.length - 1])) {\r\n        sections.pop();\r\n      }\r\n      return sections;\r\n    };\r\n    var isNativeOverrideKeyEvent = function (editor, e) {\r\n      return e.ctrlKey && !shouldNeverUseNative(editor);\r\n    };\r\n    var isTriggeredByKeyboard = function (editor, e) {\r\n      return e.type !== 'longpress' && (e.button !== 2 || e.target === editor.getBody() && e.pointerType === '');\r\n    };\r\n    var getSelectedElement = function (editor, e) {\r\n      return isTriggeredByKeyboard(editor, e) ? editor.selection.getStart(true) : e.target;\r\n    };\r\n    var getAnchorType = function (editor, e) {\r\n      var selector = getAvoidOverlapSelector(editor);\r\n      var anchorType = isTriggeredByKeyboard(editor, e) ? 'selection' : 'point';\r\n      if (isNotEmpty(selector)) {\r\n        var target = getSelectedElement(editor, e);\r\n        var selectorExists = closest(SugarElement.fromDom(target), selector);\r\n        return selectorExists ? 'node' : anchorType;\r\n      } else {\r\n        return anchorType;\r\n      }\r\n    };\r\n    var setup$5 = function (editor, lazySink, backstage) {\r\n      var detection = detect$1();\r\n      var isTouch = detection.deviceType.isTouch;\r\n      var contextmenu = build$1(InlineView.sketch({\r\n        dom: { tag: 'div' },\r\n        lazySink: lazySink,\r\n        onEscape: function () {\r\n          return editor.focus();\r\n        },\r\n        onShow: function () {\r\n          return backstage.setContextMenuState(true);\r\n        },\r\n        onHide: function () {\r\n          return backstage.setContextMenuState(false);\r\n        },\r\n        fireDismissalEventInstead: {},\r\n        inlineBehaviours: derive$1([config('dismissContextMenu', [run$1(dismissRequested(), function (comp, _se) {\r\n              Sandboxing.close(comp);\r\n              editor.focus();\r\n            })])])\r\n      }));\r\n      var hideContextMenu = function (_e) {\r\n        return InlineView.hide(contextmenu);\r\n      };\r\n      var showContextMenu = function (e) {\r\n        if (shouldNeverUseNative(editor)) {\r\n          e.preventDefault();\r\n        }\r\n        if (isNativeOverrideKeyEvent(editor, e) || isContextMenuDisabled(editor)) {\r\n          return;\r\n        }\r\n        var anchorType = getAnchorType(editor, e);\r\n        var buildMenu = function () {\r\n          var selectedElement = getSelectedElement(editor, e);\r\n          var registry = editor.ui.registry.getAll();\r\n          var menuConfig = getContextMenu(editor);\r\n          return generateContextMenu(registry.contextMenus, menuConfig, selectedElement);\r\n        };\r\n        var initAndShow$2 = isTouch() ? initAndShow : initAndShow$1;\r\n        initAndShow$2(editor, e, buildMenu, backstage, contextmenu, anchorType);\r\n      };\r\n      editor.on('init', function () {\r\n        var hideEvents = 'ResizeEditor ScrollContent ScrollWindow longpresscancel' + (isTouch() ? '' : ' ResizeWindow');\r\n        editor.on(hideEvents, hideContextMenu);\r\n        editor.on('longpress contextmenu', showContextMenu);\r\n      });\r\n    };\r\n\r\n    var adt = Adt.generate([\r\n      {\r\n        offset: [\r\n          'x',\r\n          'y'\r\n        ]\r\n      },\r\n      {\r\n        absolute: [\r\n          'x',\r\n          'y'\r\n        ]\r\n      },\r\n      {\r\n        fixed: [\r\n          'x',\r\n          'y'\r\n        ]\r\n      }\r\n    ]);\r\n    var subtract = function (change) {\r\n      return function (point) {\r\n        return point.translate(-change.left, -change.top);\r\n      };\r\n    };\r\n    var add = function (change) {\r\n      return function (point) {\r\n        return point.translate(change.left, change.top);\r\n      };\r\n    };\r\n    var transform = function (changes) {\r\n      return function (x, y) {\r\n        return foldl(changes, function (rest, f) {\r\n          return f(rest);\r\n        }, SugarPosition(x, y));\r\n      };\r\n    };\r\n    var asFixed = function (coord, scroll, origin) {\r\n      return coord.fold(transform([\r\n        add(origin),\r\n        subtract(scroll)\r\n      ]), transform([subtract(scroll)]), transform([]));\r\n    };\r\n    var asAbsolute = function (coord, scroll, origin) {\r\n      return coord.fold(transform([add(origin)]), transform([]), transform([add(scroll)]));\r\n    };\r\n    var asOffset = function (coord, scroll, origin) {\r\n      return coord.fold(transform([]), transform([subtract(origin)]), transform([\r\n        add(scroll),\r\n        subtract(origin)\r\n      ]));\r\n    };\r\n    var withinRange = function (coord1, coord2, xRange, yRange, scroll, origin) {\r\n      var a1 = asAbsolute(coord1, scroll, origin);\r\n      var a2 = asAbsolute(coord2, scroll, origin);\r\n      return Math.abs(a1.left - a2.left) <= xRange && Math.abs(a1.top - a2.top) <= yRange;\r\n    };\r\n    var getDeltas = function (coord1, coord2, xRange, yRange, scroll, origin) {\r\n      var a1 = asAbsolute(coord1, scroll, origin);\r\n      var a2 = asAbsolute(coord2, scroll, origin);\r\n      var left = Math.abs(a1.left - a2.left);\r\n      var top = Math.abs(a1.top - a2.top);\r\n      return SugarPosition(left, top);\r\n    };\r\n    var toStyles = function (coord, scroll, origin) {\r\n      var stylesOpt = coord.fold(function (x, y) {\r\n        return {\r\n          position: Optional.some('absolute'),\r\n          left: Optional.some(x + 'px'),\r\n          top: Optional.some(y + 'px')\r\n        };\r\n      }, function (x, y) {\r\n        return {\r\n          position: Optional.some('absolute'),\r\n          left: Optional.some(x - origin.left + 'px'),\r\n          top: Optional.some(y - origin.top + 'px')\r\n        };\r\n      }, function (x, y) {\r\n        return {\r\n          position: Optional.some('fixed'),\r\n          left: Optional.some(x + 'px'),\r\n          top: Optional.some(y + 'px')\r\n        };\r\n      });\r\n      return __assign({\r\n        right: Optional.none(),\r\n        bottom: Optional.none()\r\n      }, stylesOpt);\r\n    };\r\n    var translate = function (coord, deltaX, deltaY) {\r\n      return coord.fold(function (x, y) {\r\n        return offset(x + deltaX, y + deltaY);\r\n      }, function (x, y) {\r\n        return absolute(x + deltaX, y + deltaY);\r\n      }, function (x, y) {\r\n        return fixed(x + deltaX, y + deltaY);\r\n      });\r\n    };\r\n    var absorb = function (partialCoord, originalCoord, scroll, origin) {\r\n      var absorbOne = function (stencil, nu) {\r\n        return function (optX, optY) {\r\n          var original = stencil(originalCoord, scroll, origin);\r\n          return nu(optX.getOr(original.left), optY.getOr(original.top));\r\n        };\r\n      };\r\n      return partialCoord.fold(absorbOne(asOffset, offset), absorbOne(asAbsolute, absolute), absorbOne(asFixed, fixed));\r\n    };\r\n    var offset = adt.offset;\r\n    var absolute = adt.absolute;\r\n    var fixed = adt.fixed;\r\n\r\n    var parseAttrToInt = function (element, name) {\r\n      var value = get$d(element, name);\r\n      return isUndefined(value) ? NaN : parseInt(value, 10);\r\n    };\r\n    var get = function (component, snapsInfo) {\r\n      var element = component.element;\r\n      var x = parseAttrToInt(element, snapsInfo.leftAttr);\r\n      var y = parseAttrToInt(element, snapsInfo.topAttr);\r\n      return isNaN(x) || isNaN(y) ? Optional.none() : Optional.some(SugarPosition(x, y));\r\n    };\r\n    var set = function (component, snapsInfo, pt) {\r\n      var element = component.element;\r\n      set$8(element, snapsInfo.leftAttr, pt.left + 'px');\r\n      set$8(element, snapsInfo.topAttr, pt.top + 'px');\r\n    };\r\n    var clear = function (component, snapsInfo) {\r\n      var element = component.element;\r\n      remove$7(element, snapsInfo.leftAttr);\r\n      remove$7(element, snapsInfo.topAttr);\r\n    };\r\n\r\n    var getCoords = function (component, snapInfo, coord, delta) {\r\n      return get(component, snapInfo).fold(function () {\r\n        return coord;\r\n      }, function (fixed$1) {\r\n        return fixed(fixed$1.left + delta.left, fixed$1.top + delta.top);\r\n      });\r\n    };\r\n    var moveOrSnap = function (component, snapInfo, coord, delta, scroll, origin) {\r\n      var newCoord = getCoords(component, snapInfo, coord, delta);\r\n      var snap = snapInfo.mustSnap ? findClosestSnap(component, snapInfo, newCoord, scroll, origin) : findSnap(component, snapInfo, newCoord, scroll, origin);\r\n      var fixedCoord = asFixed(newCoord, scroll, origin);\r\n      set(component, snapInfo, fixedCoord);\r\n      return snap.fold(function () {\r\n        return {\r\n          coord: fixed(fixedCoord.left, fixedCoord.top),\r\n          extra: Optional.none()\r\n        };\r\n      }, function (spanned) {\r\n        return {\r\n          coord: spanned.output,\r\n          extra: spanned.extra\r\n        };\r\n      });\r\n    };\r\n    var stopDrag = function (component, snapInfo) {\r\n      clear(component, snapInfo);\r\n    };\r\n    var findMatchingSnap = function (snaps, newCoord, scroll, origin) {\r\n      return findMap(snaps, function (snap) {\r\n        var sensor = snap.sensor;\r\n        var inRange = withinRange(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);\r\n        return inRange ? Optional.some({\r\n          output: absorb(snap.output, newCoord, scroll, origin),\r\n          extra: snap.extra\r\n        }) : Optional.none();\r\n      });\r\n    };\r\n    var findClosestSnap = function (component, snapInfo, newCoord, scroll, origin) {\r\n      var snaps = snapInfo.getSnapPoints(component);\r\n      var matchSnap = findMatchingSnap(snaps, newCoord, scroll, origin);\r\n      return matchSnap.orThunk(function () {\r\n        var bestSnap = foldl(snaps, function (acc, snap) {\r\n          var sensor = snap.sensor;\r\n          var deltas = getDeltas(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);\r\n          return acc.deltas.fold(function () {\r\n            return {\r\n              deltas: Optional.some(deltas),\r\n              snap: Optional.some(snap)\r\n            };\r\n          }, function (bestDeltas) {\r\n            var currAvg = (deltas.left + deltas.top) / 2;\r\n            var bestAvg = (bestDeltas.left + bestDeltas.top) / 2;\r\n            if (currAvg <= bestAvg) {\r\n              return {\r\n                deltas: Optional.some(deltas),\r\n                snap: Optional.some(snap)\r\n              };\r\n            } else {\r\n              return acc;\r\n            }\r\n          });\r\n        }, {\r\n          deltas: Optional.none(),\r\n          snap: Optional.none()\r\n        });\r\n        return bestSnap.snap.map(function (snap) {\r\n          return {\r\n            output: absorb(snap.output, newCoord, scroll, origin),\r\n            extra: snap.extra\r\n          };\r\n        });\r\n      });\r\n    };\r\n    var findSnap = function (component, snapInfo, newCoord, scroll, origin) {\r\n      var snaps = snapInfo.getSnapPoints(component);\r\n      return findMatchingSnap(snaps, newCoord, scroll, origin);\r\n    };\r\n    var snapTo$1 = function (snap, scroll, origin) {\r\n      return {\r\n        coord: absorb(snap.output, snap.output, scroll, origin),\r\n        extra: snap.extra\r\n      };\r\n    };\r\n\r\n    var snapTo = function (component, dragConfig, _state, snap) {\r\n      var target = dragConfig.getTarget(component.element);\r\n      if (dragConfig.repositionTarget) {\r\n        var doc = owner$4(component.element);\r\n        var scroll_1 = get$9(doc);\r\n        var origin_1 = getOrigin(target);\r\n        var snapPin = snapTo$1(snap, scroll_1, origin_1);\r\n        var styles = toStyles(snapPin.coord, scroll_1, origin_1);\r\n        setOptions(target, styles);\r\n      }\r\n    };\r\n\r\n    var DraggingApis = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        snapTo: snapTo\r\n    });\r\n\r\n    var initialAttribute = 'data-initial-z-index';\r\n    var resetZIndex = function (blocker) {\r\n      parent(blocker.element).filter(isElement$2).each(function (root) {\r\n        getOpt(root, initialAttribute).fold(function () {\r\n          return remove$6(root, 'z-index');\r\n        }, function (zIndex) {\r\n          return set$7(root, 'z-index', zIndex);\r\n        });\r\n        remove$7(root, initialAttribute);\r\n      });\r\n    };\r\n    var changeZIndex = function (blocker) {\r\n      parent(blocker.element).filter(isElement$2).each(function (root) {\r\n        getRaw(root, 'z-index').each(function (zindex) {\r\n          set$8(root, initialAttribute, zindex);\r\n        });\r\n        set$7(root, 'z-index', get$c(blocker.element, 'z-index'));\r\n      });\r\n    };\r\n    var instigate = function (anyComponent, blocker) {\r\n      anyComponent.getSystem().addToGui(blocker);\r\n      changeZIndex(blocker);\r\n    };\r\n    var discard = function (blocker) {\r\n      resetZIndex(blocker);\r\n      blocker.getSystem().removeFromGui(blocker);\r\n    };\r\n    var createComponent = function (component, blockerClass, blockerEvents) {\r\n      return component.getSystem().build(Container.sketch({\r\n        dom: {\r\n          styles: {\r\n            'left': '0px',\r\n            'top': '0px',\r\n            'width': '100%',\r\n            'height': '100%',\r\n            'position': 'fixed',\r\n            'z-index': '1000000000000000'\r\n          },\r\n          classes: [blockerClass]\r\n        },\r\n        events: blockerEvents\r\n      }));\r\n    };\r\n\r\n    var SnapSchema = optionObjOf('snaps', [\r\n      required$1('getSnapPoints'),\r\n      onHandler('onSensor'),\r\n      required$1('leftAttr'),\r\n      required$1('topAttr'),\r\n      defaulted('lazyViewport', win),\r\n      defaulted('mustSnap', false)\r\n    ]);\r\n\r\n    var schema$6 = [\r\n      defaulted('useFixed', never),\r\n      required$1('blockerClass'),\r\n      defaulted('getTarget', identity$1),\r\n      defaulted('onDrag', noop),\r\n      defaulted('repositionTarget', true),\r\n      defaulted('onDrop', noop),\r\n      defaultedFunction('getBounds', win),\r\n      SnapSchema\r\n    ];\r\n\r\n    var getCurrentCoord = function (target) {\r\n      return lift3(getRaw(target, 'left'), getRaw(target, 'top'), getRaw(target, 'position'), function (left, top, position) {\r\n        var nu = position === 'fixed' ? fixed : offset;\r\n        return nu(parseInt(left, 10), parseInt(top, 10));\r\n      }).getOrThunk(function () {\r\n        var location = absolute$3(target);\r\n        return absolute(location.left, location.top);\r\n      });\r\n    };\r\n    var clampCoords = function (component, coords, scroll, origin, startData) {\r\n      var bounds = startData.bounds;\r\n      var absoluteCoord = asAbsolute(coords, scroll, origin);\r\n      var newX = clamp$1(absoluteCoord.left, bounds.x, bounds.x + bounds.width - startData.width);\r\n      var newY = clamp$1(absoluteCoord.top, bounds.y, bounds.y + bounds.height - startData.height);\r\n      var newCoords = absolute(newX, newY);\r\n      return coords.fold(function () {\r\n        var offset$1 = asOffset(newCoords, scroll, origin);\r\n        return offset(offset$1.left, offset$1.top);\r\n      }, constant$1(newCoords), function () {\r\n        var fixed$1 = asFixed(newCoords, scroll, origin);\r\n        return fixed(fixed$1.left, fixed$1.top);\r\n      });\r\n    };\r\n    var calcNewCoord = function (component, optSnaps, currentCoord, scroll, origin, delta, startData) {\r\n      var newCoord = optSnaps.fold(function () {\r\n        var translated = translate(currentCoord, delta.left, delta.top);\r\n        var fixedCoord = asFixed(translated, scroll, origin);\r\n        return fixed(fixedCoord.left, fixedCoord.top);\r\n      }, function (snapInfo) {\r\n        var snapping = moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);\r\n        snapping.extra.each(function (extra) {\r\n          snapInfo.onSensor(component, extra);\r\n        });\r\n        return snapping.coord;\r\n      });\r\n      return clampCoords(component, newCoord, scroll, origin, startData);\r\n    };\r\n    var dragBy = function (component, dragConfig, startData, delta) {\r\n      var target = dragConfig.getTarget(component.element);\r\n      if (dragConfig.repositionTarget) {\r\n        var doc = owner$4(component.element);\r\n        var scroll_1 = get$9(doc);\r\n        var origin_1 = getOrigin(target);\r\n        var currentCoord = getCurrentCoord(target);\r\n        var newCoord = calcNewCoord(component, dragConfig.snaps, currentCoord, scroll_1, origin_1, delta, startData);\r\n        var styles = toStyles(newCoord, scroll_1, origin_1);\r\n        setOptions(target, styles);\r\n      }\r\n      dragConfig.onDrag(component, target, delta);\r\n    };\r\n\r\n    var calcStartData = function (dragConfig, comp) {\r\n      return {\r\n        bounds: dragConfig.getBounds(),\r\n        height: getOuter$2(comp.element),\r\n        width: getOuter$1(comp.element)\r\n      };\r\n    };\r\n    var move = function (component, dragConfig, dragState, dragMode, event) {\r\n      var delta = dragState.update(dragMode, event);\r\n      var dragStartData = dragState.getStartData().getOrThunk(function () {\r\n        return calcStartData(dragConfig, component);\r\n      });\r\n      delta.each(function (dlt) {\r\n        dragBy(component, dragConfig, dragStartData, dlt);\r\n      });\r\n    };\r\n    var stop = function (component, blocker, dragConfig, dragState) {\r\n      blocker.each(discard);\r\n      dragConfig.snaps.each(function (snapInfo) {\r\n        stopDrag(component, snapInfo);\r\n      });\r\n      var target = dragConfig.getTarget(component.element);\r\n      dragState.reset();\r\n      dragConfig.onDrop(component, target);\r\n    };\r\n    var handlers = function (events) {\r\n      return function (dragConfig, dragState) {\r\n        var updateStartState = function (comp) {\r\n          dragState.setStartData(calcStartData(dragConfig, comp));\r\n        };\r\n        return derive$2(__spreadArray([run$1(windowScroll(), function (comp) {\r\n            dragState.getStartData().each(function () {\r\n              return updateStartState(comp);\r\n            });\r\n          })], events(dragConfig, dragState, updateStartState), true));\r\n      };\r\n    };\r\n\r\n    var init$2 = function (dragApi) {\r\n      return derive$2([\r\n        run$1(mousedown(), dragApi.forceDrop),\r\n        run$1(mouseup(), dragApi.drop),\r\n        run$1(mousemove(), function (comp, simulatedEvent) {\r\n          dragApi.move(simulatedEvent.event);\r\n        }),\r\n        run$1(mouseout(), dragApi.delayDrop)\r\n      ]);\r\n    };\r\n\r\n    var getData$1 = function (event) {\r\n      return Optional.from(SugarPosition(event.x, event.y));\r\n    };\r\n    var getDelta$1 = function (old, nu) {\r\n      return SugarPosition(nu.left - old.left, nu.top - old.top);\r\n    };\r\n\r\n    var MouseData = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        getData: getData$1,\r\n        getDelta: getDelta$1\r\n    });\r\n\r\n    var events$2 = function (dragConfig, dragState, updateStartState) {\r\n      return [run$1(mousedown(), function (component, simulatedEvent) {\r\n          var raw = simulatedEvent.event.raw;\r\n          if (raw.button !== 0) {\r\n            return;\r\n          }\r\n          simulatedEvent.stop();\r\n          var stop$1 = function () {\r\n            return stop(component, Optional.some(blocker), dragConfig, dragState);\r\n          };\r\n          var delayDrop = DelayedFunction(stop$1, 200);\r\n          var dragApi = {\r\n            drop: stop$1,\r\n            delayDrop: delayDrop.schedule,\r\n            forceDrop: stop$1,\r\n            move: function (event) {\r\n              delayDrop.cancel();\r\n              move(component, dragConfig, dragState, MouseData, event);\r\n            }\r\n          };\r\n          var blocker = createComponent(component, dragConfig.blockerClass, init$2(dragApi));\r\n          var start = function () {\r\n            updateStartState(component);\r\n            instigate(component, blocker);\r\n          };\r\n          start();\r\n        })];\r\n    };\r\n    var schema$5 = __spreadArray(__spreadArray([], schema$6, true), [output$1('dragger', { handlers: handlers(events$2) })], false);\r\n\r\n    var init$1 = function (dragApi) {\r\n      return derive$2([\r\n        run$1(touchstart(), dragApi.forceDrop),\r\n        run$1(touchend(), dragApi.drop),\r\n        run$1(touchcancel(), dragApi.drop),\r\n        run$1(touchmove(), function (comp, simulatedEvent) {\r\n          dragApi.move(simulatedEvent.event);\r\n        })\r\n      ]);\r\n    };\r\n\r\n    var getDataFrom = function (touches) {\r\n      var touch = touches[0];\r\n      return Optional.some(SugarPosition(touch.clientX, touch.clientY));\r\n    };\r\n    var getData = function (event) {\r\n      var raw = event.raw;\r\n      var touches = raw.touches;\r\n      return touches.length === 1 ? getDataFrom(touches) : Optional.none();\r\n    };\r\n    var getDelta = function (old, nu) {\r\n      return SugarPosition(nu.left - old.left, nu.top - old.top);\r\n    };\r\n\r\n    var TouchData = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        getData: getData,\r\n        getDelta: getDelta\r\n    });\r\n\r\n    var events$1 = function (dragConfig, dragState, updateStartState) {\r\n      var blockerSingleton = value$1();\r\n      var stopBlocking = function (component) {\r\n        stop(component, blockerSingleton.get(), dragConfig, dragState);\r\n        blockerSingleton.clear();\r\n      };\r\n      return [\r\n        run$1(touchstart(), function (component, simulatedEvent) {\r\n          simulatedEvent.stop();\r\n          var stop = function () {\r\n            return stopBlocking(component);\r\n          };\r\n          var dragApi = {\r\n            drop: stop,\r\n            delayDrop: noop,\r\n            forceDrop: stop,\r\n            move: function (event) {\r\n              move(component, dragConfig, dragState, TouchData, event);\r\n            }\r\n          };\r\n          var blocker = createComponent(component, dragConfig.blockerClass, init$1(dragApi));\r\n          blockerSingleton.set(blocker);\r\n          var start = function () {\r\n            updateStartState(component);\r\n            instigate(component, blocker);\r\n          };\r\n          start();\r\n        }),\r\n        run$1(touchmove(), function (component, simulatedEvent) {\r\n          simulatedEvent.stop();\r\n          move(component, dragConfig, dragState, TouchData, simulatedEvent.event);\r\n        }),\r\n        run$1(touchend(), function (component, simulatedEvent) {\r\n          simulatedEvent.stop();\r\n          stopBlocking(component);\r\n        }),\r\n        run$1(touchcancel(), stopBlocking)\r\n      ];\r\n    };\r\n    var schema$4 = __spreadArray(__spreadArray([], schema$6, true), [output$1('dragger', { handlers: handlers(events$1) })], false);\r\n\r\n    var events = function (dragConfig, dragState, updateStartState) {\r\n      return __spreadArray(__spreadArray([], events$2(dragConfig, dragState, updateStartState), true), events$1(dragConfig, dragState, updateStartState), true);\r\n    };\r\n    var schema$3 = __spreadArray(__spreadArray([], schema$6, true), [output$1('dragger', { handlers: handlers(events) })], false);\r\n\r\n    var mouse = schema$5;\r\n    var touch = schema$4;\r\n    var mouseOrTouch = schema$3;\r\n\r\n    var DraggingBranches = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        mouse: mouse,\r\n        touch: touch,\r\n        mouseOrTouch: mouseOrTouch\r\n    });\r\n\r\n    var init = function () {\r\n      var previous = Optional.none();\r\n      var startData = Optional.none();\r\n      var reset = function () {\r\n        previous = Optional.none();\r\n        startData = Optional.none();\r\n      };\r\n      var calculateDelta = function (mode, nu) {\r\n        var result = previous.map(function (old) {\r\n          return mode.getDelta(old, nu);\r\n        });\r\n        previous = Optional.some(nu);\r\n        return result;\r\n      };\r\n      var update = function (mode, dragEvent) {\r\n        return mode.getData(dragEvent).bind(function (nuData) {\r\n          return calculateDelta(mode, nuData);\r\n        });\r\n      };\r\n      var setStartData = function (data) {\r\n        startData = Optional.some(data);\r\n      };\r\n      var getStartData = function () {\r\n        return startData;\r\n      };\r\n      var readState = constant$1({});\r\n      return nu$8({\r\n        readState: readState,\r\n        reset: reset,\r\n        update: update,\r\n        getStartData: getStartData,\r\n        setStartData: setStartData\r\n      });\r\n    };\r\n\r\n    var DragState = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        init: init\r\n    });\r\n\r\n    var Dragging = createModes({\r\n      branchKey: 'mode',\r\n      branches: DraggingBranches,\r\n      name: 'dragging',\r\n      active: {\r\n        events: function (dragConfig, dragState) {\r\n          var dragger = dragConfig.dragger;\r\n          return dragger.handlers(dragConfig, dragState);\r\n        }\r\n      },\r\n      extra: {\r\n        snap: function (sConfig) {\r\n          return {\r\n            sensor: sConfig.sensor,\r\n            range: sConfig.range,\r\n            output: sConfig.output,\r\n            extra: Optional.from(sConfig.extra)\r\n          };\r\n        }\r\n      },\r\n      state: DragState,\r\n      apis: DraggingApis\r\n    });\r\n\r\n    var snapWidth = 40;\r\n    var snapOffset = snapWidth / 2;\r\n    var calcSnap = function (selectorOpt, td, x, y, width, height) {\r\n      return selectorOpt.fold(function () {\r\n        return Dragging.snap({\r\n          sensor: absolute(x - snapOffset, y - snapOffset),\r\n          range: SugarPosition(width, height),\r\n          output: absolute(Optional.some(x), Optional.some(y)),\r\n          extra: { td: td }\r\n        });\r\n      }, function (selectorHandle) {\r\n        var sensorLeft = x - snapOffset;\r\n        var sensorTop = y - snapOffset;\r\n        var sensorWidth = snapWidth;\r\n        var sensorHeight = snapWidth;\r\n        var rect = selectorHandle.element.dom.getBoundingClientRect();\r\n        return Dragging.snap({\r\n          sensor: absolute(sensorLeft, sensorTop),\r\n          range: SugarPosition(sensorWidth, sensorHeight),\r\n          output: absolute(Optional.some(x - rect.width / 2), Optional.some(y - rect.height / 2)),\r\n          extra: { td: td }\r\n        });\r\n      });\r\n    };\r\n    var getSnapsConfig = function (getSnapPoints, cell, onChange) {\r\n      var isSameCell = function (cellOpt, td) {\r\n        return cellOpt.exists(function (currentTd) {\r\n          return eq(currentTd, td);\r\n        });\r\n      };\r\n      return {\r\n        getSnapPoints: getSnapPoints,\r\n        leftAttr: 'data-drag-left',\r\n        topAttr: 'data-drag-top',\r\n        onSensor: function (component, extra) {\r\n          var td = extra.td;\r\n          if (!isSameCell(cell.get(), td)) {\r\n            cell.set(td);\r\n            onChange(td);\r\n          }\r\n        },\r\n        mustSnap: true\r\n      };\r\n    };\r\n    var createSelector = function (snaps) {\r\n      return record(Button.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-selector']\r\n        },\r\n        buttonBehaviours: derive$1([\r\n          Dragging.config({\r\n            mode: 'mouseOrTouch',\r\n            blockerClass: 'blocker',\r\n            snaps: snaps\r\n          }),\r\n          Unselecting.config({})\r\n        ]),\r\n        eventOrder: {\r\n          mousedown: [\r\n            'dragging',\r\n            'alloy.base.behaviour'\r\n          ],\r\n          touchstart: [\r\n            'dragging',\r\n            'alloy.base.behaviour'\r\n          ]\r\n        }\r\n      }));\r\n    };\r\n    var setup$4 = function (editor, sink) {\r\n      var tlTds = Cell([]);\r\n      var brTds = Cell([]);\r\n      var isVisible = Cell(false);\r\n      var startCell = value$1();\r\n      var finishCell = value$1();\r\n      var getTopLeftSnap = function (td) {\r\n        var box = absolute$2(td);\r\n        return calcSnap(memTopLeft.getOpt(sink), td, box.x, box.y, box.width, box.height);\r\n      };\r\n      var getTopLeftSnaps = function () {\r\n        return map$2(tlTds.get(), function (td) {\r\n          return getTopLeftSnap(td);\r\n        });\r\n      };\r\n      var getBottomRightSnap = function (td) {\r\n        var box = absolute$2(td);\r\n        return calcSnap(memBottomRight.getOpt(sink), td, box.right, box.bottom, box.width, box.height);\r\n      };\r\n      var getBottomRightSnaps = function () {\r\n        return map$2(brTds.get(), function (td) {\r\n          return getBottomRightSnap(td);\r\n        });\r\n      };\r\n      var topLeftSnaps = getSnapsConfig(getTopLeftSnaps, startCell, function (start) {\r\n        finishCell.get().each(function (finish) {\r\n          editor.fire('TableSelectorChange', {\r\n            start: start,\r\n            finish: finish\r\n          });\r\n        });\r\n      });\r\n      var bottomRightSnaps = getSnapsConfig(getBottomRightSnaps, finishCell, function (finish) {\r\n        startCell.get().each(function (start) {\r\n          editor.fire('TableSelectorChange', {\r\n            start: start,\r\n            finish: finish\r\n          });\r\n        });\r\n      });\r\n      var memTopLeft = createSelector(topLeftSnaps);\r\n      var memBottomRight = createSelector(bottomRightSnaps);\r\n      var topLeft = build$1(memTopLeft.asSpec());\r\n      var bottomRight = build$1(memBottomRight.asSpec());\r\n      var showOrHideHandle = function (selector, cell, isAbove, isBelow) {\r\n        var cellRect = cell.dom.getBoundingClientRect();\r\n        remove$6(selector.element, 'display');\r\n        var viewportHeight = defaultView(SugarElement.fromDom(editor.getBody())).dom.innerHeight;\r\n        var aboveViewport = isAbove(cellRect);\r\n        var belowViewport = isBelow(cellRect, viewportHeight);\r\n        if (aboveViewport || belowViewport) {\r\n          set$7(selector.element, 'display', 'none');\r\n        }\r\n      };\r\n      var snapTo = function (selector, cell, getSnapConfig, pos) {\r\n        var snap = getSnapConfig(cell);\r\n        Dragging.snapTo(selector, snap);\r\n        var isAbove = function (rect) {\r\n          return rect[pos] < 0;\r\n        };\r\n        var isBelow = function (rect, viewportHeight) {\r\n          return rect[pos] > viewportHeight;\r\n        };\r\n        showOrHideHandle(selector, cell, isAbove, isBelow);\r\n      };\r\n      var snapTopLeft = function (cell) {\r\n        return snapTo(topLeft, cell, getTopLeftSnap, 'top');\r\n      };\r\n      var snapLastTopLeft = function () {\r\n        return startCell.get().each(snapTopLeft);\r\n      };\r\n      var snapBottomRight = function (cell) {\r\n        return snapTo(bottomRight, cell, getBottomRightSnap, 'bottom');\r\n      };\r\n      var snapLastBottomRight = function () {\r\n        return finishCell.get().each(snapBottomRight);\r\n      };\r\n      if (detect$1().deviceType.isTouch()) {\r\n        editor.on('TableSelectionChange', function (e) {\r\n          if (!isVisible.get()) {\r\n            attach(sink, topLeft);\r\n            attach(sink, bottomRight);\r\n            isVisible.set(true);\r\n          }\r\n          startCell.set(e.start);\r\n          finishCell.set(e.finish);\r\n          e.otherCells.each(function (otherCells) {\r\n            tlTds.set(otherCells.upOrLeftCells);\r\n            brTds.set(otherCells.downOrRightCells);\r\n            snapTopLeft(e.start);\r\n            snapBottomRight(e.finish);\r\n          });\r\n        });\r\n        editor.on('ResizeEditor ResizeWindow ScrollContent', function () {\r\n          snapLastTopLeft();\r\n          snapLastBottomRight();\r\n        });\r\n        editor.on('TableSelectionClear', function () {\r\n          if (isVisible.get()) {\r\n            detach(topLeft);\r\n            detach(bottomRight);\r\n            isVisible.set(false);\r\n          }\r\n          startCell.clear();\r\n          finishCell.clear();\r\n        });\r\n      }\r\n    };\r\n\r\n    var isHidden = function (elm) {\r\n      if (elm.nodeType === 1) {\r\n        if (elm.nodeName === 'BR' || !!elm.getAttribute('data-mce-bogus')) {\r\n          return true;\r\n        }\r\n        if (elm.getAttribute('data-mce-type') === 'bookmark') {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var renderElementPath = function (editor, settings, providersBackstage) {\r\n      if (!settings.delimiter) {\r\n        settings.delimiter = '\\xBB';\r\n      }\r\n      var getDataPath = function (data) {\r\n        var parts = data || [];\r\n        var newPathElements = map$2(parts, function (part, index) {\r\n          return Button.sketch({\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-statusbar__path-item'],\r\n              attributes: {\r\n                'role': 'button',\r\n                'data-index': index,\r\n                'tab-index': -1,\r\n                'aria-level': index + 1\r\n              },\r\n              innerHtml: part.name\r\n            },\r\n            action: function (_btn) {\r\n              editor.focus();\r\n              editor.selection.select(part.element);\r\n              editor.nodeChanged();\r\n            },\r\n            buttonBehaviours: derive$1([\r\n              DisablingConfigs.button(providersBackstage.isDisabled),\r\n              receivingConfig()\r\n            ])\r\n          });\r\n        });\r\n        var divider = {\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-statusbar__path-divider'],\r\n            attributes: { 'aria-hidden': true },\r\n            innerHtml: ' ' + settings.delimiter + ' '\r\n          }\r\n        };\r\n        return foldl(newPathElements.slice(1), function (acc, element) {\r\n          var newAcc = acc;\r\n          newAcc.push(divider);\r\n          newAcc.push(element);\r\n          return newAcc;\r\n        }, [newPathElements[0]]);\r\n      };\r\n      var updatePath = function (parents) {\r\n        var newPath = [];\r\n        var i = parents.length;\r\n        while (i-- > 0) {\r\n          var parent_1 = parents[i];\r\n          if (parent_1.nodeType === 1 && !isHidden(parent_1)) {\r\n            var args = editor.fire('ResolveName', {\r\n              name: parent_1.nodeName.toLowerCase(),\r\n              target: parent_1\r\n            });\r\n            if (!args.isDefaultPrevented()) {\r\n              newPath.push({\r\n                name: args.name,\r\n                element: parent_1\r\n              });\r\n            }\r\n            if (args.isPropagationStopped()) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        return newPath;\r\n      };\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-statusbar__path'],\r\n          attributes: { role: 'navigation' }\r\n        },\r\n        behaviours: derive$1([\r\n          Keying.config({\r\n            mode: 'flow',\r\n            selector: 'div[role=button]'\r\n          }),\r\n          Disabling.config({ disabled: providersBackstage.isDisabled }),\r\n          receivingConfig(),\r\n          Tabstopping.config({}),\r\n          Replacing.config({}),\r\n          config('elementPathEvents', [runOnAttached(function (comp, _e) {\r\n              editor.shortcuts.add('alt+F11', 'focus statusbar elementpath', function () {\r\n                return Keying.focusIn(comp);\r\n              });\r\n              editor.on('NodeChange', function (e) {\r\n                var newPath = updatePath(e.parents);\r\n                if (newPath.length > 0) {\r\n                  Replacing.set(comp, getDataPath(newPath));\r\n                } else {\r\n                  Replacing.set(comp, []);\r\n                }\r\n              });\r\n            })])\r\n        ]),\r\n        components: []\r\n      };\r\n    };\r\n\r\n    var ResizeTypes;\r\n    (function (ResizeTypes) {\r\n      ResizeTypes[ResizeTypes['None'] = 0] = 'None';\r\n      ResizeTypes[ResizeTypes['Both'] = 1] = 'Both';\r\n      ResizeTypes[ResizeTypes['Vertical'] = 2] = 'Vertical';\r\n    }(ResizeTypes || (ResizeTypes = {})));\r\n    var getDimensions = function (editor, deltas, resizeType, originalHeight, originalWidth) {\r\n      var dimensions = {};\r\n      dimensions.height = calcCappedSize(originalHeight + deltas.top, getMinHeightSetting(editor), getMaxHeightSetting(editor));\r\n      if (resizeType === ResizeTypes.Both) {\r\n        dimensions.width = calcCappedSize(originalWidth + deltas.left, getMinWidthSetting(editor), getMaxWidthSetting(editor));\r\n      }\r\n      return dimensions;\r\n    };\r\n    var resize = function (editor, deltas, resizeType) {\r\n      var container = SugarElement.fromDom(editor.getContainer());\r\n      var dimensions = getDimensions(editor, deltas, resizeType, get$b(container), get$a(container));\r\n      each(dimensions, function (val, dim) {\r\n        return set$7(container, dim, numToPx(val));\r\n      });\r\n      fireResizeEditor(editor);\r\n    };\r\n\r\n    var getResizeType = function (editor) {\r\n      var fallback = !editor.hasPlugin('autoresize');\r\n      var resize = editor.getParam('resize', fallback);\r\n      if (resize === false) {\r\n        return ResizeTypes.None;\r\n      } else if (resize === 'both') {\r\n        return ResizeTypes.Both;\r\n      } else {\r\n        return ResizeTypes.Vertical;\r\n      }\r\n    };\r\n    var keyboardHandler = function (editor, resizeType, x, y) {\r\n      var scale = 20;\r\n      var delta = SugarPosition(x * scale, y * scale);\r\n      resize(editor, delta, resizeType);\r\n      return Optional.some(true);\r\n    };\r\n    var renderResizeHandler = function (editor, providersBackstage) {\r\n      var resizeType = getResizeType(editor);\r\n      if (resizeType === ResizeTypes.None) {\r\n        return Optional.none();\r\n      }\r\n      return Optional.some(render$3('resize-handle', {\r\n        tag: 'div',\r\n        classes: ['tox-statusbar__resize-handle'],\r\n        attributes: { title: providersBackstage.translate('Resize') },\r\n        behaviours: [\r\n          Dragging.config({\r\n            mode: 'mouse',\r\n            repositionTarget: false,\r\n            onDrag: function (_comp, _target, delta) {\r\n              return resize(editor, delta, resizeType);\r\n            },\r\n            blockerClass: 'tox-blocker'\r\n          }),\r\n          Keying.config({\r\n            mode: 'special',\r\n            onLeft: function () {\r\n              return keyboardHandler(editor, resizeType, -1, 0);\r\n            },\r\n            onRight: function () {\r\n              return keyboardHandler(editor, resizeType, 1, 0);\r\n            },\r\n            onUp: function () {\r\n              return keyboardHandler(editor, resizeType, 0, -1);\r\n            },\r\n            onDown: function () {\r\n              return keyboardHandler(editor, resizeType, 0, 1);\r\n            }\r\n          }),\r\n          Tabstopping.config({}),\r\n          Focusing.config({})\r\n        ]\r\n      }, providersBackstage.icons));\r\n    };\r\n\r\n    var renderWordCount = function (editor, providersBackstage) {\r\n      var _a;\r\n      var replaceCountText = function (comp, count, mode) {\r\n        return Replacing.set(comp, [text$1(providersBackstage.translate([\r\n            '{0} ' + mode,\r\n            count[mode]\r\n          ]))]);\r\n      };\r\n      return Button.sketch({\r\n        dom: {\r\n          tag: 'button',\r\n          classes: ['tox-statusbar__wordcount']\r\n        },\r\n        components: [],\r\n        buttonBehaviours: derive$1([\r\n          DisablingConfigs.button(providersBackstage.isDisabled),\r\n          receivingConfig(),\r\n          Tabstopping.config({}),\r\n          Replacing.config({}),\r\n          Representing.config({\r\n            store: {\r\n              mode: 'memory',\r\n              initialValue: {\r\n                mode: 'words',\r\n                count: {\r\n                  words: 0,\r\n                  characters: 0\r\n                }\r\n              }\r\n            }\r\n          }),\r\n          config('wordcount-events', [\r\n            runOnExecute$1(function (comp) {\r\n              var currentVal = Representing.getValue(comp);\r\n              var newMode = currentVal.mode === 'words' ? 'characters' : 'words';\r\n              Representing.setValue(comp, {\r\n                mode: newMode,\r\n                count: currentVal.count\r\n              });\r\n              replaceCountText(comp, currentVal.count, newMode);\r\n            }),\r\n            runOnAttached(function (comp) {\r\n              editor.on('wordCountUpdate', function (e) {\r\n                var mode = Representing.getValue(comp).mode;\r\n                Representing.setValue(comp, {\r\n                  mode: mode,\r\n                  count: e.wordCount\r\n                });\r\n                replaceCountText(comp, e.wordCount, mode);\r\n              });\r\n            })\r\n          ])\r\n        ]),\r\n        eventOrder: (_a = {}, _a[execute$5()] = [\r\n          'disabling',\r\n          'alloy.base.behaviour',\r\n          'wordcount-events'\r\n        ], _a)\r\n      });\r\n    };\r\n\r\n    var renderStatusbar = function (editor, providersBackstage) {\r\n      var renderBranding = function () {\r\n        var label = global$e.translate([\r\n          'Powered by {0}',\r\n          'Tiny'\r\n        ]);\r\n        var linkHtml = '<a href=\"https://www.tiny.cloud/?utm_campaign=editor_referral&amp;utm_medium=poweredby&amp;utm_source=tinymce&amp;utm_content=v5\" rel=\"noopener\" target=\"_blank\" tabindex=\"-1\" aria-label=\"' + label + '\">' + label + '</a>';\r\n        return {\r\n          dom: {\r\n            tag: 'span',\r\n            classes: ['tox-statusbar__branding'],\r\n            innerHtml: linkHtml\r\n          }\r\n        };\r\n      };\r\n      var getTextComponents = function () {\r\n        var components = [];\r\n        if (editor.getParam('elementpath', true, 'boolean')) {\r\n          components.push(renderElementPath(editor, {}, providersBackstage));\r\n        }\r\n        if (editor.hasPlugin('wordcount')) {\r\n          components.push(renderWordCount(editor, providersBackstage));\r\n        }\r\n        if (editor.getParam('branding', true, 'boolean')) {\r\n          components.push(renderBranding());\r\n        }\r\n        if (components.length > 0) {\r\n          return [{\r\n              dom: {\r\n                tag: 'div',\r\n                classes: ['tox-statusbar__text-container']\r\n              },\r\n              components: components\r\n            }];\r\n        }\r\n        return [];\r\n      };\r\n      var getComponents = function () {\r\n        var components = getTextComponents();\r\n        var resizeHandler = renderResizeHandler(editor, providersBackstage);\r\n        return components.concat(resizeHandler.toArray());\r\n      };\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-statusbar']\r\n        },\r\n        components: getComponents()\r\n      };\r\n    };\r\n\r\n    var setup$3 = function (editor) {\r\n      var _a;\r\n      var isInline = editor.inline;\r\n      var mode = isInline ? Inline : Iframe;\r\n      var header = isStickyToolbar(editor) ? StickyHeader : StaticHeader;\r\n      var lazyOuterContainer = Optional.none();\r\n      var platform = detect$1();\r\n      var isIE = platform.browser.isIE();\r\n      var platformClasses = isIE ? ['tox-platform-ie'] : [];\r\n      var isTouch = platform.deviceType.isTouch();\r\n      var touchPlatformClass = 'tox-platform-touch';\r\n      var deviceClasses = isTouch ? [touchPlatformClass] : [];\r\n      var isToolbarBottom = isToolbarLocationBottom(editor);\r\n      var uiContainer = getUiContainer(editor);\r\n      var dirAttributes = global$e.isRtl() ? { attributes: { dir: 'rtl' } } : {};\r\n      var verticalDirAttributes = { attributes: (_a = {}, _a[Attribute] = isToolbarBottom ? AttributeValue.BottomToTop : AttributeValue.TopToBottom, _a) };\r\n      var lazyHeader = function () {\r\n        return lazyOuterContainer.bind(OuterContainer.getHeader);\r\n      };\r\n      var isHeaderDocked = function () {\r\n        return header.isDocked(lazyHeader);\r\n      };\r\n      var resizeUiMothership = function () {\r\n        set$7(uiMothership.element, 'width', document.body.clientWidth + 'px');\r\n      };\r\n      var makeSinkDefinition = function () {\r\n        var isGridUiContainer = eq(body(), uiContainer) && get$c(uiContainer, 'display') === 'grid';\r\n        var sinkSpec = {\r\n          dom: __assign({\r\n            tag: 'div',\r\n            classes: [\r\n              'tox',\r\n              'tox-silver-sink',\r\n              'tox-tinymce-aux'\r\n            ].concat(platformClasses).concat(deviceClasses)\r\n          }, dirAttributes),\r\n          behaviours: derive$1([Positioning.config({\r\n              useFixed: function () {\r\n                return isHeaderDocked();\r\n              }\r\n            })])\r\n        };\r\n        var reactiveWidthSpec = {\r\n          dom: { styles: { width: document.body.clientWidth + 'px' } },\r\n          events: derive$2([run$1(windowResize(), resizeUiMothership)])\r\n        };\r\n        return deepMerge(sinkSpec, isGridUiContainer ? reactiveWidthSpec : {});\r\n      };\r\n      var sink = build$1(makeSinkDefinition());\r\n      var lazySink = function () {\r\n        return Result.value(sink);\r\n      };\r\n      var memAnchorBar = record({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-anchorbar']\r\n        }\r\n      });\r\n      var lazyAnchorBar = function () {\r\n        return lazyOuterContainer.bind(function (container) {\r\n          return memAnchorBar.getOpt(container);\r\n        }).getOrDie('Could not find a anchor bar element');\r\n      };\r\n      var lazyToolbar = function () {\r\n        return lazyOuterContainer.bind(function (container) {\r\n          return OuterContainer.getToolbar(container);\r\n        }).getOrDie('Could not find more toolbar element');\r\n      };\r\n      var lazyThrobber = function () {\r\n        return lazyOuterContainer.bind(function (container) {\r\n          return OuterContainer.getThrobber(container);\r\n        }).getOrDie('Could not find throbber element');\r\n      };\r\n      var backstage = init$7(sink, editor, lazyAnchorBar);\r\n      var partMenubar = OuterContainer.parts.menubar({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-menubar']\r\n        },\r\n        backstage: backstage,\r\n        onEscape: function () {\r\n          editor.focus();\r\n        }\r\n      });\r\n      var toolbarMode = getToolbarMode(editor);\r\n      var partToolbar = OuterContainer.parts.toolbar(__assign({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-toolbar']\r\n        },\r\n        getSink: lazySink,\r\n        providers: backstage.shared.providers,\r\n        onEscape: function () {\r\n          editor.focus();\r\n        },\r\n        type: toolbarMode,\r\n        lazyToolbar: lazyToolbar,\r\n        lazyHeader: function () {\r\n          return lazyHeader().getOrDie('Could not find header element');\r\n        }\r\n      }, verticalDirAttributes));\r\n      var partMultipleToolbar = OuterContainer.parts['multiple-toolbar']({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-toolbar-overlord']\r\n        },\r\n        providers: backstage.shared.providers,\r\n        onEscape: function () {\r\n          editor.focus();\r\n        },\r\n        type: toolbarMode\r\n      });\r\n      var partSocket = OuterContainer.parts.socket({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-edit-area']\r\n        }\r\n      });\r\n      var partSidebar = OuterContainer.parts.sidebar({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-sidebar']\r\n        }\r\n      });\r\n      var partThrobber = OuterContainer.parts.throbber({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-throbber']\r\n        },\r\n        backstage: backstage\r\n      });\r\n      var sb = editor.getParam('statusbar', true, 'boolean');\r\n      var statusbar = sb && !isInline ? Optional.some(renderStatusbar(editor, backstage.shared.providers)) : Optional.none();\r\n      var socketSidebarContainer = {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-sidebar-wrap']\r\n        },\r\n        components: [\r\n          partSocket,\r\n          partSidebar\r\n        ]\r\n      };\r\n      var hasMultipleToolbar = isMultipleToolbars(editor);\r\n      var hasToolbar = isToolbarEnabled(editor);\r\n      var hasMenubar = isMenubarEnabled(editor);\r\n      var getPartToolbar = function () {\r\n        if (hasMultipleToolbar) {\r\n          return [partMultipleToolbar];\r\n        } else if (hasToolbar) {\r\n          return [partToolbar];\r\n        } else {\r\n          return [];\r\n        }\r\n      };\r\n      var partHeader = OuterContainer.parts.header({\r\n        dom: __assign({\r\n          tag: 'div',\r\n          classes: ['tox-editor-header']\r\n        }, verticalDirAttributes),\r\n        components: flatten([\r\n          hasMenubar ? [partMenubar] : [],\r\n          getPartToolbar(),\r\n          useFixedContainer(editor) ? [] : [memAnchorBar.asSpec()]\r\n        ]),\r\n        sticky: isStickyToolbar(editor),\r\n        editor: editor,\r\n        sharedBackstage: backstage.shared\r\n      });\r\n      var editorComponents = flatten([\r\n        isToolbarBottom ? [] : [partHeader],\r\n        isInline ? [] : [socketSidebarContainer],\r\n        isToolbarBottom ? [partHeader] : []\r\n      ]);\r\n      var editorContainer = {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-editor-container']\r\n        },\r\n        components: editorComponents\r\n      };\r\n      var containerComponents = flatten([\r\n        [editorContainer],\r\n        isInline ? [] : statusbar.toArray(),\r\n        [partThrobber]\r\n      ]);\r\n      var isHidden = isDistractionFree(editor);\r\n      var attributes = __assign(__assign({ role: 'application' }, global$e.isRtl() ? { dir: 'rtl' } : {}), isHidden ? { 'aria-hidden': 'true' } : {});\r\n      var outerContainer = build$1(OuterContainer.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [\r\n            'tox',\r\n            'tox-tinymce'\r\n          ].concat(isInline ? ['tox-tinymce-inline'] : []).concat(isToolbarBottom ? ['tox-tinymce--toolbar-bottom'] : []).concat(deviceClasses).concat(platformClasses),\r\n          styles: __assign({ visibility: 'hidden' }, isHidden ? {\r\n            opacity: '0',\r\n            border: '0'\r\n          } : {}),\r\n          attributes: attributes\r\n        },\r\n        components: containerComponents,\r\n        behaviours: derive$1([\r\n          receivingConfig(),\r\n          Disabling.config({ disableClass: 'tox-tinymce--disabled' }),\r\n          Keying.config({\r\n            mode: 'cyclic',\r\n            selector: '.tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle'\r\n          })\r\n        ])\r\n      }));\r\n      lazyOuterContainer = Optional.some(outerContainer);\r\n      editor.shortcuts.add('alt+F9', 'focus menubar', function () {\r\n        OuterContainer.focusMenubar(outerContainer);\r\n      });\r\n      editor.shortcuts.add('alt+F10', 'focus toolbar', function () {\r\n        OuterContainer.focusToolbar(outerContainer);\r\n      });\r\n      editor.addCommand('ToggleToolbarDrawer', function () {\r\n        OuterContainer.toggleToolbarDrawer(outerContainer);\r\n      });\r\n      editor.addQueryStateHandler('ToggleToolbarDrawer', function () {\r\n        return OuterContainer.isToolbarDrawerToggled(outerContainer);\r\n      });\r\n      var mothership = takeover(outerContainer);\r\n      var uiMothership = takeover(sink);\r\n      setup$b(editor, mothership, uiMothership);\r\n      var getUi = function () {\r\n        var channels = {\r\n          broadcastAll: uiMothership.broadcast,\r\n          broadcastOn: uiMothership.broadcastOn,\r\n          register: noop\r\n        };\r\n        return { channels: channels };\r\n      };\r\n      var setEditorSize = function () {\r\n        var parsedHeight = numToPx(getHeightWithFallback(editor));\r\n        var parsedWidth = numToPx(getWidthWithFallback(editor));\r\n        if (!editor.inline) {\r\n          if (isValidValue('div', 'width', parsedWidth)) {\r\n            set$7(outerContainer.element, 'width', parsedWidth);\r\n          }\r\n          if (isValidValue('div', 'height', parsedHeight)) {\r\n            set$7(outerContainer.element, 'height', parsedHeight);\r\n          } else {\r\n            set$7(outerContainer.element, 'height', '200px');\r\n          }\r\n        }\r\n        return parsedHeight;\r\n      };\r\n      var renderUI = function () {\r\n        header.setup(editor, backstage.shared, lazyHeader);\r\n        setup$6(editor, backstage);\r\n        setup$5(editor, lazySink, backstage);\r\n        setup$8(editor);\r\n        setup$7(editor, lazyThrobber, backstage.shared);\r\n        map$1(getToolbarGroups(editor), function (toolbarGroupButtonConfig, name) {\r\n          editor.ui.registry.addGroupToolbarButton(name, toolbarGroupButtonConfig);\r\n        });\r\n        var _a = editor.ui.registry.getAll(), buttons = _a.buttons, menuItems = _a.menuItems, contextToolbars = _a.contextToolbars, sidebars = _a.sidebars;\r\n        var toolbarOpt = getMultipleToolbarsSetting(editor);\r\n        var rawUiConfig = {\r\n          menuItems: menuItems,\r\n          menus: getMenus(editor),\r\n          menubar: getMenubar(editor),\r\n          toolbar: toolbarOpt.getOrThunk(function () {\r\n            return getToolbar(editor);\r\n          }),\r\n          allowToolbarGroups: toolbarMode === ToolbarMode.floating,\r\n          buttons: buttons,\r\n          sidebar: sidebars\r\n        };\r\n        register$7(editor, contextToolbars, sink, { backstage: backstage });\r\n        setup$4(editor, sink);\r\n        var elm = editor.getElement();\r\n        var height = setEditorSize();\r\n        var uiComponents = {\r\n          mothership: mothership,\r\n          uiMothership: uiMothership,\r\n          outerContainer: outerContainer\r\n        };\r\n        var args = {\r\n          targetNode: elm,\r\n          height: height\r\n        };\r\n        return mode.render(editor, uiComponents, rawUiConfig, backstage, args);\r\n      };\r\n      return {\r\n        mothership: mothership,\r\n        uiMothership: uiMothership,\r\n        backstage: backstage,\r\n        renderUI: renderUI,\r\n        getUi: getUi\r\n      };\r\n    };\r\n\r\n    var describedBy = function (describedElement, describeElement) {\r\n      var describeId = Optional.from(get$d(describedElement, 'id')).fold(function () {\r\n        var id = generate$6('dialog-describe');\r\n        set$8(describeElement, 'id', id);\r\n        return id;\r\n      }, identity$1);\r\n      set$8(describedElement, 'aria-describedby', describeId);\r\n    };\r\n\r\n    var labelledBy = function (labelledElement, labelElement) {\r\n      var labelId = getOpt(labelledElement, 'id').fold(function () {\r\n        var id = generate$6('dialog-label');\r\n        set$8(labelElement, 'id', id);\r\n        return id;\r\n      }, identity$1);\r\n      set$8(labelledElement, 'aria-labelledby', labelId);\r\n    };\r\n\r\n    var schema$2 = constant$1([\r\n      required$1('lazySink'),\r\n      option('dragBlockClass'),\r\n      defaultedFunction('getBounds', win),\r\n      defaulted('useTabstopAt', always),\r\n      defaulted('eventOrder', {}),\r\n      field('modalBehaviours', [Keying]),\r\n      onKeyboardHandler('onExecute'),\r\n      onStrictKeyboardHandler('onEscape')\r\n    ]);\r\n    var basic = { sketch: identity$1 };\r\n    var parts$2 = constant$1([\r\n      optional({\r\n        name: 'draghandle',\r\n        overrides: function (detail, spec) {\r\n          return {\r\n            behaviours: derive$1([Dragging.config({\r\n                mode: 'mouse',\r\n                getTarget: function (handle) {\r\n                  return ancestor(handle, '[role=\"dialog\"]').getOr(handle);\r\n                },\r\n                blockerClass: detail.dragBlockClass.getOrDie(new Error('The drag blocker class was not specified for a dialog with a drag handle: \\n' + JSON.stringify(spec, null, 2)).message),\r\n                getBounds: detail.getDragBounds\r\n              })])\r\n          };\r\n        }\r\n      }),\r\n      required({\r\n        schema: [required$1('dom')],\r\n        name: 'title'\r\n      }),\r\n      required({\r\n        factory: basic,\r\n        schema: [required$1('dom')],\r\n        name: 'close'\r\n      }),\r\n      required({\r\n        factory: basic,\r\n        schema: [required$1('dom')],\r\n        name: 'body'\r\n      }),\r\n      optional({\r\n        factory: basic,\r\n        schema: [required$1('dom')],\r\n        name: 'footer'\r\n      }),\r\n      external$1({\r\n        factory: {\r\n          sketch: function (spec, detail) {\r\n            return __assign(__assign({}, spec), {\r\n              dom: detail.dom,\r\n              components: detail.components\r\n            });\r\n          }\r\n        },\r\n        schema: [\r\n          defaulted('dom', {\r\n            tag: 'div',\r\n            styles: {\r\n              position: 'fixed',\r\n              left: '0px',\r\n              top: '0px',\r\n              right: '0px',\r\n              bottom: '0px'\r\n            }\r\n          }),\r\n          defaulted('components', [])\r\n        ],\r\n        name: 'blocker'\r\n      })\r\n    ]);\r\n\r\n    var factory$4 = function (detail, components, spec, externals) {\r\n      var _a;\r\n      var dialogComp = value$1();\r\n      var showDialog = function (dialog) {\r\n        dialogComp.set(dialog);\r\n        var sink = detail.lazySink(dialog).getOrDie();\r\n        var externalBlocker = externals.blocker();\r\n        var blocker = sink.getSystem().build(__assign(__assign({}, externalBlocker), {\r\n          components: externalBlocker.components.concat([premade(dialog)]),\r\n          behaviours: derive$1([\r\n            Focusing.config({}),\r\n            config('dialog-blocker-events', [runOnSource(focusin(), function () {\r\n                Keying.focusIn(dialog);\r\n              })])\r\n          ])\r\n        }));\r\n        attach(sink, blocker);\r\n        Keying.focusIn(dialog);\r\n      };\r\n      var hideDialog = function (dialog) {\r\n        dialogComp.clear();\r\n        parent(dialog.element).each(function (blockerDom) {\r\n          dialog.getSystem().getByDom(blockerDom).each(function (blocker) {\r\n            detach(blocker);\r\n          });\r\n        });\r\n      };\r\n      var getDialogBody = function (dialog) {\r\n        return getPartOrDie(dialog, detail, 'body');\r\n      };\r\n      var getDialogFooter = function (dialog) {\r\n        return getPartOrDie(dialog, detail, 'footer');\r\n      };\r\n      var setBusy = function (dialog, getBusySpec) {\r\n        Blocking.block(dialog, getBusySpec);\r\n      };\r\n      var setIdle = function (dialog) {\r\n        Blocking.unblock(dialog);\r\n      };\r\n      var modalEventsId = generate$6('modal-events');\r\n      var eventOrder = __assign(__assign({}, detail.eventOrder), (_a = {}, _a[attachedToDom()] = [modalEventsId].concat(detail.eventOrder['alloy.system.attached'] || []), _a));\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        apis: {\r\n          show: showDialog,\r\n          hide: hideDialog,\r\n          getBody: getDialogBody,\r\n          getFooter: getDialogFooter,\r\n          setIdle: setIdle,\r\n          setBusy: setBusy\r\n        },\r\n        eventOrder: eventOrder,\r\n        domModification: {\r\n          attributes: {\r\n            'role': 'dialog',\r\n            'aria-modal': 'true'\r\n          }\r\n        },\r\n        behaviours: augment(detail.modalBehaviours, [\r\n          Replacing.config({}),\r\n          Keying.config({\r\n            mode: 'cyclic',\r\n            onEnter: detail.onExecute,\r\n            onEscape: detail.onEscape,\r\n            useTabstopAt: detail.useTabstopAt\r\n          }),\r\n          Blocking.config({ getRoot: dialogComp.get }),\r\n          config(modalEventsId, [runOnAttached(function (c) {\r\n              labelledBy(c.element, getPartOrDie(c, detail, 'title').element);\r\n              describedBy(c.element, getPartOrDie(c, detail, 'body').element);\r\n            })])\r\n        ])\r\n      };\r\n    };\r\n    var ModalDialog = composite({\r\n      name: 'ModalDialog',\r\n      configFields: schema$2(),\r\n      partFields: parts$2(),\r\n      factory: factory$4,\r\n      apis: {\r\n        show: function (apis, dialog) {\r\n          apis.show(dialog);\r\n        },\r\n        hide: function (apis, dialog) {\r\n          apis.hide(dialog);\r\n        },\r\n        getBody: function (apis, dialog) {\r\n          return apis.getBody(dialog);\r\n        },\r\n        getFooter: function (apis, dialog) {\r\n          return apis.getFooter(dialog);\r\n        },\r\n        setBusy: function (apis, dialog, getBusySpec) {\r\n          apis.setBusy(dialog, getBusySpec);\r\n        },\r\n        setIdle: function (apis, dialog) {\r\n          apis.setIdle(dialog);\r\n        }\r\n      }\r\n    });\r\n\r\n    var dialogToggleMenuItemSchema = objOf([\r\n      requiredString('type'),\r\n      requiredString('name')\r\n    ].concat(commonMenuItemFields));\r\n    var dialogToggleMenuItemDataProcessor = boolean;\r\n\r\n    var baseFooterButtonFields = [\r\n      field$1('name', 'name', defaultedThunk(function () {\r\n        return generate$6('button-name');\r\n      }), string),\r\n      optionString('icon'),\r\n      defaultedStringEnum('align', 'end', [\r\n        'start',\r\n        'end'\r\n      ]),\r\n      defaultedBoolean('primary', false),\r\n      defaultedBoolean('disabled', false)\r\n    ];\r\n    var dialogFooterButtonFields = __spreadArray(__spreadArray([], baseFooterButtonFields, true), [requiredString('text')], false);\r\n    var normalFooterButtonFields = __spreadArray([requiredStringEnum('type', [\r\n        'submit',\r\n        'cancel',\r\n        'custom'\r\n      ])], dialogFooterButtonFields, true);\r\n    var menuFooterButtonFields = __spreadArray([\r\n      requiredStringEnum('type', ['menu']),\r\n      optionString('text'),\r\n      optionString('tooltip'),\r\n      optionString('icon'),\r\n      requiredArrayOf('items', dialogToggleMenuItemSchema)\r\n    ], baseFooterButtonFields, true);\r\n    var dialogFooterButtonSchema = choose$1('type', {\r\n      submit: normalFooterButtonFields,\r\n      cancel: normalFooterButtonFields,\r\n      custom: normalFooterButtonFields,\r\n      menu: menuFooterButtonFields\r\n    });\r\n\r\n    var alertBannerFields = [\r\n      requiredString('type'),\r\n      requiredString('text'),\r\n      requiredStringEnum('level', [\r\n        'info',\r\n        'warn',\r\n        'error',\r\n        'success'\r\n      ]),\r\n      requiredString('icon'),\r\n      defaulted('url', '')\r\n    ];\r\n    var alertBannerSchema = objOf(alertBannerFields);\r\n\r\n    var createBarFields = function (itemsField) {\r\n      return [\r\n        requiredString('type'),\r\n        itemsField\r\n      ];\r\n    };\r\n\r\n    var buttonFields = [\r\n      requiredString('type'),\r\n      requiredString('text'),\r\n      defaultedBoolean('disabled', false),\r\n      defaultedBoolean('primary', false),\r\n      field$1('name', 'name', defaultedThunk(function () {\r\n        return generate$6('button-name');\r\n      }), string),\r\n      optionString('icon'),\r\n      defaultedBoolean('borderless', false)\r\n    ];\r\n    var buttonSchema = objOf(buttonFields);\r\n\r\n    var checkboxFields = [\r\n      requiredString('type'),\r\n      requiredString('name'),\r\n      requiredString('label'),\r\n      defaultedBoolean('disabled', false)\r\n    ];\r\n    var checkboxSchema = objOf(checkboxFields);\r\n    var checkboxDataProcessor = boolean;\r\n\r\n    var formComponentFields = [\r\n      requiredString('type'),\r\n      requiredString('name')\r\n    ];\r\n    var formComponentWithLabelFields = formComponentFields.concat([optionString('label')]);\r\n\r\n    var collectionFields = formComponentWithLabelFields.concat([defaulted('columns', 'auto')]);\r\n    var collectionSchema = objOf(collectionFields);\r\n    var collectionDataProcessor = arrOfObj([\r\n      requiredString('value'),\r\n      requiredString('text'),\r\n      requiredString('icon')\r\n    ]);\r\n\r\n    var colorInputFields = formComponentWithLabelFields;\r\n    var colorInputSchema = objOf(colorInputFields);\r\n    var colorInputDataProcessor = string;\r\n\r\n    var colorPickerFields = formComponentWithLabelFields;\r\n    var colorPickerSchema = objOf(colorPickerFields);\r\n    var colorPickerDataProcessor = string;\r\n\r\n    var customEditorFields = formComponentFields.concat([\r\n      defaultedString('tag', 'textarea'),\r\n      requiredString('scriptId'),\r\n      requiredString('scriptUrl'),\r\n      defaultedPostMsg('settings', undefined)\r\n    ]);\r\n    var customEditorFieldsOld = formComponentFields.concat([\r\n      defaultedString('tag', 'textarea'),\r\n      requiredFunction('init')\r\n    ]);\r\n    var customEditorSchema = valueOf(function (v) {\r\n      return asRaw('customeditor.old', objOfOnly(customEditorFieldsOld), v).orThunk(function () {\r\n        return asRaw('customeditor.new', objOfOnly(customEditorFields), v);\r\n      });\r\n    });\r\n    var customEditorDataProcessor = string;\r\n\r\n    var dropZoneFields = formComponentWithLabelFields;\r\n    var dropZoneSchema = objOf(dropZoneFields);\r\n    var dropZoneDataProcessor = arrOfVal();\r\n\r\n    var createGridFields = function (itemsField) {\r\n      return [\r\n        requiredString('type'),\r\n        requiredNumber('columns'),\r\n        itemsField\r\n      ];\r\n    };\r\n\r\n    var htmlPanelFields = [\r\n      requiredString('type'),\r\n      requiredString('html'),\r\n      defaultedStringEnum('presets', 'presentation', [\r\n        'presentation',\r\n        'document'\r\n      ])\r\n    ];\r\n    var htmlPanelSchema = objOf(htmlPanelFields);\r\n\r\n    var iframeFields = formComponentWithLabelFields.concat([defaultedBoolean('sandboxed', true)]);\r\n    var iframeSchema = objOf(iframeFields);\r\n    var iframeDataProcessor = string;\r\n\r\n    var imageToolsFields = formComponentWithLabelFields.concat([requiredOf('currentState', objOf([\r\n        required$1('blob'),\r\n        requiredString('url')\r\n      ]))]);\r\n    var imageToolsSchema = objOf(imageToolsFields);\r\n\r\n    var inputFields = formComponentWithLabelFields.concat([\r\n      optionString('inputMode'),\r\n      optionString('placeholder'),\r\n      defaultedBoolean('maximized', false),\r\n      defaultedBoolean('disabled', false)\r\n    ]);\r\n    var inputSchema = objOf(inputFields);\r\n    var inputDataProcessor = string;\r\n\r\n    var createLabelFields = function (itemsField) {\r\n      return [\r\n        requiredString('type'),\r\n        requiredString('label'),\r\n        itemsField\r\n      ];\r\n    };\r\n\r\n    var listBoxSingleItemFields = [\r\n      requiredString('text'),\r\n      requiredString('value')\r\n    ];\r\n    var listBoxNestedItemFields = [\r\n      requiredString('text'),\r\n      requiredArrayOf('items', thunkOf('items', function () {\r\n        return listBoxItemSchema;\r\n      }))\r\n    ];\r\n    var listBoxItemSchema = oneOf([\r\n      objOf(listBoxSingleItemFields),\r\n      objOf(listBoxNestedItemFields)\r\n    ]);\r\n    var listBoxFields = formComponentWithLabelFields.concat([\r\n      requiredArrayOf('items', listBoxItemSchema),\r\n      defaultedBoolean('disabled', false)\r\n    ]);\r\n    var listBoxSchema = objOf(listBoxFields);\r\n    var listBoxDataProcessor = string;\r\n\r\n    var selectBoxFields = formComponentWithLabelFields.concat([\r\n      requiredArrayOfObj('items', [\r\n        requiredString('text'),\r\n        requiredString('value')\r\n      ]),\r\n      defaultedNumber('size', 1),\r\n      defaultedBoolean('disabled', false)\r\n    ]);\r\n    var selectBoxSchema = objOf(selectBoxFields);\r\n    var selectBoxDataProcessor = string;\r\n\r\n    var sizeInputFields = formComponentWithLabelFields.concat([\r\n      defaultedBoolean('constrain', true),\r\n      defaultedBoolean('disabled', false)\r\n    ]);\r\n    var sizeInputSchema = objOf(sizeInputFields);\r\n    var sizeInputDataProcessor = objOf([\r\n      requiredString('width'),\r\n      requiredString('height')\r\n    ]);\r\n\r\n    var tableFields = [\r\n      requiredString('type'),\r\n      requiredArrayOf('header', string),\r\n      requiredArrayOf('cells', arrOf(string))\r\n    ];\r\n    var tableSchema = objOf(tableFields);\r\n\r\n    var textAreaFields = formComponentWithLabelFields.concat([\r\n      optionString('placeholder'),\r\n      defaultedBoolean('maximized', false),\r\n      defaultedBoolean('disabled', false)\r\n    ]);\r\n    var textAreaSchema = objOf(textAreaFields);\r\n    var textAreaDataProcessor = string;\r\n\r\n    var urlInputFields = formComponentWithLabelFields.concat([\r\n      defaultedStringEnum('filetype', 'file', [\r\n        'image',\r\n        'media',\r\n        'file'\r\n      ]),\r\n      defaulted('disabled', false)\r\n    ]);\r\n    var urlInputSchema = objOf(urlInputFields);\r\n    var urlInputDataProcessor = objOf([\r\n      requiredString('value'),\r\n      defaulted('meta', {})\r\n    ]);\r\n\r\n    var createItemsField = function (name) {\r\n      return field$1('items', 'items', required$2(), arrOf(valueOf(function (v) {\r\n        return asRaw('Checking item of ' + name, itemSchema, v).fold(function (sErr) {\r\n          return Result.error(formatError(sErr));\r\n        }, function (passValue) {\r\n          return Result.value(passValue);\r\n        });\r\n      })));\r\n    };\r\n    var itemSchema = valueThunk(function () {\r\n      return choose$2('type', {\r\n        alertbanner: alertBannerSchema,\r\n        bar: objOf(createBarFields(createItemsField('bar'))),\r\n        button: buttonSchema,\r\n        checkbox: checkboxSchema,\r\n        colorinput: colorInputSchema,\r\n        colorpicker: colorPickerSchema,\r\n        dropzone: dropZoneSchema,\r\n        grid: objOf(createGridFields(createItemsField('grid'))),\r\n        iframe: iframeSchema,\r\n        input: inputSchema,\r\n        listbox: listBoxSchema,\r\n        selectbox: selectBoxSchema,\r\n        sizeinput: sizeInputSchema,\r\n        textarea: textAreaSchema,\r\n        urlinput: urlInputSchema,\r\n        customeditor: customEditorSchema,\r\n        htmlpanel: htmlPanelSchema,\r\n        imagetools: imageToolsSchema,\r\n        collection: collectionSchema,\r\n        label: objOf(createLabelFields(createItemsField('label'))),\r\n        table: tableSchema,\r\n        panel: panelSchema\r\n      });\r\n    });\r\n    var panelFields = [\r\n      requiredString('type'),\r\n      defaulted('classes', []),\r\n      requiredArrayOf('items', itemSchema)\r\n    ];\r\n    var panelSchema = objOf(panelFields);\r\n\r\n    var tabFields = [\r\n      field$1('name', 'name', defaultedThunk(function () {\r\n        return generate$6('tab-name');\r\n      }), string),\r\n      requiredString('title'),\r\n      requiredArrayOf('items', itemSchema)\r\n    ];\r\n    var tabPanelFields = [\r\n      requiredString('type'),\r\n      requiredArrayOfObj('tabs', tabFields)\r\n    ];\r\n    var tabPanelSchema = objOf(tabPanelFields);\r\n\r\n    var dialogButtonFields = dialogFooterButtonFields;\r\n    var dialogButtonSchema = dialogFooterButtonSchema;\r\n    var dialogSchema = objOf([\r\n      requiredString('title'),\r\n      requiredOf('body', choose$2('type', {\r\n        panel: panelSchema,\r\n        tabpanel: tabPanelSchema\r\n      })),\r\n      defaultedString('size', 'normal'),\r\n      requiredArrayOf('buttons', dialogButtonSchema),\r\n      defaulted('initialData', {}),\r\n      defaultedFunction('onAction', noop),\r\n      defaultedFunction('onChange', noop),\r\n      defaultedFunction('onSubmit', noop),\r\n      defaultedFunction('onClose', noop),\r\n      defaultedFunction('onCancel', noop),\r\n      defaulted('onTabChange', noop)\r\n    ]);\r\n    var createDialog = function (spec) {\r\n      return asRaw('dialog', dialogSchema, spec);\r\n    };\r\n\r\n    var urlDialogButtonSchema = objOf(__spreadArray([requiredStringEnum('type', [\r\n        'cancel',\r\n        'custom'\r\n      ])], dialogButtonFields, true));\r\n    var urlDialogSchema = objOf([\r\n      requiredString('title'),\r\n      requiredString('url'),\r\n      optionNumber('height'),\r\n      optionNumber('width'),\r\n      optionArrayOf('buttons', urlDialogButtonSchema),\r\n      defaultedFunction('onAction', noop),\r\n      defaultedFunction('onCancel', noop),\r\n      defaultedFunction('onClose', noop),\r\n      defaultedFunction('onMessage', noop)\r\n    ]);\r\n    var createUrlDialog = function (spec) {\r\n      return asRaw('dialog', urlDialogSchema, spec);\r\n    };\r\n\r\n    var getAllObjects = function (obj) {\r\n      if (isObject(obj)) {\r\n        return [obj].concat(bind$3(values(obj), getAllObjects));\r\n      } else if (isArray(obj)) {\r\n        return bind$3(obj, getAllObjects);\r\n      } else {\r\n        return [];\r\n      }\r\n    };\r\n\r\n    var isNamedItem = function (obj) {\r\n      return isString(obj.type) && isString(obj.name);\r\n    };\r\n    var dataProcessors = {\r\n      checkbox: checkboxDataProcessor,\r\n      colorinput: colorInputDataProcessor,\r\n      colorpicker: colorPickerDataProcessor,\r\n      dropzone: dropZoneDataProcessor,\r\n      input: inputDataProcessor,\r\n      iframe: iframeDataProcessor,\r\n      sizeinput: sizeInputDataProcessor,\r\n      selectbox: selectBoxDataProcessor,\r\n      listbox: listBoxDataProcessor,\r\n      size: sizeInputDataProcessor,\r\n      textarea: textAreaDataProcessor,\r\n      urlinput: urlInputDataProcessor,\r\n      customeditor: customEditorDataProcessor,\r\n      collection: collectionDataProcessor,\r\n      togglemenuitem: dialogToggleMenuItemDataProcessor\r\n    };\r\n    var getDataProcessor = function (item) {\r\n      return Optional.from(dataProcessors[item.type]);\r\n    };\r\n    var getNamedItems = function (structure) {\r\n      return filter$2(getAllObjects(structure), isNamedItem);\r\n    };\r\n\r\n    var createDataValidator = function (structure) {\r\n      var namedItems = getNamedItems(structure);\r\n      var fields = bind$3(namedItems, function (item) {\r\n        return getDataProcessor(item).fold(function () {\r\n          return [];\r\n        }, function (schema) {\r\n          return [requiredOf(item.name, schema)];\r\n        });\r\n      });\r\n      return objOf(fields);\r\n    };\r\n\r\n    var extract = function (structure) {\r\n      var internalDialog = getOrDie(createDialog(structure));\r\n      var dataValidator = createDataValidator(structure);\r\n      var initialData = structure.initialData;\r\n      return {\r\n        internalDialog: internalDialog,\r\n        dataValidator: dataValidator,\r\n        initialData: initialData\r\n      };\r\n    };\r\n    var DialogManager = {\r\n      open: function (factory, structure) {\r\n        var extraction = extract(structure);\r\n        return factory(extraction.internalDialog, extraction.initialData, extraction.dataValidator);\r\n      },\r\n      openUrl: function (factory, structure) {\r\n        var internalDialog = getOrDie(createUrlDialog(structure));\r\n        return factory(internalDialog);\r\n      },\r\n      redial: function (structure) {\r\n        return extract(structure);\r\n      }\r\n    };\r\n\r\n    var toValidValues = function (values) {\r\n      var errors = [];\r\n      var result = {};\r\n      each(values, function (value, name) {\r\n        value.fold(function () {\r\n          errors.push(name);\r\n        }, function (v) {\r\n          result[name] = v;\r\n        });\r\n      });\r\n      return errors.length > 0 ? Result.error(errors) : Result.value(result);\r\n    };\r\n\r\n    var renderBodyPanel = function (spec, backstage) {\r\n      var memForm = record(Form.sketch(function (parts) {\r\n        return {\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-form'].concat(spec.classes)\r\n          },\r\n          components: map$2(spec.items, function (item) {\r\n            return interpretInForm(parts, item, backstage);\r\n          })\r\n        };\r\n      }));\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-dialog__body']\r\n        },\r\n        components: [{\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-dialog__body-content']\r\n            },\r\n            components: [memForm.asSpec()]\r\n          }],\r\n        behaviours: derive$1([\r\n          Keying.config({\r\n            mode: 'acyclic',\r\n            useTabstopAt: not(isPseudoStop)\r\n          }),\r\n          ComposingConfigs.memento(memForm),\r\n          RepresentingConfigs.memento(memForm, {\r\n            postprocess: function (formValue) {\r\n              return toValidValues(formValue).fold(function (err) {\r\n                console.error(err);\r\n                return {};\r\n              }, identity$1);\r\n            }\r\n          })\r\n        ])\r\n      };\r\n    };\r\n\r\n    var factory$3 = function (detail, _spec) {\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: detail.components,\r\n        events: events$a(detail.action),\r\n        behaviours: augment(detail.tabButtonBehaviours, [\r\n          Focusing.config({}),\r\n          Keying.config({\r\n            mode: 'execution',\r\n            useSpace: true,\r\n            useEnter: true\r\n          }),\r\n          Representing.config({\r\n            store: {\r\n              mode: 'memory',\r\n              initialValue: detail.value\r\n            }\r\n          })\r\n        ]),\r\n        domModification: detail.domModification\r\n      };\r\n    };\r\n    var TabButton = single({\r\n      name: 'TabButton',\r\n      configFields: [\r\n        defaulted('uid', undefined),\r\n        required$1('value'),\r\n        field$1('dom', 'dom', mergeWithThunk(function () {\r\n          return {\r\n            attributes: {\r\n              'role': 'tab',\r\n              'id': generate$6('aria'),\r\n              'aria-selected': 'false'\r\n            }\r\n          };\r\n        }), anyValue()),\r\n        option('action'),\r\n        defaulted('domModification', {}),\r\n        field('tabButtonBehaviours', [\r\n          Focusing,\r\n          Keying,\r\n          Representing\r\n        ]),\r\n        required$1('view')\r\n      ],\r\n      factory: factory$3\r\n    });\r\n\r\n    var schema$1 = constant$1([\r\n      required$1('tabs'),\r\n      required$1('dom'),\r\n      defaulted('clickToDismiss', false),\r\n      field('tabbarBehaviours', [\r\n        Highlighting,\r\n        Keying\r\n      ]),\r\n      markers$1([\r\n        'tabClass',\r\n        'selectedClass'\r\n      ])\r\n    ]);\r\n    var tabsPart = group({\r\n      factory: TabButton,\r\n      name: 'tabs',\r\n      unit: 'tab',\r\n      overrides: function (barDetail) {\r\n        var dismissTab$1 = function (tabbar, button) {\r\n          Highlighting.dehighlight(tabbar, button);\r\n          emitWith(tabbar, dismissTab(), {\r\n            tabbar: tabbar,\r\n            button: button\r\n          });\r\n        };\r\n        var changeTab$1 = function (tabbar, button) {\r\n          Highlighting.highlight(tabbar, button);\r\n          emitWith(tabbar, changeTab(), {\r\n            tabbar: tabbar,\r\n            button: button\r\n          });\r\n        };\r\n        return {\r\n          action: function (button) {\r\n            var tabbar = button.getSystem().getByUid(barDetail.uid).getOrDie();\r\n            var activeButton = Highlighting.isHighlighted(tabbar, button);\r\n            var response = function () {\r\n              if (activeButton && barDetail.clickToDismiss) {\r\n                return dismissTab$1;\r\n              } else if (!activeButton) {\r\n                return changeTab$1;\r\n              } else {\r\n                return noop;\r\n              }\r\n            }();\r\n            response(tabbar, button);\r\n          },\r\n          domModification: { classes: [barDetail.markers.tabClass] }\r\n        };\r\n      }\r\n    });\r\n    var parts$1 = constant$1([tabsPart]);\r\n\r\n    var factory$2 = function (detail, components, _spec, _externals) {\r\n      return {\r\n        'uid': detail.uid,\r\n        'dom': detail.dom,\r\n        components: components,\r\n        'debug.sketcher': 'Tabbar',\r\n        'domModification': { attributes: { role: 'tablist' } },\r\n        'behaviours': augment(detail.tabbarBehaviours, [\r\n          Highlighting.config({\r\n            highlightClass: detail.markers.selectedClass,\r\n            itemClass: detail.markers.tabClass,\r\n            onHighlight: function (tabbar, tab) {\r\n              set$8(tab.element, 'aria-selected', 'true');\r\n            },\r\n            onDehighlight: function (tabbar, tab) {\r\n              set$8(tab.element, 'aria-selected', 'false');\r\n            }\r\n          }),\r\n          Keying.config({\r\n            mode: 'flow',\r\n            getInitial: function (tabbar) {\r\n              return Highlighting.getHighlighted(tabbar).map(function (tab) {\r\n                return tab.element;\r\n              });\r\n            },\r\n            selector: '.' + detail.markers.tabClass,\r\n            executeOnMove: true\r\n          })\r\n        ])\r\n      };\r\n    };\r\n    var Tabbar = composite({\r\n      name: 'Tabbar',\r\n      configFields: schema$1(),\r\n      partFields: parts$1(),\r\n      factory: factory$2\r\n    });\r\n\r\n    var factory$1 = function (detail, _spec) {\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        behaviours: augment(detail.tabviewBehaviours, [Replacing.config({})]),\r\n        domModification: { attributes: { role: 'tabpanel' } }\r\n      };\r\n    };\r\n    var Tabview = single({\r\n      name: 'Tabview',\r\n      configFields: [field('tabviewBehaviours', [Replacing])],\r\n      factory: factory$1\r\n    });\r\n\r\n    var schema = constant$1([\r\n      defaulted('selectFirst', true),\r\n      onHandler('onChangeTab'),\r\n      onHandler('onDismissTab'),\r\n      defaulted('tabs', []),\r\n      field('tabSectionBehaviours', [])\r\n    ]);\r\n    var barPart = required({\r\n      factory: Tabbar,\r\n      schema: [\r\n        required$1('dom'),\r\n        requiredObjOf('markers', [\r\n          required$1('tabClass'),\r\n          required$1('selectedClass')\r\n        ])\r\n      ],\r\n      name: 'tabbar',\r\n      defaults: function (detail) {\r\n        return { tabs: detail.tabs };\r\n      }\r\n    });\r\n    var viewPart = required({\r\n      factory: Tabview,\r\n      name: 'tabview'\r\n    });\r\n    var parts = constant$1([\r\n      barPart,\r\n      viewPart\r\n    ]);\r\n\r\n    var factory = function (detail, components, _spec, _externals) {\r\n      var changeTab$1 = function (button) {\r\n        var tabValue = Representing.getValue(button);\r\n        getPart(button, detail, 'tabview').each(function (tabview) {\r\n          var tabWithValue = find$5(detail.tabs, function (t) {\r\n            return t.value === tabValue;\r\n          });\r\n          tabWithValue.each(function (tabData) {\r\n            var panel = tabData.view();\r\n            getOpt(button.element, 'id').each(function (id) {\r\n              set$8(tabview.element, 'aria-labelledby', id);\r\n            });\r\n            Replacing.set(tabview, panel);\r\n            detail.onChangeTab(tabview, button, panel);\r\n          });\r\n        });\r\n      };\r\n      var changeTabBy = function (section, byPred) {\r\n        getPart(section, detail, 'tabbar').each(function (tabbar) {\r\n          byPred(tabbar).each(emitExecute);\r\n        });\r\n      };\r\n      return {\r\n        uid: detail.uid,\r\n        dom: detail.dom,\r\n        components: components,\r\n        behaviours: get$2(detail.tabSectionBehaviours),\r\n        events: derive$2(flatten([\r\n          detail.selectFirst ? [runOnAttached(function (section, _simulatedEvent) {\r\n              changeTabBy(section, Highlighting.getFirst);\r\n            })] : [],\r\n          [\r\n            run$1(changeTab(), function (section, simulatedEvent) {\r\n              var button = simulatedEvent.event.button;\r\n              changeTab$1(button);\r\n            }),\r\n            run$1(dismissTab(), function (section, simulatedEvent) {\r\n              var button = simulatedEvent.event.button;\r\n              detail.onDismissTab(section, button);\r\n            })\r\n          ]\r\n        ])),\r\n        apis: {\r\n          getViewItems: function (section) {\r\n            return getPart(section, detail, 'tabview').map(function (tabview) {\r\n              return Replacing.contents(tabview);\r\n            }).getOr([]);\r\n          },\r\n          showTab: function (section, tabKey) {\r\n            var getTabIfNotActive = function (tabbar) {\r\n              var candidates = Highlighting.getCandidates(tabbar);\r\n              var optTab = find$5(candidates, function (c) {\r\n                return Representing.getValue(c) === tabKey;\r\n              });\r\n              return optTab.filter(function (tab) {\r\n                return !Highlighting.isHighlighted(tabbar, tab);\r\n              });\r\n            };\r\n            changeTabBy(section, getTabIfNotActive);\r\n          }\r\n        }\r\n      };\r\n    };\r\n    var TabSection = composite({\r\n      name: 'TabSection',\r\n      configFields: schema(),\r\n      partFields: parts(),\r\n      factory: factory,\r\n      apis: {\r\n        getViewItems: function (apis, component) {\r\n          return apis.getViewItems(component);\r\n        },\r\n        showTab: function (apis, component, tabKey) {\r\n          apis.showTab(component, tabKey);\r\n        }\r\n      }\r\n    });\r\n\r\n    var measureHeights = function (allTabs, tabview, tabviewComp) {\r\n      return map$2(allTabs, function (_tab, i) {\r\n        Replacing.set(tabviewComp, allTabs[i].view());\r\n        var rect = tabview.dom.getBoundingClientRect();\r\n        Replacing.set(tabviewComp, []);\r\n        return rect.height;\r\n      });\r\n    };\r\n    var getMaxHeight = function (heights) {\r\n      return head(sort(heights, function (a, b) {\r\n        if (a > b) {\r\n          return -1;\r\n        } else if (a < b) {\r\n          return +1;\r\n        } else {\r\n          return 0;\r\n        }\r\n      }));\r\n    };\r\n    var getMaxTabviewHeight = function (dialog, tabview, tablist) {\r\n      var documentElement$1 = documentElement(dialog).dom;\r\n      var rootElm = ancestor(dialog, '.tox-dialog-wrap').getOr(dialog);\r\n      var isFixed = get$c(rootElm, 'position') === 'fixed';\r\n      var maxHeight;\r\n      if (isFixed) {\r\n        maxHeight = Math.max(documentElement$1.clientHeight, window.innerHeight);\r\n      } else {\r\n        maxHeight = Math.max(documentElement$1.offsetHeight, documentElement$1.scrollHeight);\r\n      }\r\n      var tabviewHeight = get$b(tabview);\r\n      var isTabListBeside = tabview.dom.offsetLeft >= tablist.dom.offsetLeft + get$a(tablist);\r\n      var currentTabHeight = isTabListBeside ? Math.max(get$b(tablist), tabviewHeight) : tabviewHeight;\r\n      var dialogTopMargin = parseInt(get$c(dialog, 'margin-top'), 10) || 0;\r\n      var dialogBottomMargin = parseInt(get$c(dialog, 'margin-bottom'), 10) || 0;\r\n      var dialogHeight = get$b(dialog) + dialogTopMargin + dialogBottomMargin;\r\n      var chromeHeight = dialogHeight - currentTabHeight;\r\n      return maxHeight - chromeHeight;\r\n    };\r\n    var showTab = function (allTabs, comp) {\r\n      head(allTabs).each(function (tab) {\r\n        return TabSection.showTab(comp, tab.value);\r\n      });\r\n    };\r\n    var setTabviewHeight = function (tabview, height) {\r\n      set$7(tabview, 'height', height + 'px');\r\n      if (!detect$1().browser.isIE()) {\r\n        set$7(tabview, 'flex-basis', height + 'px');\r\n      } else {\r\n        remove$6(tabview, 'flex-basis');\r\n      }\r\n    };\r\n    var updateTabviewHeight = function (dialogBody, tabview, maxTabHeight) {\r\n      ancestor(dialogBody, '[role=\"dialog\"]').each(function (dialog) {\r\n        descendant(dialog, '[role=\"tablist\"]').each(function (tablist) {\r\n          maxTabHeight.get().map(function (height) {\r\n            set$7(tabview, 'height', '0');\r\n            set$7(tabview, 'flex-basis', '0');\r\n            return Math.min(height, getMaxTabviewHeight(dialog, tabview, tablist));\r\n          }).each(function (height) {\r\n            setTabviewHeight(tabview, height);\r\n          });\r\n        });\r\n      });\r\n    };\r\n    var getTabview = function (dialog) {\r\n      return descendant(dialog, '[role=\"tabpanel\"]');\r\n    };\r\n    var setMode = function (allTabs) {\r\n      var smartTabHeight = function () {\r\n        var maxTabHeight = value$1();\r\n        var extraEvents = [\r\n          runOnAttached(function (comp) {\r\n            var dialog = comp.element;\r\n            getTabview(dialog).each(function (tabview) {\r\n              set$7(tabview, 'visibility', 'hidden');\r\n              comp.getSystem().getByDom(tabview).toOptional().each(function (tabviewComp) {\r\n                var heights = measureHeights(allTabs, tabview, tabviewComp);\r\n                var maxTabHeightOpt = getMaxHeight(heights);\r\n                maxTabHeightOpt.fold(maxTabHeight.clear, maxTabHeight.set);\r\n              });\r\n              updateTabviewHeight(dialog, tabview, maxTabHeight);\r\n              remove$6(tabview, 'visibility');\r\n              showTab(allTabs, comp);\r\n              global$f.requestAnimationFrame(function () {\r\n                updateTabviewHeight(dialog, tabview, maxTabHeight);\r\n              });\r\n            });\r\n          }),\r\n          run$1(windowResize(), function (comp) {\r\n            var dialog = comp.element;\r\n            getTabview(dialog).each(function (tabview) {\r\n              updateTabviewHeight(dialog, tabview, maxTabHeight);\r\n            });\r\n          }),\r\n          run$1(formResizeEvent, function (comp, _se) {\r\n            var dialog = comp.element;\r\n            getTabview(dialog).each(function (tabview) {\r\n              var oldFocus = active(getRootNode(tabview));\r\n              set$7(tabview, 'visibility', 'hidden');\r\n              var oldHeight = getRaw(tabview, 'height').map(function (h) {\r\n                return parseInt(h, 10);\r\n              });\r\n              remove$6(tabview, 'height');\r\n              remove$6(tabview, 'flex-basis');\r\n              var newHeight = tabview.dom.getBoundingClientRect().height;\r\n              var hasGrown = oldHeight.forall(function (h) {\r\n                return newHeight > h;\r\n              });\r\n              if (hasGrown) {\r\n                maxTabHeight.set(newHeight);\r\n                updateTabviewHeight(dialog, tabview, maxTabHeight);\r\n              } else {\r\n                oldHeight.each(function (h) {\r\n                  setTabviewHeight(tabview, h);\r\n                });\r\n              }\r\n              remove$6(tabview, 'visibility');\r\n              oldFocus.each(focus$3);\r\n            });\r\n          })\r\n        ];\r\n        var selectFirst = false;\r\n        return {\r\n          extraEvents: extraEvents,\r\n          selectFirst: selectFirst\r\n        };\r\n      }();\r\n      var naiveTabHeight = function () {\r\n        var extraEvents = [];\r\n        var selectFirst = true;\r\n        return {\r\n          extraEvents: extraEvents,\r\n          selectFirst: selectFirst\r\n        };\r\n      }();\r\n      return {\r\n        smartTabHeight: smartTabHeight,\r\n        naiveTabHeight: naiveTabHeight\r\n      };\r\n    };\r\n\r\n    var SendDataToSectionChannel = 'send-data-to-section';\r\n    var SendDataToViewChannel = 'send-data-to-view';\r\n    var renderTabPanel = function (spec, backstage) {\r\n      var storedValue = Cell({});\r\n      var updateDataWithForm = function (form) {\r\n        var formData = Representing.getValue(form);\r\n        var validData = toValidValues(formData).getOr({});\r\n        var currentData = storedValue.get();\r\n        var newData = deepMerge(currentData, validData);\r\n        storedValue.set(newData);\r\n      };\r\n      var setDataOnForm = function (form) {\r\n        var tabData = storedValue.get();\r\n        Representing.setValue(form, tabData);\r\n      };\r\n      var oldTab = Cell(null);\r\n      var allTabs = map$2(spec.tabs, function (tab) {\r\n        return {\r\n          value: tab.name,\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-dialog__body-nav-item'],\r\n            innerHtml: backstage.shared.providers.translate(tab.title)\r\n          },\r\n          view: function () {\r\n            return [Form.sketch(function (parts) {\r\n                return {\r\n                  dom: {\r\n                    tag: 'div',\r\n                    classes: ['tox-form']\r\n                  },\r\n                  components: map$2(tab.items, function (item) {\r\n                    return interpretInForm(parts, item, backstage);\r\n                  }),\r\n                  formBehaviours: derive$1([\r\n                    Keying.config({\r\n                      mode: 'acyclic',\r\n                      useTabstopAt: not(isPseudoStop)\r\n                    }),\r\n                    config('TabView.form.events', [\r\n                      runOnAttached(setDataOnForm),\r\n                      runOnDetached(updateDataWithForm)\r\n                    ]),\r\n                    Receiving.config({\r\n                      channels: wrapAll([\r\n                        {\r\n                          key: SendDataToSectionChannel,\r\n                          value: { onReceive: updateDataWithForm }\r\n                        },\r\n                        {\r\n                          key: SendDataToViewChannel,\r\n                          value: { onReceive: setDataOnForm }\r\n                        }\r\n                      ])\r\n                    })\r\n                  ])\r\n                };\r\n              })];\r\n          }\r\n        };\r\n      });\r\n      var tabMode = setMode(allTabs).smartTabHeight;\r\n      return TabSection.sketch({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-dialog__body']\r\n        },\r\n        onChangeTab: function (section, button, _viewItems) {\r\n          var name = Representing.getValue(button);\r\n          emitWith(section, formTabChangeEvent, {\r\n            name: name,\r\n            oldName: oldTab.get()\r\n          });\r\n          oldTab.set(name);\r\n        },\r\n        tabs: allTabs,\r\n        components: [\r\n          TabSection.parts.tabbar({\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-dialog__body-nav']\r\n            },\r\n            components: [Tabbar.parts.tabs({})],\r\n            markers: {\r\n              tabClass: 'tox-tab',\r\n              selectedClass: 'tox-dialog__body-nav-item--active'\r\n            },\r\n            tabbarBehaviours: derive$1([Tabstopping.config({})])\r\n          }),\r\n          TabSection.parts.tabview({\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-dialog__body-content']\r\n            }\r\n          })\r\n        ],\r\n        selectFirst: tabMode.selectFirst,\r\n        tabSectionBehaviours: derive$1([\r\n          config('tabpanel', tabMode.extraEvents),\r\n          Keying.config({ mode: 'acyclic' }),\r\n          Composing.config({\r\n            find: function (comp) {\r\n              return head(TabSection.getViewItems(comp));\r\n            }\r\n          }),\r\n          Representing.config({\r\n            store: {\r\n              mode: 'manual',\r\n              getValue: function (tsection) {\r\n                tsection.getSystem().broadcastOn([SendDataToSectionChannel], {});\r\n                return storedValue.get();\r\n              },\r\n              setValue: function (tsection, value) {\r\n                storedValue.set(value);\r\n                tsection.getSystem().broadcastOn([SendDataToViewChannel], {});\r\n              }\r\n            }\r\n          })\r\n        ])\r\n      });\r\n    };\r\n\r\n    var dialogChannel = generate$6('update-dialog');\r\n    var titleChannel = generate$6('update-title');\r\n    var bodyChannel = generate$6('update-body');\r\n    var footerChannel = generate$6('update-footer');\r\n    var bodySendMessageChannel = generate$6('body-send-message');\r\n\r\n    var renderBody = function (spec, id, backstage, ariaAttrs) {\r\n      var renderComponents = function (incoming) {\r\n        switch (incoming.body.type) {\r\n        case 'tabpanel': {\r\n            return [renderTabPanel(incoming.body, backstage)];\r\n          }\r\n        default: {\r\n            return [renderBodyPanel(incoming.body, backstage)];\r\n          }\r\n        }\r\n      };\r\n      var updateState = function (_comp, incoming) {\r\n        return Optional.some({\r\n          isTabPanel: function () {\r\n            return incoming.body.type === 'tabpanel';\r\n          }\r\n        });\r\n      };\r\n      var ariaAttributes = { 'aria-live': 'polite' };\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-dialog__content-js'],\r\n          attributes: __assign(__assign({}, id.map(function (x) {\r\n            return { id: x };\r\n          }).getOr({})), ariaAttrs ? ariaAttributes : {})\r\n        },\r\n        components: [],\r\n        behaviours: derive$1([\r\n          ComposingConfigs.childAt(0),\r\n          Reflecting.config({\r\n            channel: bodyChannel,\r\n            updateState: updateState,\r\n            renderComponents: renderComponents,\r\n            initialData: spec\r\n          })\r\n        ])\r\n      };\r\n    };\r\n    var renderInlineBody = function (spec, contentId, backstage, ariaAttrs) {\r\n      return renderBody(spec, Optional.some(contentId), backstage, ariaAttrs);\r\n    };\r\n    var renderModalBody = function (spec, backstage) {\r\n      var bodySpec = renderBody(spec, Optional.none(), backstage, false);\r\n      return ModalDialog.parts.body(bodySpec);\r\n    };\r\n    var renderIframeBody = function (spec) {\r\n      var bodySpec = {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-dialog__content-js']\r\n        },\r\n        components: [{\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-dialog__body-iframe']\r\n            },\r\n            components: [craft({\r\n                dom: {\r\n                  tag: 'iframe',\r\n                  attributes: { src: spec.url }\r\n                },\r\n                behaviours: derive$1([\r\n                  Tabstopping.config({}),\r\n                  Focusing.config({})\r\n                ])\r\n              })]\r\n          }],\r\n        behaviours: derive$1([Keying.config({\r\n            mode: 'acyclic',\r\n            useTabstopAt: not(isPseudoStop)\r\n          })])\r\n      };\r\n      return ModalDialog.parts.body(bodySpec);\r\n    };\r\n\r\n    var isTouch = global$9.deviceType.isTouch();\r\n    var hiddenHeader = function (title, close) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          styles: { display: 'none' },\r\n          classes: ['tox-dialog__header']\r\n        },\r\n        components: [\r\n          title,\r\n          close\r\n        ]\r\n      };\r\n    };\r\n    var pClose = function (onClose, providersBackstage) {\r\n      return ModalDialog.parts.close(Button.sketch({\r\n        dom: {\r\n          tag: 'button',\r\n          classes: [\r\n            'tox-button',\r\n            'tox-button--icon',\r\n            'tox-button--naked'\r\n          ],\r\n          attributes: {\r\n            'type': 'button',\r\n            'aria-label': providersBackstage.translate('Close')\r\n          }\r\n        },\r\n        action: onClose,\r\n        buttonBehaviours: derive$1([Tabstopping.config({})])\r\n      }));\r\n    };\r\n    var pUntitled = function () {\r\n      return ModalDialog.parts.title({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-dialog__title'],\r\n          innerHtml: '',\r\n          styles: { display: 'none' }\r\n        }\r\n      });\r\n    };\r\n    var pBodyMessage = function (message, providersBackstage) {\r\n      return ModalDialog.parts.body({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-dialog__body']\r\n        },\r\n        components: [{\r\n            dom: {\r\n              tag: 'div',\r\n              classes: ['tox-dialog__body-content']\r\n            },\r\n            components: [{ dom: fromHtml('<p>' + sanitizeHtmlString(providersBackstage.translate(message)) + '</p>') }]\r\n          }]\r\n      });\r\n    };\r\n    var pFooter = function (buttons) {\r\n      return ModalDialog.parts.footer({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-dialog__footer']\r\n        },\r\n        components: buttons\r\n      });\r\n    };\r\n    var pFooterGroup = function (startButtons, endButtons) {\r\n      return [\r\n        Container.sketch({\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-dialog__footer-start']\r\n          },\r\n          components: startButtons\r\n        }),\r\n        Container.sketch({\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-dialog__footer-end']\r\n          },\r\n          components: endButtons\r\n        })\r\n      ];\r\n    };\r\n    var renderDialog$1 = function (spec) {\r\n      var _a;\r\n      var dialogClass = 'tox-dialog';\r\n      var blockerClass = dialogClass + '-wrap';\r\n      var blockerBackdropClass = blockerClass + '__backdrop';\r\n      var scrollLockClass = dialogClass + '__disable-scroll';\r\n      return ModalDialog.sketch({\r\n        lazySink: spec.lazySink,\r\n        onEscape: function (comp) {\r\n          spec.onEscape(comp);\r\n          return Optional.some(true);\r\n        },\r\n        useTabstopAt: function (elem) {\r\n          return !isPseudoStop(elem);\r\n        },\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [dialogClass].concat(spec.extraClasses),\r\n          styles: __assign({ position: 'relative' }, spec.extraStyles)\r\n        },\r\n        components: __spreadArray([\r\n          spec.header,\r\n          spec.body\r\n        ], spec.footer.toArray(), true),\r\n        parts: {\r\n          blocker: {\r\n            dom: fromHtml('<div class=\"' + blockerClass + '\"></div>'),\r\n            components: [{\r\n                dom: {\r\n                  tag: 'div',\r\n                  classes: isTouch ? [\r\n                    blockerBackdropClass,\r\n                    blockerBackdropClass + '--opaque'\r\n                  ] : [blockerBackdropClass]\r\n                }\r\n              }]\r\n          }\r\n        },\r\n        dragBlockClass: blockerClass,\r\n        modalBehaviours: derive$1(__spreadArray([\r\n          Focusing.config({}),\r\n          config('dialog-events', spec.dialogEvents.concat([runOnSource(focusin(), function (comp, _se) {\r\n              Keying.focusIn(comp);\r\n            })])),\r\n          config('scroll-lock', [\r\n            runOnAttached(function () {\r\n              add$2(body(), scrollLockClass);\r\n            }),\r\n            runOnDetached(function () {\r\n              remove$2(body(), scrollLockClass);\r\n            })\r\n          ])\r\n        ], spec.extraBehaviours, true)),\r\n        eventOrder: __assign((_a = {}, _a[execute$5()] = ['dialog-events'], _a[attachedToDom()] = [\r\n          'scroll-lock',\r\n          'dialog-events',\r\n          'alloy.base.behaviour'\r\n        ], _a[detachedFromDom()] = [\r\n          'alloy.base.behaviour',\r\n          'dialog-events',\r\n          'scroll-lock'\r\n        ], _a), spec.eventOrder)\r\n      });\r\n    };\r\n\r\n    var renderClose = function (providersBackstage) {\r\n      return Button.sketch({\r\n        dom: {\r\n          tag: 'button',\r\n          classes: [\r\n            'tox-button',\r\n            'tox-button--icon',\r\n            'tox-button--naked'\r\n          ],\r\n          attributes: {\r\n            'type': 'button',\r\n            'aria-label': providersBackstage.translate('Close'),\r\n            'title': providersBackstage.translate('Close')\r\n          }\r\n        },\r\n        components: [render$3('close', {\r\n            tag: 'div',\r\n            classes: ['tox-icon']\r\n          }, providersBackstage.icons)],\r\n        action: function (comp) {\r\n          emit(comp, formCancelEvent);\r\n        }\r\n      });\r\n    };\r\n    var renderTitle = function (spec, id, providersBackstage) {\r\n      var renderComponents = function (data) {\r\n        return [text$1(providersBackstage.translate(data.title))];\r\n      };\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-dialog__title'],\r\n          attributes: __assign({}, id.map(function (x) {\r\n            return { id: x };\r\n          }).getOr({}))\r\n        },\r\n        components: renderComponents(spec),\r\n        behaviours: derive$1([Reflecting.config({\r\n            channel: titleChannel,\r\n            renderComponents: renderComponents\r\n          })])\r\n      };\r\n    };\r\n    var renderDragHandle = function () {\r\n      return { dom: fromHtml('<div class=\"tox-dialog__draghandle\"></div>') };\r\n    };\r\n    var renderInlineHeader = function (spec, titleId, providersBackstage) {\r\n      return Container.sketch({\r\n        dom: fromHtml('<div class=\"tox-dialog__header\"></div>'),\r\n        components: [\r\n          renderTitle(spec, Optional.some(titleId), providersBackstage),\r\n          renderDragHandle(),\r\n          renderClose(providersBackstage)\r\n        ],\r\n        containerBehaviours: derive$1([Dragging.config({\r\n            mode: 'mouse',\r\n            blockerClass: 'blocker',\r\n            getTarget: function (handle) {\r\n              return closest$1(handle, '[role=\"dialog\"]').getOrDie();\r\n            },\r\n            snaps: {\r\n              getSnapPoints: function () {\r\n                return [];\r\n              },\r\n              leftAttr: 'data-drag-left',\r\n              topAttr: 'data-drag-top'\r\n            }\r\n          })])\r\n      });\r\n    };\r\n    var renderModalHeader = function (spec, providersBackstage) {\r\n      var pTitle = ModalDialog.parts.title(renderTitle(spec, Optional.none(), providersBackstage));\r\n      var pHandle = ModalDialog.parts.draghandle(renderDragHandle());\r\n      var pClose = ModalDialog.parts.close(renderClose(providersBackstage));\r\n      var components = [pTitle].concat(spec.draggable ? [pHandle] : []).concat([pClose]);\r\n      return Container.sketch({\r\n        dom: fromHtml('<div class=\"tox-dialog__header\"></div>'),\r\n        components: components\r\n      });\r\n    };\r\n\r\n    var getHeader = function (title, backstage) {\r\n      return renderModalHeader({\r\n        title: backstage.shared.providers.translate(title),\r\n        draggable: backstage.dialog.isDraggableModal()\r\n      }, backstage.shared.providers);\r\n    };\r\n    var getBusySpec = function (message, bs, providers) {\r\n      return {\r\n        dom: {\r\n          tag: 'div',\r\n          classes: ['tox-dialog__busy-spinner'],\r\n          attributes: { 'aria-label': providers.translate(message) },\r\n          styles: {\r\n            left: '0px',\r\n            right: '0px',\r\n            bottom: '0px',\r\n            top: '0px',\r\n            position: 'absolute'\r\n          }\r\n        },\r\n        behaviours: bs,\r\n        components: [{ dom: fromHtml('<div class=\"tox-spinner\"><div></div><div></div><div></div></div>') }]\r\n      };\r\n    };\r\n    var getEventExtras = function (lazyDialog, providers, extra) {\r\n      return {\r\n        onClose: function () {\r\n          return extra.closeWindow();\r\n        },\r\n        onBlock: function (blockEvent) {\r\n          ModalDialog.setBusy(lazyDialog(), function (_comp, bs) {\r\n            return getBusySpec(blockEvent.message, bs, providers);\r\n          });\r\n        },\r\n        onUnblock: function () {\r\n          ModalDialog.setIdle(lazyDialog());\r\n        }\r\n      };\r\n    };\r\n    var renderModalDialog = function (spec, initialData, dialogEvents, backstage) {\r\n      var _a;\r\n      var updateState = function (_comp, incoming) {\r\n        return Optional.some(incoming);\r\n      };\r\n      return build$1(renderDialog$1(__assign(__assign({}, spec), {\r\n        lazySink: backstage.shared.getSink,\r\n        extraBehaviours: __spreadArray([\r\n          Reflecting.config({\r\n            channel: dialogChannel,\r\n            updateState: updateState,\r\n            initialData: initialData\r\n          }),\r\n          RepresentingConfigs.memory({})\r\n        ], spec.extraBehaviours, true),\r\n        onEscape: function (comp) {\r\n          emit(comp, formCancelEvent);\r\n        },\r\n        dialogEvents: dialogEvents,\r\n        eventOrder: (_a = {}, _a[receive()] = [\r\n          Reflecting.name(),\r\n          Receiving.name()\r\n        ], _a[attachedToDom()] = [\r\n          'scroll-lock',\r\n          Reflecting.name(),\r\n          'messages',\r\n          'dialog-events',\r\n          'alloy.base.behaviour'\r\n        ], _a[detachedFromDom()] = [\r\n          'alloy.base.behaviour',\r\n          'dialog-events',\r\n          'messages',\r\n          Reflecting.name(),\r\n          'scroll-lock'\r\n        ], _a)\r\n      })));\r\n    };\r\n    var mapMenuButtons = function (buttons) {\r\n      var mapItems = function (button) {\r\n        var items = map$2(button.items, function (item) {\r\n          var cell = Cell(false);\r\n          return __assign(__assign({}, item), { storage: cell });\r\n        });\r\n        return __assign(__assign({}, button), { items: items });\r\n      };\r\n      return map$2(buttons, function (button) {\r\n        if (button.type === 'menu') {\r\n          return mapItems(button);\r\n        }\r\n        return button;\r\n      });\r\n    };\r\n    var extractCellsToObject = function (buttons) {\r\n      return foldl(buttons, function (acc, button) {\r\n        if (button.type === 'menu') {\r\n          var menuButton = button;\r\n          return foldl(menuButton.items, function (innerAcc, item) {\r\n            innerAcc[item.name] = item.storage;\r\n            return innerAcc;\r\n          }, acc);\r\n        }\r\n        return acc;\r\n      }, {});\r\n    };\r\n\r\n    var initCommonEvents = function (fireApiEvent, extras) {\r\n      return [\r\n        runWithTarget(focusin(), onFocus),\r\n        fireApiEvent(formCloseEvent, function (_api, spec) {\r\n          extras.onClose();\r\n          spec.onClose();\r\n        }),\r\n        fireApiEvent(formCancelEvent, function (api, spec, _event, self) {\r\n          spec.onCancel(api);\r\n          emit(self, formCloseEvent);\r\n        }),\r\n        run$1(formUnblockEvent, function (_c, _se) {\r\n          return extras.onUnblock();\r\n        }),\r\n        run$1(formBlockEvent, function (_c, se) {\r\n          return extras.onBlock(se.event);\r\n        })\r\n      ];\r\n    };\r\n    var initUrlDialog = function (getInstanceApi, extras) {\r\n      var fireApiEvent = function (eventName, f) {\r\n        return run$1(eventName, function (c, se) {\r\n          withSpec(c, function (spec, _c) {\r\n            f(getInstanceApi(), spec, se.event, c);\r\n          });\r\n        });\r\n      };\r\n      var withSpec = function (c, f) {\r\n        Reflecting.getState(c).get().each(function (currentDialog) {\r\n          f(currentDialog, c);\r\n        });\r\n      };\r\n      return __spreadArray(__spreadArray([], initCommonEvents(fireApiEvent, extras), true), [fireApiEvent(formActionEvent, function (api, spec, event) {\r\n          spec.onAction(api, { name: event.name });\r\n        })], false);\r\n    };\r\n    var initDialog = function (getInstanceApi, extras, getSink) {\r\n      var fireApiEvent = function (eventName, f) {\r\n        return run$1(eventName, function (c, se) {\r\n          withSpec(c, function (spec, _c) {\r\n            f(getInstanceApi(), spec, se.event, c);\r\n          });\r\n        });\r\n      };\r\n      var withSpec = function (c, f) {\r\n        Reflecting.getState(c).get().each(function (currentDialogInit) {\r\n          f(currentDialogInit.internalDialog, c);\r\n        });\r\n      };\r\n      return __spreadArray(__spreadArray([], initCommonEvents(fireApiEvent, extras), true), [\r\n        fireApiEvent(formSubmitEvent, function (api, spec) {\r\n          return spec.onSubmit(api);\r\n        }),\r\n        fireApiEvent(formChangeEvent, function (api, spec, event) {\r\n          spec.onChange(api, { name: event.name });\r\n        }),\r\n        fireApiEvent(formActionEvent, function (api, spec, event, component) {\r\n          var focusIn = function () {\r\n            return Keying.focusIn(component);\r\n          };\r\n          var isDisabled = function (focused) {\r\n            return has$1(focused, 'disabled') || getOpt(focused, 'aria-disabled').exists(function (val) {\r\n              return val === 'true';\r\n            });\r\n          };\r\n          var rootNode = getRootNode(component.element);\r\n          var current = active(rootNode);\r\n          spec.onAction(api, {\r\n            name: event.name,\r\n            value: event.value\r\n          });\r\n          active(rootNode).fold(focusIn, function (focused) {\r\n            if (isDisabled(focused)) {\r\n              focusIn();\r\n            } else if (current.exists(function (cur) {\r\n                return contains(focused, cur) && isDisabled(cur);\r\n              })) {\r\n              focusIn();\r\n            } else {\r\n              getSink().toOptional().filter(function (sink) {\r\n                return !contains(sink.element, focused);\r\n              }).each(focusIn);\r\n            }\r\n          });\r\n        }),\r\n        fireApiEvent(formTabChangeEvent, function (api, spec, event) {\r\n          spec.onTabChange(api, {\r\n            newTabName: event.name,\r\n            oldTabName: event.oldName\r\n          });\r\n        }),\r\n        runOnDetached(function (component) {\r\n          var api = getInstanceApi();\r\n          Representing.setValue(component, api.getData());\r\n        })\r\n      ], false);\r\n    };\r\n    var SilverDialogEvents = {\r\n      initUrlDialog: initUrlDialog,\r\n      initDialog: initDialog\r\n    };\r\n\r\n    var makeButton = function (button, backstage) {\r\n      return renderFooterButton(button, button.type, backstage);\r\n    };\r\n    var lookup = function (compInSystem, footerButtons, buttonName) {\r\n      return find$5(footerButtons, function (button) {\r\n        return button.name === buttonName;\r\n      }).bind(function (memButton) {\r\n        return memButton.memento.getOpt(compInSystem);\r\n      });\r\n    };\r\n    var renderComponents = function (_data, state) {\r\n      var footerButtons = state.map(function (s) {\r\n        return s.footerButtons;\r\n      }).getOr([]);\r\n      var buttonGroups = partition$3(footerButtons, function (button) {\r\n        return button.align === 'start';\r\n      });\r\n      var makeGroup = function (edge, buttons) {\r\n        return Container.sketch({\r\n          dom: {\r\n            tag: 'div',\r\n            classes: ['tox-dialog__footer-' + edge]\r\n          },\r\n          components: map$2(buttons, function (button) {\r\n            return button.memento.asSpec();\r\n          })\r\n        });\r\n      };\r\n      var startButtons = makeGroup('start', buttonGroups.pass);\r\n      var endButtons = makeGroup('end', buttonGroups.fail);\r\n      return [\r\n        startButtons,\r\n        endButtons\r\n      ];\r\n    };\r\n    var renderFooter = function (initSpec, backstage) {\r\n      var updateState = function (_comp, data) {\r\n        var footerButtons = map$2(data.buttons, function (button) {\r\n          var memButton = record(makeButton(button, backstage));\r\n          return {\r\n            name: button.name,\r\n            align: button.align,\r\n            memento: memButton\r\n          };\r\n        });\r\n        var lookupByName = function (compInSystem, buttonName) {\r\n          return lookup(compInSystem, footerButtons, buttonName);\r\n        };\r\n        return Optional.some({\r\n          lookupByName: lookupByName,\r\n          footerButtons: footerButtons\r\n        });\r\n      };\r\n      return {\r\n        dom: fromHtml('<div class=\"tox-dialog__footer\"></div>'),\r\n        components: [],\r\n        behaviours: derive$1([Reflecting.config({\r\n            channel: footerChannel,\r\n            initialData: initSpec,\r\n            updateState: updateState,\r\n            renderComponents: renderComponents\r\n          })])\r\n      };\r\n    };\r\n    var renderInlineFooter = function (initSpec, backstage) {\r\n      return renderFooter(initSpec, backstage);\r\n    };\r\n    var renderModalFooter = function (initSpec, backstage) {\r\n      return ModalDialog.parts.footer(renderFooter(initSpec, backstage));\r\n    };\r\n\r\n    var getCompByName = function (access, name) {\r\n      var root = access.getRoot();\r\n      if (root.getSystem().isConnected()) {\r\n        var form_1 = Composing.getCurrent(access.getFormWrapper()).getOr(access.getFormWrapper());\r\n        return Form.getField(form_1, name).fold(function () {\r\n          var footer = access.getFooter();\r\n          var footerState = Reflecting.getState(footer);\r\n          return footerState.get().bind(function (f) {\r\n            return f.lookupByName(form_1, name);\r\n          });\r\n        }, function (comp) {\r\n          return Optional.some(comp);\r\n        });\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var validateData$1 = function (access, data) {\r\n      var root = access.getRoot();\r\n      return Reflecting.getState(root).get().map(function (dialogState) {\r\n        return getOrDie(asRaw('data', dialogState.dataValidator, data));\r\n      }).getOr(data);\r\n    };\r\n    var getDialogApi = function (access, doRedial, menuItemStates) {\r\n      var withRoot = function (f) {\r\n        var root = access.getRoot();\r\n        if (root.getSystem().isConnected()) {\r\n          f(root);\r\n        }\r\n      };\r\n      var getData = function () {\r\n        var root = access.getRoot();\r\n        var valueComp = root.getSystem().isConnected() ? access.getFormWrapper() : root;\r\n        var representedValues = Representing.getValue(valueComp);\r\n        var menuItemCurrentState = map$1(menuItemStates, function (cell) {\r\n          return cell.get();\r\n        });\r\n        return __assign(__assign({}, representedValues), menuItemCurrentState);\r\n      };\r\n      var setData = function (newData) {\r\n        withRoot(function (_) {\r\n          var prevData = instanceApi.getData();\r\n          var mergedData = __assign(__assign({}, prevData), newData);\r\n          var newInternalData = validateData$1(access, mergedData);\r\n          var form = access.getFormWrapper();\r\n          Representing.setValue(form, newInternalData);\r\n          each(menuItemStates, function (v, k) {\r\n            if (has$2(mergedData, k)) {\r\n              v.set(mergedData[k]);\r\n            }\r\n          });\r\n        });\r\n      };\r\n      var disable = function (name) {\r\n        getCompByName(access, name).each(Disabling.disable);\r\n      };\r\n      var enable = function (name) {\r\n        getCompByName(access, name).each(Disabling.enable);\r\n      };\r\n      var focus = function (name) {\r\n        getCompByName(access, name).each(Focusing.focus);\r\n      };\r\n      var block = function (message) {\r\n        if (!isString(message)) {\r\n          throw new Error('The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument');\r\n        }\r\n        withRoot(function (root) {\r\n          emitWith(root, formBlockEvent, { message: message });\r\n        });\r\n      };\r\n      var unblock = function () {\r\n        withRoot(function (root) {\r\n          emit(root, formUnblockEvent);\r\n        });\r\n      };\r\n      var showTab = function (name) {\r\n        withRoot(function (_) {\r\n          var body = access.getBody();\r\n          var bodyState = Reflecting.getState(body);\r\n          if (bodyState.get().exists(function (b) {\r\n              return b.isTabPanel();\r\n            })) {\r\n            Composing.getCurrent(body).each(function (tabSection) {\r\n              TabSection.showTab(tabSection, name);\r\n            });\r\n          }\r\n        });\r\n      };\r\n      var redial = function (d) {\r\n        withRoot(function (root) {\r\n          var dialogInit = doRedial(d);\r\n          root.getSystem().broadcastOn([dialogChannel], dialogInit);\r\n          root.getSystem().broadcastOn([titleChannel], dialogInit.internalDialog);\r\n          root.getSystem().broadcastOn([bodyChannel], dialogInit.internalDialog);\r\n          root.getSystem().broadcastOn([footerChannel], dialogInit.internalDialog);\r\n          instanceApi.setData(dialogInit.initialData);\r\n        });\r\n      };\r\n      var close = function () {\r\n        withRoot(function (root) {\r\n          emit(root, formCloseEvent);\r\n        });\r\n      };\r\n      var instanceApi = {\r\n        getData: getData,\r\n        setData: setData,\r\n        disable: disable,\r\n        enable: enable,\r\n        focus: focus,\r\n        block: block,\r\n        unblock: unblock,\r\n        showTab: showTab,\r\n        redial: redial,\r\n        close: close\r\n      };\r\n      return instanceApi;\r\n    };\r\n\r\n    var getDialogSizeClasses = function (size) {\r\n      switch (size) {\r\n      case 'large':\r\n        return ['tox-dialog--width-lg'];\r\n      case 'medium':\r\n        return ['tox-dialog--width-md'];\r\n      default:\r\n        return [];\r\n      }\r\n    };\r\n    var renderDialog = function (dialogInit, extra, backstage) {\r\n      var header = getHeader(dialogInit.internalDialog.title, backstage);\r\n      var body = renderModalBody({ body: dialogInit.internalDialog.body }, backstage);\r\n      var storagedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons);\r\n      var objOfCells = extractCellsToObject(storagedMenuButtons);\r\n      var footer = renderModalFooter({ buttons: storagedMenuButtons }, backstage);\r\n      var dialogEvents = SilverDialogEvents.initDialog(function () {\r\n        return instanceApi;\r\n      }, getEventExtras(function () {\r\n        return dialog;\r\n      }, backstage.shared.providers, extra), backstage.shared.getSink);\r\n      var dialogSize = getDialogSizeClasses(dialogInit.internalDialog.size);\r\n      var spec = {\r\n        header: header,\r\n        body: body,\r\n        footer: Optional.some(footer),\r\n        extraClasses: dialogSize,\r\n        extraBehaviours: [],\r\n        extraStyles: {}\r\n      };\r\n      var dialog = renderModalDialog(spec, dialogInit, dialogEvents, backstage);\r\n      var modalAccess = function () {\r\n        var getForm = function () {\r\n          var outerForm = ModalDialog.getBody(dialog);\r\n          return Composing.getCurrent(outerForm).getOr(outerForm);\r\n        };\r\n        return {\r\n          getRoot: constant$1(dialog),\r\n          getBody: function () {\r\n            return ModalDialog.getBody(dialog);\r\n          },\r\n          getFooter: function () {\r\n            return ModalDialog.getFooter(dialog);\r\n          },\r\n          getFormWrapper: getForm\r\n        };\r\n      }();\r\n      var instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);\r\n      return {\r\n        dialog: dialog,\r\n        instanceApi: instanceApi\r\n      };\r\n    };\r\n\r\n    var renderInlineDialog = function (dialogInit, extra, backstage, ariaAttrs) {\r\n      var _a, _b;\r\n      var dialogLabelId = generate$6('dialog-label');\r\n      var dialogContentId = generate$6('dialog-content');\r\n      var updateState = function (_comp, incoming) {\r\n        return Optional.some(incoming);\r\n      };\r\n      var memHeader = record(renderInlineHeader({\r\n        title: dialogInit.internalDialog.title,\r\n        draggable: true\r\n      }, dialogLabelId, backstage.shared.providers));\r\n      var memBody = record(renderInlineBody({ body: dialogInit.internalDialog.body }, dialogContentId, backstage, ariaAttrs));\r\n      var storagedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons);\r\n      var objOfCells = extractCellsToObject(storagedMenuButtons);\r\n      var memFooter = record(renderInlineFooter({ buttons: storagedMenuButtons }, backstage));\r\n      var dialogEvents = SilverDialogEvents.initDialog(function () {\r\n        return instanceApi;\r\n      }, {\r\n        onBlock: function (event) {\r\n          Blocking.block(dialog, function (_comp, bs) {\r\n            return getBusySpec(event.message, bs, backstage.shared.providers);\r\n          });\r\n        },\r\n        onUnblock: function () {\r\n          Blocking.unblock(dialog);\r\n        },\r\n        onClose: function () {\r\n          return extra.closeWindow();\r\n        }\r\n      }, backstage.shared.getSink);\r\n      var dialog = build$1({\r\n        dom: {\r\n          tag: 'div',\r\n          classes: [\r\n            'tox-dialog',\r\n            'tox-dialog-inline'\r\n          ],\r\n          attributes: (_a = { role: 'dialog' }, _a['aria-labelledby'] = dialogLabelId, _a['aria-describedby'] = dialogContentId, _a)\r\n        },\r\n        eventOrder: (_b = {}, _b[receive()] = [\r\n          Reflecting.name(),\r\n          Receiving.name()\r\n        ], _b[execute$5()] = ['execute-on-form'], _b[attachedToDom()] = [\r\n          'reflecting',\r\n          'execute-on-form'\r\n        ], _b),\r\n        behaviours: derive$1([\r\n          Keying.config({\r\n            mode: 'cyclic',\r\n            onEscape: function (c) {\r\n              emit(c, formCloseEvent);\r\n              return Optional.some(true);\r\n            },\r\n            useTabstopAt: function (elem) {\r\n              return !isPseudoStop(elem) && (name$2(elem) !== 'button' || get$d(elem, 'disabled') !== 'disabled');\r\n            }\r\n          }),\r\n          Reflecting.config({\r\n            channel: dialogChannel,\r\n            updateState: updateState,\r\n            initialData: dialogInit\r\n          }),\r\n          Focusing.config({}),\r\n          config('execute-on-form', dialogEvents.concat([runOnSource(focusin(), function (comp, _se) {\r\n              Keying.focusIn(comp);\r\n            })])),\r\n          Blocking.config({\r\n            getRoot: function () {\r\n              return Optional.some(dialog);\r\n            }\r\n          }),\r\n          Replacing.config({}),\r\n          RepresentingConfigs.memory({})\r\n        ]),\r\n        components: [\r\n          memHeader.asSpec(),\r\n          memBody.asSpec(),\r\n          memFooter.asSpec()\r\n        ]\r\n      });\r\n      var instanceApi = getDialogApi({\r\n        getRoot: constant$1(dialog),\r\n        getFooter: function () {\r\n          return memFooter.get(dialog);\r\n        },\r\n        getBody: function () {\r\n          return memBody.get(dialog);\r\n        },\r\n        getFormWrapper: function () {\r\n          var body = memBody.get(dialog);\r\n          return Composing.getCurrent(body).getOr(body);\r\n        }\r\n      }, extra.redial, objOfCells);\r\n      return {\r\n        dialog: dialog,\r\n        instanceApi: instanceApi\r\n      };\r\n    };\r\n\r\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.URI');\r\n\r\n    var getUrlDialogApi = function (root) {\r\n      var withRoot = function (f) {\r\n        if (root.getSystem().isConnected()) {\r\n          f(root);\r\n        }\r\n      };\r\n      var block = function (message) {\r\n        if (!isString(message)) {\r\n          throw new Error('The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument');\r\n        }\r\n        withRoot(function (root) {\r\n          emitWith(root, formBlockEvent, { message: message });\r\n        });\r\n      };\r\n      var unblock = function () {\r\n        withRoot(function (root) {\r\n          emit(root, formUnblockEvent);\r\n        });\r\n      };\r\n      var close = function () {\r\n        withRoot(function (root) {\r\n          emit(root, formCloseEvent);\r\n        });\r\n      };\r\n      var sendMessage = function (data) {\r\n        withRoot(function (root) {\r\n          root.getSystem().broadcastOn([bodySendMessageChannel], data);\r\n        });\r\n      };\r\n      return {\r\n        block: block,\r\n        unblock: unblock,\r\n        close: close,\r\n        sendMessage: sendMessage\r\n      };\r\n    };\r\n\r\n    var SUPPORTED_MESSAGE_ACTIONS = [\r\n      'insertContent',\r\n      'setContent',\r\n      'execCommand',\r\n      'close',\r\n      'block',\r\n      'unblock'\r\n    ];\r\n    var isSupportedMessage = function (data) {\r\n      return isObject(data) && SUPPORTED_MESSAGE_ACTIONS.indexOf(data.mceAction) !== -1;\r\n    };\r\n    var isCustomMessage = function (data) {\r\n      return !isSupportedMessage(data) && isObject(data) && has$2(data, 'mceAction');\r\n    };\r\n    var handleMessage = function (editor, api, data) {\r\n      switch (data.mceAction) {\r\n      case 'insertContent':\r\n        editor.insertContent(data.content);\r\n        break;\r\n      case 'setContent':\r\n        editor.setContent(data.content);\r\n        break;\r\n      case 'execCommand':\r\n        var ui = isBoolean(data.ui) ? data.ui : false;\r\n        editor.execCommand(data.cmd, ui, data.value);\r\n        break;\r\n      case 'close':\r\n        api.close();\r\n        break;\r\n      case 'block':\r\n        api.block(data.message);\r\n        break;\r\n      case 'unblock':\r\n        api.unblock();\r\n        break;\r\n      }\r\n    };\r\n    var renderUrlDialog = function (internalDialog, extra, editor, backstage) {\r\n      var _a;\r\n      var header = getHeader(internalDialog.title, backstage);\r\n      var body = renderIframeBody(internalDialog);\r\n      var footer = internalDialog.buttons.bind(function (buttons) {\r\n        if (buttons.length === 0) {\r\n          return Optional.none();\r\n        } else {\r\n          return Optional.some(renderModalFooter({ buttons: buttons }, backstage));\r\n        }\r\n      });\r\n      var dialogEvents = SilverDialogEvents.initUrlDialog(function () {\r\n        return instanceApi;\r\n      }, getEventExtras(function () {\r\n        return dialog;\r\n      }, backstage.shared.providers, extra));\r\n      var styles = __assign(__assign({}, internalDialog.height.fold(function () {\r\n        return {};\r\n      }, function (height) {\r\n        return {\r\n          'height': height + 'px',\r\n          'max-height': height + 'px'\r\n        };\r\n      })), internalDialog.width.fold(function () {\r\n        return {};\r\n      }, function (width) {\r\n        return {\r\n          'width': width + 'px',\r\n          'max-width': width + 'px'\r\n        };\r\n      }));\r\n      var classes = internalDialog.width.isNone() && internalDialog.height.isNone() ? ['tox-dialog--width-lg'] : [];\r\n      var iframeUri = new global$1(internalDialog.url, { base_uri: new global$1(window.location.href) });\r\n      var iframeDomain = iframeUri.protocol + '://' + iframeUri.host + (iframeUri.port ? ':' + iframeUri.port : '');\r\n      var messageHandlerUnbinder = unbindable();\r\n      var extraBehaviours = [\r\n        config('messages', [\r\n          runOnAttached(function () {\r\n            var unbind = bind(SugarElement.fromDom(window), 'message', function (e) {\r\n              if (iframeUri.isSameOrigin(new global$1(e.raw.origin))) {\r\n                var data = e.raw.data;\r\n                if (isSupportedMessage(data)) {\r\n                  handleMessage(editor, instanceApi, data);\r\n                } else if (isCustomMessage(data)) {\r\n                  internalDialog.onMessage(instanceApi, data);\r\n                }\r\n              }\r\n            });\r\n            messageHandlerUnbinder.set(unbind);\r\n          }),\r\n          runOnDetached(messageHandlerUnbinder.clear)\r\n        ]),\r\n        Receiving.config({\r\n          channels: (_a = {}, _a[bodySendMessageChannel] = {\r\n            onReceive: function (comp, data) {\r\n              descendant(comp.element, 'iframe').each(function (iframeEle) {\r\n                var iframeWin = iframeEle.dom.contentWindow;\r\n                iframeWin.postMessage(data, iframeDomain);\r\n              });\r\n            }\r\n          }, _a)\r\n        })\r\n      ];\r\n      var spec = {\r\n        header: header,\r\n        body: body,\r\n        footer: footer,\r\n        extraClasses: classes,\r\n        extraBehaviours: extraBehaviours,\r\n        extraStyles: styles\r\n      };\r\n      var dialog = renderModalDialog(spec, internalDialog, dialogEvents, backstage);\r\n      var instanceApi = getUrlDialogApi(dialog);\r\n      return {\r\n        dialog: dialog,\r\n        instanceApi: instanceApi\r\n      };\r\n    };\r\n\r\n    var setup$2 = function (extras) {\r\n      var sharedBackstage = extras.backstage.shared;\r\n      var open = function (message, callback) {\r\n        var closeDialog = function () {\r\n          ModalDialog.hide(alertDialog);\r\n          callback();\r\n        };\r\n        var memFooterClose = record(renderFooterButton({\r\n          name: 'close-alert',\r\n          text: 'OK',\r\n          primary: true,\r\n          align: 'end',\r\n          disabled: false,\r\n          icon: Optional.none()\r\n        }, 'cancel', extras.backstage));\r\n        var titleSpec = pUntitled();\r\n        var closeSpec = pClose(closeDialog, sharedBackstage.providers);\r\n        var alertDialog = build$1(renderDialog$1({\r\n          lazySink: function () {\r\n            return sharedBackstage.getSink();\r\n          },\r\n          header: hiddenHeader(titleSpec, closeSpec),\r\n          body: pBodyMessage(message, sharedBackstage.providers),\r\n          footer: Optional.some(pFooter(pFooterGroup([], [memFooterClose.asSpec()]))),\r\n          onEscape: closeDialog,\r\n          extraClasses: ['tox-alert-dialog'],\r\n          extraBehaviours: [],\r\n          extraStyles: {},\r\n          dialogEvents: [run$1(formCancelEvent, closeDialog)],\r\n          eventOrder: {}\r\n        }));\r\n        ModalDialog.show(alertDialog);\r\n        var footerCloseButton = memFooterClose.get(alertDialog);\r\n        Focusing.focus(footerCloseButton);\r\n      };\r\n      return { open: open };\r\n    };\r\n\r\n    var setup$1 = function (extras) {\r\n      var sharedBackstage = extras.backstage.shared;\r\n      var open = function (message, callback) {\r\n        var closeDialog = function (state) {\r\n          ModalDialog.hide(confirmDialog);\r\n          callback(state);\r\n        };\r\n        var memFooterYes = record(renderFooterButton({\r\n          name: 'yes',\r\n          text: 'Yes',\r\n          primary: true,\r\n          align: 'end',\r\n          disabled: false,\r\n          icon: Optional.none()\r\n        }, 'submit', extras.backstage));\r\n        var footerNo = renderFooterButton({\r\n          name: 'no',\r\n          text: 'No',\r\n          primary: false,\r\n          align: 'end',\r\n          disabled: false,\r\n          icon: Optional.none()\r\n        }, 'cancel', extras.backstage);\r\n        var titleSpec = pUntitled();\r\n        var closeSpec = pClose(function () {\r\n          return closeDialog(false);\r\n        }, sharedBackstage.providers);\r\n        var confirmDialog = build$1(renderDialog$1({\r\n          lazySink: function () {\r\n            return sharedBackstage.getSink();\r\n          },\r\n          header: hiddenHeader(titleSpec, closeSpec),\r\n          body: pBodyMessage(message, sharedBackstage.providers),\r\n          footer: Optional.some(pFooter(pFooterGroup([], [\r\n            footerNo,\r\n            memFooterYes.asSpec()\r\n          ]))),\r\n          onEscape: function () {\r\n            return closeDialog(false);\r\n          },\r\n          extraClasses: ['tox-confirm-dialog'],\r\n          extraBehaviours: [],\r\n          extraStyles: {},\r\n          dialogEvents: [\r\n            run$1(formCancelEvent, function () {\r\n              return closeDialog(false);\r\n            }),\r\n            run$1(formSubmitEvent, function () {\r\n              return closeDialog(true);\r\n            })\r\n          ],\r\n          eventOrder: {}\r\n        }));\r\n        ModalDialog.show(confirmDialog);\r\n        var footerYesButton = memFooterYes.get(confirmDialog);\r\n        Focusing.focus(footerYesButton);\r\n      };\r\n      return { open: open };\r\n    };\r\n\r\n    var validateData = function (data, validator) {\r\n      return getOrDie(asRaw('data', validator, data));\r\n    };\r\n    var isAlertOrConfirmDialog = function (target) {\r\n      return closest(target, '.tox-alert-dialog') || closest(target, '.tox-confirm-dialog');\r\n    };\r\n    var inlineAdditionalBehaviours = function (editor, isStickyToolbar, isToolbarLocationTop) {\r\n      if (isStickyToolbar && isToolbarLocationTop) {\r\n        return [];\r\n      } else {\r\n        return [Docking.config({\r\n            contextual: {\r\n              lazyContext: function () {\r\n                return Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer())));\r\n              },\r\n              fadeInClass: 'tox-dialog-dock-fadein',\r\n              fadeOutClass: 'tox-dialog-dock-fadeout',\r\n              transitionClass: 'tox-dialog-dock-transition'\r\n            },\r\n            modes: ['top']\r\n          })];\r\n      }\r\n    };\r\n    var setup = function (extras) {\r\n      var backstage = extras.backstage;\r\n      var editor = extras.editor;\r\n      var isStickyToolbar$1 = isStickyToolbar(editor);\r\n      var alertDialog = setup$2(extras);\r\n      var confirmDialog = setup$1(extras);\r\n      var open = function (config, params, closeWindow) {\r\n        if (params !== undefined && params.inline === 'toolbar') {\r\n          return openInlineDialog(config, backstage.shared.anchors.inlineDialog(), closeWindow, params.ariaAttrs);\r\n        } else if (params !== undefined && params.inline === 'cursor') {\r\n          return openInlineDialog(config, backstage.shared.anchors.cursor(), closeWindow, params.ariaAttrs);\r\n        } else {\r\n          return openModalDialog(config, closeWindow);\r\n        }\r\n      };\r\n      var openUrl = function (config, closeWindow) {\r\n        return openModalUrlDialog(config, closeWindow);\r\n      };\r\n      var openModalUrlDialog = function (config, closeWindow) {\r\n        var factory = function (contents) {\r\n          var dialog = renderUrlDialog(contents, {\r\n            closeWindow: function () {\r\n              ModalDialog.hide(dialog.dialog);\r\n              closeWindow(dialog.instanceApi);\r\n            }\r\n          }, editor, backstage);\r\n          ModalDialog.show(dialog.dialog);\r\n          return dialog.instanceApi;\r\n        };\r\n        return DialogManager.openUrl(factory, config);\r\n      };\r\n      var openModalDialog = function (config, closeWindow) {\r\n        var factory = function (contents, internalInitialData, dataValidator) {\r\n          var initialData = internalInitialData;\r\n          var dialogInit = {\r\n            dataValidator: dataValidator,\r\n            initialData: initialData,\r\n            internalDialog: contents\r\n          };\r\n          var dialog = renderDialog(dialogInit, {\r\n            redial: DialogManager.redial,\r\n            closeWindow: function () {\r\n              ModalDialog.hide(dialog.dialog);\r\n              closeWindow(dialog.instanceApi);\r\n            }\r\n          }, backstage);\r\n          ModalDialog.show(dialog.dialog);\r\n          dialog.instanceApi.setData(initialData);\r\n          return dialog.instanceApi;\r\n        };\r\n        return DialogManager.open(factory, config);\r\n      };\r\n      var openInlineDialog = function (config$1, anchor, closeWindow, ariaAttrs) {\r\n        var factory = function (contents, internalInitialData, dataValidator) {\r\n          var initialData = validateData(internalInitialData, dataValidator);\r\n          var inlineDialog = value$1();\r\n          var isToolbarLocationTop = backstage.shared.header.isPositionedAtTop();\r\n          var dialogInit = {\r\n            dataValidator: dataValidator,\r\n            initialData: initialData,\r\n            internalDialog: contents\r\n          };\r\n          var refreshDocking = function () {\r\n            return inlineDialog.on(function (dialog) {\r\n              InlineView.reposition(dialog);\r\n              Docking.refresh(dialog);\r\n            });\r\n          };\r\n          var dialogUi = renderInlineDialog(dialogInit, {\r\n            redial: DialogManager.redial,\r\n            closeWindow: function () {\r\n              inlineDialog.on(InlineView.hide);\r\n              editor.off('ResizeEditor', refreshDocking);\r\n              inlineDialog.clear();\r\n              closeWindow(dialogUi.instanceApi);\r\n            }\r\n          }, backstage, ariaAttrs);\r\n          var inlineDialogComp = build$1(InlineView.sketch(__assign(__assign({\r\n            lazySink: backstage.shared.getSink,\r\n            dom: {\r\n              tag: 'div',\r\n              classes: []\r\n            },\r\n            fireDismissalEventInstead: {}\r\n          }, isToolbarLocationTop ? {} : { fireRepositionEventInstead: {} }), {\r\n            inlineBehaviours: derive$1(__spreadArray([config('window-manager-inline-events', [run$1(dismissRequested(), function (_comp, _se) {\r\n                  emit(dialogUi.dialog, formCancelEvent);\r\n                })])], inlineAdditionalBehaviours(editor, isStickyToolbar$1, isToolbarLocationTop), true)),\r\n            isExtraPart: function (_comp, target) {\r\n              return isAlertOrConfirmDialog(target);\r\n            }\r\n          })));\r\n          inlineDialog.set(inlineDialogComp);\r\n          InlineView.showWithin(inlineDialogComp, premade(dialogUi.dialog), { anchor: anchor }, Optional.some(body()));\r\n          if (!isStickyToolbar$1 || !isToolbarLocationTop) {\r\n            Docking.refresh(inlineDialogComp);\r\n            editor.on('ResizeEditor', refreshDocking);\r\n          }\r\n          dialogUi.instanceApi.setData(initialData);\r\n          Keying.focusIn(dialogUi.dialog);\r\n          return dialogUi.instanceApi;\r\n        };\r\n        return DialogManager.open(factory, config$1);\r\n      };\r\n      var confirm = function (message, callback) {\r\n        confirmDialog.open(message, function (state) {\r\n          callback(state);\r\n        });\r\n      };\r\n      var alert = function (message, callback) {\r\n        alertDialog.open(message, function () {\r\n          callback();\r\n        });\r\n      };\r\n      var close = function (instanceApi) {\r\n        instanceApi.close();\r\n      };\r\n      return {\r\n        open: open,\r\n        openUrl: openUrl,\r\n        alert: alert,\r\n        close: close,\r\n        confirm: confirm\r\n      };\r\n    };\r\n\r\n    function Theme () {\r\n      global$g.add('silver', function (editor) {\r\n        var _a = setup$3(editor), uiMothership = _a.uiMothership, backstage = _a.backstage, renderUI = _a.renderUI, getUi = _a.getUi;\r\n        Autocompleter.register(editor, backstage.shared);\r\n        var windowMgr = setup({\r\n          editor: editor,\r\n          backstage: backstage\r\n        });\r\n        return {\r\n          renderUI: renderUI,\r\n          getWindowManagerImpl: constant$1(windowMgr),\r\n          getNotificationManagerImpl: function () {\r\n            return NotificationManagerImpl(editor, { backstage: backstage }, uiMothership);\r\n          },\r\n          ui: getUi()\r\n        };\r\n      });\r\n    }\r\n\r\n    Theme();\r\n\r\n}());\r\n\n\n//# sourceURL=webpack://test/./node_modules/tinymce/themes/silver/theme.js?\n}");

/***/ }),

/***/ "./node_modules/tinymce/tinymce.js":
/*!*****************************************!*\
  !*** ./node_modules/tinymce/tinymce.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{/**\r\n * Copyright (c) Tiny Technologies, Inc. All rights reserved.\r\n * Licensed under the LGPL or a commercial license.\r\n * For LGPL see License.txt in the project root for license information.\r\n * For commercial licenses see https://www.tiny.cloud/\r\n *\r\n * Version: 5.10.8 (2023-10-19)\r\n */\r\n(function () {\r\n    'use strict';\r\n\r\n    var typeOf$1 = function (x) {\r\n      if (x === null) {\r\n        return 'null';\r\n      }\r\n      if (x === undefined) {\r\n        return 'undefined';\r\n      }\r\n      var t = typeof x;\r\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\r\n        return 'array';\r\n      }\r\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\r\n        return 'string';\r\n      }\r\n      return t;\r\n    };\r\n    var isEquatableType = function (x) {\r\n      return [\r\n        'undefined',\r\n        'boolean',\r\n        'number',\r\n        'string',\r\n        'function',\r\n        'xml',\r\n        'null'\r\n      ].indexOf(x) !== -1;\r\n    };\r\n\r\n    var sort$1 = function (xs, compareFn) {\r\n      var clone = Array.prototype.slice.call(xs);\r\n      return clone.sort(compareFn);\r\n    };\r\n\r\n    var contramap = function (eqa, f) {\r\n      return eq$2(function (x, y) {\r\n        return eqa.eq(f(x), f(y));\r\n      });\r\n    };\r\n    var eq$2 = function (f) {\r\n      return { eq: f };\r\n    };\r\n    var tripleEq = eq$2(function (x, y) {\r\n      return x === y;\r\n    });\r\n    var eqString = tripleEq;\r\n    var eqArray = function (eqa) {\r\n      return eq$2(function (x, y) {\r\n        if (x.length !== y.length) {\r\n          return false;\r\n        }\r\n        var len = x.length;\r\n        for (var i = 0; i < len; i++) {\r\n          if (!eqa.eq(x[i], y[i])) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      });\r\n    };\r\n    var eqSortedArray = function (eqa, compareFn) {\r\n      return contramap(eqArray(eqa), function (xs) {\r\n        return sort$1(xs, compareFn);\r\n      });\r\n    };\r\n    var eqRecord = function (eqa) {\r\n      return eq$2(function (x, y) {\r\n        var kx = Object.keys(x);\r\n        var ky = Object.keys(y);\r\n        if (!eqSortedArray(eqString).eq(kx, ky)) {\r\n          return false;\r\n        }\r\n        var len = kx.length;\r\n        for (var i = 0; i < len; i++) {\r\n          var q = kx[i];\r\n          if (!eqa.eq(x[q], y[q])) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      });\r\n    };\r\n    var eqAny = eq$2(function (x, y) {\r\n      if (x === y) {\r\n        return true;\r\n      }\r\n      var tx = typeOf$1(x);\r\n      var ty = typeOf$1(y);\r\n      if (tx !== ty) {\r\n        return false;\r\n      }\r\n      if (isEquatableType(tx)) {\r\n        return x === y;\r\n      } else if (tx === 'array') {\r\n        return eqArray(eqAny).eq(x, y);\r\n      } else if (tx === 'object') {\r\n        return eqRecord(eqAny).eq(x, y);\r\n      }\r\n      return false;\r\n    });\r\n\r\n    var typeOf = function (x) {\r\n      var t = typeof x;\r\n      if (x === null) {\r\n        return 'null';\r\n      } else if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\r\n        return 'array';\r\n      } else if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\r\n        return 'string';\r\n      } else {\r\n        return t;\r\n      }\r\n    };\r\n    var isType$1 = function (type) {\r\n      return function (value) {\r\n        return typeOf(value) === type;\r\n      };\r\n    };\r\n    var isSimpleType = function (type) {\r\n      return function (value) {\r\n        return typeof value === type;\r\n      };\r\n    };\r\n    var eq$1 = function (t) {\r\n      return function (a) {\r\n        return t === a;\r\n      };\r\n    };\r\n    var isString$1 = isType$1('string');\r\n    var isObject = isType$1('object');\r\n    var isArray$1 = isType$1('array');\r\n    var isNull = eq$1(null);\r\n    var isBoolean = isSimpleType('boolean');\r\n    var isUndefined = eq$1(undefined);\r\n    var isNullable = function (a) {\r\n      return a === null || a === undefined;\r\n    };\r\n    var isNonNullable = function (a) {\r\n      return !isNullable(a);\r\n    };\r\n    var isFunction = isSimpleType('function');\r\n    var isNumber = isSimpleType('number');\r\n\r\n    var noop = function () {\r\n    };\r\n    var compose = function (fa, fb) {\r\n      return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        return fa(fb.apply(null, args));\r\n      };\r\n    };\r\n    var compose1 = function (fbc, fab) {\r\n      return function (a) {\r\n        return fbc(fab(a));\r\n      };\r\n    };\r\n    var constant = function (value) {\r\n      return function () {\r\n        return value;\r\n      };\r\n    };\r\n    var identity = function (x) {\r\n      return x;\r\n    };\r\n    var tripleEquals = function (a, b) {\r\n      return a === b;\r\n    };\r\n    function curry(fn) {\r\n      var initialArgs = [];\r\n      for (var _i = 1; _i < arguments.length; _i++) {\r\n        initialArgs[_i - 1] = arguments[_i];\r\n      }\r\n      return function () {\r\n        var restArgs = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          restArgs[_i] = arguments[_i];\r\n        }\r\n        var all = initialArgs.concat(restArgs);\r\n        return fn.apply(null, all);\r\n      };\r\n    }\r\n    var not = function (f) {\r\n      return function (t) {\r\n        return !f(t);\r\n      };\r\n    };\r\n    var die = function (msg) {\r\n      return function () {\r\n        throw new Error(msg);\r\n      };\r\n    };\r\n    var apply = function (f) {\r\n      return f();\r\n    };\r\n    var call = function (f) {\r\n      f();\r\n    };\r\n    var never = constant(false);\r\n    var always = constant(true);\r\n\r\n    var none = function () {\r\n      return NONE;\r\n    };\r\n    var NONE = function () {\r\n      var call = function (thunk) {\r\n        return thunk();\r\n      };\r\n      var id = identity;\r\n      var me = {\r\n        fold: function (n, _s) {\r\n          return n();\r\n        },\r\n        isSome: never,\r\n        isNone: always,\r\n        getOr: id,\r\n        getOrThunk: call,\r\n        getOrDie: function (msg) {\r\n          throw new Error(msg || 'error: getOrDie called on none.');\r\n        },\r\n        getOrNull: constant(null),\r\n        getOrUndefined: constant(undefined),\r\n        or: id,\r\n        orThunk: call,\r\n        map: none,\r\n        each: noop,\r\n        bind: none,\r\n        exists: never,\r\n        forall: always,\r\n        filter: function () {\r\n          return none();\r\n        },\r\n        toArray: function () {\r\n          return [];\r\n        },\r\n        toString: constant('none()')\r\n      };\r\n      return me;\r\n    }();\r\n    var some = function (a) {\r\n      var constant_a = constant(a);\r\n      var self = function () {\r\n        return me;\r\n      };\r\n      var bind = function (f) {\r\n        return f(a);\r\n      };\r\n      var me = {\r\n        fold: function (n, s) {\r\n          return s(a);\r\n        },\r\n        isSome: always,\r\n        isNone: never,\r\n        getOr: constant_a,\r\n        getOrThunk: constant_a,\r\n        getOrDie: constant_a,\r\n        getOrNull: constant_a,\r\n        getOrUndefined: constant_a,\r\n        or: self,\r\n        orThunk: self,\r\n        map: function (f) {\r\n          return some(f(a));\r\n        },\r\n        each: function (f) {\r\n          f(a);\r\n        },\r\n        bind: bind,\r\n        exists: bind,\r\n        forall: bind,\r\n        filter: function (f) {\r\n          return f(a) ? me : NONE;\r\n        },\r\n        toArray: function () {\r\n          return [a];\r\n        },\r\n        toString: function () {\r\n          return 'some(' + a + ')';\r\n        }\r\n      };\r\n      return me;\r\n    };\r\n    var from$1 = function (value) {\r\n      return value === null || value === undefined ? NONE : some(value);\r\n    };\r\n    var Optional = {\r\n      some: some,\r\n      none: none,\r\n      from: from$1\r\n    };\r\n\r\n    var nativeSlice = Array.prototype.slice;\r\n    var nativeIndexOf = Array.prototype.indexOf;\r\n    var nativePush = Array.prototype.push;\r\n    var rawIndexOf = function (ts, t) {\r\n      return nativeIndexOf.call(ts, t);\r\n    };\r\n    var indexOf$2 = function (xs, x) {\r\n      var r = rawIndexOf(xs, x);\r\n      return r === -1 ? Optional.none() : Optional.some(r);\r\n    };\r\n    var contains$3 = function (xs, x) {\r\n      return rawIndexOf(xs, x) > -1;\r\n    };\r\n    var exists = function (xs, pred) {\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        if (pred(x, i)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var map$3 = function (xs, f) {\r\n      var len = xs.length;\r\n      var r = new Array(len);\r\n      for (var i = 0; i < len; i++) {\r\n        var x = xs[i];\r\n        r[i] = f(x, i);\r\n      }\r\n      return r;\r\n    };\r\n    var each$k = function (xs, f) {\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    var eachr = function (xs, f) {\r\n      for (var i = xs.length - 1; i >= 0; i--) {\r\n        var x = xs[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    var partition = function (xs, pred) {\r\n      var pass = [];\r\n      var fail = [];\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        var arr = pred(x, i) ? pass : fail;\r\n        arr.push(x);\r\n      }\r\n      return {\r\n        pass: pass,\r\n        fail: fail\r\n      };\r\n    };\r\n    var filter$4 = function (xs, pred) {\r\n      var r = [];\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        if (pred(x, i)) {\r\n          r.push(x);\r\n        }\r\n      }\r\n      return r;\r\n    };\r\n    var foldr = function (xs, f, acc) {\r\n      eachr(xs, function (x, i) {\r\n        acc = f(acc, x, i);\r\n      });\r\n      return acc;\r\n    };\r\n    var foldl = function (xs, f, acc) {\r\n      each$k(xs, function (x, i) {\r\n        acc = f(acc, x, i);\r\n      });\r\n      return acc;\r\n    };\r\n    var findUntil$1 = function (xs, pred, until) {\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        if (pred(x, i)) {\r\n          return Optional.some(x);\r\n        } else if (until(x, i)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var find$3 = function (xs, pred) {\r\n      return findUntil$1(xs, pred, never);\r\n    };\r\n    var findIndex$2 = function (xs, pred) {\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        if (pred(x, i)) {\r\n          return Optional.some(i);\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var flatten = function (xs) {\r\n      var r = [];\r\n      for (var i = 0, len = xs.length; i < len; ++i) {\r\n        if (!isArray$1(xs[i])) {\r\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\r\n        }\r\n        nativePush.apply(r, xs[i]);\r\n      }\r\n      return r;\r\n    };\r\n    var bind = function (xs, f) {\r\n      return flatten(map$3(xs, f));\r\n    };\r\n    var forall = function (xs, pred) {\r\n      for (var i = 0, len = xs.length; i < len; ++i) {\r\n        var x = xs[i];\r\n        if (pred(x, i) !== true) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    var reverse = function (xs) {\r\n      var r = nativeSlice.call(xs, 0);\r\n      r.reverse();\r\n      return r;\r\n    };\r\n    var difference = function (a1, a2) {\r\n      return filter$4(a1, function (x) {\r\n        return !contains$3(a2, x);\r\n      });\r\n    };\r\n    var mapToObject = function (xs, f) {\r\n      var r = {};\r\n      for (var i = 0, len = xs.length; i < len; i++) {\r\n        var x = xs[i];\r\n        r[String(x)] = f(x, i);\r\n      }\r\n      return r;\r\n    };\r\n    var sort = function (xs, comparator) {\r\n      var copy = nativeSlice.call(xs, 0);\r\n      copy.sort(comparator);\r\n      return copy;\r\n    };\r\n    var get$a = function (xs, i) {\r\n      return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\r\n    };\r\n    var head = function (xs) {\r\n      return get$a(xs, 0);\r\n    };\r\n    var last$2 = function (xs) {\r\n      return get$a(xs, xs.length - 1);\r\n    };\r\n    var from = isFunction(Array.from) ? Array.from : function (x) {\r\n      return nativeSlice.call(x);\r\n    };\r\n    var findMap = function (arr, f) {\r\n      for (var i = 0; i < arr.length; i++) {\r\n        var r = f(arr[i], i);\r\n        if (r.isSome()) {\r\n          return r;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n\r\n    var keys = Object.keys;\r\n    var hasOwnProperty$1 = Object.hasOwnProperty;\r\n    var each$j = function (obj, f) {\r\n      var props = keys(obj);\r\n      for (var k = 0, len = props.length; k < len; k++) {\r\n        var i = props[k];\r\n        var x = obj[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    var map$2 = function (obj, f) {\r\n      return tupleMap(obj, function (x, i) {\r\n        return {\r\n          k: i,\r\n          v: f(x, i)\r\n        };\r\n      });\r\n    };\r\n    var tupleMap = function (obj, f) {\r\n      var r = {};\r\n      each$j(obj, function (x, i) {\r\n        var tuple = f(x, i);\r\n        r[tuple.k] = tuple.v;\r\n      });\r\n      return r;\r\n    };\r\n    var objAcc = function (r) {\r\n      return function (x, i) {\r\n        r[i] = x;\r\n      };\r\n    };\r\n    var internalFilter = function (obj, pred, onTrue, onFalse) {\r\n      var r = {};\r\n      each$j(obj, function (x, i) {\r\n        (pred(x, i) ? onTrue : onFalse)(x, i);\r\n      });\r\n      return r;\r\n    };\r\n    var bifilter = function (obj, pred) {\r\n      var t = {};\r\n      var f = {};\r\n      internalFilter(obj, pred, objAcc(t), objAcc(f));\r\n      return {\r\n        t: t,\r\n        f: f\r\n      };\r\n    };\r\n    var filter$3 = function (obj, pred) {\r\n      var t = {};\r\n      internalFilter(obj, pred, objAcc(t), noop);\r\n      return t;\r\n    };\r\n    var mapToArray = function (obj, f) {\r\n      var r = [];\r\n      each$j(obj, function (value, name) {\r\n        r.push(f(value, name));\r\n      });\r\n      return r;\r\n    };\r\n    var values = function (obj) {\r\n      return mapToArray(obj, identity);\r\n    };\r\n    var get$9 = function (obj, key) {\r\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\r\n    };\r\n    var has$2 = function (obj, key) {\r\n      return hasOwnProperty$1.call(obj, key);\r\n    };\r\n    var hasNonNullableKey = function (obj, key) {\r\n      return has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\r\n    };\r\n    var equal$1 = function (a1, a2, eq) {\r\n      if (eq === void 0) {\r\n        eq = eqAny;\r\n      }\r\n      return eqRecord(eq).eq(a1, a2);\r\n    };\r\n\r\n    var isArray = Array.isArray;\r\n    var toArray$1 = function (obj) {\r\n      if (!isArray(obj)) {\r\n        var array = [];\r\n        for (var i = 0, l = obj.length; i < l; i++) {\r\n          array[i] = obj[i];\r\n        }\r\n        return array;\r\n      } else {\r\n        return obj;\r\n      }\r\n    };\r\n    var each$i = function (o, cb, s) {\r\n      var n, l;\r\n      if (!o) {\r\n        return false;\r\n      }\r\n      s = s || o;\r\n      if (o.length !== undefined) {\r\n        for (n = 0, l = o.length; n < l; n++) {\r\n          if (cb.call(s, o[n], n, o) === false) {\r\n            return false;\r\n          }\r\n        }\r\n      } else {\r\n        for (n in o) {\r\n          if (has$2(o, n)) {\r\n            if (cb.call(s, o[n], n, o) === false) {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    var map$1 = function (array, callback) {\r\n      var out = [];\r\n      each$i(array, function (item, index) {\r\n        out.push(callback(item, index, array));\r\n      });\r\n      return out;\r\n    };\r\n    var filter$2 = function (a, f) {\r\n      var o = [];\r\n      each$i(a, function (v, index) {\r\n        if (!f || f(v, index, a)) {\r\n          o.push(v);\r\n        }\r\n      });\r\n      return o;\r\n    };\r\n    var indexOf$1 = function (a, v) {\r\n      if (a) {\r\n        for (var i = 0, l = a.length; i < l; i++) {\r\n          if (a[i] === v) {\r\n            return i;\r\n          }\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    var reduce = function (collection, iteratee, accumulator, thisArg) {\r\n      var acc = isUndefined(accumulator) ? collection[0] : accumulator;\r\n      for (var i = 0; i < collection.length; i++) {\r\n        acc = iteratee.call(thisArg, acc, collection[i], i);\r\n      }\r\n      return acc;\r\n    };\r\n    var findIndex$1 = function (array, predicate, thisArg) {\r\n      var i, l;\r\n      for (i = 0, l = array.length; i < l; i++) {\r\n        if (predicate.call(thisArg, array[i], i, array)) {\r\n          return i;\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    var last$1 = function (collection) {\r\n      return collection[collection.length - 1];\r\n    };\r\n\r\n    var __assign = function () {\r\n      __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n          s = arguments[i];\r\n          for (var p in s)\r\n            if (Object.prototype.hasOwnProperty.call(s, p))\r\n              t[p] = s[p];\r\n        }\r\n        return t;\r\n      };\r\n      return __assign.apply(this, arguments);\r\n    };\r\n    function __rest(s, e) {\r\n      var t = {};\r\n      for (var p in s)\r\n        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n          t[p] = s[p];\r\n      if (s != null && typeof Object.getOwnPropertySymbols === 'function')\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n            t[p[i]] = s[p[i]];\r\n        }\r\n      return t;\r\n    }\r\n    function __spreadArray(to, from, pack) {\r\n      if (pack || arguments.length === 2)\r\n        for (var i = 0, l = from.length, ar; i < l; i++) {\r\n          if (ar || !(i in from)) {\r\n            if (!ar)\r\n              ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n          }\r\n        }\r\n      return to.concat(ar || Array.prototype.slice.call(from));\r\n    }\r\n\r\n    var cached = function (f) {\r\n      var called = false;\r\n      var r;\r\n      return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        if (!called) {\r\n          called = true;\r\n          r = f.apply(null, args);\r\n        }\r\n        return r;\r\n      };\r\n    };\r\n\r\n    var DeviceType = function (os, browser, userAgent, mediaMatch) {\r\n      var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\r\n      var isiPhone = os.isiOS() && !isiPad;\r\n      var isMobile = os.isiOS() || os.isAndroid();\r\n      var isTouch = isMobile || mediaMatch('(pointer:coarse)');\r\n      var isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\r\n      var isPhone = isiPhone || isMobile && !isTablet;\r\n      var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\r\n      var isDesktop = !isPhone && !isTablet && !iOSwebview;\r\n      return {\r\n        isiPad: constant(isiPad),\r\n        isiPhone: constant(isiPhone),\r\n        isTablet: constant(isTablet),\r\n        isPhone: constant(isPhone),\r\n        isTouch: constant(isTouch),\r\n        isAndroid: os.isAndroid,\r\n        isiOS: os.isiOS,\r\n        isWebView: constant(iOSwebview),\r\n        isDesktop: constant(isDesktop)\r\n      };\r\n    };\r\n\r\n    var firstMatch = function (regexes, s) {\r\n      for (var i = 0; i < regexes.length; i++) {\r\n        var x = regexes[i];\r\n        if (x.test(s)) {\r\n          return x;\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n    var find$2 = function (regexes, agent) {\r\n      var r = firstMatch(regexes, agent);\r\n      if (!r) {\r\n        return {\r\n          major: 0,\r\n          minor: 0\r\n        };\r\n      }\r\n      var group = function (i) {\r\n        return Number(agent.replace(r, '$' + i));\r\n      };\r\n      return nu$4(group(1), group(2));\r\n    };\r\n    var detect$3 = function (versionRegexes, agent) {\r\n      var cleanedAgent = String(agent).toLowerCase();\r\n      if (versionRegexes.length === 0) {\r\n        return unknown$2();\r\n      }\r\n      return find$2(versionRegexes, cleanedAgent);\r\n    };\r\n    var unknown$2 = function () {\r\n      return nu$4(0, 0);\r\n    };\r\n    var nu$4 = function (major, minor) {\r\n      return {\r\n        major: major,\r\n        minor: minor\r\n      };\r\n    };\r\n    var Version = {\r\n      nu: nu$4,\r\n      detect: detect$3,\r\n      unknown: unknown$2\r\n    };\r\n\r\n    var detectBrowser$1 = function (browsers, userAgentData) {\r\n      return findMap(userAgentData.brands, function (uaBrand) {\r\n        var lcBrand = uaBrand.brand.toLowerCase();\r\n        return find$3(browsers, function (browser) {\r\n          var _a;\r\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\r\n        }).map(function (info) {\r\n          return {\r\n            current: info.name,\r\n            version: Version.nu(parseInt(uaBrand.version, 10), 0)\r\n          };\r\n        });\r\n      });\r\n    };\r\n\r\n    var detect$2 = function (candidates, userAgent) {\r\n      var agent = String(userAgent).toLowerCase();\r\n      return find$3(candidates, function (candidate) {\r\n        return candidate.search(agent);\r\n      });\r\n    };\r\n    var detectBrowser = function (browsers, userAgent) {\r\n      return detect$2(browsers, userAgent).map(function (browser) {\r\n        var version = Version.detect(browser.versionRegexes, userAgent);\r\n        return {\r\n          current: browser.name,\r\n          version: version\r\n        };\r\n      });\r\n    };\r\n    var detectOs = function (oses, userAgent) {\r\n      return detect$2(oses, userAgent).map(function (os) {\r\n        var version = Version.detect(os.versionRegexes, userAgent);\r\n        return {\r\n          current: os.name,\r\n          version: version\r\n        };\r\n      });\r\n    };\r\n\r\n    var removeFromStart = function (str, numChars) {\r\n      return str.substring(numChars);\r\n    };\r\n\r\n    var checkRange = function (str, substr, start) {\r\n      return substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\r\n    };\r\n    var removeLeading = function (str, prefix) {\r\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\r\n    };\r\n    var contains$2 = function (str, substr) {\r\n      return str.indexOf(substr) !== -1;\r\n    };\r\n    var startsWith = function (str, prefix) {\r\n      return checkRange(str, prefix, 0);\r\n    };\r\n    var blank = function (r) {\r\n      return function (s) {\r\n        return s.replace(r, '');\r\n      };\r\n    };\r\n    var trim$5 = blank(/^\\s+|\\s+$/g);\r\n    var lTrim = blank(/^\\s+/g);\r\n    var rTrim = blank(/\\s+$/g);\r\n    var isNotEmpty = function (s) {\r\n      return s.length > 0;\r\n    };\r\n    var isEmpty$3 = function (s) {\r\n      return !isNotEmpty(s);\r\n    };\r\n\r\n    var normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\r\n    var checkContains = function (target) {\r\n      return function (uastring) {\r\n        return contains$2(uastring, target);\r\n      };\r\n    };\r\n    var browsers = [\r\n      {\r\n        name: 'Edge',\r\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\r\n        search: function (uastring) {\r\n          return contains$2(uastring, 'edge/') && contains$2(uastring, 'chrome') && contains$2(uastring, 'safari') && contains$2(uastring, 'applewebkit');\r\n        }\r\n      },\r\n      {\r\n        name: 'Chrome',\r\n        brand: 'Chromium',\r\n        versionRegexes: [\r\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\r\n          normalVersionRegex\r\n        ],\r\n        search: function (uastring) {\r\n          return contains$2(uastring, 'chrome') && !contains$2(uastring, 'chromeframe');\r\n        }\r\n      },\r\n      {\r\n        name: 'IE',\r\n        versionRegexes: [\r\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\r\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\r\n        ],\r\n        search: function (uastring) {\r\n          return contains$2(uastring, 'msie') || contains$2(uastring, 'trident');\r\n        }\r\n      },\r\n      {\r\n        name: 'Opera',\r\n        versionRegexes: [\r\n          normalVersionRegex,\r\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\r\n        ],\r\n        search: checkContains('opera')\r\n      },\r\n      {\r\n        name: 'Firefox',\r\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\r\n        search: checkContains('firefox')\r\n      },\r\n      {\r\n        name: 'Safari',\r\n        versionRegexes: [\r\n          normalVersionRegex,\r\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\r\n        ],\r\n        search: function (uastring) {\r\n          return (contains$2(uastring, 'safari') || contains$2(uastring, 'mobile/')) && contains$2(uastring, 'applewebkit');\r\n        }\r\n      }\r\n    ];\r\n    var oses = [\r\n      {\r\n        name: 'Windows',\r\n        search: checkContains('win'),\r\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'iOS',\r\n        search: function (uastring) {\r\n          return contains$2(uastring, 'iphone') || contains$2(uastring, 'ipad');\r\n        },\r\n        versionRegexes: [\r\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\r\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\r\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\r\n        ]\r\n      },\r\n      {\r\n        name: 'Android',\r\n        search: checkContains('android'),\r\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'OSX',\r\n        search: checkContains('mac os x'),\r\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'Linux',\r\n        search: checkContains('linux'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'Solaris',\r\n        search: checkContains('sunos'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'FreeBSD',\r\n        search: checkContains('freebsd'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'ChromeOS',\r\n        search: checkContains('cros'),\r\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\r\n      }\r\n    ];\r\n    var PlatformInfo = {\r\n      browsers: constant(browsers),\r\n      oses: constant(oses)\r\n    };\r\n\r\n    var edge = 'Edge';\r\n    var chrome = 'Chrome';\r\n    var ie$1 = 'IE';\r\n    var opera = 'Opera';\r\n    var firefox = 'Firefox';\r\n    var safari = 'Safari';\r\n    var unknown$1 = function () {\r\n      return nu$3({\r\n        current: undefined,\r\n        version: Version.unknown()\r\n      });\r\n    };\r\n    var nu$3 = function (info) {\r\n      var current = info.current;\r\n      var version = info.version;\r\n      var isBrowser = function (name) {\r\n        return function () {\r\n          return current === name;\r\n        };\r\n      };\r\n      return {\r\n        current: current,\r\n        version: version,\r\n        isEdge: isBrowser(edge),\r\n        isChrome: isBrowser(chrome),\r\n        isIE: isBrowser(ie$1),\r\n        isOpera: isBrowser(opera),\r\n        isFirefox: isBrowser(firefox),\r\n        isSafari: isBrowser(safari)\r\n      };\r\n    };\r\n    var Browser = {\r\n      unknown: unknown$1,\r\n      nu: nu$3,\r\n      edge: constant(edge),\r\n      chrome: constant(chrome),\r\n      ie: constant(ie$1),\r\n      opera: constant(opera),\r\n      firefox: constant(firefox),\r\n      safari: constant(safari)\r\n    };\r\n\r\n    var windows = 'Windows';\r\n    var ios = 'iOS';\r\n    var android = 'Android';\r\n    var linux = 'Linux';\r\n    var osx = 'OSX';\r\n    var solaris = 'Solaris';\r\n    var freebsd = 'FreeBSD';\r\n    var chromeos = 'ChromeOS';\r\n    var unknown = function () {\r\n      return nu$2({\r\n        current: undefined,\r\n        version: Version.unknown()\r\n      });\r\n    };\r\n    var nu$2 = function (info) {\r\n      var current = info.current;\r\n      var version = info.version;\r\n      var isOS = function (name) {\r\n        return function () {\r\n          return current === name;\r\n        };\r\n      };\r\n      return {\r\n        current: current,\r\n        version: version,\r\n        isWindows: isOS(windows),\r\n        isiOS: isOS(ios),\r\n        isAndroid: isOS(android),\r\n        isOSX: isOS(osx),\r\n        isLinux: isOS(linux),\r\n        isSolaris: isOS(solaris),\r\n        isFreeBSD: isOS(freebsd),\r\n        isChromeOS: isOS(chromeos)\r\n      };\r\n    };\r\n    var OperatingSystem = {\r\n      unknown: unknown,\r\n      nu: nu$2,\r\n      windows: constant(windows),\r\n      ios: constant(ios),\r\n      android: constant(android),\r\n      linux: constant(linux),\r\n      osx: constant(osx),\r\n      solaris: constant(solaris),\r\n      freebsd: constant(freebsd),\r\n      chromeos: constant(chromeos)\r\n    };\r\n\r\n    var detect$1 = function (userAgent, userAgentDataOpt, mediaMatch) {\r\n      var browsers = PlatformInfo.browsers();\r\n      var oses = PlatformInfo.oses();\r\n      var browser = userAgentDataOpt.bind(function (userAgentData) {\r\n        return detectBrowser$1(browsers, userAgentData);\r\n      }).orThunk(function () {\r\n        return detectBrowser(browsers, userAgent);\r\n      }).fold(Browser.unknown, Browser.nu);\r\n      var os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\r\n      var deviceType = DeviceType(os, browser, userAgent, mediaMatch);\r\n      return {\r\n        browser: browser,\r\n        os: os,\r\n        deviceType: deviceType\r\n      };\r\n    };\r\n    var PlatformDetection = { detect: detect$1 };\r\n\r\n    var mediaMatch = function (query) {\r\n      return window.matchMedia(query).matches;\r\n    };\r\n    var platform$2 = cached(function () {\r\n      return PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch);\r\n    });\r\n    var detect = function () {\r\n      return platform$2();\r\n    };\r\n\r\n    var userAgent = navigator.userAgent;\r\n    var platform$1 = detect();\r\n    var browser$4 = platform$1.browser;\r\n    var os = platform$1.os;\r\n    var deviceType = platform$1.deviceType;\r\n    var webkit = /WebKit/.test(userAgent) && !browser$4.isEdge();\r\n    var fileApi = 'FormData' in window && 'FileReader' in window && 'URL' in window && !!URL.createObjectURL;\r\n    var windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\r\n    var Env = {\r\n      opera: browser$4.isOpera(),\r\n      webkit: webkit,\r\n      ie: browser$4.isIE() || browser$4.isEdge() ? browser$4.version.major : false,\r\n      gecko: browser$4.isFirefox(),\r\n      mac: os.isOSX() || os.isiOS(),\r\n      iOS: deviceType.isiPad() || deviceType.isiPhone(),\r\n      android: os.isAndroid(),\r\n      contentEditable: true,\r\n      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\r\n      caretAfter: true,\r\n      range: window.getSelection && 'Range' in window,\r\n      documentMode: browser$4.isIE() ? document.documentMode || 7 : 10,\r\n      fileApi: fileApi,\r\n      ceFalse: true,\r\n      cacheSuffix: null,\r\n      container: null,\r\n      experimentalShadowDom: false,\r\n      canHaveCSP: !browser$4.isIE(),\r\n      desktop: deviceType.isDesktop(),\r\n      windowsPhone: windowsPhone,\r\n      browser: {\r\n        current: browser$4.current,\r\n        version: browser$4.version,\r\n        isChrome: browser$4.isChrome,\r\n        isEdge: browser$4.isEdge,\r\n        isFirefox: browser$4.isFirefox,\r\n        isIE: browser$4.isIE,\r\n        isOpera: browser$4.isOpera,\r\n        isSafari: browser$4.isSafari\r\n      },\r\n      os: {\r\n        current: os.current,\r\n        version: os.version,\r\n        isAndroid: os.isAndroid,\r\n        isChromeOS: os.isChromeOS,\r\n        isFreeBSD: os.isFreeBSD,\r\n        isiOS: os.isiOS,\r\n        isLinux: os.isLinux,\r\n        isOSX: os.isOSX,\r\n        isSolaris: os.isSolaris,\r\n        isWindows: os.isWindows\r\n      },\r\n      deviceType: {\r\n        isDesktop: deviceType.isDesktop,\r\n        isiPad: deviceType.isiPad,\r\n        isiPhone: deviceType.isiPhone,\r\n        isPhone: deviceType.isPhone,\r\n        isTablet: deviceType.isTablet,\r\n        isTouch: deviceType.isTouch,\r\n        isWebView: deviceType.isWebView\r\n      }\r\n    };\r\n\r\n    var whiteSpaceRegExp$2 = /^\\s*|\\s*$/g;\r\n    var trim$4 = function (str) {\r\n      return str === null || str === undefined ? '' : ('' + str).replace(whiteSpaceRegExp$2, '');\r\n    };\r\n    var is$3 = function (obj, type) {\r\n      if (!type) {\r\n        return obj !== undefined;\r\n      }\r\n      if (type === 'array' && isArray(obj)) {\r\n        return true;\r\n      }\r\n      return typeof obj === type;\r\n    };\r\n    var makeMap$4 = function (items, delim, map) {\r\n      var i;\r\n      items = items || [];\r\n      delim = delim || ',';\r\n      if (typeof items === 'string') {\r\n        items = items.split(delim);\r\n      }\r\n      map = map || {};\r\n      i = items.length;\r\n      while (i--) {\r\n        map[items[i]] = {};\r\n      }\r\n      return map;\r\n    };\r\n    var hasOwnProperty = has$2;\r\n    var create$9 = function (s, p, root) {\r\n      var self = this;\r\n      var sp, scn, c, de = 0;\r\n      s = /^((static) )?([\\w.]+)(:([\\w.]+))?/.exec(s);\r\n      var cn = s[3].match(/(^|\\.)(\\w+)$/i)[2];\r\n      var ns = self.createNS(s[3].replace(/\\.\\w+$/, ''), root);\r\n      if (ns[cn]) {\r\n        return;\r\n      }\r\n      if (s[2] === 'static') {\r\n        ns[cn] = p;\r\n        if (this.onCreate) {\r\n          this.onCreate(s[2], s[3], ns[cn]);\r\n        }\r\n        return;\r\n      }\r\n      if (!p[cn]) {\r\n        p[cn] = function () {\r\n        };\r\n        de = 1;\r\n      }\r\n      ns[cn] = p[cn];\r\n      self.extend(ns[cn].prototype, p);\r\n      if (s[5]) {\r\n        sp = self.resolve(s[5]).prototype;\r\n        scn = s[5].match(/\\.(\\w+)$/i)[1];\r\n        c = ns[cn];\r\n        if (de) {\r\n          ns[cn] = function () {\r\n            return sp[scn].apply(this, arguments);\r\n          };\r\n        } else {\r\n          ns[cn] = function () {\r\n            this.parent = sp[scn];\r\n            return c.apply(this, arguments);\r\n          };\r\n        }\r\n        ns[cn].prototype[cn] = ns[cn];\r\n        self.each(sp, function (f, n) {\r\n          ns[cn].prototype[n] = sp[n];\r\n        });\r\n        self.each(p, function (f, n) {\r\n          if (sp[n]) {\r\n            ns[cn].prototype[n] = function () {\r\n              this.parent = sp[n];\r\n              return f.apply(this, arguments);\r\n            };\r\n          } else {\r\n            if (n !== cn) {\r\n              ns[cn].prototype[n] = f;\r\n            }\r\n          }\r\n        });\r\n      }\r\n      self.each(p.static, function (f, n) {\r\n        ns[cn][n] = f;\r\n      });\r\n    };\r\n    var extend$6 = function (obj) {\r\n      var exts = [];\r\n      for (var _i = 1; _i < arguments.length; _i++) {\r\n        exts[_i - 1] = arguments[_i];\r\n      }\r\n      for (var i = 0; i < exts.length; i++) {\r\n        var ext = exts[i];\r\n        for (var name_1 in ext) {\r\n          if (has$2(ext, name_1)) {\r\n            var value = ext[name_1];\r\n            if (value !== undefined) {\r\n              obj[name_1] = value;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return obj;\r\n    };\r\n    var walk$3 = function (o, f, n, s) {\r\n      s = s || this;\r\n      if (o) {\r\n        if (n) {\r\n          o = o[n];\r\n        }\r\n        each$i(o, function (o, i) {\r\n          if (f.call(s, o, i, n) === false) {\r\n            return false;\r\n          }\r\n          walk$3(o, f, n, s);\r\n        });\r\n      }\r\n    };\r\n    var createNS = function (n, o) {\r\n      var i, v;\r\n      o = o || window;\r\n      n = n.split('.');\r\n      for (i = 0; i < n.length; i++) {\r\n        v = n[i];\r\n        if (!o[v]) {\r\n          o[v] = {};\r\n        }\r\n        o = o[v];\r\n      }\r\n      return o;\r\n    };\r\n    var resolve$3 = function (n, o) {\r\n      var i, l;\r\n      o = o || window;\r\n      n = n.split('.');\r\n      for (i = 0, l = n.length; i < l; i++) {\r\n        o = o[n[i]];\r\n        if (!o) {\r\n          break;\r\n        }\r\n      }\r\n      return o;\r\n    };\r\n    var explode$4 = function (s, d) {\r\n      if (!s || is$3(s, 'array')) {\r\n        return s;\r\n      }\r\n      return map$1(s.split(d || ','), trim$4);\r\n    };\r\n    var _addCacheSuffix = function (url) {\r\n      var cacheSuffix = Env.cacheSuffix;\r\n      if (cacheSuffix) {\r\n        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\r\n      }\r\n      return url;\r\n    };\r\n    var Tools = {\r\n      trim: trim$4,\r\n      isArray: isArray,\r\n      is: is$3,\r\n      toArray: toArray$1,\r\n      makeMap: makeMap$4,\r\n      each: each$i,\r\n      map: map$1,\r\n      grep: filter$2,\r\n      inArray: indexOf$1,\r\n      hasOwn: hasOwnProperty,\r\n      extend: extend$6,\r\n      create: create$9,\r\n      walk: walk$3,\r\n      createNS: createNS,\r\n      resolve: resolve$3,\r\n      explode: explode$4,\r\n      _addCacheSuffix: _addCacheSuffix\r\n    };\r\n\r\n    var fromHtml$1 = function (html, scope) {\r\n      var doc = scope || document;\r\n      var div = doc.createElement('div');\r\n      div.innerHTML = html;\r\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\r\n        console.error('HTML does not have a single root node', html);\r\n        throw new Error('HTML must have a single root node');\r\n      }\r\n      return fromDom$2(div.childNodes[0]);\r\n    };\r\n    var fromTag = function (tag, scope) {\r\n      var doc = scope || document;\r\n      var node = doc.createElement(tag);\r\n      return fromDom$2(node);\r\n    };\r\n    var fromText = function (text, scope) {\r\n      var doc = scope || document;\r\n      var node = doc.createTextNode(text);\r\n      return fromDom$2(node);\r\n    };\r\n    var fromDom$2 = function (node) {\r\n      if (node === null || node === undefined) {\r\n        throw new Error('Node cannot be null or undefined');\r\n      }\r\n      return { dom: node };\r\n    };\r\n    var fromPoint$1 = function (docElm, x, y) {\r\n      return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\r\n    };\r\n    var SugarElement = {\r\n      fromHtml: fromHtml$1,\r\n      fromTag: fromTag,\r\n      fromText: fromText,\r\n      fromDom: fromDom$2,\r\n      fromPoint: fromPoint$1\r\n    };\r\n\r\n    var toArray = function (target, f) {\r\n      var r = [];\r\n      var recurse = function (e) {\r\n        r.push(e);\r\n        return f(e);\r\n      };\r\n      var cur = f(target);\r\n      do {\r\n        cur = cur.bind(recurse);\r\n      } while (cur.isSome());\r\n      return r;\r\n    };\r\n\r\n    var compareDocumentPosition = function (a, b, match) {\r\n      return (a.compareDocumentPosition(b) & match) !== 0;\r\n    };\r\n    var documentPositionContainedBy = function (a, b) {\r\n      return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_CONTAINED_BY);\r\n    };\r\n\r\n    var COMMENT = 8;\r\n    var DOCUMENT = 9;\r\n    var DOCUMENT_FRAGMENT = 11;\r\n    var ELEMENT = 1;\r\n    var TEXT = 3;\r\n\r\n    var is$2 = function (element, selector) {\r\n      var dom = element.dom;\r\n      if (dom.nodeType !== ELEMENT) {\r\n        return false;\r\n      } else {\r\n        var elem = dom;\r\n        if (elem.matches !== undefined) {\r\n          return elem.matches(selector);\r\n        } else if (elem.msMatchesSelector !== undefined) {\r\n          return elem.msMatchesSelector(selector);\r\n        } else if (elem.webkitMatchesSelector !== undefined) {\r\n          return elem.webkitMatchesSelector(selector);\r\n        } else if (elem.mozMatchesSelector !== undefined) {\r\n          return elem.mozMatchesSelector(selector);\r\n        } else {\r\n          throw new Error('Browser lacks native selectors');\r\n        }\r\n      }\r\n    };\r\n    var bypassSelector = function (dom) {\r\n      return dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\r\n    };\r\n    var all = function (selector, scope) {\r\n      var base = scope === undefined ? document : scope.dom;\r\n      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\r\n    };\r\n    var one = function (selector, scope) {\r\n      var base = scope === undefined ? document : scope.dom;\r\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\r\n    };\r\n\r\n    var eq = function (e1, e2) {\r\n      return e1.dom === e2.dom;\r\n    };\r\n    var regularContains = function (e1, e2) {\r\n      var d1 = e1.dom;\r\n      var d2 = e2.dom;\r\n      return d1 === d2 ? false : d1.contains(d2);\r\n    };\r\n    var ieContains = function (e1, e2) {\r\n      return documentPositionContainedBy(e1.dom, e2.dom);\r\n    };\r\n    var contains$1 = function (e1, e2) {\r\n      return detect().browser.isIE() ? ieContains(e1, e2) : regularContains(e1, e2);\r\n    };\r\n\r\n    typeof window !== 'undefined' ? window : Function('return this;')();\r\n\r\n    var name = function (element) {\r\n      var r = element.dom.nodeName;\r\n      return r.toLowerCase();\r\n    };\r\n    var type = function (element) {\r\n      return element.dom.nodeType;\r\n    };\r\n    var isType = function (t) {\r\n      return function (element) {\r\n        return type(element) === t;\r\n      };\r\n    };\r\n    var isComment$1 = function (element) {\r\n      return type(element) === COMMENT || name(element) === '#comment';\r\n    };\r\n    var isElement$6 = isType(ELEMENT);\r\n    var isText$8 = isType(TEXT);\r\n    var isDocument$2 = isType(DOCUMENT);\r\n    var isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\r\n    var isTag = function (tag) {\r\n      return function (e) {\r\n        return isElement$6(e) && name(e) === tag;\r\n      };\r\n    };\r\n\r\n    var owner$1 = function (element) {\r\n      return SugarElement.fromDom(element.dom.ownerDocument);\r\n    };\r\n    var documentOrOwner = function (dos) {\r\n      return isDocument$2(dos) ? dos : owner$1(dos);\r\n    };\r\n    var documentElement = function (element) {\r\n      return SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\r\n    };\r\n    var defaultView = function (element) {\r\n      return SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\r\n    };\r\n    var parent = function (element) {\r\n      return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\r\n    };\r\n    var parents$1 = function (element, isRoot) {\r\n      var stop = isFunction(isRoot) ? isRoot : never;\r\n      var dom = element.dom;\r\n      var ret = [];\r\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\r\n        var rawParent = dom.parentNode;\r\n        var p = SugarElement.fromDom(rawParent);\r\n        ret.push(p);\r\n        if (stop(p) === true) {\r\n          break;\r\n        } else {\r\n          dom = rawParent;\r\n        }\r\n      }\r\n      return ret;\r\n    };\r\n    var siblings = function (element) {\r\n      var filterSelf = function (elements) {\r\n        return filter$4(elements, function (x) {\r\n          return !eq(element, x);\r\n        });\r\n      };\r\n      return parent(element).map(children).map(filterSelf).getOr([]);\r\n    };\r\n    var prevSibling = function (element) {\r\n      return Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\r\n    };\r\n    var nextSibling = function (element) {\r\n      return Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\r\n    };\r\n    var prevSiblings = function (element) {\r\n      return reverse(toArray(element, prevSibling));\r\n    };\r\n    var nextSiblings = function (element) {\r\n      return toArray(element, nextSibling);\r\n    };\r\n    var children = function (element) {\r\n      return map$3(element.dom.childNodes, SugarElement.fromDom);\r\n    };\r\n    var child$1 = function (element, index) {\r\n      var cs = element.dom.childNodes;\r\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\r\n    };\r\n    var firstChild = function (element) {\r\n      return child$1(element, 0);\r\n    };\r\n    var lastChild = function (element) {\r\n      return child$1(element, element.dom.childNodes.length - 1);\r\n    };\r\n    var childNodesCount = function (element) {\r\n      return element.dom.childNodes.length;\r\n    };\r\n\r\n    var getHead = function (doc) {\r\n      var b = doc.dom.head;\r\n      if (b === null || b === undefined) {\r\n        throw new Error('Head is not available yet');\r\n      }\r\n      return SugarElement.fromDom(b);\r\n    };\r\n\r\n    var isShadowRoot = function (dos) {\r\n      return isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\r\n    };\r\n    var supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\r\n    var isSupported$1 = constant(supported);\r\n    var getRootNode = supported ? function (e) {\r\n      return SugarElement.fromDom(e.dom.getRootNode());\r\n    } : documentOrOwner;\r\n    var getStyleContainer = function (dos) {\r\n      return isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\r\n    };\r\n    var getShadowRoot = function (e) {\r\n      var r = getRootNode(e);\r\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\r\n    };\r\n    var getShadowHost = function (e) {\r\n      return SugarElement.fromDom(e.dom.host);\r\n    };\r\n    var getOriginalEventTarget = function (event) {\r\n      if (isSupported$1() && isNonNullable(event.target)) {\r\n        var el = SugarElement.fromDom(event.target);\r\n        if (isElement$6(el) && isOpenShadowHost(el)) {\r\n          if (event.composed && event.composedPath) {\r\n            var composedPath = event.composedPath();\r\n            if (composedPath) {\r\n              return head(composedPath);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return Optional.from(event.target);\r\n    };\r\n    var isOpenShadowHost = function (element) {\r\n      return isNonNullable(element.dom.shadowRoot);\r\n    };\r\n\r\n    var before$4 = function (marker, element) {\r\n      var parent$1 = parent(marker);\r\n      parent$1.each(function (v) {\r\n        v.dom.insertBefore(element.dom, marker.dom);\r\n      });\r\n    };\r\n    var after$3 = function (marker, element) {\r\n      var sibling = nextSibling(marker);\r\n      sibling.fold(function () {\r\n        var parent$1 = parent(marker);\r\n        parent$1.each(function (v) {\r\n          append$1(v, element);\r\n        });\r\n      }, function (v) {\r\n        before$4(v, element);\r\n      });\r\n    };\r\n    var prepend = function (parent, element) {\r\n      var firstChild$1 = firstChild(parent);\r\n      firstChild$1.fold(function () {\r\n        append$1(parent, element);\r\n      }, function (v) {\r\n        parent.dom.insertBefore(element.dom, v.dom);\r\n      });\r\n    };\r\n    var append$1 = function (parent, element) {\r\n      parent.dom.appendChild(element.dom);\r\n    };\r\n    var wrap$3 = function (element, wrapper) {\r\n      before$4(element, wrapper);\r\n      append$1(wrapper, element);\r\n    };\r\n\r\n    var before$3 = function (marker, elements) {\r\n      each$k(elements, function (x) {\r\n        before$4(marker, x);\r\n      });\r\n    };\r\n    var append = function (parent, elements) {\r\n      each$k(elements, function (x) {\r\n        append$1(parent, x);\r\n      });\r\n    };\r\n\r\n    var empty = function (element) {\r\n      element.dom.textContent = '';\r\n      each$k(children(element), function (rogue) {\r\n        remove$7(rogue);\r\n      });\r\n    };\r\n    var remove$7 = function (element) {\r\n      var dom = element.dom;\r\n      if (dom.parentNode !== null) {\r\n        dom.parentNode.removeChild(dom);\r\n      }\r\n    };\r\n    var unwrap = function (wrapper) {\r\n      var children$1 = children(wrapper);\r\n      if (children$1.length > 0) {\r\n        before$3(wrapper, children$1);\r\n      }\r\n      remove$7(wrapper);\r\n    };\r\n\r\n    var inBody = function (element) {\r\n      var dom = isText$8(element) ? element.dom.parentNode : element.dom;\r\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\r\n        return false;\r\n      }\r\n      var doc = dom.ownerDocument;\r\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(function () {\r\n        return doc.body.contains(dom);\r\n      }, compose1(inBody, getShadowHost));\r\n    };\r\n\r\n    var r = function (left, top) {\r\n      var translate = function (x, y) {\r\n        return r(left + x, top + y);\r\n      };\r\n      return {\r\n        left: left,\r\n        top: top,\r\n        translate: translate\r\n      };\r\n    };\r\n    var SugarPosition = r;\r\n\r\n    var boxPosition = function (dom) {\r\n      var box = dom.getBoundingClientRect();\r\n      return SugarPosition(box.left, box.top);\r\n    };\r\n    var firstDefinedOrZero = function (a, b) {\r\n      if (a !== undefined) {\r\n        return a;\r\n      } else {\r\n        return b !== undefined ? b : 0;\r\n      }\r\n    };\r\n    var absolute = function (element) {\r\n      var doc = element.dom.ownerDocument;\r\n      var body = doc.body;\r\n      var win = doc.defaultView;\r\n      var html = doc.documentElement;\r\n      if (body === element.dom) {\r\n        return SugarPosition(body.offsetLeft, body.offsetTop);\r\n      }\r\n      var scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\r\n      var scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\r\n      var clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\r\n      var clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\r\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\r\n    };\r\n    var viewport = function (element) {\r\n      var dom = element.dom;\r\n      var doc = dom.ownerDocument;\r\n      var body = doc.body;\r\n      if (body === dom) {\r\n        return SugarPosition(body.offsetLeft, body.offsetTop);\r\n      }\r\n      if (!inBody(element)) {\r\n        return SugarPosition(0, 0);\r\n      }\r\n      return boxPosition(dom);\r\n    };\r\n\r\n    var get$8 = function (_DOC) {\r\n      var doc = _DOC !== undefined ? _DOC.dom : document;\r\n      var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\r\n      var y = doc.body.scrollTop || doc.documentElement.scrollTop;\r\n      return SugarPosition(x, y);\r\n    };\r\n    var to = function (x, y, _DOC) {\r\n      var doc = _DOC !== undefined ? _DOC.dom : document;\r\n      var win = doc.defaultView;\r\n      if (win) {\r\n        win.scrollTo(x, y);\r\n      }\r\n    };\r\n    var intoView = function (element, alignToTop) {\r\n      var isSafari = detect().browser.isSafari();\r\n      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\r\n        element.dom.scrollIntoViewIfNeeded(false);\r\n      } else {\r\n        element.dom.scrollIntoView(alignToTop);\r\n      }\r\n    };\r\n\r\n    var get$7 = function (_win) {\r\n      var win = _win === undefined ? window : _win;\r\n      if (detect().browser.isFirefox()) {\r\n        return Optional.none();\r\n      } else {\r\n        return Optional.from(win['visualViewport']);\r\n      }\r\n    };\r\n    var bounds = function (x, y, width, height) {\r\n      return {\r\n        x: x,\r\n        y: y,\r\n        width: width,\r\n        height: height,\r\n        right: x + width,\r\n        bottom: y + height\r\n      };\r\n    };\r\n    var getBounds = function (_win) {\r\n      var win = _win === undefined ? window : _win;\r\n      var doc = win.document;\r\n      var scroll = get$8(SugarElement.fromDom(doc));\r\n      return get$7(win).fold(function () {\r\n        var html = win.document.documentElement;\r\n        var width = html.clientWidth;\r\n        var height = html.clientHeight;\r\n        return bounds(scroll.left, scroll.top, width, height);\r\n      }, function (visualViewport) {\r\n        return bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height);\r\n      });\r\n    };\r\n\r\n    var isNodeType = function (type) {\r\n      return function (node) {\r\n        return !!node && node.nodeType === type;\r\n      };\r\n    };\r\n    var isRestrictedNode = function (node) {\r\n      return !!node && !Object.getPrototypeOf(node);\r\n    };\r\n    var isElement$5 = isNodeType(1);\r\n    var matchNodeNames = function (names) {\r\n      var lowercasedNames = names.map(function (s) {\r\n        return s.toLowerCase();\r\n      });\r\n      return function (node) {\r\n        if (node && node.nodeName) {\r\n          var nodeName = node.nodeName.toLowerCase();\r\n          return contains$3(lowercasedNames, nodeName);\r\n        }\r\n        return false;\r\n      };\r\n    };\r\n    var matchStyleValues = function (name, values) {\r\n      var items = values.toLowerCase().split(' ');\r\n      return function (node) {\r\n        if (isElement$5(node)) {\r\n          for (var i = 0; i < items.length; i++) {\r\n            var computed = node.ownerDocument.defaultView.getComputedStyle(node, null);\r\n            var cssValue = computed ? computed.getPropertyValue(name) : null;\r\n            if (cssValue === items[i]) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n    };\r\n    var hasAttribute = function (attrName) {\r\n      return function (node) {\r\n        return isElement$5(node) && node.hasAttribute(attrName);\r\n      };\r\n    };\r\n    var hasAttributeValue = function (attrName, attrValue) {\r\n      return function (node) {\r\n        return isElement$5(node) && node.getAttribute(attrName) === attrValue;\r\n      };\r\n    };\r\n    var isBogus$2 = function (node) {\r\n      return isElement$5(node) && node.hasAttribute('data-mce-bogus');\r\n    };\r\n    var isBogusAll$1 = function (node) {\r\n      return isElement$5(node) && node.getAttribute('data-mce-bogus') === 'all';\r\n    };\r\n    var isTable$3 = function (node) {\r\n      return isElement$5(node) && node.tagName === 'TABLE';\r\n    };\r\n    var hasContentEditableState = function (value) {\r\n      return function (node) {\r\n        if (isElement$5(node)) {\r\n          if (node.contentEditable === value) {\r\n            return true;\r\n          }\r\n          if (node.getAttribute('data-mce-contenteditable') === value) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n    };\r\n    var isTextareaOrInput = matchNodeNames([\r\n      'textarea',\r\n      'input'\r\n    ]);\r\n    var isText$7 = isNodeType(3);\r\n    var isComment = isNodeType(8);\r\n    var isDocument$1 = isNodeType(9);\r\n    var isDocumentFragment = isNodeType(11);\r\n    var isBr$5 = matchNodeNames(['br']);\r\n    var isImg = matchNodeNames(['img']);\r\n    var isContentEditableTrue$4 = hasContentEditableState('true');\r\n    var isContentEditableFalse$b = hasContentEditableState('false');\r\n    var isTableCell$5 = matchNodeNames([\r\n      'td',\r\n      'th'\r\n    ]);\r\n    var isMedia$2 = matchNodeNames([\r\n      'video',\r\n      'audio',\r\n      'object',\r\n      'embed'\r\n    ]);\r\n\r\n    var is$1 = function (lhs, rhs, comparator) {\r\n      if (comparator === void 0) {\r\n        comparator = tripleEquals;\r\n      }\r\n      return lhs.exists(function (left) {\r\n        return comparator(left, rhs);\r\n      });\r\n    };\r\n    var cat = function (arr) {\r\n      var r = [];\r\n      var push = function (x) {\r\n        r.push(x);\r\n      };\r\n      for (var i = 0; i < arr.length; i++) {\r\n        arr[i].each(push);\r\n      }\r\n      return r;\r\n    };\r\n    var lift2 = function (oa, ob, f) {\r\n      return oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\r\n    };\r\n    var lift3 = function (oa, ob, oc, f) {\r\n      return oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\r\n    };\r\n    var someIf = function (b, a) {\r\n      return b ? Optional.some(a) : Optional.none();\r\n    };\r\n\r\n    var isSupported = function (dom) {\r\n      return dom.style !== undefined && isFunction(dom.style.getPropertyValue);\r\n    };\r\n\r\n    var rawSet = function (dom, key, value) {\r\n      if (isString$1(value) || isBoolean(value) || isNumber(value)) {\r\n        dom.setAttribute(key, value + '');\r\n      } else {\r\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\r\n        throw new Error('Attribute value was not simple');\r\n      }\r\n    };\r\n    var set$1 = function (element, key, value) {\r\n      rawSet(element.dom, key, value);\r\n    };\r\n    var setAll$1 = function (element, attrs) {\r\n      var dom = element.dom;\r\n      each$j(attrs, function (v, k) {\r\n        rawSet(dom, k, v);\r\n      });\r\n    };\r\n    var get$6 = function (element, key) {\r\n      var v = element.dom.getAttribute(key);\r\n      return v === null ? undefined : v;\r\n    };\r\n    var getOpt = function (element, key) {\r\n      return Optional.from(get$6(element, key));\r\n    };\r\n    var has$1 = function (element, key) {\r\n      var dom = element.dom;\r\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\r\n    };\r\n    var remove$6 = function (element, key) {\r\n      element.dom.removeAttribute(key);\r\n    };\r\n    var clone$3 = function (element) {\r\n      return foldl(element.dom.attributes, function (acc, attr) {\r\n        acc[attr.name] = attr.value;\r\n        return acc;\r\n      }, {});\r\n    };\r\n\r\n    var internalSet = function (dom, property, value) {\r\n      if (!isString$1(value)) {\r\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\r\n        throw new Error('CSS value must be a string: ' + value);\r\n      }\r\n      if (isSupported(dom)) {\r\n        dom.style.setProperty(property, value);\r\n      }\r\n    };\r\n    var setAll = function (element, css) {\r\n      var dom = element.dom;\r\n      each$j(css, function (v, k) {\r\n        internalSet(dom, k, v);\r\n      });\r\n    };\r\n    var get$5 = function (element, property) {\r\n      var dom = element.dom;\r\n      var styles = window.getComputedStyle(dom);\r\n      var r = styles.getPropertyValue(property);\r\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\r\n    };\r\n    var getUnsafeProperty = function (dom, property) {\r\n      return isSupported(dom) ? dom.style.getPropertyValue(property) : '';\r\n    };\r\n    var getRaw = function (element, property) {\r\n      var dom = element.dom;\r\n      var raw = getUnsafeProperty(dom, property);\r\n      return Optional.from(raw).filter(function (r) {\r\n        return r.length > 0;\r\n      });\r\n    };\r\n    var getAllRaw = function (element) {\r\n      var css = {};\r\n      var dom = element.dom;\r\n      if (isSupported(dom)) {\r\n        for (var i = 0; i < dom.style.length; i++) {\r\n          var ruleName = dom.style.item(i);\r\n          css[ruleName] = dom.style[ruleName];\r\n        }\r\n      }\r\n      return css;\r\n    };\r\n    var reflow = function (e) {\r\n      return e.dom.offsetWidth;\r\n    };\r\n\r\n    var browser$3 = detect().browser;\r\n    var firstElement = function (nodes) {\r\n      return find$3(nodes, isElement$6);\r\n    };\r\n    var getTableCaptionDeltaY = function (elm) {\r\n      if (browser$3.isFirefox() && name(elm) === 'table') {\r\n        return firstElement(children(elm)).filter(function (elm) {\r\n          return name(elm) === 'caption';\r\n        }).bind(function (caption) {\r\n          return firstElement(nextSiblings(caption)).map(function (body) {\r\n            var bodyTop = body.dom.offsetTop;\r\n            var captionTop = caption.dom.offsetTop;\r\n            var captionHeight = caption.dom.offsetHeight;\r\n            return bodyTop <= captionTop ? -captionHeight : 0;\r\n          });\r\n        }).getOr(0);\r\n      } else {\r\n        return 0;\r\n      }\r\n    };\r\n    var hasChild = function (elm, child) {\r\n      return elm.children && contains$3(elm.children, child);\r\n    };\r\n    var getPos = function (body, elm, rootElm) {\r\n      var x = 0, y = 0;\r\n      var doc = body.ownerDocument;\r\n      rootElm = rootElm ? rootElm : body;\r\n      if (elm) {\r\n        if (rootElm === body && elm.getBoundingClientRect && get$5(SugarElement.fromDom(body), 'position') === 'static') {\r\n          var pos = elm.getBoundingClientRect();\r\n          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\r\n          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\r\n          return {\r\n            x: x,\r\n            y: y\r\n          };\r\n        }\r\n        var offsetParent = elm;\r\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\r\n          var castOffsetParent = offsetParent;\r\n          x += castOffsetParent.offsetLeft || 0;\r\n          y += castOffsetParent.offsetTop || 0;\r\n          offsetParent = castOffsetParent.offsetParent;\r\n        }\r\n        offsetParent = elm.parentNode;\r\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\r\n          x -= offsetParent.scrollLeft || 0;\r\n          y -= offsetParent.scrollTop || 0;\r\n          offsetParent = offsetParent.parentNode;\r\n        }\r\n        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\r\n      }\r\n      return {\r\n        x: x,\r\n        y: y\r\n      };\r\n    };\r\n\r\n    var exports$1 = {}, module$1 = { exports: exports$1 };\r\n    (function (define, exports, module, require) {\r\n      (function (global, factory) {\r\n        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.EphoxContactWrapper = factory());\r\n      }(this, function () {\r\n        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\r\n        var promise = { exports: {} };\r\n        (function (module) {\r\n          (function (root) {\r\n            var setTimeoutFunc = setTimeout;\r\n            function noop() {\r\n            }\r\n            function bind(fn, thisArg) {\r\n              return function () {\r\n                fn.apply(thisArg, arguments);\r\n              };\r\n            }\r\n            function Promise(fn) {\r\n              if (typeof this !== 'object')\r\n                throw new TypeError('Promises must be constructed via new');\r\n              if (typeof fn !== 'function')\r\n                throw new TypeError('not a function');\r\n              this._state = 0;\r\n              this._handled = false;\r\n              this._value = undefined;\r\n              this._deferreds = [];\r\n              doResolve(fn, this);\r\n            }\r\n            function handle(self, deferred) {\r\n              while (self._state === 3) {\r\n                self = self._value;\r\n              }\r\n              if (self._state === 0) {\r\n                self._deferreds.push(deferred);\r\n                return;\r\n              }\r\n              self._handled = true;\r\n              Promise._immediateFn(function () {\r\n                var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\r\n                if (cb === null) {\r\n                  (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\r\n                  return;\r\n                }\r\n                var ret;\r\n                try {\r\n                  ret = cb(self._value);\r\n                } catch (e) {\r\n                  reject(deferred.promise, e);\r\n                  return;\r\n                }\r\n                resolve(deferred.promise, ret);\r\n              });\r\n            }\r\n            function resolve(self, newValue) {\r\n              try {\r\n                if (newValue === self)\r\n                  throw new TypeError('A promise cannot be resolved with itself.');\r\n                if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\r\n                  var then = newValue.then;\r\n                  if (newValue instanceof Promise) {\r\n                    self._state = 3;\r\n                    self._value = newValue;\r\n                    finale(self);\r\n                    return;\r\n                  } else if (typeof then === 'function') {\r\n                    doResolve(bind(then, newValue), self);\r\n                    return;\r\n                  }\r\n                }\r\n                self._state = 1;\r\n                self._value = newValue;\r\n                finale(self);\r\n              } catch (e) {\r\n                reject(self, e);\r\n              }\r\n            }\r\n            function reject(self, newValue) {\r\n              self._state = 2;\r\n              self._value = newValue;\r\n              finale(self);\r\n            }\r\n            function finale(self) {\r\n              if (self._state === 2 && self._deferreds.length === 0) {\r\n                Promise._immediateFn(function () {\r\n                  if (!self._handled) {\r\n                    Promise._unhandledRejectionFn(self._value);\r\n                  }\r\n                });\r\n              }\r\n              for (var i = 0, len = self._deferreds.length; i < len; i++) {\r\n                handle(self, self._deferreds[i]);\r\n              }\r\n              self._deferreds = null;\r\n            }\r\n            function Handler(onFulfilled, onRejected, promise) {\r\n              this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\r\n              this.onRejected = typeof onRejected === 'function' ? onRejected : null;\r\n              this.promise = promise;\r\n            }\r\n            function doResolve(fn, self) {\r\n              var done = false;\r\n              try {\r\n                fn(function (value) {\r\n                  if (done)\r\n                    return;\r\n                  done = true;\r\n                  resolve(self, value);\r\n                }, function (reason) {\r\n                  if (done)\r\n                    return;\r\n                  done = true;\r\n                  reject(self, reason);\r\n                });\r\n              } catch (ex) {\r\n                if (done)\r\n                  return;\r\n                done = true;\r\n                reject(self, ex);\r\n              }\r\n            }\r\n            Promise.prototype['catch'] = function (onRejected) {\r\n              return this.then(null, onRejected);\r\n            };\r\n            Promise.prototype.then = function (onFulfilled, onRejected) {\r\n              var prom = new this.constructor(noop);\r\n              handle(this, new Handler(onFulfilled, onRejected, prom));\r\n              return prom;\r\n            };\r\n            Promise.all = function (arr) {\r\n              var args = Array.prototype.slice.call(arr);\r\n              return new Promise(function (resolve, reject) {\r\n                if (args.length === 0)\r\n                  return resolve([]);\r\n                var remaining = args.length;\r\n                function res(i, val) {\r\n                  try {\r\n                    if (val && (typeof val === 'object' || typeof val === 'function')) {\r\n                      var then = val.then;\r\n                      if (typeof then === 'function') {\r\n                        then.call(val, function (val) {\r\n                          res(i, val);\r\n                        }, reject);\r\n                        return;\r\n                      }\r\n                    }\r\n                    args[i] = val;\r\n                    if (--remaining === 0) {\r\n                      resolve(args);\r\n                    }\r\n                  } catch (ex) {\r\n                    reject(ex);\r\n                  }\r\n                }\r\n                for (var i = 0; i < args.length; i++) {\r\n                  res(i, args[i]);\r\n                }\r\n              });\r\n            };\r\n            Promise.resolve = function (value) {\r\n              if (value && typeof value === 'object' && value.constructor === Promise) {\r\n                return value;\r\n              }\r\n              return new Promise(function (resolve) {\r\n                resolve(value);\r\n              });\r\n            };\r\n            Promise.reject = function (value) {\r\n              return new Promise(function (resolve, reject) {\r\n                reject(value);\r\n              });\r\n            };\r\n            Promise.race = function (values) {\r\n              return new Promise(function (resolve, reject) {\r\n                for (var i = 0, len = values.length; i < len; i++) {\r\n                  values[i].then(resolve, reject);\r\n                }\r\n              });\r\n            };\r\n            Promise._immediateFn = typeof setImmediate === 'function' ? function (fn) {\r\n              setImmediate(fn);\r\n            } : function (fn) {\r\n              setTimeoutFunc(fn, 0);\r\n            };\r\n            Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\r\n              if (typeof console !== 'undefined' && console) {\r\n                console.warn('Possible Unhandled Promise Rejection:', err);\r\n              }\r\n            };\r\n            Promise._setImmediateFn = function _setImmediateFn(fn) {\r\n              Promise._immediateFn = fn;\r\n            };\r\n            Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {\r\n              Promise._unhandledRejectionFn = fn;\r\n            };\r\n            if (module.exports) {\r\n              module.exports = Promise;\r\n            } else if (!root.Promise) {\r\n              root.Promise = Promise;\r\n            }\r\n          }(commonjsGlobal));\r\n        }(promise));\r\n        var promisePolyfill = promise.exports;\r\n        var Global = function () {\r\n          if (typeof window !== 'undefined') {\r\n            return window;\r\n          } else {\r\n            return Function('return this;')();\r\n          }\r\n        }();\r\n        var promisePolyfill_1 = { boltExport: Global.Promise || promisePolyfill };\r\n        return promisePolyfill_1;\r\n      }));\r\n    }(undefined, exports$1, module$1));\r\n    var Promise$1 = module$1.exports.boltExport;\r\n\r\n    var nu$1 = function (baseFn) {\r\n      var data = Optional.none();\r\n      var callbacks = [];\r\n      var map = function (f) {\r\n        return nu$1(function (nCallback) {\r\n          get(function (data) {\r\n            nCallback(f(data));\r\n          });\r\n        });\r\n      };\r\n      var get = function (nCallback) {\r\n        if (isReady()) {\r\n          call(nCallback);\r\n        } else {\r\n          callbacks.push(nCallback);\r\n        }\r\n      };\r\n      var set = function (x) {\r\n        if (!isReady()) {\r\n          data = Optional.some(x);\r\n          run(callbacks);\r\n          callbacks = [];\r\n        }\r\n      };\r\n      var isReady = function () {\r\n        return data.isSome();\r\n      };\r\n      var run = function (cbs) {\r\n        each$k(cbs, call);\r\n      };\r\n      var call = function (cb) {\r\n        data.each(function (x) {\r\n          setTimeout(function () {\r\n            cb(x);\r\n          }, 0);\r\n        });\r\n      };\r\n      baseFn(set);\r\n      return {\r\n        get: get,\r\n        map: map,\r\n        isReady: isReady\r\n      };\r\n    };\r\n    var pure$1 = function (a) {\r\n      return nu$1(function (callback) {\r\n        callback(a);\r\n      });\r\n    };\r\n    var LazyValue = {\r\n      nu: nu$1,\r\n      pure: pure$1\r\n    };\r\n\r\n    var errorReporter = function (err) {\r\n      setTimeout(function () {\r\n        throw err;\r\n      }, 0);\r\n    };\r\n    var make = function (run) {\r\n      var get = function (callback) {\r\n        run().then(callback, errorReporter);\r\n      };\r\n      var map = function (fab) {\r\n        return make(function () {\r\n          return run().then(fab);\r\n        });\r\n      };\r\n      var bind = function (aFutureB) {\r\n        return make(function () {\r\n          return run().then(function (v) {\r\n            return aFutureB(v).toPromise();\r\n          });\r\n        });\r\n      };\r\n      var anonBind = function (futureB) {\r\n        return make(function () {\r\n          return run().then(function () {\r\n            return futureB.toPromise();\r\n          });\r\n        });\r\n      };\r\n      var toLazy = function () {\r\n        return LazyValue.nu(get);\r\n      };\r\n      var toCached = function () {\r\n        var cache = null;\r\n        return make(function () {\r\n          if (cache === null) {\r\n            cache = run();\r\n          }\r\n          return cache;\r\n        });\r\n      };\r\n      var toPromise = run;\r\n      return {\r\n        map: map,\r\n        bind: bind,\r\n        anonBind: anonBind,\r\n        toLazy: toLazy,\r\n        toCached: toCached,\r\n        toPromise: toPromise,\r\n        get: get\r\n      };\r\n    };\r\n    var nu = function (baseFn) {\r\n      return make(function () {\r\n        return new Promise$1(baseFn);\r\n      });\r\n    };\r\n    var pure = function (a) {\r\n      return make(function () {\r\n        return Promise$1.resolve(a);\r\n      });\r\n    };\r\n    var Future = {\r\n      nu: nu,\r\n      pure: pure\r\n    };\r\n\r\n    var par$1 = function (asyncValues, nu) {\r\n      return nu(function (callback) {\r\n        var r = [];\r\n        var count = 0;\r\n        var cb = function (i) {\r\n          return function (value) {\r\n            r[i] = value;\r\n            count++;\r\n            if (count >= asyncValues.length) {\r\n              callback(r);\r\n            }\r\n          };\r\n        };\r\n        if (asyncValues.length === 0) {\r\n          callback([]);\r\n        } else {\r\n          each$k(asyncValues, function (asyncValue, i) {\r\n            asyncValue.get(cb(i));\r\n          });\r\n        }\r\n      });\r\n    };\r\n\r\n    var par = function (futures) {\r\n      return par$1(futures, Future.nu);\r\n    };\r\n\r\n    var value$1 = function (o) {\r\n      var or = function (_opt) {\r\n        return value$1(o);\r\n      };\r\n      var orThunk = function (_f) {\r\n        return value$1(o);\r\n      };\r\n      var map = function (f) {\r\n        return value$1(f(o));\r\n      };\r\n      var mapError = function (_f) {\r\n        return value$1(o);\r\n      };\r\n      var each = function (f) {\r\n        f(o);\r\n      };\r\n      var bind = function (f) {\r\n        return f(o);\r\n      };\r\n      var fold = function (_, onValue) {\r\n        return onValue(o);\r\n      };\r\n      var exists = function (f) {\r\n        return f(o);\r\n      };\r\n      var forall = function (f) {\r\n        return f(o);\r\n      };\r\n      var toOptional = function () {\r\n        return Optional.some(o);\r\n      };\r\n      return {\r\n        isValue: always,\r\n        isError: never,\r\n        getOr: constant(o),\r\n        getOrThunk: constant(o),\r\n        getOrDie: constant(o),\r\n        or: or,\r\n        orThunk: orThunk,\r\n        fold: fold,\r\n        map: map,\r\n        mapError: mapError,\r\n        each: each,\r\n        bind: bind,\r\n        exists: exists,\r\n        forall: forall,\r\n        toOptional: toOptional\r\n      };\r\n    };\r\n    var error = function (message) {\r\n      var getOrThunk = function (f) {\r\n        return f();\r\n      };\r\n      var getOrDie = function () {\r\n        return die(String(message))();\r\n      };\r\n      var or = identity;\r\n      var orThunk = function (f) {\r\n        return f();\r\n      };\r\n      var map = function (_f) {\r\n        return error(message);\r\n      };\r\n      var mapError = function (f) {\r\n        return error(f(message));\r\n      };\r\n      var bind = function (_f) {\r\n        return error(message);\r\n      };\r\n      var fold = function (onError, _) {\r\n        return onError(message);\r\n      };\r\n      return {\r\n        isValue: never,\r\n        isError: always,\r\n        getOr: identity,\r\n        getOrThunk: getOrThunk,\r\n        getOrDie: getOrDie,\r\n        or: or,\r\n        orThunk: orThunk,\r\n        fold: fold,\r\n        map: map,\r\n        mapError: mapError,\r\n        each: noop,\r\n        bind: bind,\r\n        exists: never,\r\n        forall: always,\r\n        toOptional: Optional.none\r\n      };\r\n    };\r\n    var fromOption = function (opt, err) {\r\n      return opt.fold(function () {\r\n        return error(err);\r\n      }, value$1);\r\n    };\r\n    var Result = {\r\n      value: value$1,\r\n      error: error,\r\n      fromOption: fromOption\r\n    };\r\n\r\n    var generate$1 = function (cases) {\r\n      if (!isArray$1(cases)) {\r\n        throw new Error('cases must be an array');\r\n      }\r\n      if (cases.length === 0) {\r\n        throw new Error('there must be at least one case');\r\n      }\r\n      var constructors = [];\r\n      var adt = {};\r\n      each$k(cases, function (acase, count) {\r\n        var keys$1 = keys(acase);\r\n        if (keys$1.length !== 1) {\r\n          throw new Error('one and only one name per case');\r\n        }\r\n        var key = keys$1[0];\r\n        var value = acase[key];\r\n        if (adt[key] !== undefined) {\r\n          throw new Error('duplicate key detected:' + key);\r\n        } else if (key === 'cata') {\r\n          throw new Error('cannot have a case named cata (sorry)');\r\n        } else if (!isArray$1(value)) {\r\n          throw new Error('case arguments must be an array');\r\n        }\r\n        constructors.push(key);\r\n        adt[key] = function () {\r\n          var args = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n          }\r\n          var argLength = args.length;\r\n          if (argLength !== value.length) {\r\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\r\n          }\r\n          var match = function (branches) {\r\n            var branchKeys = keys(branches);\r\n            if (constructors.length !== branchKeys.length) {\r\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\r\n            }\r\n            var allReqd = forall(constructors, function (reqKey) {\r\n              return contains$3(branchKeys, reqKey);\r\n            });\r\n            if (!allReqd) {\r\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\r\n            }\r\n            return branches[key].apply(null, args);\r\n          };\r\n          return {\r\n            fold: function () {\r\n              var foldArgs = [];\r\n              for (var _i = 0; _i < arguments.length; _i++) {\r\n                foldArgs[_i] = arguments[_i];\r\n              }\r\n              if (foldArgs.length !== cases.length) {\r\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\r\n              }\r\n              var target = foldArgs[count];\r\n              return target.apply(null, args);\r\n            },\r\n            match: match,\r\n            log: function (label) {\r\n              console.log(label, {\r\n                constructors: constructors,\r\n                constructor: key,\r\n                params: args\r\n              });\r\n            }\r\n          };\r\n        };\r\n      });\r\n      return adt;\r\n    };\r\n    var Adt = { generate: generate$1 };\r\n\r\n    Adt.generate([\r\n      {\r\n        bothErrors: [\r\n          'error1',\r\n          'error2'\r\n        ]\r\n      },\r\n      {\r\n        firstError: [\r\n          'error1',\r\n          'value2'\r\n        ]\r\n      },\r\n      {\r\n        secondError: [\r\n          'value1',\r\n          'error2'\r\n        ]\r\n      },\r\n      {\r\n        bothValues: [\r\n          'value1',\r\n          'value2'\r\n        ]\r\n      }\r\n    ]);\r\n    var unite = function (result) {\r\n      return result.fold(identity, identity);\r\n    };\r\n\r\n    function ClosestOrAncestor (is, ancestor, scope, a, isRoot) {\r\n      if (is(scope, a)) {\r\n        return Optional.some(scope);\r\n      } else if (isFunction(isRoot) && isRoot(scope)) {\r\n        return Optional.none();\r\n      } else {\r\n        return ancestor(scope, a, isRoot);\r\n      }\r\n    }\r\n\r\n    var ancestor$3 = function (scope, predicate, isRoot) {\r\n      var element = scope.dom;\r\n      var stop = isFunction(isRoot) ? isRoot : never;\r\n      while (element.parentNode) {\r\n        element = element.parentNode;\r\n        var el = SugarElement.fromDom(element);\r\n        if (predicate(el)) {\r\n          return Optional.some(el);\r\n        } else if (stop(el)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var closest$3 = function (scope, predicate, isRoot) {\r\n      var is = function (s, test) {\r\n        return test(s);\r\n      };\r\n      return ClosestOrAncestor(is, ancestor$3, scope, predicate, isRoot);\r\n    };\r\n    var sibling$2 = function (scope, predicate) {\r\n      var element = scope.dom;\r\n      if (!element.parentNode) {\r\n        return Optional.none();\r\n      }\r\n      return child(SugarElement.fromDom(element.parentNode), function (x) {\r\n        return !eq(scope, x) && predicate(x);\r\n      });\r\n    };\r\n    var child = function (scope, predicate) {\r\n      var pred = function (node) {\r\n        return predicate(SugarElement.fromDom(node));\r\n      };\r\n      var result = find$3(scope.dom.childNodes, pred);\r\n      return result.map(SugarElement.fromDom);\r\n    };\r\n\r\n    var ancestor$2 = function (scope, selector, isRoot) {\r\n      return ancestor$3(scope, function (e) {\r\n        return is$2(e, selector);\r\n      }, isRoot);\r\n    };\r\n    var descendant = function (scope, selector) {\r\n      return one(selector, scope);\r\n    };\r\n    var closest$2 = function (scope, selector, isRoot) {\r\n      var is = function (element, selector) {\r\n        return is$2(element, selector);\r\n      };\r\n      return ClosestOrAncestor(is, ancestor$2, scope, selector, isRoot);\r\n    };\r\n\r\n    var promiseObj = window.Promise ? window.Promise : Promise$1;\r\n\r\n    var requestAnimationFramePromise;\r\n    var requestAnimationFrame = function (callback, element) {\r\n      var requestAnimationFrameFunc = window.requestAnimationFrame;\r\n      var vendors = [\r\n        'ms',\r\n        'moz',\r\n        'webkit'\r\n      ];\r\n      var featurefill = function (cb) {\r\n        window.setTimeout(cb, 0);\r\n      };\r\n      for (var i = 0; i < vendors.length && !requestAnimationFrameFunc; i++) {\r\n        requestAnimationFrameFunc = window[vendors[i] + 'RequestAnimationFrame'];\r\n      }\r\n      if (!requestAnimationFrameFunc) {\r\n        requestAnimationFrameFunc = featurefill;\r\n      }\r\n      requestAnimationFrameFunc(callback, element);\r\n    };\r\n    var wrappedSetTimeout = function (callback, time) {\r\n      if (typeof time !== 'number') {\r\n        time = 0;\r\n      }\r\n      return setTimeout(callback, time);\r\n    };\r\n    var wrappedSetInterval = function (callback, time) {\r\n      if (typeof time !== 'number') {\r\n        time = 1;\r\n      }\r\n      return setInterval(callback, time);\r\n    };\r\n    var wrappedClearTimeout = function (id) {\r\n      return clearTimeout(id);\r\n    };\r\n    var wrappedClearInterval = function (id) {\r\n      return clearInterval(id);\r\n    };\r\n    var debounce = function (callback, time) {\r\n      var timer;\r\n      var func = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        clearTimeout(timer);\r\n        timer = wrappedSetTimeout(function () {\r\n          callback.apply(this, args);\r\n        }, time);\r\n      };\r\n      func.stop = function () {\r\n        clearTimeout(timer);\r\n      };\r\n      return func;\r\n    };\r\n    var Delay = {\r\n      requestAnimationFrame: function (callback, element) {\r\n        if (requestAnimationFramePromise) {\r\n          requestAnimationFramePromise.then(callback);\r\n          return;\r\n        }\r\n        requestAnimationFramePromise = new promiseObj(function (resolve) {\r\n          if (!element) {\r\n            element = document.body;\r\n          }\r\n          requestAnimationFrame(resolve, element);\r\n        }).then(callback);\r\n      },\r\n      setTimeout: wrappedSetTimeout,\r\n      setInterval: wrappedSetInterval,\r\n      setEditorTimeout: function (editor, callback, time) {\r\n        return wrappedSetTimeout(function () {\r\n          if (!editor.removed) {\r\n            callback();\r\n          }\r\n        }, time);\r\n      },\r\n      setEditorInterval: function (editor, callback, time) {\r\n        var timer = wrappedSetInterval(function () {\r\n          if (!editor.removed) {\r\n            callback();\r\n          } else {\r\n            clearInterval(timer);\r\n          }\r\n        }, time);\r\n        return timer;\r\n      },\r\n      debounce: debounce,\r\n      throttle: debounce,\r\n      clearInterval: wrappedClearInterval,\r\n      clearTimeout: wrappedClearTimeout\r\n    };\r\n\r\n    var StyleSheetLoader = function (documentOrShadowRoot, settings) {\r\n      if (settings === void 0) {\r\n        settings = {};\r\n      }\r\n      var idCount = 0;\r\n      var loadedStates = {};\r\n      var edos = SugarElement.fromDom(documentOrShadowRoot);\r\n      var doc = documentOrOwner(edos);\r\n      var maxLoadTime = settings.maxLoadTime || 5000;\r\n      var _setReferrerPolicy = function (referrerPolicy) {\r\n        settings.referrerPolicy = referrerPolicy;\r\n      };\r\n      var addStyle = function (element) {\r\n        append$1(getStyleContainer(edos), element);\r\n      };\r\n      var removeStyle = function (id) {\r\n        var styleContainer = getStyleContainer(edos);\r\n        descendant(styleContainer, '#' + id).each(remove$7);\r\n      };\r\n      var getOrCreateState = function (url) {\r\n        return get$9(loadedStates, url).getOrThunk(function () {\r\n          return {\r\n            id: 'mce-u' + idCount++,\r\n            passed: [],\r\n            failed: [],\r\n            count: 0\r\n          };\r\n        });\r\n      };\r\n      var load = function (url, success, failure) {\r\n        var link;\r\n        var urlWithSuffix = Tools._addCacheSuffix(url);\r\n        var state = getOrCreateState(urlWithSuffix);\r\n        loadedStates[urlWithSuffix] = state;\r\n        state.count++;\r\n        var resolve = function (callbacks, status) {\r\n          var i = callbacks.length;\r\n          while (i--) {\r\n            callbacks[i]();\r\n          }\r\n          state.status = status;\r\n          state.passed = [];\r\n          state.failed = [];\r\n          if (link) {\r\n            link.onload = null;\r\n            link.onerror = null;\r\n            link = null;\r\n          }\r\n        };\r\n        var passed = function () {\r\n          return resolve(state.passed, 2);\r\n        };\r\n        var failed = function () {\r\n          return resolve(state.failed, 3);\r\n        };\r\n        var wait = function (testCallback, waitCallback) {\r\n          if (!testCallback()) {\r\n            if (Date.now() - startTime < maxLoadTime) {\r\n              Delay.setTimeout(waitCallback);\r\n            } else {\r\n              failed();\r\n            }\r\n          }\r\n        };\r\n        var waitForWebKitLinkLoaded = function () {\r\n          wait(function () {\r\n            var styleSheets = documentOrShadowRoot.styleSheets;\r\n            var i = styleSheets.length;\r\n            while (i--) {\r\n              var styleSheet = styleSheets[i];\r\n              var owner = styleSheet.ownerNode;\r\n              if (owner && owner.id === link.id) {\r\n                passed();\r\n                return true;\r\n              }\r\n            }\r\n            return false;\r\n          }, waitForWebKitLinkLoaded);\r\n        };\r\n        if (success) {\r\n          state.passed.push(success);\r\n        }\r\n        if (failure) {\r\n          state.failed.push(failure);\r\n        }\r\n        if (state.status === 1) {\r\n          return;\r\n        }\r\n        if (state.status === 2) {\r\n          passed();\r\n          return;\r\n        }\r\n        if (state.status === 3) {\r\n          failed();\r\n          return;\r\n        }\r\n        state.status = 1;\r\n        var linkElem = SugarElement.fromTag('link', doc.dom);\r\n        setAll$1(linkElem, {\r\n          rel: 'stylesheet',\r\n          type: 'text/css',\r\n          id: state.id\r\n        });\r\n        var startTime = Date.now();\r\n        if (settings.contentCssCors) {\r\n          set$1(linkElem, 'crossOrigin', 'anonymous');\r\n        }\r\n        if (settings.referrerPolicy) {\r\n          set$1(linkElem, 'referrerpolicy', settings.referrerPolicy);\r\n        }\r\n        link = linkElem.dom;\r\n        link.onload = waitForWebKitLinkLoaded;\r\n        link.onerror = failed;\r\n        addStyle(linkElem);\r\n        set$1(linkElem, 'href', urlWithSuffix);\r\n      };\r\n      var loadF = function (url) {\r\n        return Future.nu(function (resolve) {\r\n          load(url, compose(resolve, constant(Result.value(url))), compose(resolve, constant(Result.error(url))));\r\n        });\r\n      };\r\n      var loadAll = function (urls, success, failure) {\r\n        par(map$3(urls, loadF)).get(function (result) {\r\n          var parts = partition(result, function (r) {\r\n            return r.isValue();\r\n          });\r\n          if (parts.fail.length > 0) {\r\n            failure(parts.fail.map(unite));\r\n          } else {\r\n            success(parts.pass.map(unite));\r\n          }\r\n        });\r\n      };\r\n      var unload = function (url) {\r\n        var urlWithSuffix = Tools._addCacheSuffix(url);\r\n        get$9(loadedStates, urlWithSuffix).each(function (state) {\r\n          var count = --state.count;\r\n          if (count === 0) {\r\n            delete loadedStates[urlWithSuffix];\r\n            removeStyle(state.id);\r\n          }\r\n        });\r\n      };\r\n      var unloadAll = function (urls) {\r\n        each$k(urls, function (url) {\r\n          unload(url);\r\n        });\r\n      };\r\n      return {\r\n        load: load,\r\n        loadAll: loadAll,\r\n        unload: unload,\r\n        unloadAll: unloadAll,\r\n        _setReferrerPolicy: _setReferrerPolicy\r\n      };\r\n    };\r\n\r\n    var create$8 = function () {\r\n      var map = new WeakMap();\r\n      var forElement = function (referenceElement, settings) {\r\n        var root = getRootNode(referenceElement);\r\n        var rootDom = root.dom;\r\n        return Optional.from(map.get(rootDom)).getOrThunk(function () {\r\n          var sl = StyleSheetLoader(rootDom, settings);\r\n          map.set(rootDom, sl);\r\n          return sl;\r\n        });\r\n      };\r\n      return { forElement: forElement };\r\n    };\r\n    var instance = create$8();\r\n\r\n    var DomTreeWalker = function () {\r\n      function DomTreeWalker(startNode, rootNode) {\r\n        this.node = startNode;\r\n        this.rootNode = rootNode;\r\n        this.current = this.current.bind(this);\r\n        this.next = this.next.bind(this);\r\n        this.prev = this.prev.bind(this);\r\n        this.prev2 = this.prev2.bind(this);\r\n      }\r\n      DomTreeWalker.prototype.current = function () {\r\n        return this.node;\r\n      };\r\n      DomTreeWalker.prototype.next = function (shallow) {\r\n        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\r\n        return this.node;\r\n      };\r\n      DomTreeWalker.prototype.prev = function (shallow) {\r\n        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\r\n        return this.node;\r\n      };\r\n      DomTreeWalker.prototype.prev2 = function (shallow) {\r\n        this.node = this.findPreviousNode(this.node, 'lastChild', 'previousSibling', shallow);\r\n        return this.node;\r\n      };\r\n      DomTreeWalker.prototype.findSibling = function (node, startName, siblingName, shallow) {\r\n        var sibling, parent;\r\n        if (node) {\r\n          if (!shallow && node[startName]) {\r\n            return node[startName];\r\n          }\r\n          if (node !== this.rootNode) {\r\n            sibling = node[siblingName];\r\n            if (sibling) {\r\n              return sibling;\r\n            }\r\n            for (parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\r\n              sibling = parent[siblingName];\r\n              if (sibling) {\r\n                return sibling;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n      DomTreeWalker.prototype.findPreviousNode = function (node, startName, siblingName, shallow) {\r\n        var sibling, parent, child;\r\n        if (node) {\r\n          sibling = node[siblingName];\r\n          if (this.rootNode && sibling === this.rootNode) {\r\n            return;\r\n          }\r\n          if (sibling) {\r\n            if (!shallow) {\r\n              for (child = sibling[startName]; child; child = child[startName]) {\r\n                if (!child[startName]) {\r\n                  return child;\r\n                }\r\n              }\r\n            }\r\n            return sibling;\r\n          }\r\n          parent = node.parentNode;\r\n          if (parent && parent !== this.rootNode) {\r\n            return parent;\r\n          }\r\n        }\r\n      };\r\n      return DomTreeWalker;\r\n    }();\r\n\r\n    var blocks = [\r\n      'article',\r\n      'aside',\r\n      'details',\r\n      'div',\r\n      'dt',\r\n      'figcaption',\r\n      'footer',\r\n      'form',\r\n      'fieldset',\r\n      'header',\r\n      'hgroup',\r\n      'html',\r\n      'main',\r\n      'nav',\r\n      'section',\r\n      'summary',\r\n      'body',\r\n      'p',\r\n      'dl',\r\n      'multicol',\r\n      'dd',\r\n      'figure',\r\n      'address',\r\n      'center',\r\n      'blockquote',\r\n      'h1',\r\n      'h2',\r\n      'h3',\r\n      'h4',\r\n      'h5',\r\n      'h6',\r\n      'listing',\r\n      'xmp',\r\n      'pre',\r\n      'plaintext',\r\n      'menu',\r\n      'dir',\r\n      'ul',\r\n      'ol',\r\n      'li',\r\n      'hr',\r\n      'table',\r\n      'tbody',\r\n      'thead',\r\n      'tfoot',\r\n      'th',\r\n      'tr',\r\n      'td',\r\n      'caption'\r\n    ];\r\n    var tableCells = [\r\n      'td',\r\n      'th'\r\n    ];\r\n    var tableSections = [\r\n      'thead',\r\n      'tbody',\r\n      'tfoot'\r\n    ];\r\n    var textBlocks = [\r\n      'h1',\r\n      'h2',\r\n      'h3',\r\n      'h4',\r\n      'h5',\r\n      'h6',\r\n      'p',\r\n      'div',\r\n      'address',\r\n      'pre',\r\n      'form',\r\n      'blockquote',\r\n      'center',\r\n      'dir',\r\n      'fieldset',\r\n      'header',\r\n      'footer',\r\n      'article',\r\n      'section',\r\n      'hgroup',\r\n      'aside',\r\n      'nav',\r\n      'figure'\r\n    ];\r\n    var headings = [\r\n      'h1',\r\n      'h2',\r\n      'h3',\r\n      'h4',\r\n      'h5',\r\n      'h6'\r\n    ];\r\n    var listItems$1 = [\r\n      'li',\r\n      'dd',\r\n      'dt'\r\n    ];\r\n    var lists = [\r\n      'ul',\r\n      'ol',\r\n      'dl'\r\n    ];\r\n    var wsElements = [\r\n      'pre',\r\n      'script',\r\n      'textarea',\r\n      'style'\r\n    ];\r\n    var lazyLookup = function (items) {\r\n      var lookup;\r\n      return function (node) {\r\n        lookup = lookup ? lookup : mapToObject(items, always);\r\n        return has$2(lookup, name(node));\r\n      };\r\n    };\r\n    var isHeading = lazyLookup(headings);\r\n    var isBlock$2 = lazyLookup(blocks);\r\n    var isTable$2 = function (node) {\r\n      return name(node) === 'table';\r\n    };\r\n    var isInline$1 = function (node) {\r\n      return isElement$6(node) && !isBlock$2(node);\r\n    };\r\n    var isBr$4 = function (node) {\r\n      return isElement$6(node) && name(node) === 'br';\r\n    };\r\n    var isTextBlock$2 = lazyLookup(textBlocks);\r\n    var isList = lazyLookup(lists);\r\n    var isListItem = lazyLookup(listItems$1);\r\n    var isTableSection = lazyLookup(tableSections);\r\n    var isTableCell$4 = lazyLookup(tableCells);\r\n    var isWsPreserveElement = lazyLookup(wsElements);\r\n\r\n    var ancestor$1 = function (scope, selector, isRoot) {\r\n      return ancestor$2(scope, selector, isRoot).isSome();\r\n    };\r\n\r\n    var zeroWidth = '\\uFEFF';\r\n    var nbsp = '\\xA0';\r\n    var isZwsp$1 = function (char) {\r\n      return char === zeroWidth;\r\n    };\r\n    var removeZwsp = function (s) {\r\n      return s.replace(/\\uFEFF/g, '');\r\n    };\r\n\r\n    var ZWSP$1 = zeroWidth;\r\n    var isZwsp = isZwsp$1;\r\n    var trim$3 = removeZwsp;\r\n\r\n    var isElement$4 = isElement$5;\r\n    var isText$6 = isText$7;\r\n    var isCaretContainerBlock$1 = function (node) {\r\n      if (isText$6(node)) {\r\n        node = node.parentNode;\r\n      }\r\n      return isElement$4(node) && node.hasAttribute('data-mce-caret');\r\n    };\r\n    var isCaretContainerInline = function (node) {\r\n      return isText$6(node) && isZwsp(node.data);\r\n    };\r\n    var isCaretContainer$2 = function (node) {\r\n      return isCaretContainerBlock$1(node) || isCaretContainerInline(node);\r\n    };\r\n    var hasContent = function (node) {\r\n      return node.firstChild !== node.lastChild || !isBr$5(node.firstChild);\r\n    };\r\n    var insertInline$1 = function (node, before) {\r\n      var doc = node.ownerDocument;\r\n      var textNode = doc.createTextNode(ZWSP$1);\r\n      var parentNode = node.parentNode;\r\n      if (!before) {\r\n        var sibling = node.nextSibling;\r\n        if (isText$6(sibling)) {\r\n          if (isCaretContainer$2(sibling)) {\r\n            return sibling;\r\n          }\r\n          if (startsWithCaretContainer$1(sibling)) {\r\n            sibling.splitText(1);\r\n            return sibling;\r\n          }\r\n        }\r\n        if (node.nextSibling) {\r\n          parentNode.insertBefore(textNode, node.nextSibling);\r\n        } else {\r\n          parentNode.appendChild(textNode);\r\n        }\r\n      } else {\r\n        var sibling = node.previousSibling;\r\n        if (isText$6(sibling)) {\r\n          if (isCaretContainer$2(sibling)) {\r\n            return sibling;\r\n          }\r\n          if (endsWithCaretContainer$1(sibling)) {\r\n            return sibling.splitText(sibling.data.length - 1);\r\n          }\r\n        }\r\n        parentNode.insertBefore(textNode, node);\r\n      }\r\n      return textNode;\r\n    };\r\n    var isBeforeInline = function (pos) {\r\n      var container = pos.container();\r\n      if (!isText$7(container)) {\r\n        return false;\r\n      }\r\n      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\r\n    };\r\n    var isAfterInline = function (pos) {\r\n      var container = pos.container();\r\n      if (!isText$7(container)) {\r\n        return false;\r\n      }\r\n      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\r\n    };\r\n    var createBogusBr = function () {\r\n      var br = document.createElement('br');\r\n      br.setAttribute('data-mce-bogus', '1');\r\n      return br;\r\n    };\r\n    var insertBlock$1 = function (blockName, node, before) {\r\n      var doc = node.ownerDocument;\r\n      var blockNode = doc.createElement(blockName);\r\n      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\r\n      blockNode.setAttribute('data-mce-bogus', 'all');\r\n      blockNode.appendChild(createBogusBr());\r\n      var parentNode = node.parentNode;\r\n      if (!before) {\r\n        if (node.nextSibling) {\r\n          parentNode.insertBefore(blockNode, node.nextSibling);\r\n        } else {\r\n          parentNode.appendChild(blockNode);\r\n        }\r\n      } else {\r\n        parentNode.insertBefore(blockNode, node);\r\n      }\r\n      return blockNode;\r\n    };\r\n    var startsWithCaretContainer$1 = function (node) {\r\n      return isText$6(node) && node.data[0] === ZWSP$1;\r\n    };\r\n    var endsWithCaretContainer$1 = function (node) {\r\n      return isText$6(node) && node.data[node.data.length - 1] === ZWSP$1;\r\n    };\r\n    var trimBogusBr = function (elm) {\r\n      var brs = elm.getElementsByTagName('br');\r\n      var lastBr = brs[brs.length - 1];\r\n      if (isBogus$2(lastBr)) {\r\n        lastBr.parentNode.removeChild(lastBr);\r\n      }\r\n    };\r\n    var showCaretContainerBlock = function (caretContainer) {\r\n      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\r\n        trimBogusBr(caretContainer);\r\n        caretContainer.removeAttribute('data-mce-caret');\r\n        caretContainer.removeAttribute('data-mce-bogus');\r\n        caretContainer.removeAttribute('style');\r\n        caretContainer.removeAttribute('_moz_abspos');\r\n        return caretContainer;\r\n      }\r\n      return null;\r\n    };\r\n    var isRangeInCaretContainerBlock = function (range) {\r\n      return isCaretContainerBlock$1(range.startContainer);\r\n    };\r\n\r\n    var isContentEditableTrue$3 = isContentEditableTrue$4;\r\n    var isContentEditableFalse$a = isContentEditableFalse$b;\r\n    var isBr$3 = isBr$5;\r\n    var isText$5 = isText$7;\r\n    var isInvalidTextElement = matchNodeNames([\r\n      'script',\r\n      'style',\r\n      'textarea'\r\n    ]);\r\n    var isAtomicInline = matchNodeNames([\r\n      'img',\r\n      'input',\r\n      'textarea',\r\n      'hr',\r\n      'iframe',\r\n      'video',\r\n      'audio',\r\n      'object',\r\n      'embed'\r\n    ]);\r\n    var isTable$1 = matchNodeNames(['table']);\r\n    var isCaretContainer$1 = isCaretContainer$2;\r\n    var isCaretCandidate$3 = function (node) {\r\n      if (isCaretContainer$1(node)) {\r\n        return false;\r\n      }\r\n      if (isText$5(node)) {\r\n        return !isInvalidTextElement(node.parentNode);\r\n      }\r\n      return isAtomicInline(node) || isBr$3(node) || isTable$1(node) || isNonUiContentEditableFalse(node);\r\n    };\r\n    var isUnselectable = function (node) {\r\n      return isElement$5(node) && node.getAttribute('unselectable') === 'true';\r\n    };\r\n    var isNonUiContentEditableFalse = function (node) {\r\n      return isUnselectable(node) === false && isContentEditableFalse$a(node);\r\n    };\r\n    var isInEditable = function (node, root) {\r\n      for (node = node.parentNode; node && node !== root; node = node.parentNode) {\r\n        if (isNonUiContentEditableFalse(node)) {\r\n          return false;\r\n        }\r\n        if (isContentEditableTrue$3(node)) {\r\n          return true;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    var isAtomicContentEditableFalse = function (node) {\r\n      if (!isNonUiContentEditableFalse(node)) {\r\n        return false;\r\n      }\r\n      return foldl(from(node.getElementsByTagName('*')), function (result, elm) {\r\n        return result || isContentEditableTrue$3(elm);\r\n      }, false) !== true;\r\n    };\r\n    var isAtomic$1 = function (node) {\r\n      return isAtomicInline(node) || isAtomicContentEditableFalse(node);\r\n    };\r\n    var isEditableCaretCandidate$1 = function (node, root) {\r\n      return isCaretCandidate$3(node) && isInEditable(node, root);\r\n    };\r\n\r\n    var whiteSpaceRegExp$1 = /^[ \\t\\r\\n]*$/;\r\n    var isWhitespaceText = function (text) {\r\n      return whiteSpaceRegExp$1.test(text);\r\n    };\r\n\r\n    var hasWhitespacePreserveParent = function (node, rootNode) {\r\n      var rootElement = SugarElement.fromDom(rootNode);\r\n      var startNode = SugarElement.fromDom(node);\r\n      return ancestor$1(startNode, 'pre,code', curry(eq, rootElement));\r\n    };\r\n    var isWhitespace = function (node, rootNode) {\r\n      return isText$7(node) && isWhitespaceText(node.data) && hasWhitespacePreserveParent(node, rootNode) === false;\r\n    };\r\n    var isNamedAnchor = function (node) {\r\n      return isElement$5(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\r\n    };\r\n    var isContent$1 = function (node, rootNode) {\r\n      return isCaretCandidate$3(node) && isWhitespace(node, rootNode) === false || isNamedAnchor(node) || isBookmark(node);\r\n    };\r\n    var isBookmark = hasAttribute('data-mce-bookmark');\r\n    var isBogus$1 = hasAttribute('data-mce-bogus');\r\n    var isBogusAll = hasAttributeValue('data-mce-bogus', 'all');\r\n    var isEmptyNode = function (targetNode, skipBogus) {\r\n      var brCount = 0;\r\n      if (isContent$1(targetNode, targetNode)) {\r\n        return false;\r\n      } else {\r\n        var node = targetNode.firstChild;\r\n        if (!node) {\r\n          return true;\r\n        }\r\n        var walker = new DomTreeWalker(node, targetNode);\r\n        do {\r\n          if (skipBogus) {\r\n            if (isBogusAll(node)) {\r\n              node = walker.next(true);\r\n              continue;\r\n            }\r\n            if (isBogus$1(node)) {\r\n              node = walker.next();\r\n              continue;\r\n            }\r\n          }\r\n          if (isBr$5(node)) {\r\n            brCount++;\r\n            node = walker.next();\r\n            continue;\r\n          }\r\n          if (isContent$1(node, targetNode)) {\r\n            return false;\r\n          }\r\n          node = walker.next();\r\n        } while (node);\r\n        return brCount <= 1;\r\n      }\r\n    };\r\n    var isEmpty$2 = function (elm, skipBogus) {\r\n      if (skipBogus === void 0) {\r\n        skipBogus = true;\r\n      }\r\n      return isEmptyNode(elm.dom, skipBogus);\r\n    };\r\n\r\n    var isSpan = function (node) {\r\n      return node.nodeName.toLowerCase() === 'span';\r\n    };\r\n    var isInlineContent = function (node, root) {\r\n      return isNonNullable(node) && (isContent$1(node, root) || isInline$1(SugarElement.fromDom(node)));\r\n    };\r\n    var surroundedByInlineContent = function (node, root) {\r\n      var prev = new DomTreeWalker(node, root).prev(false);\r\n      var next = new DomTreeWalker(node, root).next(false);\r\n      var prevIsInline = isUndefined(prev) || isInlineContent(prev, root);\r\n      var nextIsInline = isUndefined(next) || isInlineContent(next, root);\r\n      return prevIsInline && nextIsInline;\r\n    };\r\n    var isBookmarkNode$2 = function (node) {\r\n      return isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\r\n    };\r\n    var isKeepTextNode = function (node, root) {\r\n      return isText$7(node) && node.data.length > 0 && surroundedByInlineContent(node, root);\r\n    };\r\n    var isKeepElement = function (node) {\r\n      return isElement$5(node) ? node.childNodes.length > 0 : false;\r\n    };\r\n    var isDocument = function (node) {\r\n      return isDocumentFragment(node) || isDocument$1(node);\r\n    };\r\n    var trimNode = function (dom, node, root) {\r\n      var rootNode = root || node;\r\n      if (isElement$5(node) && isBookmarkNode$2(node)) {\r\n        return node;\r\n      }\r\n      var children = node.childNodes;\r\n      for (var i = children.length - 1; i >= 0; i--) {\r\n        trimNode(dom, children[i], rootNode);\r\n      }\r\n      if (isElement$5(node)) {\r\n        var currentChildren = node.childNodes;\r\n        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\r\n          node.parentNode.insertBefore(currentChildren[0], node);\r\n        }\r\n      }\r\n      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {\r\n        dom.remove(node);\r\n      }\r\n      return node;\r\n    };\r\n\r\n    var makeMap$3 = Tools.makeMap;\r\n    var attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\r\n    var textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\r\n    var rawCharsRegExp = /[<>&\\\"\\']/g;\r\n    var entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\r\n    var asciiMap = {\r\n      128: '\\u20AC',\r\n      130: '\\u201A',\r\n      131: '\\u0192',\r\n      132: '\\u201E',\r\n      133: '\\u2026',\r\n      134: '\\u2020',\r\n      135: '\\u2021',\r\n      136: '\\u02c6',\r\n      137: '\\u2030',\r\n      138: '\\u0160',\r\n      139: '\\u2039',\r\n      140: '\\u0152',\r\n      142: '\\u017d',\r\n      145: '\\u2018',\r\n      146: '\\u2019',\r\n      147: '\\u201C',\r\n      148: '\\u201D',\r\n      149: '\\u2022',\r\n      150: '\\u2013',\r\n      151: '\\u2014',\r\n      152: '\\u02DC',\r\n      153: '\\u2122',\r\n      154: '\\u0161',\r\n      155: '\\u203A',\r\n      156: '\\u0153',\r\n      158: '\\u017e',\r\n      159: '\\u0178'\r\n    };\r\n    var baseEntities = {\r\n      '\"': '&quot;',\r\n      '\\'': '&#39;',\r\n      '<': '&lt;',\r\n      '>': '&gt;',\r\n      '&': '&amp;',\r\n      '`': '&#96;'\r\n    };\r\n    var reverseEntities = {\r\n      '&lt;': '<',\r\n      '&gt;': '>',\r\n      '&amp;': '&',\r\n      '&quot;': '\"',\r\n      '&apos;': '\\''\r\n    };\r\n    var nativeDecode = function (text) {\r\n      var elm = SugarElement.fromTag('div').dom;\r\n      elm.innerHTML = text;\r\n      return elm.textContent || elm.innerText || text;\r\n    };\r\n    var buildEntitiesLookup = function (items, radix) {\r\n      var i, chr, entity;\r\n      var lookup = {};\r\n      if (items) {\r\n        items = items.split(',');\r\n        radix = radix || 10;\r\n        for (i = 0; i < items.length; i += 2) {\r\n          chr = String.fromCharCode(parseInt(items[i], radix));\r\n          if (!baseEntities[chr]) {\r\n            entity = '&' + items[i + 1] + ';';\r\n            lookup[chr] = entity;\r\n            lookup[entity] = chr;\r\n          }\r\n        }\r\n        return lookup;\r\n      }\r\n    };\r\n    var namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\r\n    var encodeRaw = function (text, attr) {\r\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {\r\n        return baseEntities[chr] || chr;\r\n      });\r\n    };\r\n    var encodeAllRaw = function (text) {\r\n      return ('' + text).replace(rawCharsRegExp, function (chr) {\r\n        return baseEntities[chr] || chr;\r\n      });\r\n    };\r\n    var encodeNumeric = function (text, attr) {\r\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {\r\n        if (chr.length > 1) {\r\n          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\r\n        }\r\n        return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\r\n      });\r\n    };\r\n    var encodeNamed = function (text, attr, entities) {\r\n      entities = entities || namedEntities;\r\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {\r\n        return baseEntities[chr] || entities[chr] || chr;\r\n      });\r\n    };\r\n    var getEncodeFunc = function (name, entities) {\r\n      var entitiesMap = buildEntitiesLookup(entities) || namedEntities;\r\n      var encodeNamedAndNumeric = function (text, attr) {\r\n        return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {\r\n          if (baseEntities[chr] !== undefined) {\r\n            return baseEntities[chr];\r\n          }\r\n          if (entitiesMap[chr] !== undefined) {\r\n            return entitiesMap[chr];\r\n          }\r\n          if (chr.length > 1) {\r\n            return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\r\n          }\r\n          return '&#' + chr.charCodeAt(0) + ';';\r\n        });\r\n      };\r\n      var encodeCustomNamed = function (text, attr) {\r\n        return encodeNamed(text, attr, entitiesMap);\r\n      };\r\n      var nameMap = makeMap$3(name.replace(/\\+/g, ','));\r\n      if (nameMap.named && nameMap.numeric) {\r\n        return encodeNamedAndNumeric;\r\n      }\r\n      if (nameMap.named) {\r\n        if (entities) {\r\n          return encodeCustomNamed;\r\n        }\r\n        return encodeNamed;\r\n      }\r\n      if (nameMap.numeric) {\r\n        return encodeNumeric;\r\n      }\r\n      return encodeRaw;\r\n    };\r\n    var decode = function (text) {\r\n      return text.replace(entityRegExp, function (all, numeric) {\r\n        if (numeric) {\r\n          if (numeric.charAt(0).toLowerCase() === 'x') {\r\n            numeric = parseInt(numeric.substr(1), 16);\r\n          } else {\r\n            numeric = parseInt(numeric, 10);\r\n          }\r\n          if (numeric > 65535) {\r\n            numeric -= 65536;\r\n            return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\r\n          }\r\n          return asciiMap[numeric] || String.fromCharCode(numeric);\r\n        }\r\n        return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\r\n      });\r\n    };\r\n    var Entities = {\r\n      encodeRaw: encodeRaw,\r\n      encodeAllRaw: encodeAllRaw,\r\n      encodeNumeric: encodeNumeric,\r\n      encodeNamed: encodeNamed,\r\n      getEncodeFunc: getEncodeFunc,\r\n      decode: decode\r\n    };\r\n\r\n    var mapCache = {}, dummyObj = {};\r\n    var makeMap$2 = Tools.makeMap, each$h = Tools.each, extend$5 = Tools.extend, explode$3 = Tools.explode, inArray$2 = Tools.inArray;\r\n    var split$1 = function (items, delim) {\r\n      items = Tools.trim(items);\r\n      return items ? items.split(delim || ' ') : [];\r\n    };\r\n    var createMap = function (defaultValue, extendWith) {\r\n      var value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\r\n      return extend$5(value, extendWith);\r\n    };\r\n    var getTextRootBlockElements = function (schema) {\r\n      return createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());\r\n    };\r\n    var compileSchema = function (type) {\r\n      var schema = {};\r\n      var globalAttributes, blockContent;\r\n      var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;\r\n      var add = function (name, attributes, children) {\r\n        var ni, attributesOrder, element;\r\n        var arrayToMap = function (array, obj) {\r\n          var map = {};\r\n          var i, l;\r\n          for (i = 0, l = array.length; i < l; i++) {\r\n            map[array[i]] = obj || {};\r\n          }\r\n          return map;\r\n        };\r\n        children = children || [];\r\n        attributes = attributes || '';\r\n        if (typeof children === 'string') {\r\n          children = split$1(children);\r\n        }\r\n        var names = split$1(name);\r\n        ni = names.length;\r\n        while (ni--) {\r\n          attributesOrder = split$1([\r\n            globalAttributes,\r\n            attributes\r\n          ].join(' '));\r\n          element = {\r\n            attributes: arrayToMap(attributesOrder),\r\n            attributesOrder: attributesOrder,\r\n            children: arrayToMap(children, dummyObj)\r\n          };\r\n          schema[names[ni]] = element;\r\n        }\r\n      };\r\n      var addAttrs = function (name, attributes) {\r\n        var ni, schemaItem, i, l;\r\n        var names = split$1(name);\r\n        ni = names.length;\r\n        var attrs = split$1(attributes);\r\n        while (ni--) {\r\n          schemaItem = schema[names[ni]];\r\n          for (i = 0, l = attrs.length; i < l; i++) {\r\n            schemaItem.attributes[attrs[i]] = {};\r\n            schemaItem.attributesOrder.push(attrs[i]);\r\n          }\r\n        }\r\n      };\r\n      if (mapCache[type]) {\r\n        return mapCache[type];\r\n      }\r\n      globalAttributes = 'id accesskey class dir lang style tabindex title role';\r\n      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\r\n      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\r\n      if (type !== 'html4') {\r\n        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';\r\n        blockContent += ' article aside details dialog figure main header footer hgroup section nav';\r\n        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen';\r\n      }\r\n      if (type !== 'html5-strict') {\r\n        globalAttributes += ' xml:lang';\r\n        html4PhrasingContent = 'acronym applet basefont big font strike tt';\r\n        phrasingContent = [\r\n          phrasingContent,\r\n          html4PhrasingContent\r\n        ].join(' ');\r\n        each$h(split$1(html4PhrasingContent), function (name) {\r\n          add(name, '', phrasingContent);\r\n        });\r\n        html4BlockContent = 'center dir isindex noframes';\r\n        blockContent = [\r\n          blockContent,\r\n          html4BlockContent\r\n        ].join(' ');\r\n        flowContent = [\r\n          blockContent,\r\n          phrasingContent\r\n        ].join(' ');\r\n        each$h(split$1(html4BlockContent), function (name) {\r\n          add(name, '', flowContent);\r\n        });\r\n      }\r\n      flowContent = flowContent || [\r\n        blockContent,\r\n        phrasingContent\r\n      ].join(' ');\r\n      add('html', 'manifest', 'head body');\r\n      add('head', '', 'base command link meta noscript script style title');\r\n      add('title hr noscript br');\r\n      add('base', 'href target');\r\n      add('link', 'href rel media hreflang type sizes hreflang');\r\n      add('meta', 'name http-equiv content charset');\r\n      add('style', 'media type scoped');\r\n      add('script', 'src async defer type charset');\r\n      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\r\n      add('address dt dd div caption', '', flowContent);\r\n      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\r\n      add('blockquote', 'cite', flowContent);\r\n      add('ol', 'reversed start type', 'li');\r\n      add('ul', '', 'li');\r\n      add('li', 'value', flowContent);\r\n      add('dl', '', 'dt dd');\r\n      add('a', 'href target rel media hreflang type', phrasingContent);\r\n      add('q', 'cite', phrasingContent);\r\n      add('ins del', 'cite datetime', flowContent);\r\n      add('img', 'src sizes srcset alt usemap ismap width height');\r\n      add('iframe', 'src name width height', flowContent);\r\n      add('embed', 'src type width height');\r\n      add('object', 'data type typemustmatch name usemap form width height', [\r\n        flowContent,\r\n        'param'\r\n      ].join(' '));\r\n      add('param', 'name value');\r\n      add('map', 'name', [\r\n        flowContent,\r\n        'area'\r\n      ].join(' '));\r\n      add('area', 'alt coords shape href target rel media hreflang type');\r\n      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\r\n      add('colgroup', 'span', 'col');\r\n      add('col', 'span');\r\n      add('tbody thead tfoot', '', 'tr');\r\n      add('tr', '', 'td th');\r\n      add('td', 'colspan rowspan headers', flowContent);\r\n      add('th', 'colspan rowspan headers scope abbr', flowContent);\r\n      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\r\n      add('fieldset', 'disabled form name', [\r\n        flowContent,\r\n        'legend'\r\n      ].join(' '));\r\n      add('label', 'form for', phrasingContent);\r\n      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\r\n      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\r\n      add('select', 'disabled form multiple name required size', 'option optgroup');\r\n      add('optgroup', 'disabled label', 'option');\r\n      add('option', 'disabled label selected value');\r\n      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\r\n      add('menu', 'type label', [\r\n        flowContent,\r\n        'li'\r\n      ].join(' '));\r\n      add('noscript', '', flowContent);\r\n      if (type !== 'html4') {\r\n        add('wbr');\r\n        add('ruby', '', [\r\n          phrasingContent,\r\n          'rt rp'\r\n        ].join(' '));\r\n        add('figcaption', '', flowContent);\r\n        add('mark rt rp summary bdi', '', phrasingContent);\r\n        add('canvas', 'width height', flowContent);\r\n        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [\r\n          flowContent,\r\n          'track source'\r\n        ].join(' '));\r\n        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [\r\n          flowContent,\r\n          'track source'\r\n        ].join(' '));\r\n        add('picture', '', 'img source');\r\n        add('source', 'src srcset type media sizes');\r\n        add('track', 'kind src srclang label default');\r\n        add('datalist', '', [\r\n          phrasingContent,\r\n          'option'\r\n        ].join(' '));\r\n        add('article section nav aside main header footer', '', flowContent);\r\n        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\r\n        add('figure', '', [\r\n          flowContent,\r\n          'figcaption'\r\n        ].join(' '));\r\n        add('time', 'datetime', phrasingContent);\r\n        add('dialog', 'open', flowContent);\r\n        add('command', 'type label icon disabled checked radiogroup command');\r\n        add('output', 'for form name', phrasingContent);\r\n        add('progress', 'value max', phrasingContent);\r\n        add('meter', 'value min max low high optimum', phrasingContent);\r\n        add('details', 'open', [\r\n          flowContent,\r\n          'summary'\r\n        ].join(' '));\r\n        add('keygen', 'autofocus challenge disabled form keytype name');\r\n      }\r\n      if (type !== 'html5-strict') {\r\n        addAttrs('script', 'language xml:space');\r\n        addAttrs('style', 'xml:space');\r\n        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\r\n        addAttrs('embed', 'align name hspace vspace');\r\n        addAttrs('param', 'valuetype type');\r\n        addAttrs('a', 'charset name rev shape coords');\r\n        addAttrs('br', 'clear');\r\n        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\r\n        addAttrs('img', 'name longdesc align border hspace vspace');\r\n        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\r\n        addAttrs('font basefont', 'size color face');\r\n        addAttrs('input', 'usemap align');\r\n        addAttrs('select');\r\n        addAttrs('textarea');\r\n        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\r\n        addAttrs('ul', 'type compact');\r\n        addAttrs('li', 'type');\r\n        addAttrs('ol dl menu dir', 'compact');\r\n        addAttrs('pre', 'width xml:space');\r\n        addAttrs('hr', 'align noshade size width');\r\n        addAttrs('isindex', 'prompt');\r\n        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\r\n        addAttrs('col', 'width align char charoff valign');\r\n        addAttrs('colgroup', 'width align char charoff valign');\r\n        addAttrs('thead', 'align char charoff valign');\r\n        addAttrs('tr', 'align char charoff valign bgcolor');\r\n        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\r\n        addAttrs('form', 'accept');\r\n        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\r\n        addAttrs('tfoot', 'align char charoff valign');\r\n        addAttrs('tbody', 'align char charoff valign');\r\n        addAttrs('area', 'nohref');\r\n        addAttrs('body', 'background bgcolor text link vlink alink');\r\n      }\r\n      if (type !== 'html4') {\r\n        addAttrs('input button select textarea', 'autofocus');\r\n        addAttrs('input textarea', 'placeholder');\r\n        addAttrs('a', 'download');\r\n        addAttrs('link script img', 'crossorigin');\r\n        addAttrs('img', 'loading');\r\n        addAttrs('iframe', 'sandbox seamless allowfullscreen loading');\r\n      }\r\n      each$h(split$1('a form meter progress dfn'), function (name) {\r\n        if (schema[name]) {\r\n          delete schema[name].children[name];\r\n        }\r\n      });\r\n      delete schema.caption.children.table;\r\n      delete schema.script;\r\n      mapCache[type] = schema;\r\n      return schema;\r\n    };\r\n    var compileElementMap = function (value, mode) {\r\n      var styles;\r\n      if (value) {\r\n        styles = {};\r\n        if (typeof value === 'string') {\r\n          value = { '*': value };\r\n        }\r\n        each$h(value, function (value, key) {\r\n          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$3(value, /[, ]/);\r\n        });\r\n      }\r\n      return styles;\r\n    };\r\n    var Schema = function (settings) {\r\n      var elements = {};\r\n      var children = {};\r\n      var patternElements = [];\r\n      var customElementsMap = {}, specialElements = {};\r\n      var createLookupTable = function (option, defaultValue, extendWith) {\r\n        var value = settings[option];\r\n        if (!value) {\r\n          value = mapCache[option];\r\n          if (!value) {\r\n            value = createMap(defaultValue, extendWith);\r\n            mapCache[option] = value;\r\n          }\r\n        } else {\r\n          value = makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\r\n        }\r\n        return value;\r\n      };\r\n      settings = settings || {};\r\n      var schemaItems = compileSchema(settings.schema);\r\n      if (settings.verify_html === false) {\r\n        settings.valid_elements = '*[*]';\r\n      }\r\n      var validStyles = compileElementMap(settings.valid_styles);\r\n      var invalidStyles = compileElementMap(settings.invalid_styles, 'map');\r\n      var validClasses = compileElementMap(settings.valid_classes, 'map');\r\n      var whiteSpaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\r\n      var selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\r\n      var shortEndedElementsMap = createLookupTable('short_ended_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\r\n      var boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls');\r\n      var nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\r\n      var nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre', shortEndedElementsMap);\r\n      var moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', shortEndedElementsMap);\r\n      var textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\r\n      var blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary', textBlockElementsMap);\r\n      var textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');\r\n      each$h((settings.special || 'script noscript iframe noframes noembed title style textarea xmp').split(' '), function (name) {\r\n        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\r\n      });\r\n      var patternToRegExp = function (str) {\r\n        return new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\r\n      };\r\n      var addValidElements = function (validElements) {\r\n        var ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, value;\r\n        var elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/, attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=:<]+)?(?:([=:<])(.*))?$/, hasPatternsRegExp = /[*?+]/;\r\n        if (validElements) {\r\n          var validElementsArr = split$1(validElements, ',');\r\n          if (elements['@']) {\r\n            globalAttributes = elements['@'].attributes;\r\n            globalAttributesOrder = elements['@'].attributesOrder;\r\n          }\r\n          for (ei = 0, el = validElementsArr.length; ei < el; ei++) {\r\n            matches = elementRuleRegExp.exec(validElementsArr[ei]);\r\n            if (matches) {\r\n              prefix = matches[1];\r\n              elementName = matches[2];\r\n              outputName = matches[3];\r\n              attrData = matches[5];\r\n              attributes = {};\r\n              attributesOrder = [];\r\n              element = {\r\n                attributes: attributes,\r\n                attributesOrder: attributesOrder\r\n              };\r\n              if (prefix === '#') {\r\n                element.paddEmpty = true;\r\n              }\r\n              if (prefix === '-') {\r\n                element.removeEmpty = true;\r\n              }\r\n              if (matches[4] === '!') {\r\n                element.removeEmptyAttrs = true;\r\n              }\r\n              if (globalAttributes) {\r\n                each$j(globalAttributes, function (value, key) {\r\n                  attributes[key] = value;\r\n                });\r\n                attributesOrder.push.apply(attributesOrder, globalAttributesOrder);\r\n              }\r\n              if (attrData) {\r\n                attrData = split$1(attrData, '|');\r\n                for (ai = 0, al = attrData.length; ai < al; ai++) {\r\n                  matches = attrRuleRegExp.exec(attrData[ai]);\r\n                  if (matches) {\r\n                    attr = {};\r\n                    attrType = matches[1];\r\n                    attrName = matches[2].replace(/[\\\\:]:/g, ':');\r\n                    prefix = matches[3];\r\n                    value = matches[4];\r\n                    if (attrType === '!') {\r\n                      element.attributesRequired = element.attributesRequired || [];\r\n                      element.attributesRequired.push(attrName);\r\n                      attr.required = true;\r\n                    }\r\n                    if (attrType === '-') {\r\n                      delete attributes[attrName];\r\n                      attributesOrder.splice(inArray$2(attributesOrder, attrName), 1);\r\n                      continue;\r\n                    }\r\n                    if (prefix) {\r\n                      if (prefix === '=') {\r\n                        element.attributesDefault = element.attributesDefault || [];\r\n                        element.attributesDefault.push({\r\n                          name: attrName,\r\n                          value: value\r\n                        });\r\n                        attr.defaultValue = value;\r\n                      }\r\n                      if (prefix === ':') {\r\n                        element.attributesForced = element.attributesForced || [];\r\n                        element.attributesForced.push({\r\n                          name: attrName,\r\n                          value: value\r\n                        });\r\n                        attr.forcedValue = value;\r\n                      }\r\n                      if (prefix === '<') {\r\n                        attr.validValues = makeMap$2(value, '?');\r\n                      }\r\n                    }\r\n                    if (hasPatternsRegExp.test(attrName)) {\r\n                      element.attributePatterns = element.attributePatterns || [];\r\n                      attr.pattern = patternToRegExp(attrName);\r\n                      element.attributePatterns.push(attr);\r\n                    } else {\r\n                      if (!attributes[attrName]) {\r\n                        attributesOrder.push(attrName);\r\n                      }\r\n                      attributes[attrName] = attr;\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              if (!globalAttributes && elementName === '@') {\r\n                globalAttributes = attributes;\r\n                globalAttributesOrder = attributesOrder;\r\n              }\r\n              if (outputName) {\r\n                element.outputName = elementName;\r\n                elements[outputName] = element;\r\n              }\r\n              if (hasPatternsRegExp.test(elementName)) {\r\n                element.pattern = patternToRegExp(elementName);\r\n                patternElements.push(element);\r\n              } else {\r\n                elements[elementName] = element;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n      var setValidElements = function (validElements) {\r\n        elements = {};\r\n        patternElements = [];\r\n        addValidElements(validElements);\r\n        each$h(schemaItems, function (element, name) {\r\n          children[name] = element.children;\r\n        });\r\n      };\r\n      var addCustomElements = function (customElements) {\r\n        var customElementRegExp = /^(~)?(.+)$/;\r\n        if (customElements) {\r\n          mapCache.text_block_elements = mapCache.block_elements = null;\r\n          each$h(split$1(customElements, ','), function (rule) {\r\n            var matches = customElementRegExp.exec(rule), inline = matches[1] === '~', cloneName = inline ? 'span' : 'div', name = matches[2];\r\n            children[name] = children[cloneName];\r\n            customElementsMap[name] = cloneName;\r\n            if (!inline) {\r\n              blockElementsMap[name.toUpperCase()] = {};\r\n              blockElementsMap[name] = {};\r\n            }\r\n            if (!elements[name]) {\r\n              var customRule = elements[cloneName];\r\n              customRule = extend$5({}, customRule);\r\n              delete customRule.removeEmptyAttrs;\r\n              delete customRule.removeEmpty;\r\n              elements[name] = customRule;\r\n            }\r\n            each$h(children, function (element, elmName) {\r\n              if (element[cloneName]) {\r\n                children[elmName] = element = extend$5({}, children[elmName]);\r\n                element[name] = element[cloneName];\r\n              }\r\n            });\r\n          });\r\n        }\r\n      };\r\n      var addValidChildren = function (validChildren) {\r\n        var childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\r\n        mapCache[settings.schema] = null;\r\n        if (validChildren) {\r\n          each$h(split$1(validChildren, ','), function (rule) {\r\n            var matches = childRuleRegExp.exec(rule);\r\n            var parent, prefix;\r\n            if (matches) {\r\n              prefix = matches[1];\r\n              if (prefix) {\r\n                parent = children[matches[2]];\r\n              } else {\r\n                parent = children[matches[2]] = { '#comment': {} };\r\n              }\r\n              parent = children[matches[2]];\r\n              each$h(split$1(matches[3], '|'), function (child) {\r\n                if (prefix === '-') {\r\n                  delete parent[child];\r\n                } else {\r\n                  parent[child] = {};\r\n                }\r\n              });\r\n            }\r\n          });\r\n        }\r\n      };\r\n      var getElementRule = function (name) {\r\n        var element = elements[name], i;\r\n        if (element) {\r\n          return element;\r\n        }\r\n        i = patternElements.length;\r\n        while (i--) {\r\n          element = patternElements[i];\r\n          if (element.pattern.test(name)) {\r\n            return element;\r\n          }\r\n        }\r\n      };\r\n      if (!settings.valid_elements) {\r\n        each$h(schemaItems, function (element, name) {\r\n          elements[name] = {\r\n            attributes: element.attributes,\r\n            attributesOrder: element.attributesOrder\r\n          };\r\n          children[name] = element.children;\r\n        });\r\n        if (settings.schema !== 'html5') {\r\n          each$h(split$1('strong/b em/i'), function (item) {\r\n            var items = split$1(item, '/');\r\n            elements[items[1]].outputName = items[0];\r\n          });\r\n        }\r\n        each$h(textInlineElementsMap, function (_val, name) {\r\n          if (elements[name]) {\r\n            if (settings.padd_empty_block_inline_children) {\r\n              elements[name].paddInEmptyBlock = true;\r\n            }\r\n            elements[name].removeEmpty = true;\r\n          }\r\n        });\r\n        each$h(split$1('ol ul blockquote a table tbody'), function (name) {\r\n          if (elements[name]) {\r\n            elements[name].removeEmpty = true;\r\n          }\r\n        });\r\n        each$h(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li'), function (name) {\r\n          elements[name].paddEmpty = true;\r\n        });\r\n        each$h(split$1('span'), function (name) {\r\n          elements[name].removeEmptyAttrs = true;\r\n        });\r\n      } else {\r\n        setValidElements(settings.valid_elements);\r\n      }\r\n      addCustomElements(settings.custom_elements);\r\n      addValidChildren(settings.valid_children);\r\n      addValidElements(settings.extended_valid_elements);\r\n      addValidChildren('+ol[ul|ol],+ul[ul|ol]');\r\n      each$h({\r\n        dd: 'dl',\r\n        dt: 'dl',\r\n        li: 'ul ol',\r\n        td: 'tr',\r\n        th: 'tr',\r\n        tr: 'tbody thead tfoot',\r\n        tbody: 'table',\r\n        thead: 'table',\r\n        tfoot: 'table',\r\n        legend: 'fieldset',\r\n        area: 'map',\r\n        param: 'video audio object'\r\n      }, function (parents, item) {\r\n        if (elements[item]) {\r\n          elements[item].parentsRequired = split$1(parents);\r\n        }\r\n      });\r\n      if (settings.invalid_elements) {\r\n        each$h(explode$3(settings.invalid_elements), function (item) {\r\n          if (elements[item]) {\r\n            delete elements[item];\r\n          }\r\n        });\r\n      }\r\n      if (!getElementRule('span')) {\r\n        addValidElements('span[!data-mce-type|*]');\r\n      }\r\n      var getValidStyles = constant(validStyles);\r\n      var getInvalidStyles = constant(invalidStyles);\r\n      var getValidClasses = constant(validClasses);\r\n      var getBoolAttrs = constant(boolAttrMap);\r\n      var getBlockElements = constant(blockElementsMap);\r\n      var getTextBlockElements = constant(textBlockElementsMap);\r\n      var getTextInlineElements = constant(textInlineElementsMap);\r\n      var getShortEndedElements = constant(shortEndedElementsMap);\r\n      var getSelfClosingElements = constant(selfClosingElementsMap);\r\n      var getNonEmptyElements = constant(nonEmptyElementsMap);\r\n      var getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\r\n      var getWhiteSpaceElements = constant(whiteSpaceElementsMap);\r\n      var getSpecialElements = constant(specialElements);\r\n      var isValidChild = function (name, child) {\r\n        var parent = children[name.toLowerCase()];\r\n        return !!(parent && parent[child.toLowerCase()]);\r\n      };\r\n      var isValid = function (name, attr) {\r\n        var attrPatterns, i;\r\n        var rule = getElementRule(name);\r\n        if (rule) {\r\n          if (attr) {\r\n            if (rule.attributes[attr]) {\r\n              return true;\r\n            }\r\n            attrPatterns = rule.attributePatterns;\r\n            if (attrPatterns) {\r\n              i = attrPatterns.length;\r\n              while (i--) {\r\n                if (attrPatterns[i].pattern.test(name)) {\r\n                  return true;\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      var getCustomElements = constant(customElementsMap);\r\n      return {\r\n        children: children,\r\n        elements: elements,\r\n        getValidStyles: getValidStyles,\r\n        getValidClasses: getValidClasses,\r\n        getBlockElements: getBlockElements,\r\n        getInvalidStyles: getInvalidStyles,\r\n        getShortEndedElements: getShortEndedElements,\r\n        getTextBlockElements: getTextBlockElements,\r\n        getTextInlineElements: getTextInlineElements,\r\n        getBoolAttrs: getBoolAttrs,\r\n        getElementRule: getElementRule,\r\n        getSelfClosingElements: getSelfClosingElements,\r\n        getNonEmptyElements: getNonEmptyElements,\r\n        getMoveCaretBeforeOnEnterElements: getMoveCaretBeforeOnEnterElements,\r\n        getWhiteSpaceElements: getWhiteSpaceElements,\r\n        getSpecialElements: getSpecialElements,\r\n        isValidChild: isValidChild,\r\n        isValid: isValid,\r\n        getCustomElements: getCustomElements,\r\n        addValidElements: addValidElements,\r\n        setValidElements: setValidElements,\r\n        addCustomElements: addCustomElements,\r\n        addValidChildren: addValidChildren\r\n      };\r\n    };\r\n\r\n    var toHex = function (match, r, g, b) {\r\n      var hex = function (val) {\r\n        val = parseInt(val, 10).toString(16);\r\n        return val.length > 1 ? val : '0' + val;\r\n      };\r\n      return '#' + hex(r) + hex(g) + hex(b);\r\n    };\r\n    var Styles = function (settings, schema) {\r\n      var _this = this;\r\n      var rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\r\n      var urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\r\n      var styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\r\n      var trimRightRegExp = /\\s+$/;\r\n      var i;\r\n      var encodingLookup = {};\r\n      var validStyles;\r\n      var invalidStyles;\r\n      var invisibleChar = zeroWidth;\r\n      settings = settings || {};\r\n      if (schema) {\r\n        validStyles = schema.getValidStyles();\r\n        invalidStyles = schema.getInvalidStyles();\r\n      }\r\n      var encodingItems = ('\\\\\" \\\\\\' \\\\; \\\\: ; : ' + invisibleChar).split(' ');\r\n      for (i = 0; i < encodingItems.length; i++) {\r\n        encodingLookup[encodingItems[i]] = invisibleChar + i;\r\n        encodingLookup[invisibleChar + i] = encodingItems[i];\r\n      }\r\n      return {\r\n        toHex: function (color) {\r\n          return color.replace(rgbRegExp, toHex);\r\n        },\r\n        parse: function (css) {\r\n          var styles = {};\r\n          var matches, name, value, isEncoded;\r\n          var urlConverter = settings.url_converter;\r\n          var urlConverterScope = settings.url_converter_scope || _this;\r\n          var compress = function (prefix, suffix, noJoin) {\r\n            var top = styles[prefix + '-top' + suffix];\r\n            if (!top) {\r\n              return;\r\n            }\r\n            var right = styles[prefix + '-right' + suffix];\r\n            if (!right) {\r\n              return;\r\n            }\r\n            var bottom = styles[prefix + '-bottom' + suffix];\r\n            if (!bottom) {\r\n              return;\r\n            }\r\n            var left = styles[prefix + '-left' + suffix];\r\n            if (!left) {\r\n              return;\r\n            }\r\n            var box = [\r\n              top,\r\n              right,\r\n              bottom,\r\n              left\r\n            ];\r\n            i = box.length - 1;\r\n            while (i--) {\r\n              if (box[i] !== box[i + 1]) {\r\n                break;\r\n              }\r\n            }\r\n            if (i > -1 && noJoin) {\r\n              return;\r\n            }\r\n            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\r\n            delete styles[prefix + '-top' + suffix];\r\n            delete styles[prefix + '-right' + suffix];\r\n            delete styles[prefix + '-bottom' + suffix];\r\n            delete styles[prefix + '-left' + suffix];\r\n          };\r\n          var canCompress = function (key) {\r\n            var value = styles[key], i;\r\n            if (!value) {\r\n              return;\r\n            }\r\n            value = value.split(' ');\r\n            i = value.length;\r\n            while (i--) {\r\n              if (value[i] !== value[0]) {\r\n                return false;\r\n              }\r\n            }\r\n            styles[key] = value[0];\r\n            return true;\r\n          };\r\n          var compress2 = function (target, a, b, c) {\r\n            if (!canCompress(a)) {\r\n              return;\r\n            }\r\n            if (!canCompress(b)) {\r\n              return;\r\n            }\r\n            if (!canCompress(c)) {\r\n              return;\r\n            }\r\n            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\r\n            delete styles[a];\r\n            delete styles[b];\r\n            delete styles[c];\r\n          };\r\n          var encode = function (str) {\r\n            isEncoded = true;\r\n            return encodingLookup[str];\r\n          };\r\n          var decode = function (str, keepSlashes) {\r\n            if (isEncoded) {\r\n              str = str.replace(/\\uFEFF[0-9]/g, function (str) {\r\n                return encodingLookup[str];\r\n              });\r\n            }\r\n            if (!keepSlashes) {\r\n              str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\r\n            }\r\n            return str;\r\n          };\r\n          var decodeSingleHexSequence = function (escSeq) {\r\n            return String.fromCharCode(parseInt(escSeq.slice(1), 16));\r\n          };\r\n          var decodeHexSequences = function (value) {\r\n            return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\r\n          };\r\n          var processUrl = function (match, url, url2, url3, str, str2) {\r\n            str = str || str2;\r\n            if (str) {\r\n              str = decode(str);\r\n              return '\\'' + str.replace(/\\'/g, '\\\\\\'') + '\\'';\r\n            }\r\n            url = decode(url || url2 || url3);\r\n            if (!settings.allow_script_urls) {\r\n              var scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\r\n              if (/(java|vb)script:/i.test(scriptUrl)) {\r\n                return '';\r\n              }\r\n              if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\r\n                return '';\r\n              }\r\n            }\r\n            if (urlConverter) {\r\n              url = urlConverter.call(urlConverterScope, url, 'style');\r\n            }\r\n            return 'url(\\'' + url.replace(/\\'/g, '\\\\\\'') + '\\')';\r\n          };\r\n          if (css) {\r\n            css = css.replace(/[\\u0000-\\u001F]/g, '');\r\n            css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, function (str) {\r\n              return str.replace(/[;:]/g, encode);\r\n            });\r\n            while (matches = styleRegExp.exec(css)) {\r\n              styleRegExp.lastIndex = matches.index + matches[0].length;\r\n              name = matches[1].replace(trimRightRegExp, '').toLowerCase();\r\n              value = matches[2].replace(trimRightRegExp, '');\r\n              if (name && value) {\r\n                name = decodeHexSequences(name);\r\n                value = decodeHexSequences(value);\r\n                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\r\n                  continue;\r\n                }\r\n                if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\r\n                  continue;\r\n                }\r\n                if (name === 'font-weight' && value === '700') {\r\n                  value = 'bold';\r\n                } else if (name === 'color' || name === 'background-color') {\r\n                  value = value.toLowerCase();\r\n                }\r\n                value = value.replace(rgbRegExp, toHex);\r\n                value = value.replace(urlOrStrRegExp, processUrl);\r\n                styles[name] = isEncoded ? decode(value, true) : value;\r\n              }\r\n            }\r\n            compress('border', '', true);\r\n            compress('border', '-width');\r\n            compress('border', '-color');\r\n            compress('border', '-style');\r\n            compress('padding', '');\r\n            compress('margin', '');\r\n            compress2('border', 'border-width', 'border-style', 'border-color');\r\n            if (styles.border === 'medium none') {\r\n              delete styles.border;\r\n            }\r\n            if (styles['border-image'] === 'none') {\r\n              delete styles['border-image'];\r\n            }\r\n          }\r\n          return styles;\r\n        },\r\n        serialize: function (styles, elementName) {\r\n          var css = '';\r\n          var serializeStyles = function (name) {\r\n            var value;\r\n            var styleList = validStyles[name];\r\n            if (styleList) {\r\n              for (var i_1 = 0, l = styleList.length; i_1 < l; i_1++) {\r\n                name = styleList[i_1];\r\n                value = styles[name];\r\n                if (value) {\r\n                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\r\n                }\r\n              }\r\n            }\r\n          };\r\n          var isValid = function (name, elementName) {\r\n            var styleMap = invalidStyles['*'];\r\n            if (styleMap && styleMap[name]) {\r\n              return false;\r\n            }\r\n            styleMap = invalidStyles[elementName];\r\n            return !(styleMap && styleMap[name]);\r\n          };\r\n          if (elementName && validStyles) {\r\n            serializeStyles('*');\r\n            serializeStyles(elementName);\r\n          } else {\r\n            each$j(styles, function (value, name) {\r\n              if (value && (!invalidStyles || isValid(name, elementName))) {\r\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\r\n              }\r\n            });\r\n          }\r\n          return css;\r\n        }\r\n      };\r\n    };\r\n\r\n    var deprecated = {\r\n      keyLocation: true,\r\n      layerX: true,\r\n      layerY: true,\r\n      returnValue: true,\r\n      webkitMovementX: true,\r\n      webkitMovementY: true,\r\n      keyIdentifier: true,\r\n      mozPressure: true\r\n    };\r\n    var isNativeEvent = function (event) {\r\n      return event instanceof Event || isFunction(event.initEvent);\r\n    };\r\n    var hasIsDefaultPrevented = function (event) {\r\n      return event.isDefaultPrevented === always || event.isDefaultPrevented === never;\r\n    };\r\n    var needsNormalizing = function (event) {\r\n      return isNullable(event.preventDefault) || isNativeEvent(event);\r\n    };\r\n    var clone$2 = function (originalEvent, data) {\r\n      var event = data !== null && data !== void 0 ? data : {};\r\n      for (var name_1 in originalEvent) {\r\n        if (!has$2(deprecated, name_1)) {\r\n          event[name_1] = originalEvent[name_1];\r\n        }\r\n      }\r\n      if (isNonNullable(event.composedPath)) {\r\n        event.composedPath = function () {\r\n          return originalEvent.composedPath();\r\n        };\r\n      }\r\n      return event;\r\n    };\r\n    var normalize$3 = function (type, originalEvent, fallbackTarget, data) {\r\n      var _a;\r\n      var event = clone$2(originalEvent, data);\r\n      event.type = type;\r\n      if (isNullable(event.target)) {\r\n        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\r\n      }\r\n      if (needsNormalizing(originalEvent)) {\r\n        event.preventDefault = function () {\r\n          event.defaultPrevented = true;\r\n          event.isDefaultPrevented = always;\r\n          if (isFunction(originalEvent.preventDefault)) {\r\n            originalEvent.preventDefault();\r\n          } else if (isNativeEvent(originalEvent)) {\r\n            originalEvent.returnValue = false;\r\n          }\r\n        };\r\n        event.stopPropagation = function () {\r\n          event.cancelBubble = true;\r\n          event.isPropagationStopped = always;\r\n          if (isFunction(originalEvent.stopPropagation)) {\r\n            originalEvent.stopPropagation();\r\n          } else if (isNativeEvent(originalEvent)) {\r\n            originalEvent.cancelBubble = true;\r\n          }\r\n        };\r\n        event.stopImmediatePropagation = function () {\r\n          event.isImmediatePropagationStopped = always;\r\n          event.stopPropagation();\r\n        };\r\n        if (!hasIsDefaultPrevented(event)) {\r\n          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\r\n          event.isPropagationStopped = event.cancelBubble === true ? always : never;\r\n          event.isImmediatePropagationStopped = never;\r\n        }\r\n      }\r\n      return event;\r\n    };\r\n\r\n    var eventExpandoPrefix = 'mce-data-';\r\n    var mouseEventRe = /^(?:mouse|contextmenu)|click/;\r\n    var addEvent = function (target, name, callback, capture) {\r\n      if (target.addEventListener) {\r\n        target.addEventListener(name, callback, capture || false);\r\n      } else if (target.attachEvent) {\r\n        target.attachEvent('on' + name, callback);\r\n      }\r\n    };\r\n    var removeEvent = function (target, name, callback, capture) {\r\n      if (target.removeEventListener) {\r\n        target.removeEventListener(name, callback, capture || false);\r\n      } else if (target.detachEvent) {\r\n        target.detachEvent('on' + name, callback);\r\n      }\r\n    };\r\n    var isMouseEvent = function (event) {\r\n      return isNonNullable(event) && mouseEventRe.test(event.type);\r\n    };\r\n    var fix = function (originalEvent, data) {\r\n      var event = normalize$3(originalEvent.type, originalEvent, document, data);\r\n      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\r\n        var eventDoc = event.target.ownerDocument || document;\r\n        var doc = eventDoc.documentElement;\r\n        var body = eventDoc.body;\r\n        var mouseEvent = event;\r\n        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\r\n        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\r\n      }\r\n      if (isUndefined(event.metaKey)) {\r\n        event.metaKey = false;\r\n      }\r\n      return event;\r\n    };\r\n    var bindOnReady = function (win, callback, eventUtils) {\r\n      var doc = win.document, event = { type: 'ready' };\r\n      if (eventUtils.domLoaded) {\r\n        callback(event);\r\n        return;\r\n      }\r\n      var isDocReady = function () {\r\n        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\r\n      };\r\n      var readyHandler = function () {\r\n        removeEvent(win, 'DOMContentLoaded', readyHandler);\r\n        removeEvent(win, 'load', readyHandler);\r\n        if (!eventUtils.domLoaded) {\r\n          eventUtils.domLoaded = true;\r\n          callback(event);\r\n        }\r\n        win = null;\r\n      };\r\n      if (isDocReady()) {\r\n        readyHandler();\r\n      } else {\r\n        addEvent(win, 'DOMContentLoaded', readyHandler);\r\n      }\r\n      if (!eventUtils.domLoaded) {\r\n        addEvent(win, 'load', readyHandler);\r\n      }\r\n    };\r\n    var EventUtils = function () {\r\n      function EventUtils() {\r\n        this.domLoaded = false;\r\n        this.events = {};\r\n        this.count = 1;\r\n        this.expando = eventExpandoPrefix + (+new Date()).toString(32);\r\n        this.hasMouseEnterLeave = 'onmouseenter' in document.documentElement;\r\n        this.hasFocusIn = 'onfocusin' in document.documentElement;\r\n        this.count = 1;\r\n      }\r\n      EventUtils.prototype.bind = function (target, names, callback, scope) {\r\n        var self = this;\r\n        var id, callbackList, i, name, fakeName, nativeHandler, capture;\r\n        var win = window;\r\n        var defaultNativeHandler = function (evt) {\r\n          self.executeHandlers(fix(evt || win.event), id);\r\n        };\r\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\r\n          return;\r\n        }\r\n        if (!target[self.expando]) {\r\n          id = self.count++;\r\n          target[self.expando] = id;\r\n          self.events[id] = {};\r\n        } else {\r\n          id = target[self.expando];\r\n        }\r\n        scope = scope || target;\r\n        var namesList = names.split(' ');\r\n        i = namesList.length;\r\n        while (i--) {\r\n          name = namesList[i];\r\n          nativeHandler = defaultNativeHandler;\r\n          fakeName = capture = false;\r\n          if (name === 'DOMContentLoaded') {\r\n            name = 'ready';\r\n          }\r\n          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\r\n            callback.call(scope, fix({ type: name }));\r\n            continue;\r\n          }\r\n          if (!self.hasMouseEnterLeave) {\r\n            fakeName = self.mouseEnterLeave[name];\r\n            if (fakeName) {\r\n              nativeHandler = function (evt) {\r\n                var current = evt.currentTarget;\r\n                var related = evt.relatedTarget;\r\n                if (related && current.contains) {\r\n                  related = current.contains(related);\r\n                } else {\r\n                  while (related && related !== current) {\r\n                    related = related.parentNode;\r\n                  }\r\n                }\r\n                if (!related) {\r\n                  evt = fix(evt || win.event);\r\n                  evt.type = evt.type === 'mouseout' ? 'mouseleave' : 'mouseenter';\r\n                  evt.target = current;\r\n                  self.executeHandlers(evt, id);\r\n                }\r\n              };\r\n            }\r\n          }\r\n          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\r\n            capture = true;\r\n            fakeName = name === 'focusin' ? 'focus' : 'blur';\r\n            nativeHandler = function (evt) {\r\n              evt = fix(evt || win.event);\r\n              evt.type = evt.type === 'focus' ? 'focusin' : 'focusout';\r\n              self.executeHandlers(evt, id);\r\n            };\r\n          }\r\n          callbackList = self.events[id][name];\r\n          if (!callbackList) {\r\n            self.events[id][name] = callbackList = [{\r\n                func: callback,\r\n                scope: scope\r\n              }];\r\n            callbackList.fakeName = fakeName;\r\n            callbackList.capture = capture;\r\n            callbackList.nativeHandler = nativeHandler;\r\n            if (name === 'ready') {\r\n              bindOnReady(target, nativeHandler, self);\r\n            } else {\r\n              addEvent(target, fakeName || name, nativeHandler, capture);\r\n            }\r\n          } else {\r\n            if (name === 'ready' && self.domLoaded) {\r\n              callback(fix({ type: name }));\r\n            } else {\r\n              callbackList.push({\r\n                func: callback,\r\n                scope: scope\r\n              });\r\n            }\r\n          }\r\n        }\r\n        target = callbackList = null;\r\n        return callback;\r\n      };\r\n      EventUtils.prototype.unbind = function (target, names, callback) {\r\n        var callbackList, i, ci, name, eventMap;\r\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\r\n          return this;\r\n        }\r\n        var id = target[this.expando];\r\n        if (id) {\r\n          eventMap = this.events[id];\r\n          if (names) {\r\n            var namesList = names.split(' ');\r\n            i = namesList.length;\r\n            while (i--) {\r\n              name = namesList[i];\r\n              callbackList = eventMap[name];\r\n              if (callbackList) {\r\n                if (callback) {\r\n                  ci = callbackList.length;\r\n                  while (ci--) {\r\n                    if (callbackList[ci].func === callback) {\r\n                      var nativeHandler = callbackList.nativeHandler;\r\n                      var fakeName = callbackList.fakeName, capture = callbackList.capture;\r\n                      callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\r\n                      callbackList.nativeHandler = nativeHandler;\r\n                      callbackList.fakeName = fakeName;\r\n                      callbackList.capture = capture;\r\n                      eventMap[name] = callbackList;\r\n                    }\r\n                  }\r\n                }\r\n                if (!callback || callbackList.length === 0) {\r\n                  delete eventMap[name];\r\n                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            each$j(eventMap, function (callbackList, name) {\r\n              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\r\n            });\r\n            eventMap = {};\r\n          }\r\n          for (name in eventMap) {\r\n            if (has$2(eventMap, name)) {\r\n              return this;\r\n            }\r\n          }\r\n          delete this.events[id];\r\n          try {\r\n            delete target[this.expando];\r\n          } catch (ex) {\r\n            target[this.expando] = null;\r\n          }\r\n        }\r\n        return this;\r\n      };\r\n      EventUtils.prototype.fire = function (target, name, args) {\r\n        var id;\r\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\r\n          return this;\r\n        }\r\n        var event = fix({\r\n          type: name,\r\n          target: target\r\n        }, args);\r\n        do {\r\n          id = target[this.expando];\r\n          if (id) {\r\n            this.executeHandlers(event, id);\r\n          }\r\n          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\r\n        } while (target && !event.isPropagationStopped());\r\n        return this;\r\n      };\r\n      EventUtils.prototype.clean = function (target) {\r\n        var i, children;\r\n        if (!target || target.nodeType === 3 || target.nodeType === 8) {\r\n          return this;\r\n        }\r\n        if (target[this.expando]) {\r\n          this.unbind(target);\r\n        }\r\n        if (!target.getElementsByTagName) {\r\n          target = target.document;\r\n        }\r\n        if (target && target.getElementsByTagName) {\r\n          this.unbind(target);\r\n          children = target.getElementsByTagName('*');\r\n          i = children.length;\r\n          while (i--) {\r\n            target = children[i];\r\n            if (target[this.expando]) {\r\n              this.unbind(target);\r\n            }\r\n          }\r\n        }\r\n        return this;\r\n      };\r\n      EventUtils.prototype.destroy = function () {\r\n        this.events = {};\r\n      };\r\n      EventUtils.prototype.cancel = function (e) {\r\n        if (e) {\r\n          e.preventDefault();\r\n          e.stopImmediatePropagation();\r\n        }\r\n        return false;\r\n      };\r\n      EventUtils.prototype.executeHandlers = function (evt, id) {\r\n        var container = this.events[id];\r\n        var callbackList = container && container[evt.type];\r\n        if (callbackList) {\r\n          for (var i = 0, l = callbackList.length; i < l; i++) {\r\n            var callback = callbackList[i];\r\n            if (callback && callback.func.call(callback.scope, evt) === false) {\r\n              evt.preventDefault();\r\n            }\r\n            if (evt.isImmediatePropagationStopped()) {\r\n              return;\r\n            }\r\n          }\r\n        }\r\n      };\r\n      EventUtils.Event = new EventUtils();\r\n      return EventUtils;\r\n    }();\r\n\r\n    var support, Expr, getText, isXML, tokenize, compile, select$1, outermostContext, sortInput, hasDuplicate, setDocument, document$1, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {\r\n        if (a === b) {\r\n          hasDuplicate = true;\r\n        }\r\n        return 0;\r\n      }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push$1 = arr.push, slice$1 = arr.slice, indexOf = arr.indexOf || function (elem) {\r\n        var i = 0, len = this.length;\r\n        for (; i < len; i++) {\r\n          if (this[i] === elem) {\r\n            return i;\r\n          }\r\n        }\r\n        return -1;\r\n      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]', identifier = '(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+', attributes = '\\\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\\'((?:\\\\\\\\.|[^\\\\\\\\\\'])*)\\'|\"((?:\\\\\\\\.|[^\\\\\\\\\"])*)\"|(' + identifier + '))|)' + whitespace + '*\\\\]', pseudos = ':(' + identifier + ')(?:\\\\((' + '(\\'((?:\\\\\\\\.|[^\\\\\\\\\\'])*)\\'|\"((?:\\\\\\\\.|[^\\\\\\\\\"])*)\")|' + '((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|' + attributes + ')*)|' + '.*' + ')\\\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\\\]\\'\"]*?)' + whitespace + '*\\\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {\r\n        ID: new RegExp('^#(' + identifier + ')'),\r\n        CLASS: new RegExp('^\\\\.(' + identifier + ')'),\r\n        TAG: new RegExp('^(' + identifier + '|[*])'),\r\n        ATTR: new RegExp('^' + attributes),\r\n        PSEUDO: new RegExp('^' + pseudos),\r\n        CHILD: new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(' + whitespace + '*(even|odd|(([+-]|)(\\\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\\\d+)|))' + whitespace + '*\\\\)|)', 'i'),\r\n        bool: new RegExp('^(?:' + booleans + ')$', 'i'),\r\n        needsContext: new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(' + whitespace + '*((?:-\\\\d)?\\\\d*)' + whitespace + '*\\\\)|)(?=[^-]|$)', 'i')\r\n      }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\\d$/i, rnative = /^[^{]+\\{\\s*\\[native \\w/, rquickExpr$1 = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\\\/g, runescape = new RegExp('\\\\\\\\([\\\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {\r\n        var high = '0x' + escaped - 65536;\r\n        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);\r\n      };\r\n    try {\r\n      push$1.apply(arr = slice$1.call(preferredDoc.childNodes), preferredDoc.childNodes);\r\n      arr[preferredDoc.childNodes.length].nodeType;\r\n    } catch (e) {\r\n      push$1 = {\r\n        apply: arr.length ? function (target, els) {\r\n          push_native.apply(target, slice$1.call(els));\r\n        } : function (target, els) {\r\n          var j = target.length, i = 0;\r\n          while (target[j++] = els[i++]) {\r\n          }\r\n          target.length = j - 1;\r\n        }\r\n      };\r\n    }\r\n    var Sizzle = function (selector, context, results, seed) {\r\n      var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;\r\n      if ((context ? context.ownerDocument || context : preferredDoc) !== document$1) {\r\n        setDocument(context);\r\n      }\r\n      context = context || document$1;\r\n      results = results || [];\r\n      if (!selector || typeof selector !== 'string') {\r\n        return results;\r\n      }\r\n      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {\r\n        return [];\r\n      }\r\n      if (documentIsHTML && !seed) {\r\n        if (match = rquickExpr$1.exec(selector)) {\r\n          if (m = match[1]) {\r\n            if (nodeType === 9) {\r\n              elem = context.getElementById(m);\r\n              if (elem && elem.parentNode) {\r\n                if (elem.id === m) {\r\n                  results.push(elem);\r\n                  return results;\r\n                }\r\n              } else {\r\n                return results;\r\n              }\r\n            } else {\r\n              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {\r\n                results.push(elem);\r\n                return results;\r\n              }\r\n            }\r\n          } else if (match[2]) {\r\n            push$1.apply(results, context.getElementsByTagName(selector));\r\n            return results;\r\n          } else if ((m = match[3]) && support.getElementsByClassName) {\r\n            push$1.apply(results, context.getElementsByClassName(m));\r\n            return results;\r\n          }\r\n        }\r\n        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\r\n          nid = old = expando;\r\n          newContext = context;\r\n          newSelector = nodeType === 9 && selector;\r\n          if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {\r\n            groups = tokenize(selector);\r\n            if (old = context.getAttribute('id')) {\r\n              nid = old.replace(rescape, '\\\\$&');\r\n            } else {\r\n              context.setAttribute('id', nid);\r\n            }\r\n            nid = '[id=\\'' + nid + '\\'] ';\r\n            i = groups.length;\r\n            while (i--) {\r\n              groups[i] = nid + toSelector(groups[i]);\r\n            }\r\n            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\r\n            newSelector = groups.join(',');\r\n          }\r\n          if (newSelector) {\r\n            try {\r\n              push$1.apply(results, newContext.querySelectorAll(newSelector));\r\n              return results;\r\n            } catch (qsaError) {\r\n            } finally {\r\n              if (!old) {\r\n                context.removeAttribute('id');\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return select$1(selector.replace(rtrim, '$1'), context, results, seed);\r\n    };\r\n    function createCache() {\r\n      var keys = [];\r\n      function cache(key, value) {\r\n        if (keys.push(key + ' ') > Expr.cacheLength) {\r\n          delete cache[keys.shift()];\r\n        }\r\n        return cache[key + ' '] = value;\r\n      }\r\n      return cache;\r\n    }\r\n    function markFunction(fn) {\r\n      fn[expando] = true;\r\n      return fn;\r\n    }\r\n    function siblingCheck(a, b) {\r\n      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);\r\n      if (diff) {\r\n        return diff;\r\n      }\r\n      if (cur) {\r\n        while (cur = cur.nextSibling) {\r\n          if (cur === b) {\r\n            return -1;\r\n          }\r\n        }\r\n      }\r\n      return a ? 1 : -1;\r\n    }\r\n    function createInputPseudo(type) {\r\n      return function (elem) {\r\n        var name = elem.nodeName.toLowerCase();\r\n        return name === 'input' && elem.type === type;\r\n      };\r\n    }\r\n    function createButtonPseudo(type) {\r\n      return function (elem) {\r\n        var name = elem.nodeName.toLowerCase();\r\n        return (name === 'input' || name === 'button') && elem.type === type;\r\n      };\r\n    }\r\n    function createPositionalPseudo(fn) {\r\n      return markFunction(function (argument) {\r\n        argument = +argument;\r\n        return markFunction(function (seed, matches) {\r\n          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;\r\n          while (i--) {\r\n            if (seed[j = matchIndexes[i]]) {\r\n              seed[j] = !(matches[j] = seed[j]);\r\n            }\r\n          }\r\n        });\r\n      });\r\n    }\r\n    function testContext(context) {\r\n      return context && typeof context.getElementsByTagName !== strundefined && context;\r\n    }\r\n    support = Sizzle.support = {};\r\n    isXML = Sizzle.isXML = function (elem) {\r\n      var documentElement = elem && (elem.ownerDocument || elem).documentElement;\r\n      return documentElement ? documentElement.nodeName !== 'HTML' : false;\r\n    };\r\n    setDocument = Sizzle.setDocument = function (node) {\r\n      var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;\r\n      function getTop(win) {\r\n        try {\r\n          return win.top;\r\n        } catch (ex) {\r\n        }\r\n        return null;\r\n      }\r\n      if (doc === document$1 || doc.nodeType !== 9 || !doc.documentElement) {\r\n        return document$1;\r\n      }\r\n      document$1 = doc;\r\n      docElem = doc.documentElement;\r\n      documentIsHTML = !isXML(doc);\r\n      if (parent && parent !== getTop(parent)) {\r\n        if (parent.addEventListener) {\r\n          parent.addEventListener('unload', function () {\r\n            setDocument();\r\n          }, false);\r\n        } else if (parent.attachEvent) {\r\n          parent.attachEvent('onunload', function () {\r\n            setDocument();\r\n          });\r\n        }\r\n      }\r\n      support.attributes = true;\r\n      support.getElementsByTagName = true;\r\n      support.getElementsByClassName = rnative.test(doc.getElementsByClassName);\r\n      support.getById = true;\r\n      Expr.find.ID = function (id, context) {\r\n        if (typeof context.getElementById !== strundefined && documentIsHTML) {\r\n          var m = context.getElementById(id);\r\n          return m && m.parentNode ? [m] : [];\r\n        }\r\n      };\r\n      Expr.filter.ID = function (id) {\r\n        var attrId = id.replace(runescape, funescape);\r\n        return function (elem) {\r\n          return elem.getAttribute('id') === attrId;\r\n        };\r\n      };\r\n      Expr.find.TAG = support.getElementsByTagName ? function (tag, context) {\r\n        if (typeof context.getElementsByTagName !== strundefined) {\r\n          return context.getElementsByTagName(tag);\r\n        }\r\n      } : function (tag, context) {\r\n        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);\r\n        if (tag === '*') {\r\n          while (elem = results[i++]) {\r\n            if (elem.nodeType === 1) {\r\n              tmp.push(elem);\r\n            }\r\n          }\r\n          return tmp;\r\n        }\r\n        return results;\r\n      };\r\n      Expr.find.CLASS = support.getElementsByClassName && function (className, context) {\r\n        if (documentIsHTML) {\r\n          return context.getElementsByClassName(className);\r\n        }\r\n      };\r\n      rbuggyMatches = [];\r\n      rbuggyQSA = [];\r\n      support.disconnectedMatch = true;\r\n      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));\r\n      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));\r\n      hasCompare = rnative.test(docElem.compareDocumentPosition);\r\n      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\r\n        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;\r\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\r\n      } : function (a, b) {\r\n        if (b) {\r\n          while (b = b.parentNode) {\r\n            if (b === a) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      sortOrder = hasCompare ? function (a, b) {\r\n        if (a === b) {\r\n          hasDuplicate = true;\r\n          return 0;\r\n        }\r\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\r\n        if (compare) {\r\n          return compare;\r\n        }\r\n        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;\r\n        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\r\n          if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\r\n            return -1;\r\n          }\r\n          if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\r\n            return 1;\r\n          }\r\n          return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;\r\n        }\r\n        return compare & 4 ? -1 : 1;\r\n      } : function (a, b) {\r\n        if (a === b) {\r\n          hasDuplicate = true;\r\n          return 0;\r\n        }\r\n        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];\r\n        if (!aup || !bup) {\r\n          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;\r\n        } else if (aup === bup) {\r\n          return siblingCheck(a, b);\r\n        }\r\n        cur = a;\r\n        while (cur = cur.parentNode) {\r\n          ap.unshift(cur);\r\n        }\r\n        cur = b;\r\n        while (cur = cur.parentNode) {\r\n          bp.unshift(cur);\r\n        }\r\n        while (ap[i] === bp[i]) {\r\n          i++;\r\n        }\r\n        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\r\n      };\r\n      return doc;\r\n    };\r\n    Sizzle.matches = function (expr, elements) {\r\n      return Sizzle(expr, null, null, elements);\r\n    };\r\n    Sizzle.matchesSelector = function (elem, expr) {\r\n      if ((elem.ownerDocument || elem) !== document$1) {\r\n        setDocument(elem);\r\n      }\r\n      expr = expr.replace(rattributeQuotes, '=\\'$1\\']');\r\n      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\r\n        try {\r\n          var ret = matches.call(elem, expr);\r\n          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {\r\n            return ret;\r\n          }\r\n        } catch (e) {\r\n        }\r\n      }\r\n      return Sizzle(expr, document$1, null, [elem]).length > 0;\r\n    };\r\n    Sizzle.contains = function (context, elem) {\r\n      if ((context.ownerDocument || context) !== document$1) {\r\n        setDocument(context);\r\n      }\r\n      return contains(context, elem);\r\n    };\r\n    Sizzle.attr = function (elem, name) {\r\n      if ((elem.ownerDocument || elem) !== document$1) {\r\n        setDocument(elem);\r\n      }\r\n      var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\r\n      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\r\n    };\r\n    Sizzle.error = function (msg) {\r\n      throw new Error('Syntax error, unrecognized expression: ' + msg);\r\n    };\r\n    Sizzle.uniqueSort = function (results) {\r\n      var elem, duplicates = [], j = 0, i = 0;\r\n      hasDuplicate = !support.detectDuplicates;\r\n      sortInput = !support.sortStable && results.slice(0);\r\n      results.sort(sortOrder);\r\n      if (hasDuplicate) {\r\n        while (elem = results[i++]) {\r\n          if (elem === results[i]) {\r\n            j = duplicates.push(i);\r\n          }\r\n        }\r\n        while (j--) {\r\n          results.splice(duplicates[j], 1);\r\n        }\r\n      }\r\n      sortInput = null;\r\n      return results;\r\n    };\r\n    getText = Sizzle.getText = function (elem) {\r\n      var node, ret = '', i = 0, nodeType = elem.nodeType;\r\n      if (!nodeType) {\r\n        while (node = elem[i++]) {\r\n          ret += getText(node);\r\n        }\r\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\r\n        if (typeof elem.textContent === 'string') {\r\n          return elem.textContent;\r\n        } else {\r\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\r\n            ret += getText(elem);\r\n          }\r\n        }\r\n      } else if (nodeType === 3 || nodeType === 4) {\r\n        return elem.nodeValue;\r\n      }\r\n      return ret;\r\n    };\r\n    Expr = Sizzle.selectors = {\r\n      cacheLength: 50,\r\n      createPseudo: markFunction,\r\n      match: matchExpr,\r\n      attrHandle: {},\r\n      find: {},\r\n      relative: {\r\n        '>': {\r\n          dir: 'parentNode',\r\n          first: true\r\n        },\r\n        ' ': { dir: 'parentNode' },\r\n        '+': {\r\n          dir: 'previousSibling',\r\n          first: true\r\n        },\r\n        '~': { dir: 'previousSibling' }\r\n      },\r\n      preFilter: {\r\n        ATTR: function (match) {\r\n          match[1] = match[1].replace(runescape, funescape);\r\n          match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);\r\n          if (match[2] === '~=') {\r\n            match[3] = ' ' + match[3] + ' ';\r\n          }\r\n          return match.slice(0, 4);\r\n        },\r\n        CHILD: function (match) {\r\n          match[1] = match[1].toLowerCase();\r\n          if (match[1].slice(0, 3) === 'nth') {\r\n            if (!match[3]) {\r\n              Sizzle.error(match[0]);\r\n            }\r\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));\r\n            match[5] = +(match[7] + match[8] || match[3] === 'odd');\r\n          } else if (match[3]) {\r\n            Sizzle.error(match[0]);\r\n          }\r\n          return match;\r\n        },\r\n        PSEUDO: function (match) {\r\n          var excess, unquoted = !match[6] && match[2];\r\n          if (matchExpr.CHILD.test(match[0])) {\r\n            return null;\r\n          }\r\n          if (match[3]) {\r\n            match[2] = match[4] || match[5] || '';\r\n          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {\r\n            match[0] = match[0].slice(0, excess);\r\n            match[2] = unquoted.slice(0, excess);\r\n          }\r\n          return match.slice(0, 3);\r\n        }\r\n      },\r\n      filter: {\r\n        TAG: function (nodeNameSelector) {\r\n          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\r\n          return nodeNameSelector === '*' ? function () {\r\n            return true;\r\n          } : function (elem) {\r\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\r\n          };\r\n        },\r\n        CLASS: function (className) {\r\n          var pattern = classCache[className + ' '];\r\n          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {\r\n            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');\r\n          });\r\n        },\r\n        ATTR: function (name, operator, check) {\r\n          return function (elem) {\r\n            var result = Sizzle.attr(elem, name);\r\n            if (result == null) {\r\n              return operator === '!=';\r\n            }\r\n            if (!operator) {\r\n              return true;\r\n            }\r\n            result += '';\r\n            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;\r\n          };\r\n        },\r\n        CHILD: function (type, what, argument, first, last) {\r\n          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';\r\n          return first === 1 && last === 0 ? function (elem) {\r\n            return !!elem.parentNode;\r\n          } : function (elem, context, xml) {\r\n            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;\r\n            if (parent) {\r\n              if (simple) {\r\n                while (dir) {\r\n                  node = elem;\r\n                  while (node = node[dir]) {\r\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\r\n                      return false;\r\n                    }\r\n                  }\r\n                  start = dir = type === 'only' && !start && 'nextSibling';\r\n                }\r\n                return true;\r\n              }\r\n              start = [forward ? parent.firstChild : parent.lastChild];\r\n              if (forward && useCache) {\r\n                outerCache = parent[expando] || (parent[expando] = {});\r\n                cache = outerCache[type] || [];\r\n                nodeIndex = cache[0] === dirruns && cache[1];\r\n                diff = cache[0] === dirruns && cache[2];\r\n                node = nodeIndex && parent.childNodes[nodeIndex];\r\n                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\r\n                  if (node.nodeType === 1 && ++diff && node === elem) {\r\n                    outerCache[type] = [\r\n                      dirruns,\r\n                      nodeIndex,\r\n                      diff\r\n                    ];\r\n                    break;\r\n                  }\r\n                }\r\n              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {\r\n                diff = cache[1];\r\n              } else {\r\n                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\r\n                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\r\n                    if (useCache) {\r\n                      (node[expando] || (node[expando] = {}))[type] = [\r\n                        dirruns,\r\n                        diff\r\n                      ];\r\n                    }\r\n                    if (node === elem) {\r\n                      break;\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              diff -= last;\r\n              return diff === first || diff % first === 0 && diff / first >= 0;\r\n            }\r\n          };\r\n        },\r\n        PSEUDO: function (pseudo, argument) {\r\n          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);\r\n          if (fn[expando]) {\r\n            return fn(argument);\r\n          }\r\n          if (fn.length > 1) {\r\n            args = [\r\n              pseudo,\r\n              pseudo,\r\n              '',\r\n              argument\r\n            ];\r\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\r\n              var idx, matched = fn(seed, argument), i = matched.length;\r\n              while (i--) {\r\n                idx = indexOf.call(seed, matched[i]);\r\n                seed[idx] = !(matches[idx] = matched[i]);\r\n              }\r\n            }) : function (elem) {\r\n              return fn(elem, 0, args);\r\n            };\r\n          }\r\n          return fn;\r\n        }\r\n      },\r\n      pseudos: {\r\n        not: markFunction(function (selector) {\r\n          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));\r\n          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\r\n            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;\r\n            while (i--) {\r\n              if (elem = unmatched[i]) {\r\n                seed[i] = !(matches[i] = elem);\r\n              }\r\n            }\r\n          }) : function (elem, context, xml) {\r\n            input[0] = elem;\r\n            matcher(input, null, xml, results);\r\n            input[0] = null;\r\n            return !results.pop();\r\n          };\r\n        }),\r\n        has: markFunction(function (selector) {\r\n          return function (elem) {\r\n            return Sizzle(selector, elem).length > 0;\r\n          };\r\n        }),\r\n        contains: markFunction(function (text) {\r\n          text = text.replace(runescape, funescape);\r\n          return function (elem) {\r\n            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\r\n          };\r\n        }),\r\n        lang: markFunction(function (lang) {\r\n          if (!ridentifier.test(lang || '')) {\r\n            Sizzle.error('unsupported lang: ' + lang);\r\n          }\r\n          lang = lang.replace(runescape, funescape).toLowerCase();\r\n          return function (elem) {\r\n            var elemLang;\r\n            do {\r\n              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {\r\n                elemLang = elemLang.toLowerCase();\r\n                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;\r\n              }\r\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\r\n            return false;\r\n          };\r\n        }),\r\n        target: function (elem) {\r\n          var hash = window.location && window.location.hash;\r\n          return hash && hash.slice(1) === elem.id;\r\n        },\r\n        root: function (elem) {\r\n          return elem === docElem;\r\n        },\r\n        focus: function (elem) {\r\n          return elem === document$1.activeElement && (!document$1.hasFocus || document$1.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\r\n        },\r\n        enabled: function (elem) {\r\n          return elem.disabled === false;\r\n        },\r\n        disabled: function (elem) {\r\n          return elem.disabled === true;\r\n        },\r\n        checked: function (elem) {\r\n          var nodeName = elem.nodeName.toLowerCase();\r\n          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;\r\n        },\r\n        selected: function (elem) {\r\n          if (elem.parentNode) {\r\n            elem.parentNode.selectedIndex;\r\n          }\r\n          return elem.selected === true;\r\n        },\r\n        empty: function (elem) {\r\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\r\n            if (elem.nodeType < 6) {\r\n              return false;\r\n            }\r\n          }\r\n          return true;\r\n        },\r\n        parent: function (elem) {\r\n          return !Expr.pseudos.empty(elem);\r\n        },\r\n        header: function (elem) {\r\n          return rheader.test(elem.nodeName);\r\n        },\r\n        input: function (elem) {\r\n          return rinputs.test(elem.nodeName);\r\n        },\r\n        button: function (elem) {\r\n          var name = elem.nodeName.toLowerCase();\r\n          return name === 'input' && elem.type === 'button' || name === 'button';\r\n        },\r\n        text: function (elem) {\r\n          var attr;\r\n          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');\r\n        },\r\n        first: createPositionalPseudo(function () {\r\n          return [0];\r\n        }),\r\n        last: createPositionalPseudo(function (matchIndexes, length) {\r\n          return [length - 1];\r\n        }),\r\n        eq: createPositionalPseudo(function (matchIndexes, length, argument) {\r\n          return [argument < 0 ? argument + length : argument];\r\n        }),\r\n        even: createPositionalPseudo(function (matchIndexes, length) {\r\n          var i = 0;\r\n          for (; i < length; i += 2) {\r\n            matchIndexes.push(i);\r\n          }\r\n          return matchIndexes;\r\n        }),\r\n        odd: createPositionalPseudo(function (matchIndexes, length) {\r\n          var i = 1;\r\n          for (; i < length; i += 2) {\r\n            matchIndexes.push(i);\r\n          }\r\n          return matchIndexes;\r\n        }),\r\n        lt: createPositionalPseudo(function (matchIndexes, length, argument) {\r\n          var i = argument < 0 ? argument + length : argument;\r\n          for (; --i >= 0;) {\r\n            matchIndexes.push(i);\r\n          }\r\n          return matchIndexes;\r\n        }),\r\n        gt: createPositionalPseudo(function (matchIndexes, length, argument) {\r\n          var i = argument < 0 ? argument + length : argument;\r\n          for (; ++i < length;) {\r\n            matchIndexes.push(i);\r\n          }\r\n          return matchIndexes;\r\n        })\r\n      }\r\n    };\r\n    Expr.pseudos.nth = Expr.pseudos.eq;\r\n    each$k([\r\n      'radio',\r\n      'checkbox',\r\n      'file',\r\n      'password',\r\n      'image'\r\n    ], function (i) {\r\n      Expr.pseudos[i] = createInputPseudo(i);\r\n    });\r\n    each$k([\r\n      'submit',\r\n      'reset'\r\n    ], function (i) {\r\n      Expr.pseudos[i] = createButtonPseudo(i);\r\n    });\r\n    function setFilters() {\r\n    }\r\n    setFilters.prototype = Expr.filters = Expr.pseudos;\r\n    Expr.setFilters = new setFilters();\r\n    tokenize = Sizzle.tokenize = function (selector, parseOnly) {\r\n      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];\r\n      if (cached) {\r\n        return parseOnly ? 0 : cached.slice(0);\r\n      }\r\n      soFar = selector;\r\n      groups = [];\r\n      preFilters = Expr.preFilter;\r\n      while (soFar) {\r\n        if (!matched || (match = rcomma.exec(soFar))) {\r\n          if (match) {\r\n            soFar = soFar.slice(match[0].length) || soFar;\r\n          }\r\n          groups.push(tokens = []);\r\n        }\r\n        matched = false;\r\n        if (match = rcombinators.exec(soFar)) {\r\n          matched = match.shift();\r\n          tokens.push({\r\n            value: matched,\r\n            type: match[0].replace(rtrim, ' ')\r\n          });\r\n          soFar = soFar.slice(matched.length);\r\n        }\r\n        for (type in Expr.filter) {\r\n          if (!Expr.filter.hasOwnProperty(type)) {\r\n            continue;\r\n          }\r\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\r\n            matched = match.shift();\r\n            tokens.push({\r\n              value: matched,\r\n              type: type,\r\n              matches: match\r\n            });\r\n            soFar = soFar.slice(matched.length);\r\n          }\r\n        }\r\n        if (!matched) {\r\n          break;\r\n        }\r\n      }\r\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);\r\n    };\r\n    function toSelector(tokens) {\r\n      var i = 0, len = tokens.length, selector = '';\r\n      for (; i < len; i++) {\r\n        selector += tokens[i].value;\r\n      }\r\n      return selector;\r\n    }\r\n    function addCombinator(matcher, combinator, base) {\r\n      var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;\r\n      return combinator.first ? function (elem, context, xml) {\r\n        while (elem = elem[dir]) {\r\n          if (elem.nodeType === 1 || checkNonElements) {\r\n            return matcher(elem, context, xml);\r\n          }\r\n        }\r\n      } : function (elem, context, xml) {\r\n        var oldCache, outerCache, newCache = [\r\n            dirruns,\r\n            doneName\r\n          ];\r\n        if (xml) {\r\n          while (elem = elem[dir]) {\r\n            if (elem.nodeType === 1 || checkNonElements) {\r\n              if (matcher(elem, context, xml)) {\r\n                return true;\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          while (elem = elem[dir]) {\r\n            if (elem.nodeType === 1 || checkNonElements) {\r\n              outerCache = elem[expando] || (elem[expando] = {});\r\n              if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\r\n                return newCache[2] = oldCache[2];\r\n              } else {\r\n                outerCache[dir] = newCache;\r\n                if (newCache[2] = matcher(elem, context, xml)) {\r\n                  return true;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n    }\r\n    function elementMatcher(matchers) {\r\n      return matchers.length > 1 ? function (elem, context, xml) {\r\n        var i = matchers.length;\r\n        while (i--) {\r\n          if (!matchers[i](elem, context, xml)) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      } : matchers[0];\r\n    }\r\n    function multipleContexts(selector, contexts, results) {\r\n      var i = 0, len = contexts.length;\r\n      for (; i < len; i++) {\r\n        Sizzle(selector, contexts[i], results);\r\n      }\r\n      return results;\r\n    }\r\n    function condense(unmatched, map, filter, context, xml) {\r\n      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;\r\n      for (; i < len; i++) {\r\n        if (elem = unmatched[i]) {\r\n          if (!filter || filter(elem, context, xml)) {\r\n            newUnmatched.push(elem);\r\n            if (mapped) {\r\n              map.push(i);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return newUnmatched;\r\n    }\r\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\r\n      if (postFilter && !postFilter[expando]) {\r\n        postFilter = setMatcher(postFilter);\r\n      }\r\n      if (postFinder && !postFinder[expando]) {\r\n        postFinder = setMatcher(postFinder, postSelector);\r\n      }\r\n      return markFunction(function (seed, results, context, xml) {\r\n        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;\r\n        if (matcher) {\r\n          matcher(matcherIn, matcherOut, context, xml);\r\n        }\r\n        if (postFilter) {\r\n          temp = condense(matcherOut, postMap);\r\n          postFilter(temp, [], context, xml);\r\n          i = temp.length;\r\n          while (i--) {\r\n            if (elem = temp[i]) {\r\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\r\n            }\r\n          }\r\n        }\r\n        if (seed) {\r\n          if (postFinder || preFilter) {\r\n            if (postFinder) {\r\n              temp = [];\r\n              i = matcherOut.length;\r\n              while (i--) {\r\n                if (elem = matcherOut[i]) {\r\n                  temp.push(matcherIn[i] = elem);\r\n                }\r\n              }\r\n              postFinder(null, matcherOut = [], temp, xml);\r\n            }\r\n            i = matcherOut.length;\r\n            while (i--) {\r\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {\r\n                seed[temp] = !(results[temp] = elem);\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\r\n          if (postFinder) {\r\n            postFinder(null, results, matcherOut, xml);\r\n          } else {\r\n            push$1.apply(results, matcherOut);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    function matcherFromTokens(tokens) {\r\n      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {\r\n          return elem === checkContext;\r\n        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {\r\n          return indexOf.call(checkContext, elem) > -1;\r\n        }, implicitRelative, true), matchers = [function (elem, context, xml) {\r\n            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\r\n            checkContext = null;\r\n            return ret;\r\n          }];\r\n      for (; i < len; i++) {\r\n        if (matcher = Expr.relative[tokens[i].type]) {\r\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\r\n        } else {\r\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\r\n          if (matcher[expando]) {\r\n            j = ++i;\r\n            for (; j < len; j++) {\r\n              if (Expr.relative[tokens[j].type]) {\r\n                break;\r\n              }\r\n            }\r\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\r\n          }\r\n          matchers.push(matcher);\r\n        }\r\n      }\r\n      return elementMatcher(matchers);\r\n    }\r\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\r\n      var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {\r\n          var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;\r\n          if (outermost) {\r\n            outermostContext = context !== document$1 && context;\r\n          }\r\n          for (; i !== len && (elem = elems[i]) != null; i++) {\r\n            if (byElement && elem) {\r\n              j = 0;\r\n              while (matcher = elementMatchers[j++]) {\r\n                if (matcher(elem, context, xml)) {\r\n                  results.push(elem);\r\n                  break;\r\n                }\r\n              }\r\n              if (outermost) {\r\n                dirruns = dirrunsUnique;\r\n              }\r\n            }\r\n            if (bySet) {\r\n              if (elem = !matcher && elem) {\r\n                matchedCount--;\r\n              }\r\n              if (seed) {\r\n                unmatched.push(elem);\r\n              }\r\n            }\r\n          }\r\n          matchedCount += i;\r\n          if (bySet && i !== matchedCount) {\r\n            j = 0;\r\n            while (matcher = setMatchers[j++]) {\r\n              matcher(unmatched, setMatched, context, xml);\r\n            }\r\n            if (seed) {\r\n              if (matchedCount > 0) {\r\n                while (i--) {\r\n                  if (!(unmatched[i] || setMatched[i])) {\r\n                    setMatched[i] = pop.call(results);\r\n                  }\r\n                }\r\n              }\r\n              setMatched = condense(setMatched);\r\n            }\r\n            push$1.apply(results, setMatched);\r\n            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\r\n              Sizzle.uniqueSort(results);\r\n            }\r\n          }\r\n          if (outermost) {\r\n            dirruns = dirrunsUnique;\r\n            outermostContext = contextBackup;\r\n          }\r\n          return unmatched;\r\n        };\r\n      return bySet ? markFunction(superMatcher) : superMatcher;\r\n    }\r\n    compile = Sizzle.compile = function (selector, match) {\r\n      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];\r\n      if (!cached) {\r\n        if (!match) {\r\n          match = tokenize(selector);\r\n        }\r\n        i = match.length;\r\n        while (i--) {\r\n          cached = matcherFromTokens(match[i]);\r\n          if (cached[expando]) {\r\n            setMatchers.push(cached);\r\n          } else {\r\n            elementMatchers.push(cached);\r\n          }\r\n        }\r\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\r\n        cached.selector = selector;\r\n      }\r\n      return cached;\r\n    };\r\n    select$1 = Sizzle.select = function (selector, context, results, seed) {\r\n      var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);\r\n      results = results || [];\r\n      if (match.length === 1) {\r\n        tokens = match[0] = match[0].slice(0);\r\n        if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\r\n          context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0];\r\n          if (!context) {\r\n            return results;\r\n          } else if (compiled) {\r\n            context = context.parentNode;\r\n          }\r\n          selector = selector.slice(tokens.shift().value.length);\r\n        }\r\n        i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;\r\n        while (i--) {\r\n          token = tokens[i];\r\n          if (Expr.relative[type = token.type]) {\r\n            break;\r\n          }\r\n          if (find = Expr.find[type]) {\r\n            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\r\n              tokens.splice(i, 1);\r\n              selector = seed.length && toSelector(tokens);\r\n              if (!selector) {\r\n                push$1.apply(results, seed);\r\n                return results;\r\n              }\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);\r\n      return results;\r\n    };\r\n    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;\r\n    support.detectDuplicates = !!hasDuplicate;\r\n    setDocument();\r\n    support.sortDetached = true;\r\n\r\n    var doc = document;\r\n    var push = Array.prototype.push;\r\n    var slice = Array.prototype.slice;\r\n    var rquickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/;\r\n    var Event$1 = EventUtils.Event;\r\n    var skipUniques = Tools.makeMap('children,contents,next,prev');\r\n    var isDefined = function (obj) {\r\n      return typeof obj !== 'undefined';\r\n    };\r\n    var isString = function (obj) {\r\n      return typeof obj === 'string';\r\n    };\r\n    var isWindow = function (obj) {\r\n      return obj && obj === obj.window;\r\n    };\r\n    var createFragment$1 = function (html, fragDoc) {\r\n      fragDoc = fragDoc || doc;\r\n      var container = fragDoc.createElement('div');\r\n      var frag = fragDoc.createDocumentFragment();\r\n      container.innerHTML = html;\r\n      var node;\r\n      while (node = container.firstChild) {\r\n        frag.appendChild(node);\r\n      }\r\n      return frag;\r\n    };\r\n    var domManipulate = function (targetNodes, sourceItem, callback, reverse) {\r\n      var i;\r\n      if (isString(sourceItem)) {\r\n        sourceItem = createFragment$1(sourceItem, getElementDocument(targetNodes[0]));\r\n      } else if (sourceItem.length && !sourceItem.nodeType) {\r\n        sourceItem = DomQuery.makeArray(sourceItem);\r\n        if (reverse) {\r\n          for (i = sourceItem.length - 1; i >= 0; i--) {\r\n            domManipulate(targetNodes, sourceItem[i], callback, reverse);\r\n          }\r\n        } else {\r\n          for (i = 0; i < sourceItem.length; i++) {\r\n            domManipulate(targetNodes, sourceItem[i], callback, reverse);\r\n          }\r\n        }\r\n        return targetNodes;\r\n      }\r\n      if (sourceItem.nodeType) {\r\n        i = targetNodes.length;\r\n        while (i--) {\r\n          callback.call(targetNodes[i], sourceItem);\r\n        }\r\n      }\r\n      return targetNodes;\r\n    };\r\n    var hasClass = function (node, className) {\r\n      return node && className && (' ' + node.className + ' ').indexOf(' ' + className + ' ') !== -1;\r\n    };\r\n    var wrap$2 = function (elements, wrapper, all) {\r\n      var lastParent, newWrapper;\r\n      wrapper = DomQuery(wrapper)[0];\r\n      elements.each(function () {\r\n        var self = this;\r\n        if (!all || lastParent !== self.parentNode) {\r\n          lastParent = self.parentNode;\r\n          newWrapper = wrapper.cloneNode(false);\r\n          self.parentNode.insertBefore(newWrapper, self);\r\n          newWrapper.appendChild(self);\r\n        } else {\r\n          newWrapper.appendChild(self);\r\n        }\r\n      });\r\n      return elements;\r\n    };\r\n    var numericCssMap = Tools.makeMap('fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom', ' ');\r\n    var booleanMap = Tools.makeMap('checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected', ' ');\r\n    var propFix = {\r\n      for: 'htmlFor',\r\n      class: 'className',\r\n      readonly: 'readOnly'\r\n    };\r\n    var cssFix = { float: 'cssFloat' };\r\n    var attrHooks = {}, cssHooks = {};\r\n    var DomQueryConstructor = function (selector, context) {\r\n      return new DomQuery.fn.init(selector, context);\r\n    };\r\n    var inArray$1 = function (item, array) {\r\n      var i;\r\n      if (array.indexOf) {\r\n        return array.indexOf(item);\r\n      }\r\n      i = array.length;\r\n      while (i--) {\r\n        if (array[i] === item) {\r\n          return i;\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    var whiteSpaceRegExp = /^\\s*|\\s*$/g;\r\n    var trim$2 = function (str) {\r\n      return str === null || str === undefined ? '' : ('' + str).replace(whiteSpaceRegExp, '');\r\n    };\r\n    var each$g = function (obj, callback) {\r\n      var length, key, i, value;\r\n      if (obj) {\r\n        length = obj.length;\r\n        if (length === undefined) {\r\n          for (key in obj) {\r\n            if (obj.hasOwnProperty(key)) {\r\n              value = obj[key];\r\n              if (callback.call(value, key, value) === false) {\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          for (i = 0; i < length; i++) {\r\n            value = obj[i];\r\n            if (callback.call(value, i, value) === false) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return obj;\r\n    };\r\n    var grep$2 = function (array, callback) {\r\n      var out = [];\r\n      each$g(array, function (i, item) {\r\n        if (callback(item, i)) {\r\n          out.push(item);\r\n        }\r\n      });\r\n      return out;\r\n    };\r\n    var getElementDocument = function (element) {\r\n      if (!element) {\r\n        return doc;\r\n      }\r\n      if (element.nodeType === 9) {\r\n        return element;\r\n      }\r\n      return element.ownerDocument;\r\n    };\r\n    DomQueryConstructor.fn = DomQueryConstructor.prototype = {\r\n      constructor: DomQueryConstructor,\r\n      selector: '',\r\n      context: null,\r\n      length: 0,\r\n      init: function (selector, context) {\r\n        var self = this;\r\n        var match, node;\r\n        if (!selector) {\r\n          return self;\r\n        }\r\n        if (selector.nodeType) {\r\n          self.context = self[0] = selector;\r\n          self.length = 1;\r\n          return self;\r\n        }\r\n        if (context && context.nodeType) {\r\n          self.context = context;\r\n        } else {\r\n          if (context) {\r\n            return DomQuery(selector).attr(context);\r\n          }\r\n          self.context = context = document;\r\n        }\r\n        if (isString(selector)) {\r\n          self.selector = selector;\r\n          if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {\r\n            match = [\r\n              null,\r\n              selector,\r\n              null\r\n            ];\r\n          } else {\r\n            match = rquickExpr.exec(selector);\r\n          }\r\n          if (match) {\r\n            if (match[1]) {\r\n              node = createFragment$1(selector, getElementDocument(context)).firstChild;\r\n              while (node) {\r\n                push.call(self, node);\r\n                node = node.nextSibling;\r\n              }\r\n            } else {\r\n              node = getElementDocument(context).getElementById(match[2]);\r\n              if (!node) {\r\n                return self;\r\n              }\r\n              if (node.id !== match[2]) {\r\n                return self.find(selector);\r\n              }\r\n              self.length = 1;\r\n              self[0] = node;\r\n            }\r\n          } else {\r\n            return DomQuery(context).find(selector);\r\n          }\r\n        } else {\r\n          this.add(selector, false);\r\n        }\r\n        return self;\r\n      },\r\n      toArray: function () {\r\n        return Tools.toArray(this);\r\n      },\r\n      add: function (items, sort) {\r\n        var self = this;\r\n        var nodes, i;\r\n        if (isString(items)) {\r\n          return self.add(DomQuery(items));\r\n        }\r\n        if (sort !== false) {\r\n          nodes = DomQuery.unique(self.toArray().concat(DomQuery.makeArray(items)));\r\n          self.length = nodes.length;\r\n          for (i = 0; i < nodes.length; i++) {\r\n            self[i] = nodes[i];\r\n          }\r\n        } else {\r\n          push.apply(self, DomQuery.makeArray(items));\r\n        }\r\n        return self;\r\n      },\r\n      attr: function (name, value) {\r\n        var self = this;\r\n        var hook;\r\n        if (typeof name === 'object') {\r\n          each$g(name, function (name, value) {\r\n            self.attr(name, value);\r\n          });\r\n        } else if (isDefined(value)) {\r\n          this.each(function () {\r\n            var hook;\r\n            if (this.nodeType === 1) {\r\n              hook = attrHooks[name];\r\n              if (hook && hook.set) {\r\n                hook.set(this, value);\r\n                return;\r\n              }\r\n              if (value === null) {\r\n                this.removeAttribute(name, 2);\r\n              } else {\r\n                this.setAttribute(name, value, 2);\r\n              }\r\n            }\r\n          });\r\n        } else {\r\n          if (self[0] && self[0].nodeType === 1) {\r\n            hook = attrHooks[name];\r\n            if (hook && hook.get) {\r\n              return hook.get(self[0], name);\r\n            }\r\n            if (booleanMap[name]) {\r\n              return self.prop(name) ? name : undefined;\r\n            }\r\n            value = self[0].getAttribute(name, 2);\r\n            if (value === null) {\r\n              value = undefined;\r\n            }\r\n          }\r\n          return value;\r\n        }\r\n        return self;\r\n      },\r\n      removeAttr: function (name) {\r\n        return this.attr(name, null);\r\n      },\r\n      prop: function (name, value) {\r\n        var self = this;\r\n        name = propFix[name] || name;\r\n        if (typeof name === 'object') {\r\n          each$g(name, function (name, value) {\r\n            self.prop(name, value);\r\n          });\r\n        } else if (isDefined(value)) {\r\n          this.each(function () {\r\n            if (this.nodeType === 1) {\r\n              this[name] = value;\r\n            }\r\n          });\r\n        } else {\r\n          if (self[0] && self[0].nodeType && name in self[0]) {\r\n            return self[0][name];\r\n          }\r\n          return value;\r\n        }\r\n        return self;\r\n      },\r\n      css: function (name, value) {\r\n        var self = this;\r\n        var elm, hook;\r\n        var camel = function (name) {\r\n          return name.replace(/-(\\D)/g, function (a, b) {\r\n            return b.toUpperCase();\r\n          });\r\n        };\r\n        var dashed = function (name) {\r\n          return name.replace(/[A-Z]/g, function (a) {\r\n            return '-' + a;\r\n          });\r\n        };\r\n        if (typeof name === 'object') {\r\n          each$g(name, function (name, value) {\r\n            self.css(name, value);\r\n          });\r\n        } else {\r\n          if (isDefined(value)) {\r\n            name = camel(name);\r\n            if (typeof value === 'number' && !numericCssMap[name]) {\r\n              value = value.toString() + 'px';\r\n            }\r\n            self.each(function () {\r\n              var style = this.style;\r\n              hook = cssHooks[name];\r\n              if (hook && hook.set) {\r\n                hook.set(this, value);\r\n                return;\r\n              }\r\n              try {\r\n                this.style[cssFix[name] || name] = value;\r\n              } catch (ex) {\r\n              }\r\n              if (value === null || value === '') {\r\n                if (style.removeProperty) {\r\n                  style.removeProperty(dashed(name));\r\n                } else {\r\n                  style.removeAttribute(name);\r\n                }\r\n              }\r\n            });\r\n          } else {\r\n            elm = self[0];\r\n            hook = cssHooks[name];\r\n            if (hook && hook.get) {\r\n              return hook.get(elm);\r\n            }\r\n            if (elm.ownerDocument.defaultView) {\r\n              try {\r\n                return elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name));\r\n              } catch (ex) {\r\n                return undefined;\r\n              }\r\n            } else if (elm.currentStyle) {\r\n              return elm.currentStyle[camel(name)];\r\n            } else {\r\n              return '';\r\n            }\r\n          }\r\n        }\r\n        return self;\r\n      },\r\n      remove: function () {\r\n        var self = this;\r\n        var node, i = this.length;\r\n        while (i--) {\r\n          node = self[i];\r\n          Event$1.clean(node);\r\n          if (node.parentNode) {\r\n            node.parentNode.removeChild(node);\r\n          }\r\n        }\r\n        return this;\r\n      },\r\n      empty: function () {\r\n        var self = this;\r\n        var node, i = this.length;\r\n        while (i--) {\r\n          node = self[i];\r\n          while (node.firstChild) {\r\n            node.removeChild(node.firstChild);\r\n          }\r\n        }\r\n        return this;\r\n      },\r\n      html: function (value) {\r\n        var self = this;\r\n        var i;\r\n        if (isDefined(value)) {\r\n          i = self.length;\r\n          try {\r\n            while (i--) {\r\n              self[i].innerHTML = value;\r\n            }\r\n          } catch (ex) {\r\n            DomQuery(self[i]).empty().append(value);\r\n          }\r\n          return self;\r\n        }\r\n        return self[0] ? self[0].innerHTML : '';\r\n      },\r\n      text: function (value) {\r\n        var self = this;\r\n        var i;\r\n        if (isDefined(value)) {\r\n          i = self.length;\r\n          while (i--) {\r\n            if ('innerText' in self[i]) {\r\n              self[i].innerText = value;\r\n            } else {\r\n              self[0].textContent = value;\r\n            }\r\n          }\r\n          return self;\r\n        }\r\n        return self[0] ? self[0].innerText || self[0].textContent : '';\r\n      },\r\n      append: function () {\r\n        return domManipulate(this, arguments, function (node) {\r\n          if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {\r\n            this.appendChild(node);\r\n          }\r\n        });\r\n      },\r\n      prepend: function () {\r\n        return domManipulate(this, arguments, function (node) {\r\n          if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {\r\n            this.insertBefore(node, this.firstChild);\r\n          }\r\n        }, true);\r\n      },\r\n      before: function () {\r\n        var self = this;\r\n        if (self[0] && self[0].parentNode) {\r\n          return domManipulate(self, arguments, function (node) {\r\n            this.parentNode.insertBefore(node, this);\r\n          });\r\n        }\r\n        return self;\r\n      },\r\n      after: function () {\r\n        var self = this;\r\n        if (self[0] && self[0].parentNode) {\r\n          return domManipulate(self, arguments, function (node) {\r\n            this.parentNode.insertBefore(node, this.nextSibling);\r\n          }, true);\r\n        }\r\n        return self;\r\n      },\r\n      appendTo: function (val) {\r\n        DomQuery(val).append(this);\r\n        return this;\r\n      },\r\n      prependTo: function (val) {\r\n        DomQuery(val).prepend(this);\r\n        return this;\r\n      },\r\n      replaceWith: function (content) {\r\n        return this.before(content).remove();\r\n      },\r\n      wrap: function (content) {\r\n        return wrap$2(this, content);\r\n      },\r\n      wrapAll: function (content) {\r\n        return wrap$2(this, content, true);\r\n      },\r\n      wrapInner: function (content) {\r\n        this.each(function () {\r\n          DomQuery(this).contents().wrapAll(content);\r\n        });\r\n        return this;\r\n      },\r\n      unwrap: function () {\r\n        return this.parent().each(function () {\r\n          DomQuery(this).replaceWith(this.childNodes);\r\n        });\r\n      },\r\n      clone: function () {\r\n        var result = [];\r\n        this.each(function () {\r\n          result.push(this.cloneNode(true));\r\n        });\r\n        return DomQuery(result);\r\n      },\r\n      addClass: function (className) {\r\n        return this.toggleClass(className, true);\r\n      },\r\n      removeClass: function (className) {\r\n        return this.toggleClass(className, false);\r\n      },\r\n      toggleClass: function (className, state) {\r\n        var self = this;\r\n        if (typeof className !== 'string') {\r\n          return self;\r\n        }\r\n        if (className.indexOf(' ') !== -1) {\r\n          each$g(className.split(' '), function () {\r\n            self.toggleClass(this, state);\r\n          });\r\n        } else {\r\n          self.each(function (index, node) {\r\n            var classState = hasClass(node, className);\r\n            if (classState !== state) {\r\n              var existingClassName = node.className;\r\n              if (classState) {\r\n                node.className = trim$2((' ' + existingClassName + ' ').replace(' ' + className + ' ', ' '));\r\n              } else {\r\n                node.className += existingClassName ? ' ' + className : className;\r\n              }\r\n            }\r\n          });\r\n        }\r\n        return self;\r\n      },\r\n      hasClass: function (className) {\r\n        return hasClass(this[0], className);\r\n      },\r\n      each: function (callback) {\r\n        return each$g(this, callback);\r\n      },\r\n      on: function (name, callback) {\r\n        return this.each(function () {\r\n          Event$1.bind(this, name, callback);\r\n        });\r\n      },\r\n      off: function (name, callback) {\r\n        return this.each(function () {\r\n          Event$1.unbind(this, name, callback);\r\n        });\r\n      },\r\n      trigger: function (name) {\r\n        return this.each(function () {\r\n          if (typeof name === 'object') {\r\n            Event$1.fire(this, name.type, name);\r\n          } else {\r\n            Event$1.fire(this, name);\r\n          }\r\n        });\r\n      },\r\n      show: function () {\r\n        return this.css('display', '');\r\n      },\r\n      hide: function () {\r\n        return this.css('display', 'none');\r\n      },\r\n      slice: function () {\r\n        return DomQuery(slice.apply(this, arguments));\r\n      },\r\n      eq: function (index) {\r\n        return index === -1 ? this.slice(index) : this.slice(index, +index + 1);\r\n      },\r\n      first: function () {\r\n        return this.eq(0);\r\n      },\r\n      last: function () {\r\n        return this.eq(-1);\r\n      },\r\n      find: function (selector) {\r\n        var i, l;\r\n        var ret = [];\r\n        for (i = 0, l = this.length; i < l; i++) {\r\n          DomQuery.find(selector, this[i], ret);\r\n        }\r\n        return DomQuery(ret);\r\n      },\r\n      filter: function (selector) {\r\n        if (typeof selector === 'function') {\r\n          return DomQuery(grep$2(this.toArray(), function (item, i) {\r\n            return selector(i, item);\r\n          }));\r\n        }\r\n        return DomQuery(DomQuery.filter(selector, this.toArray()));\r\n      },\r\n      closest: function (selector) {\r\n        var result = [];\r\n        if (selector instanceof DomQuery) {\r\n          selector = selector[0];\r\n        }\r\n        this.each(function (i, node) {\r\n          while (node) {\r\n            if (typeof selector === 'string' && DomQuery(node).is(selector)) {\r\n              result.push(node);\r\n              break;\r\n            } else if (node === selector) {\r\n              result.push(node);\r\n              break;\r\n            }\r\n            node = node.parentNode;\r\n          }\r\n        });\r\n        return DomQuery(result);\r\n      },\r\n      offset: function (offset) {\r\n        var elm, doc, docElm;\r\n        var x = 0, y = 0, pos;\r\n        if (!offset) {\r\n          elm = this[0];\r\n          if (elm) {\r\n            doc = elm.ownerDocument;\r\n            docElm = doc.documentElement;\r\n            if (elm.getBoundingClientRect) {\r\n              pos = elm.getBoundingClientRect();\r\n              x = pos.left + (docElm.scrollLeft || doc.body.scrollLeft) - docElm.clientLeft;\r\n              y = pos.top + (docElm.scrollTop || doc.body.scrollTop) - docElm.clientTop;\r\n            }\r\n          }\r\n          return {\r\n            left: x,\r\n            top: y\r\n          };\r\n        }\r\n        return this.css(offset);\r\n      },\r\n      push: push,\r\n      sort: Array.prototype.sort,\r\n      splice: Array.prototype.splice\r\n    };\r\n    Tools.extend(DomQueryConstructor, {\r\n      extend: Tools.extend,\r\n      makeArray: function (object) {\r\n        if (isWindow(object) || object.nodeType) {\r\n          return [object];\r\n        }\r\n        return Tools.toArray(object);\r\n      },\r\n      inArray: inArray$1,\r\n      isArray: Tools.isArray,\r\n      each: each$g,\r\n      trim: trim$2,\r\n      grep: grep$2,\r\n      find: Sizzle,\r\n      expr: Sizzle.selectors,\r\n      unique: Sizzle.uniqueSort,\r\n      text: Sizzle.getText,\r\n      contains: Sizzle.contains,\r\n      filter: function (expr, elems, not) {\r\n        var i = elems.length;\r\n        if (not) {\r\n          expr = ':not(' + expr + ')';\r\n        }\r\n        while (i--) {\r\n          if (elems[i].nodeType !== 1) {\r\n            elems.splice(i, 1);\r\n          }\r\n        }\r\n        if (elems.length === 1) {\r\n          elems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];\r\n        } else {\r\n          elems = DomQuery.find.matches(expr, elems);\r\n        }\r\n        return elems;\r\n      }\r\n    });\r\n    var dir = function (el, prop, until) {\r\n      var matched = [];\r\n      var cur = el[prop];\r\n      if (typeof until !== 'string' && until instanceof DomQuery) {\r\n        until = until[0];\r\n      }\r\n      while (cur && cur.nodeType !== 9) {\r\n        if (until !== undefined) {\r\n          if (cur === until) {\r\n            break;\r\n          }\r\n          if (typeof until === 'string' && DomQuery(cur).is(until)) {\r\n            break;\r\n          }\r\n        }\r\n        if (cur.nodeType === 1) {\r\n          matched.push(cur);\r\n        }\r\n        cur = cur[prop];\r\n      }\r\n      return matched;\r\n    };\r\n    var sibling$1 = function (node, siblingName, nodeType, until) {\r\n      var result = [];\r\n      if (until instanceof DomQuery) {\r\n        until = until[0];\r\n      }\r\n      for (; node; node = node[siblingName]) {\r\n        if (nodeType && node.nodeType !== nodeType) {\r\n          continue;\r\n        }\r\n        if (until !== undefined) {\r\n          if (node === until) {\r\n            break;\r\n          }\r\n          if (typeof until === 'string' && DomQuery(node).is(until)) {\r\n            break;\r\n          }\r\n        }\r\n        result.push(node);\r\n      }\r\n      return result;\r\n    };\r\n    var firstSibling = function (node, siblingName, nodeType) {\r\n      for (node = node[siblingName]; node; node = node[siblingName]) {\r\n        if (node.nodeType === nodeType) {\r\n          return node;\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    each$g({\r\n      parent: function (node) {\r\n        var parent = node.parentNode;\r\n        return parent && parent.nodeType !== 11 ? parent : null;\r\n      },\r\n      parents: function (node) {\r\n        return dir(node, 'parentNode');\r\n      },\r\n      next: function (node) {\r\n        return firstSibling(node, 'nextSibling', 1);\r\n      },\r\n      prev: function (node) {\r\n        return firstSibling(node, 'previousSibling', 1);\r\n      },\r\n      children: function (node) {\r\n        return sibling$1(node.firstChild, 'nextSibling', 1);\r\n      },\r\n      contents: function (node) {\r\n        return Tools.toArray((node.nodeName === 'iframe' ? node.contentDocument || node.contentWindow.document : node).childNodes);\r\n      }\r\n    }, function (name, fn) {\r\n      DomQueryConstructor.fn[name] = function (selector) {\r\n        var self = this;\r\n        var result = [];\r\n        self.each(function () {\r\n          var nodes = fn.call(result, this, selector, result);\r\n          if (nodes) {\r\n            if (DomQuery.isArray(nodes)) {\r\n              result.push.apply(result, nodes);\r\n            } else {\r\n              result.push(nodes);\r\n            }\r\n          }\r\n        });\r\n        if (this.length > 1) {\r\n          if (!skipUniques[name]) {\r\n            result = DomQuery.unique(result);\r\n          }\r\n          if (name.indexOf('parents') === 0) {\r\n            result = result.reverse();\r\n          }\r\n        }\r\n        var wrappedResult = DomQuery(result);\r\n        if (selector) {\r\n          return wrappedResult.filter(selector);\r\n        }\r\n        return wrappedResult;\r\n      };\r\n    });\r\n    each$g({\r\n      parentsUntil: function (node, until) {\r\n        return dir(node, 'parentNode', until);\r\n      },\r\n      nextUntil: function (node, until) {\r\n        return sibling$1(node, 'nextSibling', 1, until).slice(1);\r\n      },\r\n      prevUntil: function (node, until) {\r\n        return sibling$1(node, 'previousSibling', 1, until).slice(1);\r\n      }\r\n    }, function (name, fn) {\r\n      DomQueryConstructor.fn[name] = function (selector, filter) {\r\n        var self = this;\r\n        var result = [];\r\n        self.each(function () {\r\n          var nodes = fn.call(result, this, selector, result);\r\n          if (nodes) {\r\n            if (DomQuery.isArray(nodes)) {\r\n              result.push.apply(result, nodes);\r\n            } else {\r\n              result.push(nodes);\r\n            }\r\n          }\r\n        });\r\n        if (this.length > 1) {\r\n          result = DomQuery.unique(result);\r\n          if (name.indexOf('parents') === 0 || name === 'prevUntil') {\r\n            result = result.reverse();\r\n          }\r\n        }\r\n        var wrappedResult = DomQuery(result);\r\n        if (filter) {\r\n          return wrappedResult.filter(filter);\r\n        }\r\n        return wrappedResult;\r\n      };\r\n    });\r\n    DomQueryConstructor.fn.is = function (selector) {\r\n      return !!selector && this.filter(selector).length > 0;\r\n    };\r\n    DomQueryConstructor.fn.init.prototype = DomQueryConstructor.fn;\r\n    DomQueryConstructor.overrideDefaults = function (callback) {\r\n      var defaults;\r\n      var sub = function (selector, context) {\r\n        defaults = defaults || callback();\r\n        if (arguments.length === 0) {\r\n          selector = defaults.element;\r\n        }\r\n        if (!context) {\r\n          context = defaults.context;\r\n        }\r\n        return new sub.fn.init(selector, context);\r\n      };\r\n      DomQuery.extend(sub, this);\r\n      return sub;\r\n    };\r\n    DomQueryConstructor.attrHooks = attrHooks;\r\n    DomQueryConstructor.cssHooks = cssHooks;\r\n    var DomQuery = DomQueryConstructor;\r\n\r\n    var each$f = Tools.each;\r\n    var grep$1 = Tools.grep;\r\n    var isIE = Env.ie;\r\n    var simpleSelectorRe = /^([a-z0-9],?)+$/i;\r\n    var setupAttrHooks = function (styles, settings, getContext) {\r\n      var keepValues = settings.keep_values;\r\n      var keepUrlHook = {\r\n        set: function ($elm, value, name) {\r\n          if (settings.url_converter && value !== null) {\r\n            value = settings.url_converter.call(settings.url_converter_scope || getContext(), value, name, $elm[0]);\r\n          }\r\n          $elm.attr('data-mce-' + name, value).attr(name, value);\r\n        },\r\n        get: function ($elm, name) {\r\n          return $elm.attr('data-mce-' + name) || $elm.attr(name);\r\n        }\r\n      };\r\n      var attrHooks = {\r\n        style: {\r\n          set: function ($elm, value) {\r\n            if (value !== null && typeof value === 'object') {\r\n              $elm.css(value);\r\n              return;\r\n            }\r\n            if (keepValues) {\r\n              $elm.attr('data-mce-style', value);\r\n            }\r\n            if (value !== null && typeof value === 'string') {\r\n              $elm.removeAttr('style');\r\n              $elm.css(styles.parse(value));\r\n            } else {\r\n              $elm.attr('style', value);\r\n            }\r\n          },\r\n          get: function ($elm) {\r\n            var value = $elm.attr('data-mce-style') || $elm.attr('style');\r\n            value = styles.serialize(styles.parse(value), $elm[0].nodeName);\r\n            return value;\r\n          }\r\n        }\r\n      };\r\n      if (keepValues) {\r\n        attrHooks.href = attrHooks.src = keepUrlHook;\r\n      }\r\n      return attrHooks;\r\n    };\r\n    var updateInternalStyleAttr = function (styles, $elm) {\r\n      var rawValue = $elm.attr('style');\r\n      var value = styles.serialize(styles.parse(rawValue), $elm[0].nodeName);\r\n      if (!value) {\r\n        value = null;\r\n      }\r\n      $elm.attr('data-mce-style', value);\r\n    };\r\n    var findNodeIndex = function (node, normalized) {\r\n      var idx = 0, lastNodeType, nodeType;\r\n      if (node) {\r\n        for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {\r\n          nodeType = node.nodeType;\r\n          if (normalized && nodeType === 3) {\r\n            if (nodeType === lastNodeType || !node.nodeValue.length) {\r\n              continue;\r\n            }\r\n          }\r\n          idx++;\r\n          lastNodeType = nodeType;\r\n        }\r\n      }\r\n      return idx;\r\n    };\r\n    var DOMUtils = function (doc, settings) {\r\n      if (settings === void 0) {\r\n        settings = {};\r\n      }\r\n      var addedStyles = {};\r\n      var win = window;\r\n      var files = {};\r\n      var counter = 0;\r\n      var stdMode = true;\r\n      var boxModel = true;\r\n      var styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\r\n        contentCssCors: settings.contentCssCors,\r\n        referrerPolicy: settings.referrerPolicy\r\n      });\r\n      var boundEvents = [];\r\n      var schema = settings.schema ? settings.schema : Schema({});\r\n      var styles = Styles({\r\n        url_converter: settings.url_converter,\r\n        url_converter_scope: settings.url_converter_scope\r\n      }, settings.schema);\r\n      var events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\r\n      var blockElementsMap = schema.getBlockElements();\r\n      var $ = DomQuery.overrideDefaults(function () {\r\n        return {\r\n          context: doc,\r\n          element: self.getRoot()\r\n        };\r\n      });\r\n      var isBlock = function (node) {\r\n        if (typeof node === 'string') {\r\n          return !!blockElementsMap[node];\r\n        } else if (node) {\r\n          var type = node.nodeType;\r\n          if (type) {\r\n            return !!(type === 1 && blockElementsMap[node.nodeName]);\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      var get = function (elm) {\r\n        return elm && doc && isString$1(elm) ? doc.getElementById(elm) : elm;\r\n      };\r\n      var $$ = function (elm) {\r\n        return $(typeof elm === 'string' ? get(elm) : elm);\r\n      };\r\n      var getAttrib = function (elm, name, defaultVal) {\r\n        var hook, value;\r\n        var $elm = $$(elm);\r\n        if ($elm.length) {\r\n          hook = attrHooks[name];\r\n          if (hook && hook.get) {\r\n            value = hook.get($elm, name);\r\n          } else {\r\n            value = $elm.attr(name);\r\n          }\r\n        }\r\n        if (typeof value === 'undefined') {\r\n          value = defaultVal || '';\r\n        }\r\n        return value;\r\n      };\r\n      var getAttribs = function (elm) {\r\n        var node = get(elm);\r\n        if (!node) {\r\n          return [];\r\n        }\r\n        return node.attributes;\r\n      };\r\n      var setAttrib = function (elm, name, value) {\r\n        if (value === '') {\r\n          value = null;\r\n        }\r\n        var $elm = $$(elm);\r\n        var originalValue = $elm.attr(name);\r\n        if (!$elm.length) {\r\n          return;\r\n        }\r\n        var hook = attrHooks[name];\r\n        if (hook && hook.set) {\r\n          hook.set($elm, value, name);\r\n        } else {\r\n          $elm.attr(name, value);\r\n        }\r\n        if (originalValue !== value && settings.onSetAttrib) {\r\n          settings.onSetAttrib({\r\n            attrElm: $elm,\r\n            attrName: name,\r\n            attrValue: value\r\n          });\r\n        }\r\n      };\r\n      var clone = function (node, deep) {\r\n        if (!isIE || node.nodeType !== 1 || deep) {\r\n          return node.cloneNode(deep);\r\n        } else {\r\n          var clone_1 = doc.createElement(node.nodeName);\r\n          each$f(getAttribs(node), function (attr) {\r\n            setAttrib(clone_1, attr.nodeName, getAttrib(node, attr.nodeName));\r\n          });\r\n          return clone_1;\r\n        }\r\n      };\r\n      var getRoot = function () {\r\n        return settings.root_element || doc.body;\r\n      };\r\n      var getViewPort = function (argWin) {\r\n        var vp = getBounds(argWin);\r\n        return {\r\n          x: vp.x,\r\n          y: vp.y,\r\n          w: vp.width,\r\n          h: vp.height\r\n        };\r\n      };\r\n      var getPos$1 = function (elm, rootElm) {\r\n        return getPos(doc.body, get(elm), rootElm);\r\n      };\r\n      var setStyle = function (elm, name, value) {\r\n        var $elm = isString$1(name) ? $$(elm).css(name, value) : $$(elm).css(name);\r\n        if (settings.update_styles) {\r\n          updateInternalStyleAttr(styles, $elm);\r\n        }\r\n      };\r\n      var setStyles = function (elm, stylesArg) {\r\n        var $elm = $$(elm).css(stylesArg);\r\n        if (settings.update_styles) {\r\n          updateInternalStyleAttr(styles, $elm);\r\n        }\r\n      };\r\n      var getStyle = function (elm, name, computed) {\r\n        var $elm = $$(elm);\r\n        if (computed) {\r\n          return $elm.css(name);\r\n        }\r\n        name = name.replace(/-(\\D)/g, function (a, b) {\r\n          return b.toUpperCase();\r\n        });\r\n        if (name === 'float') {\r\n          name = Env.browser.isIE() ? 'styleFloat' : 'cssFloat';\r\n        }\r\n        return $elm[0] && $elm[0].style ? $elm[0].style[name] : undefined;\r\n      };\r\n      var getSize = function (elm) {\r\n        var w, h;\r\n        elm = get(elm);\r\n        w = getStyle(elm, 'width');\r\n        h = getStyle(elm, 'height');\r\n        if (w.indexOf('px') === -1) {\r\n          w = 0;\r\n        }\r\n        if (h.indexOf('px') === -1) {\r\n          h = 0;\r\n        }\r\n        return {\r\n          w: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,\r\n          h: parseInt(h, 10) || elm.offsetHeight || elm.clientHeight\r\n        };\r\n      };\r\n      var getRect = function (elm) {\r\n        elm = get(elm);\r\n        var pos = getPos$1(elm);\r\n        var size = getSize(elm);\r\n        return {\r\n          x: pos.x,\r\n          y: pos.y,\r\n          w: size.w,\r\n          h: size.h\r\n        };\r\n      };\r\n      var is = function (elm, selector) {\r\n        var i;\r\n        if (!elm) {\r\n          return false;\r\n        }\r\n        if (!Array.isArray(elm)) {\r\n          if (selector === '*') {\r\n            return elm.nodeType === 1;\r\n          }\r\n          if (simpleSelectorRe.test(selector)) {\r\n            var selectors = selector.toLowerCase().split(/,/);\r\n            var elmName = elm.nodeName.toLowerCase();\r\n            for (i = selectors.length - 1; i >= 0; i--) {\r\n              if (selectors[i] === elmName) {\r\n                return true;\r\n              }\r\n            }\r\n            return false;\r\n          }\r\n          if (elm.nodeType && elm.nodeType !== 1) {\r\n            return false;\r\n          }\r\n        }\r\n        var elms = !Array.isArray(elm) ? [elm] : elm;\r\n        return Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;\r\n      };\r\n      var getParents = function (elm, selector, root, collect) {\r\n        var result = [];\r\n        var selectorVal;\r\n        var node = get(elm);\r\n        collect = collect === undefined;\r\n        root = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\r\n        if (Tools.is(selector, 'string')) {\r\n          selectorVal = selector;\r\n          if (selector === '*') {\r\n            selector = function (node) {\r\n              return node.nodeType === 1;\r\n            };\r\n          } else {\r\n            selector = function (node) {\r\n              return is(node, selectorVal);\r\n            };\r\n          }\r\n        }\r\n        while (node) {\r\n          if (node === root || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\r\n            break;\r\n          }\r\n          if (!selector || typeof selector === 'function' && selector(node)) {\r\n            if (collect) {\r\n              result.push(node);\r\n            } else {\r\n              return [node];\r\n            }\r\n          }\r\n          node = node.parentNode;\r\n        }\r\n        return collect ? result : null;\r\n      };\r\n      var getParent = function (node, selector, root) {\r\n        var parents = getParents(node, selector, root, false);\r\n        return parents && parents.length > 0 ? parents[0] : null;\r\n      };\r\n      var _findSib = function (node, selector, name) {\r\n        var func = selector;\r\n        if (node) {\r\n          if (typeof selector === 'string') {\r\n            func = function (node) {\r\n              return is(node, selector);\r\n            };\r\n          }\r\n          for (node = node[name]; node; node = node[name]) {\r\n            if (typeof func === 'function' && func(node)) {\r\n              return node;\r\n            }\r\n          }\r\n        }\r\n        return null;\r\n      };\r\n      var getNext = function (node, selector) {\r\n        return _findSib(node, selector, 'nextSibling');\r\n      };\r\n      var getPrev = function (node, selector) {\r\n        return _findSib(node, selector, 'previousSibling');\r\n      };\r\n      var select = function (selector, scope) {\r\n        return Sizzle(selector, get(scope) || settings.root_element || doc, []);\r\n      };\r\n      var run = function (elm, func, scope) {\r\n        var result;\r\n        var node = typeof elm === 'string' ? get(elm) : elm;\r\n        if (!node) {\r\n          return false;\r\n        }\r\n        if (Tools.isArray(node) && (node.length || node.length === 0)) {\r\n          result = [];\r\n          each$f(node, function (elm, i) {\r\n            if (elm) {\r\n              result.push(func.call(scope, typeof elm === 'string' ? get(elm) : elm, i));\r\n            }\r\n          });\r\n          return result;\r\n        }\r\n        var context = scope ? scope : this;\r\n        return func.call(context, node);\r\n      };\r\n      var setAttribs = function (elm, attrs) {\r\n        $$(elm).each(function (i, node) {\r\n          each$f(attrs, function (value, name) {\r\n            setAttrib(node, name, value);\r\n          });\r\n        });\r\n      };\r\n      var setHTML = function (elm, html) {\r\n        var $elm = $$(elm);\r\n        if (isIE) {\r\n          $elm.each(function (i, target) {\r\n            if (target.canHaveHTML === false) {\r\n              return;\r\n            }\r\n            while (target.firstChild) {\r\n              target.removeChild(target.firstChild);\r\n            }\r\n            try {\r\n              target.innerHTML = '<br>' + html;\r\n              target.removeChild(target.firstChild);\r\n            } catch (ex) {\r\n              DomQuery('<div></div>').html('<br>' + html).contents().slice(1).appendTo(target);\r\n            }\r\n            return html;\r\n          });\r\n        } else {\r\n          $elm.html(html);\r\n        }\r\n      };\r\n      var add = function (parentElm, name, attrs, html, create) {\r\n        return run(parentElm, function (parentElm) {\r\n          var newElm = typeof name === 'string' ? doc.createElement(name) : name;\r\n          setAttribs(newElm, attrs);\r\n          if (html) {\r\n            if (typeof html !== 'string' && html.nodeType) {\r\n              newElm.appendChild(html);\r\n            } else if (typeof html === 'string') {\r\n              setHTML(newElm, html);\r\n            }\r\n          }\r\n          return !create ? parentElm.appendChild(newElm) : newElm;\r\n        });\r\n      };\r\n      var create = function (name, attrs, html) {\r\n        return add(doc.createElement(name), name, attrs, html, true);\r\n      };\r\n      var decode = Entities.decode;\r\n      var encode = Entities.encodeAllRaw;\r\n      var createHTML = function (name, attrs, html) {\r\n        var outHtml = '', key;\r\n        outHtml += '<' + name;\r\n        for (key in attrs) {\r\n          if (hasNonNullableKey(attrs, key)) {\r\n            outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\r\n          }\r\n        }\r\n        if (typeof html !== 'undefined') {\r\n          return outHtml + '>' + html + '</' + name + '>';\r\n        }\r\n        return outHtml + ' />';\r\n      };\r\n      var createFragment = function (html) {\r\n        var node;\r\n        var container = doc.createElement('div');\r\n        var frag = doc.createDocumentFragment();\r\n        frag.appendChild(container);\r\n        if (html) {\r\n          container.innerHTML = html;\r\n        }\r\n        while (node = container.firstChild) {\r\n          frag.appendChild(node);\r\n        }\r\n        frag.removeChild(container);\r\n        return frag;\r\n      };\r\n      var remove = function (node, keepChildren) {\r\n        var $node = $$(node);\r\n        if (keepChildren) {\r\n          $node.each(function () {\r\n            var child;\r\n            while (child = this.firstChild) {\r\n              if (child.nodeType === 3 && child.data.length === 0) {\r\n                this.removeChild(child);\r\n              } else {\r\n                this.parentNode.insertBefore(child, this);\r\n              }\r\n            }\r\n          }).remove();\r\n        } else {\r\n          $node.remove();\r\n        }\r\n        return $node.length > 1 ? $node.toArray() : $node[0];\r\n      };\r\n      var removeAllAttribs = function (e) {\r\n        return run(e, function (e) {\r\n          var i;\r\n          var attrs = e.attributes;\r\n          for (i = attrs.length - 1; i >= 0; i--) {\r\n            e.removeAttributeNode(attrs.item(i));\r\n          }\r\n        });\r\n      };\r\n      var parseStyle = function (cssText) {\r\n        return styles.parse(cssText);\r\n      };\r\n      var serializeStyle = function (stylesArg, name) {\r\n        return styles.serialize(stylesArg, name);\r\n      };\r\n      var addStyle = function (cssText) {\r\n        var head, styleElm;\r\n        if (self !== DOMUtils.DOM && doc === document) {\r\n          if (addedStyles[cssText]) {\r\n            return;\r\n          }\r\n          addedStyles[cssText] = true;\r\n        }\r\n        styleElm = doc.getElementById('mceDefaultStyles');\r\n        if (!styleElm) {\r\n          styleElm = doc.createElement('style');\r\n          styleElm.id = 'mceDefaultStyles';\r\n          styleElm.type = 'text/css';\r\n          head = doc.getElementsByTagName('head')[0];\r\n          if (head.firstChild) {\r\n            head.insertBefore(styleElm, head.firstChild);\r\n          } else {\r\n            head.appendChild(styleElm);\r\n          }\r\n        }\r\n        if (styleElm.styleSheet) {\r\n          styleElm.styleSheet.cssText += cssText;\r\n        } else {\r\n          styleElm.appendChild(doc.createTextNode(cssText));\r\n        }\r\n      };\r\n      var loadCSS = function (urls) {\r\n        if (!urls) {\r\n          urls = '';\r\n        }\r\n        each$k(urls.split(','), function (url) {\r\n          files[url] = true;\r\n          styleSheetLoader.load(url, noop);\r\n        });\r\n      };\r\n      var toggleClass = function (elm, cls, state) {\r\n        $$(elm).toggleClass(cls, state).each(function () {\r\n          if (this.className === '') {\r\n            DomQuery(this).attr('class', null);\r\n          }\r\n        });\r\n      };\r\n      var addClass = function (elm, cls) {\r\n        $$(elm).addClass(cls);\r\n      };\r\n      var removeClass = function (elm, cls) {\r\n        toggleClass(elm, cls, false);\r\n      };\r\n      var hasClass = function (elm, cls) {\r\n        return $$(elm).hasClass(cls);\r\n      };\r\n      var show = function (elm) {\r\n        $$(elm).show();\r\n      };\r\n      var hide = function (elm) {\r\n        $$(elm).hide();\r\n      };\r\n      var isHidden = function (elm) {\r\n        return $$(elm).css('display') === 'none';\r\n      };\r\n      var uniqueId = function (prefix) {\r\n        return (!prefix ? 'mce_' : prefix) + counter++;\r\n      };\r\n      var getOuterHTML = function (elm) {\r\n        var node = typeof elm === 'string' ? get(elm) : elm;\r\n        return isElement$5(node) ? node.outerHTML : DomQuery('<div></div>').append(DomQuery(node).clone()).html();\r\n      };\r\n      var setOuterHTML = function (elm, html) {\r\n        $$(elm).each(function () {\r\n          try {\r\n            if ('outerHTML' in this) {\r\n              this.outerHTML = html;\r\n              return;\r\n            }\r\n          } catch (ex) {\r\n          }\r\n          remove(DomQuery(this).html(html), true);\r\n        });\r\n      };\r\n      var insertAfter = function (node, reference) {\r\n        var referenceNode = get(reference);\r\n        return run(node, function (node) {\r\n          var parent = referenceNode.parentNode;\r\n          var nextSibling = referenceNode.nextSibling;\r\n          if (nextSibling) {\r\n            parent.insertBefore(node, nextSibling);\r\n          } else {\r\n            parent.appendChild(node);\r\n          }\r\n          return node;\r\n        });\r\n      };\r\n      var replace = function (newElm, oldElm, keepChildren) {\r\n        return run(oldElm, function (oldElm) {\r\n          if (Tools.is(oldElm, 'array')) {\r\n            newElm = newElm.cloneNode(true);\r\n          }\r\n          if (keepChildren) {\r\n            each$f(grep$1(oldElm.childNodes), function (node) {\r\n              newElm.appendChild(node);\r\n            });\r\n          }\r\n          return oldElm.parentNode.replaceChild(newElm, oldElm);\r\n        });\r\n      };\r\n      var rename = function (elm, name) {\r\n        var newElm;\r\n        if (elm.nodeName !== name.toUpperCase()) {\r\n          newElm = create(name);\r\n          each$f(getAttribs(elm), function (attrNode) {\r\n            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\r\n          });\r\n          replace(newElm, elm, true);\r\n        }\r\n        return newElm || elm;\r\n      };\r\n      var findCommonAncestor = function (a, b) {\r\n        var ps = a, pe;\r\n        while (ps) {\r\n          pe = b;\r\n          while (pe && ps !== pe) {\r\n            pe = pe.parentNode;\r\n          }\r\n          if (ps === pe) {\r\n            break;\r\n          }\r\n          ps = ps.parentNode;\r\n        }\r\n        if (!ps && a.ownerDocument) {\r\n          return a.ownerDocument.documentElement;\r\n        }\r\n        return ps;\r\n      };\r\n      var toHex = function (rgbVal) {\r\n        return styles.toHex(Tools.trim(rgbVal));\r\n      };\r\n      var isNonEmptyElement = function (node) {\r\n        if (isElement$5(node)) {\r\n          var isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');\r\n          if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      var isEmpty = function (node, elements) {\r\n        var type, name, brCount = 0;\r\n        if (isNonEmptyElement(node)) {\r\n          return false;\r\n        }\r\n        node = node.firstChild;\r\n        if (node) {\r\n          var walker = new DomTreeWalker(node, node.parentNode);\r\n          var whitespace = schema ? schema.getWhiteSpaceElements() : {};\r\n          elements = elements || (schema ? schema.getNonEmptyElements() : null);\r\n          do {\r\n            type = node.nodeType;\r\n            if (isElement$5(node)) {\r\n              var bogusVal = node.getAttribute('data-mce-bogus');\r\n              if (bogusVal) {\r\n                node = walker.next(bogusVal === 'all');\r\n                continue;\r\n              }\r\n              name = node.nodeName.toLowerCase();\r\n              if (elements && elements[name]) {\r\n                if (name === 'br') {\r\n                  brCount++;\r\n                  node = walker.next();\r\n                  continue;\r\n                }\r\n                return false;\r\n              }\r\n              if (isNonEmptyElement(node)) {\r\n                return false;\r\n              }\r\n            }\r\n            if (type === 8) {\r\n              return false;\r\n            }\r\n            if (type === 3 && !isWhitespaceText(node.nodeValue)) {\r\n              return false;\r\n            }\r\n            if (type === 3 && node.parentNode && whitespace[node.parentNode.nodeName] && isWhitespaceText(node.nodeValue)) {\r\n              return false;\r\n            }\r\n            node = walker.next();\r\n          } while (node);\r\n        }\r\n        return brCount <= 1;\r\n      };\r\n      var createRng = function () {\r\n        return doc.createRange();\r\n      };\r\n      var split = function (parentElm, splitElm, replacementElm) {\r\n        var range = createRng();\r\n        var beforeFragment;\r\n        var afterFragment;\r\n        var parentNode;\r\n        if (parentElm && splitElm) {\r\n          range.setStart(parentElm.parentNode, findNodeIndex(parentElm));\r\n          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\r\n          beforeFragment = range.extractContents();\r\n          range = createRng();\r\n          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\r\n          range.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);\r\n          afterFragment = range.extractContents();\r\n          parentNode = parentElm.parentNode;\r\n          parentNode.insertBefore(trimNode(self, beforeFragment), parentElm);\r\n          if (replacementElm) {\r\n            parentNode.insertBefore(replacementElm, parentElm);\r\n          } else {\r\n            parentNode.insertBefore(splitElm, parentElm);\r\n          }\r\n          parentNode.insertBefore(trimNode(self, afterFragment), parentElm);\r\n          remove(parentElm);\r\n          return replacementElm || splitElm;\r\n        }\r\n      };\r\n      var bind = function (target, name, func, scope) {\r\n        if (Tools.isArray(target)) {\r\n          var i = target.length;\r\n          var rv = [];\r\n          while (i--) {\r\n            rv[i] = bind(target[i], name, func, scope);\r\n          }\r\n          return rv;\r\n        }\r\n        if (settings.collect && (target === doc || target === win)) {\r\n          boundEvents.push([\r\n            target,\r\n            name,\r\n            func,\r\n            scope\r\n          ]);\r\n        }\r\n        var output = events.bind(target, name, func, scope || self);\r\n        return output;\r\n      };\r\n      var unbind = function (target, name, func) {\r\n        if (Tools.isArray(target)) {\r\n          var i = target.length;\r\n          var rv = [];\r\n          while (i--) {\r\n            rv[i] = unbind(target[i], name, func);\r\n          }\r\n          return rv;\r\n        } else {\r\n          if (boundEvents.length > 0 && (target === doc || target === win)) {\r\n            var i = boundEvents.length;\r\n            while (i--) {\r\n              var item = boundEvents[i];\r\n              if (target === item[0] && (!name || name === item[1]) && (!func || func === item[2])) {\r\n                events.unbind(item[0], item[1], item[2]);\r\n              }\r\n            }\r\n          }\r\n          return events.unbind(target, name, func);\r\n        }\r\n      };\r\n      var fire = function (target, name, evt) {\r\n        return events.fire(target, name, evt);\r\n      };\r\n      var getContentEditable = function (node) {\r\n        if (node && isElement$5(node)) {\r\n          var contentEditable = node.getAttribute('data-mce-contenteditable');\r\n          if (contentEditable && contentEditable !== 'inherit') {\r\n            return contentEditable;\r\n          }\r\n          return node.contentEditable !== 'inherit' ? node.contentEditable : null;\r\n        } else {\r\n          return null;\r\n        }\r\n      };\r\n      var getContentEditableParent = function (node) {\r\n        var root = getRoot();\r\n        var state = null;\r\n        for (; node && node !== root; node = node.parentNode) {\r\n          state = getContentEditable(node);\r\n          if (state !== null) {\r\n            break;\r\n          }\r\n        }\r\n        return state;\r\n      };\r\n      var destroy = function () {\r\n        if (boundEvents.length > 0) {\r\n          var i = boundEvents.length;\r\n          while (i--) {\r\n            var item = boundEvents[i];\r\n            events.unbind(item[0], item[1], item[2]);\r\n          }\r\n        }\r\n        each$j(files, function (_, url) {\r\n          styleSheetLoader.unload(url);\r\n          delete files[url];\r\n        });\r\n        if (Sizzle.setDocument) {\r\n          Sizzle.setDocument();\r\n        }\r\n      };\r\n      var isChildOf = function (node, parent) {\r\n        if (!isIE) {\r\n          return node === parent || parent.contains(node);\r\n        } else {\r\n          while (node) {\r\n            if (parent === node) {\r\n              return true;\r\n            }\r\n            node = node.parentNode;\r\n          }\r\n          return false;\r\n        }\r\n      };\r\n      var dumpRng = function (r) {\r\n        return 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\r\n      };\r\n      var self = {\r\n        doc: doc,\r\n        settings: settings,\r\n        win: win,\r\n        files: files,\r\n        stdMode: stdMode,\r\n        boxModel: boxModel,\r\n        styleSheetLoader: styleSheetLoader,\r\n        boundEvents: boundEvents,\r\n        styles: styles,\r\n        schema: schema,\r\n        events: events,\r\n        isBlock: isBlock,\r\n        $: $,\r\n        $$: $$,\r\n        root: null,\r\n        clone: clone,\r\n        getRoot: getRoot,\r\n        getViewPort: getViewPort,\r\n        getRect: getRect,\r\n        getSize: getSize,\r\n        getParent: getParent,\r\n        getParents: getParents,\r\n        get: get,\r\n        getNext: getNext,\r\n        getPrev: getPrev,\r\n        select: select,\r\n        is: is,\r\n        add: add,\r\n        create: create,\r\n        createHTML: createHTML,\r\n        createFragment: createFragment,\r\n        remove: remove,\r\n        setStyle: setStyle,\r\n        getStyle: getStyle,\r\n        setStyles: setStyles,\r\n        removeAllAttribs: removeAllAttribs,\r\n        setAttrib: setAttrib,\r\n        setAttribs: setAttribs,\r\n        getAttrib: getAttrib,\r\n        getPos: getPos$1,\r\n        parseStyle: parseStyle,\r\n        serializeStyle: serializeStyle,\r\n        addStyle: addStyle,\r\n        loadCSS: loadCSS,\r\n        addClass: addClass,\r\n        removeClass: removeClass,\r\n        hasClass: hasClass,\r\n        toggleClass: toggleClass,\r\n        show: show,\r\n        hide: hide,\r\n        isHidden: isHidden,\r\n        uniqueId: uniqueId,\r\n        setHTML: setHTML,\r\n        getOuterHTML: getOuterHTML,\r\n        setOuterHTML: setOuterHTML,\r\n        decode: decode,\r\n        encode: encode,\r\n        insertAfter: insertAfter,\r\n        replace: replace,\r\n        rename: rename,\r\n        findCommonAncestor: findCommonAncestor,\r\n        toHex: toHex,\r\n        run: run,\r\n        getAttribs: getAttribs,\r\n        isEmpty: isEmpty,\r\n        createRng: createRng,\r\n        nodeIndex: findNodeIndex,\r\n        split: split,\r\n        bind: bind,\r\n        unbind: unbind,\r\n        fire: fire,\r\n        getContentEditable: getContentEditable,\r\n        getContentEditableParent: getContentEditableParent,\r\n        destroy: destroy,\r\n        isChildOf: isChildOf,\r\n        dumpRng: dumpRng\r\n      };\r\n      var attrHooks = setupAttrHooks(styles, settings, constant(self));\r\n      return self;\r\n    };\r\n    DOMUtils.DOM = DOMUtils(document);\r\n    DOMUtils.nodeIndex = findNodeIndex;\r\n\r\n    var DOM$a = DOMUtils.DOM;\r\n    var each$e = Tools.each, grep = Tools.grep;\r\n    var QUEUED = 0;\r\n    var LOADING = 1;\r\n    var LOADED = 2;\r\n    var FAILED = 3;\r\n    var ScriptLoader = function () {\r\n      function ScriptLoader(settings) {\r\n        if (settings === void 0) {\r\n          settings = {};\r\n        }\r\n        this.states = {};\r\n        this.queue = [];\r\n        this.scriptLoadedCallbacks = {};\r\n        this.queueLoadedCallbacks = [];\r\n        this.loading = 0;\r\n        this.settings = settings;\r\n      }\r\n      ScriptLoader.prototype._setReferrerPolicy = function (referrerPolicy) {\r\n        this.settings.referrerPolicy = referrerPolicy;\r\n      };\r\n      ScriptLoader.prototype.loadScript = function (url, success, failure) {\r\n        var dom = DOM$a;\r\n        var elm;\r\n        var cleanup = function () {\r\n          dom.remove(id);\r\n          if (elm) {\r\n            elm.onerror = elm.onload = elm = null;\r\n          }\r\n        };\r\n        var done = function () {\r\n          cleanup();\r\n          success();\r\n        };\r\n        var error = function () {\r\n          cleanup();\r\n          if (isFunction(failure)) {\r\n            failure();\r\n          } else {\r\n            if (typeof console !== 'undefined' && console.log) {\r\n              console.log('Failed to load script: ' + url);\r\n            }\r\n          }\r\n        };\r\n        var id = dom.uniqueId();\r\n        elm = document.createElement('script');\r\n        elm.id = id;\r\n        elm.type = 'text/javascript';\r\n        elm.src = Tools._addCacheSuffix(url);\r\n        if (this.settings.referrerPolicy) {\r\n          dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\r\n        }\r\n        elm.onload = done;\r\n        elm.onerror = error;\r\n        (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\r\n      };\r\n      ScriptLoader.prototype.isDone = function (url) {\r\n        return this.states[url] === LOADED;\r\n      };\r\n      ScriptLoader.prototype.markDone = function (url) {\r\n        this.states[url] = LOADED;\r\n      };\r\n      ScriptLoader.prototype.add = function (url, success, scope, failure) {\r\n        var state = this.states[url];\r\n        this.queue.push(url);\r\n        if (state === undefined) {\r\n          this.states[url] = QUEUED;\r\n        }\r\n        if (success) {\r\n          if (!this.scriptLoadedCallbacks[url]) {\r\n            this.scriptLoadedCallbacks[url] = [];\r\n          }\r\n          this.scriptLoadedCallbacks[url].push({\r\n            success: success,\r\n            failure: failure,\r\n            scope: scope || this\r\n          });\r\n        }\r\n      };\r\n      ScriptLoader.prototype.load = function (url, success, scope, failure) {\r\n        return this.add(url, success, scope, failure);\r\n      };\r\n      ScriptLoader.prototype.remove = function (url) {\r\n        delete this.states[url];\r\n        delete this.scriptLoadedCallbacks[url];\r\n      };\r\n      ScriptLoader.prototype.loadQueue = function (success, scope, failure) {\r\n        this.loadScripts(this.queue, success, scope, failure);\r\n      };\r\n      ScriptLoader.prototype.loadScripts = function (scripts, success, scope, failure) {\r\n        var self = this;\r\n        var failures = [];\r\n        var execCallbacks = function (name, url) {\r\n          each$e(self.scriptLoadedCallbacks[url], function (callback) {\r\n            if (isFunction(callback[name])) {\r\n              callback[name].call(callback.scope);\r\n            }\r\n          });\r\n          self.scriptLoadedCallbacks[url] = undefined;\r\n        };\r\n        self.queueLoadedCallbacks.push({\r\n          success: success,\r\n          failure: failure,\r\n          scope: scope || this\r\n        });\r\n        var loadScripts = function () {\r\n          var loadingScripts = grep(scripts);\r\n          scripts.length = 0;\r\n          each$e(loadingScripts, function (url) {\r\n            if (self.states[url] === LOADED) {\r\n              execCallbacks('success', url);\r\n              return;\r\n            }\r\n            if (self.states[url] === FAILED) {\r\n              execCallbacks('failure', url);\r\n              return;\r\n            }\r\n            if (self.states[url] !== LOADING) {\r\n              self.states[url] = LOADING;\r\n              self.loading++;\r\n              self.loadScript(url, function () {\r\n                self.states[url] = LOADED;\r\n                self.loading--;\r\n                execCallbacks('success', url);\r\n                loadScripts();\r\n              }, function () {\r\n                self.states[url] = FAILED;\r\n                self.loading--;\r\n                failures.push(url);\r\n                execCallbacks('failure', url);\r\n                loadScripts();\r\n              });\r\n            }\r\n          });\r\n          if (!self.loading) {\r\n            var notifyCallbacks = self.queueLoadedCallbacks.slice(0);\r\n            self.queueLoadedCallbacks.length = 0;\r\n            each$e(notifyCallbacks, function (callback) {\r\n              if (failures.length === 0) {\r\n                if (isFunction(callback.success)) {\r\n                  callback.success.call(callback.scope);\r\n                }\r\n              } else {\r\n                if (isFunction(callback.failure)) {\r\n                  callback.failure.call(callback.scope, failures);\r\n                }\r\n              }\r\n            });\r\n          }\r\n        };\r\n        loadScripts();\r\n      };\r\n      ScriptLoader.ScriptLoader = new ScriptLoader();\r\n      return ScriptLoader;\r\n    }();\r\n\r\n    var Cell = function (initial) {\r\n      var value = initial;\r\n      var get = function () {\r\n        return value;\r\n      };\r\n      var set = function (v) {\r\n        value = v;\r\n      };\r\n      return {\r\n        get: get,\r\n        set: set\r\n      };\r\n    };\r\n\r\n    var isRaw = function (str) {\r\n      return isObject(str) && has$2(str, 'raw');\r\n    };\r\n    var isTokenised = function (str) {\r\n      return isArray$1(str) && str.length > 1;\r\n    };\r\n    var data = {};\r\n    var currentCode = Cell('en');\r\n    var getLanguageData = function () {\r\n      return get$9(data, currentCode.get());\r\n    };\r\n    var getData = function () {\r\n      return map$2(data, function (value) {\r\n        return __assign({}, value);\r\n      });\r\n    };\r\n    var setCode = function (newCode) {\r\n      if (newCode) {\r\n        currentCode.set(newCode);\r\n      }\r\n    };\r\n    var getCode = function () {\r\n      return currentCode.get();\r\n    };\r\n    var add$4 = function (code, items) {\r\n      var langData = data[code];\r\n      if (!langData) {\r\n        data[code] = langData = {};\r\n      }\r\n      each$j(items, function (translation, name) {\r\n        langData[name.toLowerCase()] = translation;\r\n      });\r\n    };\r\n    var translate = function (text) {\r\n      var langData = getLanguageData().getOr({});\r\n      var toString = function (obj) {\r\n        if (isFunction(obj)) {\r\n          return Object.prototype.toString.call(obj);\r\n        }\r\n        return !isEmpty(obj) ? '' + obj : '';\r\n      };\r\n      var isEmpty = function (text) {\r\n        return text === '' || text === null || text === undefined;\r\n      };\r\n      var getLangData = function (text) {\r\n        var textstr = toString(text);\r\n        return get$9(langData, textstr.toLowerCase()).map(toString).getOr(textstr);\r\n      };\r\n      var removeContext = function (str) {\r\n        return str.replace(/{context:\\w+}$/, '');\r\n      };\r\n      if (isEmpty(text)) {\r\n        return '';\r\n      }\r\n      if (isRaw(text)) {\r\n        return toString(text.raw);\r\n      }\r\n      if (isTokenised(text)) {\r\n        var values_1 = text.slice(1);\r\n        var substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, function ($1, $2) {\r\n          return has$2(values_1, $2) ? toString(values_1[$2]) : $1;\r\n        });\r\n        return removeContext(substitued);\r\n      }\r\n      return removeContext(getLangData(text));\r\n    };\r\n    var isRtl$1 = function () {\r\n      return getLanguageData().bind(function (items) {\r\n        return get$9(items, '_dir');\r\n      }).exists(function (dir) {\r\n        return dir === 'rtl';\r\n      });\r\n    };\r\n    var hasCode = function (code) {\r\n      return has$2(data, code);\r\n    };\r\n    var I18n = {\r\n      getData: getData,\r\n      setCode: setCode,\r\n      getCode: getCode,\r\n      add: add$4,\r\n      translate: translate,\r\n      isRtl: isRtl$1,\r\n      hasCode: hasCode\r\n    };\r\n\r\n    var AddOnManager = function () {\r\n      var items = [];\r\n      var urls = {};\r\n      var lookup = {};\r\n      var _listeners = [];\r\n      var runListeners = function (name, state) {\r\n        var matchedListeners = filter$4(_listeners, function (listener) {\r\n          return listener.name === name && listener.state === state;\r\n        });\r\n        each$k(matchedListeners, function (listener) {\r\n          return listener.callback();\r\n        });\r\n      };\r\n      var get = function (name) {\r\n        if (lookup[name]) {\r\n          return lookup[name].instance;\r\n        }\r\n        return undefined;\r\n      };\r\n      var dependencies = function (name) {\r\n        var result;\r\n        if (lookup[name]) {\r\n          result = lookup[name].dependencies;\r\n        }\r\n        return result || [];\r\n      };\r\n      var requireLangPack = function (name, languages) {\r\n        if (AddOnManager.languageLoad !== false) {\r\n          waitFor(name, function () {\r\n            var language = I18n.getCode();\r\n            var wrappedLanguages = ',' + (languages || '') + ',';\r\n            if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\r\n              return;\r\n            }\r\n            ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\r\n          }, 'loaded');\r\n        }\r\n      };\r\n      var add = function (id, addOn, dependencies) {\r\n        var addOnConstructor = addOn;\r\n        items.push(addOnConstructor);\r\n        lookup[id] = {\r\n          instance: addOnConstructor,\r\n          dependencies: dependencies\r\n        };\r\n        runListeners(id, 'added');\r\n        return addOnConstructor;\r\n      };\r\n      var remove = function (name) {\r\n        delete urls[name];\r\n        delete lookup[name];\r\n      };\r\n      var createUrl = function (baseUrl, dep) {\r\n        if (typeof dep === 'object') {\r\n          return dep;\r\n        }\r\n        return typeof baseUrl === 'string' ? {\r\n          prefix: '',\r\n          resource: dep,\r\n          suffix: ''\r\n        } : {\r\n          prefix: baseUrl.prefix,\r\n          resource: dep,\r\n          suffix: baseUrl.suffix\r\n        };\r\n      };\r\n      var addComponents = function (pluginName, scripts) {\r\n        var pluginUrl = urls[pluginName];\r\n        each$k(scripts, function (script) {\r\n          ScriptLoader.ScriptLoader.add(pluginUrl + '/' + script);\r\n        });\r\n      };\r\n      var loadDependencies = function (name, addOnUrl, success, scope) {\r\n        var deps = dependencies(name);\r\n        each$k(deps, function (dep) {\r\n          var newUrl = createUrl(addOnUrl, dep);\r\n          load(newUrl.resource, newUrl, undefined, undefined);\r\n        });\r\n        if (success) {\r\n          if (scope) {\r\n            success.call(scope);\r\n          } else {\r\n            success.call(ScriptLoader);\r\n          }\r\n        }\r\n      };\r\n      var load = function (name, addOnUrl, success, scope, failure) {\r\n        if (urls[name]) {\r\n          return;\r\n        }\r\n        var urlString = typeof addOnUrl === 'string' ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\r\n        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\r\n          urlString = AddOnManager.baseURL + '/' + urlString;\r\n        }\r\n        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\r\n        var done = function () {\r\n          runListeners(name, 'loaded');\r\n          loadDependencies(name, addOnUrl, success, scope);\r\n        };\r\n        if (lookup[name]) {\r\n          done();\r\n        } else {\r\n          ScriptLoader.ScriptLoader.add(urlString, done, scope, failure);\r\n        }\r\n      };\r\n      var waitFor = function (name, callback, state) {\r\n        if (state === void 0) {\r\n          state = 'added';\r\n        }\r\n        if (has$2(lookup, name) && state === 'added') {\r\n          callback();\r\n        } else if (has$2(urls, name) && state === 'loaded') {\r\n          callback();\r\n        } else {\r\n          _listeners.push({\r\n            name: name,\r\n            state: state,\r\n            callback: callback\r\n          });\r\n        }\r\n      };\r\n      return {\r\n        items: items,\r\n        urls: urls,\r\n        lookup: lookup,\r\n        _listeners: _listeners,\r\n        get: get,\r\n        dependencies: dependencies,\r\n        requireLangPack: requireLangPack,\r\n        add: add,\r\n        remove: remove,\r\n        createUrl: createUrl,\r\n        addComponents: addComponents,\r\n        load: load,\r\n        waitFor: waitFor\r\n      };\r\n    };\r\n    AddOnManager.languageLoad = true;\r\n    AddOnManager.baseURL = '';\r\n    AddOnManager.PluginManager = AddOnManager();\r\n    AddOnManager.ThemeManager = AddOnManager();\r\n\r\n    var singleton = function (doRevoke) {\r\n      var subject = Cell(Optional.none());\r\n      var revoke = function () {\r\n        return subject.get().each(doRevoke);\r\n      };\r\n      var clear = function () {\r\n        revoke();\r\n        subject.set(Optional.none());\r\n      };\r\n      var isSet = function () {\r\n        return subject.get().isSome();\r\n      };\r\n      var get = function () {\r\n        return subject.get();\r\n      };\r\n      var set = function (s) {\r\n        revoke();\r\n        subject.set(Optional.some(s));\r\n      };\r\n      return {\r\n        clear: clear,\r\n        isSet: isSet,\r\n        get: get,\r\n        set: set\r\n      };\r\n    };\r\n    var value = function () {\r\n      var subject = singleton(noop);\r\n      var on = function (f) {\r\n        return subject.get().each(f);\r\n      };\r\n      return __assign(__assign({}, subject), { on: on });\r\n    };\r\n\r\n    var first = function (fn, rate) {\r\n      var timer = null;\r\n      var cancel = function () {\r\n        if (!isNull(timer)) {\r\n          clearTimeout(timer);\r\n          timer = null;\r\n        }\r\n      };\r\n      var throttle = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        if (isNull(timer)) {\r\n          timer = setTimeout(function () {\r\n            timer = null;\r\n            fn.apply(null, args);\r\n          }, rate);\r\n        }\r\n      };\r\n      return {\r\n        cancel: cancel,\r\n        throttle: throttle\r\n      };\r\n    };\r\n    var last = function (fn, rate) {\r\n      var timer = null;\r\n      var cancel = function () {\r\n        if (!isNull(timer)) {\r\n          clearTimeout(timer);\r\n          timer = null;\r\n        }\r\n      };\r\n      var throttle = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        cancel();\r\n        timer = setTimeout(function () {\r\n          timer = null;\r\n          fn.apply(null, args);\r\n        }, rate);\r\n      };\r\n      return {\r\n        cancel: cancel,\r\n        throttle: throttle\r\n      };\r\n    };\r\n\r\n    var read$4 = function (element, attr) {\r\n      var value = get$6(element, attr);\r\n      return value === undefined || value === '' ? [] : value.split(' ');\r\n    };\r\n    var add$3 = function (element, attr, id) {\r\n      var old = read$4(element, attr);\r\n      var nu = old.concat([id]);\r\n      set$1(element, attr, nu.join(' '));\r\n      return true;\r\n    };\r\n    var remove$5 = function (element, attr, id) {\r\n      var nu = filter$4(read$4(element, attr), function (v) {\r\n        return v !== id;\r\n      });\r\n      if (nu.length > 0) {\r\n        set$1(element, attr, nu.join(' '));\r\n      } else {\r\n        remove$6(element, attr);\r\n      }\r\n      return false;\r\n    };\r\n\r\n    var supports = function (element) {\r\n      return element.dom.classList !== undefined;\r\n    };\r\n    var get$4 = function (element) {\r\n      return read$4(element, 'class');\r\n    };\r\n    var add$2 = function (element, clazz) {\r\n      return add$3(element, 'class', clazz);\r\n    };\r\n    var remove$4 = function (element, clazz) {\r\n      return remove$5(element, 'class', clazz);\r\n    };\r\n\r\n    var add$1 = function (element, clazz) {\r\n      if (supports(element)) {\r\n        element.dom.classList.add(clazz);\r\n      } else {\r\n        add$2(element, clazz);\r\n      }\r\n    };\r\n    var cleanClass = function (element) {\r\n      var classList = supports(element) ? element.dom.classList : get$4(element);\r\n      if (classList.length === 0) {\r\n        remove$6(element, 'class');\r\n      }\r\n    };\r\n    var remove$3 = function (element, clazz) {\r\n      if (supports(element)) {\r\n        var classList = element.dom.classList;\r\n        classList.remove(clazz);\r\n      } else {\r\n        remove$4(element, clazz);\r\n      }\r\n      cleanClass(element);\r\n    };\r\n    var has = function (element, clazz) {\r\n      return supports(element) && element.dom.classList.contains(clazz);\r\n    };\r\n\r\n    var descendants$1 = function (scope, predicate) {\r\n      var result = [];\r\n      each$k(children(scope), function (x) {\r\n        if (predicate(x)) {\r\n          result = result.concat([x]);\r\n        }\r\n        result = result.concat(descendants$1(x, predicate));\r\n      });\r\n      return result;\r\n    };\r\n\r\n    var descendants = function (scope, selector) {\r\n      return all(selector, scope);\r\n    };\r\n\r\n    var annotation = constant('mce-annotation');\r\n    var dataAnnotation = constant('data-mce-annotation');\r\n    var dataAnnotationId = constant('data-mce-annotation-uid');\r\n\r\n    var identify = function (editor, annotationName) {\r\n      var rng = editor.selection.getRng();\r\n      var start = SugarElement.fromDom(rng.startContainer);\r\n      var root = SugarElement.fromDom(editor.getBody());\r\n      var selector = annotationName.fold(function () {\r\n        return '.' + annotation();\r\n      }, function (an) {\r\n        return '[' + dataAnnotation() + '=\"' + an + '\"]';\r\n      });\r\n      var newStart = child$1(start, rng.startOffset).getOr(start);\r\n      var closest = closest$2(newStart, selector, function (n) {\r\n        return eq(n, root);\r\n      });\r\n      var getAttr = function (c, property) {\r\n        if (has$1(c, property)) {\r\n          return Optional.some(get$6(c, property));\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      };\r\n      return closest.bind(function (c) {\r\n        return getAttr(c, '' + dataAnnotationId()).bind(function (uid) {\r\n          return getAttr(c, '' + dataAnnotation()).map(function (name) {\r\n            var elements = findMarkers(editor, uid);\r\n            return {\r\n              uid: uid,\r\n              name: name,\r\n              elements: elements\r\n            };\r\n          });\r\n        });\r\n      });\r\n    };\r\n    var isAnnotation = function (elem) {\r\n      return isElement$6(elem) && has(elem, annotation());\r\n    };\r\n    var findMarkers = function (editor, uid) {\r\n      var body = SugarElement.fromDom(editor.getBody());\r\n      return descendants(body, '[' + dataAnnotationId() + '=\"' + uid + '\"]');\r\n    };\r\n    var findAll = function (editor, name) {\r\n      var body = SugarElement.fromDom(editor.getBody());\r\n      var markers = descendants(body, '[' + dataAnnotation() + '=\"' + name + '\"]');\r\n      var directory = {};\r\n      each$k(markers, function (m) {\r\n        var uid = get$6(m, dataAnnotationId());\r\n        var nodesAlready = get$9(directory, uid).getOr([]);\r\n        directory[uid] = nodesAlready.concat([m]);\r\n      });\r\n      return directory;\r\n    };\r\n\r\n    var setup$n = function (editor, _registry) {\r\n      var changeCallbacks = Cell({});\r\n      var initData = function () {\r\n        return {\r\n          listeners: [],\r\n          previous: value()\r\n        };\r\n      };\r\n      var withCallbacks = function (name, f) {\r\n        updateCallbacks(name, function (data) {\r\n          f(data);\r\n          return data;\r\n        });\r\n      };\r\n      var updateCallbacks = function (name, f) {\r\n        var callbackMap = changeCallbacks.get();\r\n        var data = get$9(callbackMap, name).getOrThunk(initData);\r\n        var outputData = f(data);\r\n        callbackMap[name] = outputData;\r\n        changeCallbacks.set(callbackMap);\r\n      };\r\n      var fireCallbacks = function (name, uid, elements) {\r\n        withCallbacks(name, function (data) {\r\n          each$k(data.listeners, function (f) {\r\n            return f(true, name, {\r\n              uid: uid,\r\n              nodes: map$3(elements, function (elem) {\r\n                return elem.dom;\r\n              })\r\n            });\r\n          });\r\n        });\r\n      };\r\n      var fireNoAnnotation = function (name) {\r\n        withCallbacks(name, function (data) {\r\n          each$k(data.listeners, function (f) {\r\n            return f(false, name);\r\n          });\r\n        });\r\n      };\r\n      var onNodeChange = last(function () {\r\n        var callbackMap = changeCallbacks.get();\r\n        var annotations = sort(keys(callbackMap));\r\n        each$k(annotations, function (name) {\r\n          updateCallbacks(name, function (data) {\r\n            var prev = data.previous.get();\r\n            identify(editor, Optional.some(name)).fold(function () {\r\n              if (prev.isSome()) {\r\n                fireNoAnnotation(name);\r\n                data.previous.clear();\r\n              }\r\n            }, function (_a) {\r\n              var uid = _a.uid, name = _a.name, elements = _a.elements;\r\n              if (!is$1(prev, uid)) {\r\n                fireCallbacks(name, uid, elements);\r\n                data.previous.set(uid);\r\n              }\r\n            });\r\n            return {\r\n              previous: data.previous,\r\n              listeners: data.listeners\r\n            };\r\n          });\r\n        });\r\n      }, 30);\r\n      editor.on('remove', function () {\r\n        onNodeChange.cancel();\r\n      });\r\n      editor.on('NodeChange', function () {\r\n        onNodeChange.throttle();\r\n      });\r\n      var addListener = function (name, f) {\r\n        updateCallbacks(name, function (data) {\r\n          return {\r\n            previous: data.previous,\r\n            listeners: data.listeners.concat([f])\r\n          };\r\n        });\r\n      };\r\n      return { addListener: addListener };\r\n    };\r\n\r\n    var setup$m = function (editor, registry) {\r\n      var identifyParserNode = function (span) {\r\n        return Optional.from(span.attr(dataAnnotation())).bind(registry.lookup);\r\n      };\r\n      editor.on('init', function () {\r\n        editor.serializer.addNodeFilter('span', function (spans) {\r\n          each$k(spans, function (span) {\r\n            identifyParserNode(span).each(function (settings) {\r\n              if (settings.persistent === false) {\r\n                span.unwrap();\r\n              }\r\n            });\r\n          });\r\n        });\r\n      });\r\n    };\r\n\r\n    var create$7 = function () {\r\n      var annotations = {};\r\n      var register = function (name, settings) {\r\n        annotations[name] = {\r\n          name: name,\r\n          settings: settings\r\n        };\r\n      };\r\n      var lookup = function (name) {\r\n        return get$9(annotations, name).map(function (a) {\r\n          return a.settings;\r\n        });\r\n      };\r\n      return {\r\n        register: register,\r\n        lookup: lookup\r\n      };\r\n    };\r\n\r\n    var unique = 0;\r\n    var generate = function (prefix) {\r\n      var date = new Date();\r\n      var time = date.getTime();\r\n      var random = Math.floor(Math.random() * 1000000000);\r\n      unique++;\r\n      return prefix + '_' + random + unique + String(time);\r\n    };\r\n\r\n    var add = function (element, classes) {\r\n      each$k(classes, function (x) {\r\n        add$1(element, x);\r\n      });\r\n    };\r\n\r\n    var fromHtml = function (html, scope) {\r\n      var doc = scope || document;\r\n      var div = doc.createElement('div');\r\n      div.innerHTML = html;\r\n      return children(SugarElement.fromDom(div));\r\n    };\r\n    var fromDom$1 = function (nodes) {\r\n      return map$3(nodes, SugarElement.fromDom);\r\n    };\r\n\r\n    var get$3 = function (element) {\r\n      return element.dom.innerHTML;\r\n    };\r\n    var set = function (element, content) {\r\n      var owner = owner$1(element);\r\n      var docDom = owner.dom;\r\n      var fragment = SugarElement.fromDom(docDom.createDocumentFragment());\r\n      var contentElements = fromHtml(content, docDom);\r\n      append(fragment, contentElements);\r\n      empty(element);\r\n      append$1(element, fragment);\r\n    };\r\n\r\n    var clone$1 = function (original, isDeep) {\r\n      return SugarElement.fromDom(original.dom.cloneNode(isDeep));\r\n    };\r\n    var shallow = function (original) {\r\n      return clone$1(original, false);\r\n    };\r\n    var deep$1 = function (original) {\r\n      return clone$1(original, true);\r\n    };\r\n\r\n    var TextWalker = function (startNode, rootNode, isBoundary) {\r\n      if (isBoundary === void 0) {\r\n        isBoundary = never;\r\n      }\r\n      var walker = new DomTreeWalker(startNode, rootNode);\r\n      var walk = function (direction) {\r\n        var next;\r\n        do {\r\n          next = walker[direction]();\r\n        } while (next && !isText$7(next) && !isBoundary(next));\r\n        return Optional.from(next).filter(isText$7);\r\n      };\r\n      return {\r\n        current: function () {\r\n          return Optional.from(walker.current()).filter(isText$7);\r\n        },\r\n        next: function () {\r\n          return walk('next');\r\n        },\r\n        prev: function () {\r\n          return walk('prev');\r\n        },\r\n        prev2: function () {\r\n          return walk('prev2');\r\n        }\r\n      };\r\n    };\r\n\r\n    var TextSeeker = function (dom, isBoundary) {\r\n      var isBlockBoundary = isBoundary ? isBoundary : function (node) {\r\n        return dom.isBlock(node) || isBr$5(node) || isContentEditableFalse$b(node);\r\n      };\r\n      var walk = function (node, offset, walker, process) {\r\n        if (isText$7(node)) {\r\n          var newOffset = process(node, offset, node.data);\r\n          if (newOffset !== -1) {\r\n            return Optional.some({\r\n              container: node,\r\n              offset: newOffset\r\n            });\r\n          }\r\n        }\r\n        return walker().bind(function (next) {\r\n          return walk(next.container, next.offset, walker, process);\r\n        });\r\n      };\r\n      var backwards = function (node, offset, process, root) {\r\n        var walker = TextWalker(node, root, isBlockBoundary);\r\n        return walk(node, offset, function () {\r\n          return walker.prev().map(function (prev) {\r\n            return {\r\n              container: prev,\r\n              offset: prev.length\r\n            };\r\n          });\r\n        }, process).getOrNull();\r\n      };\r\n      var forwards = function (node, offset, process, root) {\r\n        var walker = TextWalker(node, root, isBlockBoundary);\r\n        return walk(node, offset, function () {\r\n          return walker.next().map(function (next) {\r\n            return {\r\n              container: next,\r\n              offset: 0\r\n            };\r\n          });\r\n        }, process).getOrNull();\r\n      };\r\n      return {\r\n        backwards: backwards,\r\n        forwards: forwards\r\n      };\r\n    };\r\n\r\n    var round$2 = Math.round;\r\n    var clone = function (rect) {\r\n      if (!rect) {\r\n        return {\r\n          left: 0,\r\n          top: 0,\r\n          bottom: 0,\r\n          right: 0,\r\n          width: 0,\r\n          height: 0\r\n        };\r\n      }\r\n      return {\r\n        left: round$2(rect.left),\r\n        top: round$2(rect.top),\r\n        bottom: round$2(rect.bottom),\r\n        right: round$2(rect.right),\r\n        width: round$2(rect.width),\r\n        height: round$2(rect.height)\r\n      };\r\n    };\r\n    var collapse = function (rect, toStart) {\r\n      rect = clone(rect);\r\n      if (toStart) {\r\n        rect.right = rect.left;\r\n      } else {\r\n        rect.left = rect.left + rect.width;\r\n        rect.right = rect.left;\r\n      }\r\n      rect.width = 0;\r\n      return rect;\r\n    };\r\n    var isEqual = function (rect1, rect2) {\r\n      return rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\r\n    };\r\n    var isValidOverflow = function (overflowY, rect1, rect2) {\r\n      return overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\r\n    };\r\n    var isAbove$1 = function (rect1, rect2) {\r\n      var halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\r\n      if (rect1.bottom - halfHeight < rect2.top) {\r\n        return true;\r\n      }\r\n      if (rect1.top > rect2.bottom) {\r\n        return false;\r\n      }\r\n      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\r\n    };\r\n    var isBelow$1 = function (rect1, rect2) {\r\n      if (rect1.top > rect2.bottom) {\r\n        return true;\r\n      }\r\n      if (rect1.bottom < rect2.top) {\r\n        return false;\r\n      }\r\n      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\r\n    };\r\n    var containsXY = function (rect, clientX, clientY) {\r\n      return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\r\n    };\r\n\r\n    var clamp$2 = function (value, min, max) {\r\n      return Math.min(Math.max(value, min), max);\r\n    };\r\n\r\n    var getSelectedNode = function (range) {\r\n      var startContainer = range.startContainer, startOffset = range.startOffset;\r\n      if (startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\r\n        return startContainer.childNodes[startOffset];\r\n      }\r\n      return null;\r\n    };\r\n    var getNode$1 = function (container, offset) {\r\n      if (isElement$5(container) && container.hasChildNodes()) {\r\n        var childNodes = container.childNodes;\r\n        var safeOffset = clamp$2(offset, 0, childNodes.length - 1);\r\n        return childNodes[safeOffset];\r\n      } else {\r\n        return container;\r\n      }\r\n    };\r\n    var getNodeUnsafe = function (container, offset) {\r\n      if (offset < 0 && isElement$5(container) && container.hasChildNodes()) {\r\n        return undefined;\r\n      } else {\r\n        return getNode$1(container, offset);\r\n      }\r\n    };\r\n\r\n    var extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\r\n    var isExtendingChar = function (ch) {\r\n      return typeof ch === 'string' && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\r\n    };\r\n\r\n    var or = function () {\r\n      var args = [];\r\n      for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n      }\r\n      return function (x) {\r\n        for (var i = 0; i < args.length; i++) {\r\n          if (args[i](x)) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n    };\r\n    var and = function () {\r\n      var args = [];\r\n      for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n      }\r\n      return function (x) {\r\n        for (var i = 0; i < args.length; i++) {\r\n          if (!args[i](x)) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      };\r\n    };\r\n\r\n    var isElement$3 = isElement$5;\r\n    var isCaretCandidate$2 = isCaretCandidate$3;\r\n    var isBlock$1 = matchStyleValues('display', 'block table');\r\n    var isFloated = matchStyleValues('float', 'left right');\r\n    var isValidElementCaretCandidate = and(isElement$3, isCaretCandidate$2, not(isFloated));\r\n    var isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\r\n    var isText$4 = isText$7;\r\n    var isBr$2 = isBr$5;\r\n    var nodeIndex$1 = DOMUtils.nodeIndex;\r\n    var resolveIndex$1 = getNodeUnsafe;\r\n    var createRange$1 = function (doc) {\r\n      return 'createRange' in doc ? doc.createRange() : DOMUtils.DOM.createRng();\r\n    };\r\n    var isWhiteSpace$1 = function (chr) {\r\n      return chr && /[\\r\\n\\t ]/.test(chr);\r\n    };\r\n    var isRange = function (rng) {\r\n      return !!rng.setStart && !!rng.setEnd;\r\n    };\r\n    var isHiddenWhiteSpaceRange = function (range) {\r\n      var container = range.startContainer;\r\n      var offset = range.startOffset;\r\n      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$7(container)) {\r\n        var text = container.data;\r\n        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var getBrClientRect = function (brNode) {\r\n      var doc = brNode.ownerDocument;\r\n      var rng = createRange$1(doc);\r\n      var nbsp$1 = doc.createTextNode(nbsp);\r\n      var parentNode = brNode.parentNode;\r\n      parentNode.insertBefore(nbsp$1, brNode);\r\n      rng.setStart(nbsp$1, 0);\r\n      rng.setEnd(nbsp$1, 1);\r\n      var clientRect = clone(rng.getBoundingClientRect());\r\n      parentNode.removeChild(nbsp$1);\r\n      return clientRect;\r\n    };\r\n    var getBoundingClientRectWebKitText = function (rng) {\r\n      var sc = rng.startContainer;\r\n      var ec = rng.endContainer;\r\n      var so = rng.startOffset;\r\n      var eo = rng.endOffset;\r\n      if (sc === ec && isText$7(ec) && so === 0 && eo === 1) {\r\n        var newRng = rng.cloneRange();\r\n        newRng.setEndAfter(ec);\r\n        return getBoundingClientRect$1(newRng);\r\n      } else {\r\n        return null;\r\n      }\r\n    };\r\n    var isZeroRect = function (r) {\r\n      return r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\r\n    };\r\n    var getBoundingClientRect$1 = function (item) {\r\n      var clientRect;\r\n      var clientRects = item.getClientRects();\r\n      if (clientRects.length > 0) {\r\n        clientRect = clone(clientRects[0]);\r\n      } else {\r\n        clientRect = clone(item.getBoundingClientRect());\r\n      }\r\n      if (!isRange(item) && isBr$2(item) && isZeroRect(clientRect)) {\r\n        return getBrClientRect(item);\r\n      }\r\n      if (isZeroRect(clientRect) && isRange(item)) {\r\n        return getBoundingClientRectWebKitText(item);\r\n      }\r\n      return clientRect;\r\n    };\r\n    var collapseAndInflateWidth = function (clientRect, toStart) {\r\n      var newClientRect = collapse(clientRect, toStart);\r\n      newClientRect.width = 1;\r\n      newClientRect.right = newClientRect.left + 1;\r\n      return newClientRect;\r\n    };\r\n    var getCaretPositionClientRects = function (caretPosition) {\r\n      var clientRects = [];\r\n      var addUniqueAndValidRect = function (clientRect) {\r\n        if (clientRect.height === 0) {\r\n          return;\r\n        }\r\n        if (clientRects.length > 0) {\r\n          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\r\n            return;\r\n          }\r\n        }\r\n        clientRects.push(clientRect);\r\n      };\r\n      var addCharacterOffset = function (container, offset) {\r\n        var range = createRange$1(container.ownerDocument);\r\n        if (offset < container.data.length) {\r\n          if (isExtendingChar(container.data[offset])) {\r\n            return clientRects;\r\n          }\r\n          if (isExtendingChar(container.data[offset - 1])) {\r\n            range.setStart(container, offset);\r\n            range.setEnd(container, offset + 1);\r\n            if (!isHiddenWhiteSpaceRange(range)) {\r\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\r\n              return clientRects;\r\n            }\r\n          }\r\n        }\r\n        if (offset > 0) {\r\n          range.setStart(container, offset - 1);\r\n          range.setEnd(container, offset);\r\n          if (!isHiddenWhiteSpaceRange(range)) {\r\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\r\n          }\r\n        }\r\n        if (offset < container.data.length) {\r\n          range.setStart(container, offset);\r\n          range.setEnd(container, offset + 1);\r\n          if (!isHiddenWhiteSpaceRange(range)) {\r\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\r\n          }\r\n        }\r\n      };\r\n      var container = caretPosition.container();\r\n      var offset = caretPosition.offset();\r\n      if (isText$4(container)) {\r\n        addCharacterOffset(container, offset);\r\n        return clientRects;\r\n      }\r\n      if (isElement$3(container)) {\r\n        if (caretPosition.isAtEnd()) {\r\n          var node = resolveIndex$1(container, offset);\r\n          if (isText$4(node)) {\r\n            addCharacterOffset(node, node.data.length);\r\n          }\r\n          if (isValidElementCaretCandidate(node) && !isBr$2(node)) {\r\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\r\n          }\r\n        } else {\r\n          var node = resolveIndex$1(container, offset);\r\n          if (isText$4(node)) {\r\n            addCharacterOffset(node, 0);\r\n          }\r\n          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\r\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\r\n            return clientRects;\r\n          }\r\n          var beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\r\n          if (isValidElementCaretCandidate(beforeNode) && !isBr$2(beforeNode)) {\r\n            if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {\r\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\r\n            }\r\n          }\r\n          if (isValidElementCaretCandidate(node)) {\r\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\r\n          }\r\n        }\r\n      }\r\n      return clientRects;\r\n    };\r\n    var CaretPosition = function (container, offset, clientRects) {\r\n      var isAtStart = function () {\r\n        if (isText$4(container)) {\r\n          return offset === 0;\r\n        }\r\n        return offset === 0;\r\n      };\r\n      var isAtEnd = function () {\r\n        if (isText$4(container)) {\r\n          return offset >= container.data.length;\r\n        }\r\n        return offset >= container.childNodes.length;\r\n      };\r\n      var toRange = function () {\r\n        var range = createRange$1(container.ownerDocument);\r\n        range.setStart(container, offset);\r\n        range.setEnd(container, offset);\r\n        return range;\r\n      };\r\n      var getClientRects = function () {\r\n        if (!clientRects) {\r\n          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\r\n        }\r\n        return clientRects;\r\n      };\r\n      var isVisible = function () {\r\n        return getClientRects().length > 0;\r\n      };\r\n      var isEqual = function (caretPosition) {\r\n        return caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\r\n      };\r\n      var getNode = function (before) {\r\n        return resolveIndex$1(container, before ? offset - 1 : offset);\r\n      };\r\n      return {\r\n        container: constant(container),\r\n        offset: constant(offset),\r\n        toRange: toRange,\r\n        getClientRects: getClientRects,\r\n        isVisible: isVisible,\r\n        isAtStart: isAtStart,\r\n        isAtEnd: isAtEnd,\r\n        isEqual: isEqual,\r\n        getNode: getNode\r\n      };\r\n    };\r\n    CaretPosition.fromRangeStart = function (range) {\r\n      return CaretPosition(range.startContainer, range.startOffset);\r\n    };\r\n    CaretPosition.fromRangeEnd = function (range) {\r\n      return CaretPosition(range.endContainer, range.endOffset);\r\n    };\r\n    CaretPosition.after = function (node) {\r\n      return CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\r\n    };\r\n    CaretPosition.before = function (node) {\r\n      return CaretPosition(node.parentNode, nodeIndex$1(node));\r\n    };\r\n    CaretPosition.isAbove = function (pos1, pos2) {\r\n      return lift2(head(pos2.getClientRects()), last$2(pos1.getClientRects()), isAbove$1).getOr(false);\r\n    };\r\n    CaretPosition.isBelow = function (pos1, pos2) {\r\n      return lift2(last$2(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\r\n    };\r\n    CaretPosition.isAtStart = function (pos) {\r\n      return pos ? pos.isAtStart() : false;\r\n    };\r\n    CaretPosition.isAtEnd = function (pos) {\r\n      return pos ? pos.isAtEnd() : false;\r\n    };\r\n    CaretPosition.isTextPosition = function (pos) {\r\n      return pos ? isText$7(pos.container()) : false;\r\n    };\r\n    CaretPosition.isElementPosition = function (pos) {\r\n      return CaretPosition.isTextPosition(pos) === false;\r\n    };\r\n\r\n    var trimEmptyTextNode$1 = function (dom, node) {\r\n      if (isText$7(node) && node.data.length === 0) {\r\n        dom.remove(node);\r\n      }\r\n    };\r\n    var insertNode = function (dom, rng, node) {\r\n      rng.insertNode(node);\r\n      trimEmptyTextNode$1(dom, node.previousSibling);\r\n      trimEmptyTextNode$1(dom, node.nextSibling);\r\n    };\r\n    var insertFragment = function (dom, rng, frag) {\r\n      var firstChild = Optional.from(frag.firstChild);\r\n      var lastChild = Optional.from(frag.lastChild);\r\n      rng.insertNode(frag);\r\n      firstChild.each(function (child) {\r\n        return trimEmptyTextNode$1(dom, child.previousSibling);\r\n      });\r\n      lastChild.each(function (child) {\r\n        return trimEmptyTextNode$1(dom, child.nextSibling);\r\n      });\r\n    };\r\n    var rangeInsertNode = function (dom, rng, node) {\r\n      if (isDocumentFragment(node)) {\r\n        insertFragment(dom, rng, node);\r\n      } else {\r\n        insertNode(dom, rng, node);\r\n      }\r\n    };\r\n\r\n    var isText$3 = isText$7;\r\n    var isBogus = isBogus$2;\r\n    var nodeIndex = DOMUtils.nodeIndex;\r\n    var normalizedParent = function (node) {\r\n      var parentNode = node.parentNode;\r\n      if (isBogus(parentNode)) {\r\n        return normalizedParent(parentNode);\r\n      }\r\n      return parentNode;\r\n    };\r\n    var getChildNodes = function (node) {\r\n      if (!node) {\r\n        return [];\r\n      }\r\n      return reduce(node.childNodes, function (result, node) {\r\n        if (isBogus(node) && node.nodeName !== 'BR') {\r\n          result = result.concat(getChildNodes(node));\r\n        } else {\r\n          result.push(node);\r\n        }\r\n        return result;\r\n      }, []);\r\n    };\r\n    var normalizedTextOffset = function (node, offset) {\r\n      while (node = node.previousSibling) {\r\n        if (!isText$3(node)) {\r\n          break;\r\n        }\r\n        offset += node.data.length;\r\n      }\r\n      return offset;\r\n    };\r\n    var equal = function (a) {\r\n      return function (b) {\r\n        return a === b;\r\n      };\r\n    };\r\n    var normalizedNodeIndex = function (node) {\r\n      var nodes, index;\r\n      nodes = getChildNodes(normalizedParent(node));\r\n      index = findIndex$1(nodes, equal(node), node);\r\n      nodes = nodes.slice(0, index + 1);\r\n      var numTextFragments = reduce(nodes, function (result, node, i) {\r\n        if (isText$3(node) && isText$3(nodes[i - 1])) {\r\n          result++;\r\n        }\r\n        return result;\r\n      }, 0);\r\n      nodes = filter$2(nodes, matchNodeNames([node.nodeName]));\r\n      index = findIndex$1(nodes, equal(node), node);\r\n      return index - numTextFragments;\r\n    };\r\n    var createPathItem = function (node) {\r\n      var name;\r\n      if (isText$3(node)) {\r\n        name = 'text()';\r\n      } else {\r\n        name = node.nodeName.toLowerCase();\r\n      }\r\n      return name + '[' + normalizedNodeIndex(node) + ']';\r\n    };\r\n    var parentsUntil$1 = function (root, node, predicate) {\r\n      var parents = [];\r\n      for (node = node.parentNode; node !== root; node = node.parentNode) {\r\n        if (predicate && predicate(node)) {\r\n          break;\r\n        }\r\n        parents.push(node);\r\n      }\r\n      return parents;\r\n    };\r\n    var create$6 = function (root, caretPosition) {\r\n      var container, offset, path = [], outputOffset, childNodes, parents;\r\n      container = caretPosition.container();\r\n      offset = caretPosition.offset();\r\n      if (isText$3(container)) {\r\n        outputOffset = normalizedTextOffset(container, offset);\r\n      } else {\r\n        childNodes = container.childNodes;\r\n        if (offset >= childNodes.length) {\r\n          outputOffset = 'after';\r\n          offset = childNodes.length - 1;\r\n        } else {\r\n          outputOffset = 'before';\r\n        }\r\n        container = childNodes[offset];\r\n      }\r\n      path.push(createPathItem(container));\r\n      parents = parentsUntil$1(root, container);\r\n      parents = filter$2(parents, not(isBogus$2));\r\n      path = path.concat(map$1(parents, function (node) {\r\n        return createPathItem(node);\r\n      }));\r\n      return path.reverse().join('/') + ',' + outputOffset;\r\n    };\r\n    var resolvePathItem = function (node, name, index) {\r\n      var nodes = getChildNodes(node);\r\n      nodes = filter$2(nodes, function (node, index) {\r\n        return !isText$3(node) || !isText$3(nodes[index - 1]);\r\n      });\r\n      nodes = filter$2(nodes, matchNodeNames([name]));\r\n      return nodes[index];\r\n    };\r\n    var findTextPosition = function (container, offset) {\r\n      var node = container, targetOffset = 0, dataLen;\r\n      while (isText$3(node)) {\r\n        dataLen = node.data.length;\r\n        if (offset >= targetOffset && offset <= targetOffset + dataLen) {\r\n          container = node;\r\n          offset = offset - targetOffset;\r\n          break;\r\n        }\r\n        if (!isText$3(node.nextSibling)) {\r\n          container = node;\r\n          offset = dataLen;\r\n          break;\r\n        }\r\n        targetOffset += dataLen;\r\n        node = node.nextSibling;\r\n      }\r\n      if (isText$3(container) && offset > container.data.length) {\r\n        offset = container.data.length;\r\n      }\r\n      return CaretPosition(container, offset);\r\n    };\r\n    var resolve$2 = function (root, path) {\r\n      var offset;\r\n      if (!path) {\r\n        return null;\r\n      }\r\n      var parts = path.split(',');\r\n      var paths = parts[0].split('/');\r\n      offset = parts.length > 1 ? parts[1] : 'before';\r\n      var container = reduce(paths, function (result, value) {\r\n        var match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\r\n        if (!match) {\r\n          return null;\r\n        }\r\n        if (match[1] === 'text()') {\r\n          match[1] = '#text';\r\n        }\r\n        return resolvePathItem(result, match[1], parseInt(match[2], 10));\r\n      }, root);\r\n      if (!container) {\r\n        return null;\r\n      }\r\n      if (!isText$3(container)) {\r\n        if (offset === 'after') {\r\n          offset = nodeIndex(container) + 1;\r\n        } else {\r\n          offset = nodeIndex(container);\r\n        }\r\n        return CaretPosition(container.parentNode, offset);\r\n      }\r\n      return findTextPosition(container, parseInt(offset, 10));\r\n    };\r\n\r\n    var isContentEditableFalse$9 = isContentEditableFalse$b;\r\n    var getNormalizedTextOffset = function (trim, container, offset) {\r\n      var node, trimmedOffset;\r\n      trimmedOffset = trim(container.data.slice(0, offset)).length;\r\n      for (node = container.previousSibling; node && isText$7(node); node = node.previousSibling) {\r\n        trimmedOffset += trim(node.data).length;\r\n      }\r\n      return trimmedOffset;\r\n    };\r\n    var getPoint = function (dom, trim, normalized, rng, start) {\r\n      var container = rng[start ? 'startContainer' : 'endContainer'];\r\n      var offset = rng[start ? 'startOffset' : 'endOffset'];\r\n      var point = [];\r\n      var childNodes, after = 0;\r\n      var root = dom.getRoot();\r\n      if (isText$7(container)) {\r\n        point.push(normalized ? getNormalizedTextOffset(trim, container, offset) : offset);\r\n      } else {\r\n        childNodes = container.childNodes;\r\n        if (offset >= childNodes.length && childNodes.length) {\r\n          after = 1;\r\n          offset = Math.max(0, childNodes.length - 1);\r\n        }\r\n        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\r\n      }\r\n      for (; container && container !== root; container = container.parentNode) {\r\n        point.push(dom.nodeIndex(container, normalized));\r\n      }\r\n      return point;\r\n    };\r\n    var getLocation = function (trim, selection, normalized, rng) {\r\n      var dom = selection.dom, bookmark = {};\r\n      bookmark.start = getPoint(dom, trim, normalized, rng, true);\r\n      if (!selection.isCollapsed()) {\r\n        bookmark.end = getPoint(dom, trim, normalized, rng, false);\r\n      }\r\n      if (isRangeInCaretContainerBlock(rng)) {\r\n        bookmark.isFakeCaret = true;\r\n      }\r\n      return bookmark;\r\n    };\r\n    var findIndex = function (dom, name, element) {\r\n      var count = 0;\r\n      Tools.each(dom.select(name), function (node) {\r\n        if (node.getAttribute('data-mce-bogus') === 'all') {\r\n          return;\r\n        }\r\n        if (node === element) {\r\n          return false;\r\n        }\r\n        count++;\r\n      });\r\n      return count;\r\n    };\r\n    var moveEndPoint$1 = function (rng, start) {\r\n      var container, offset, childNodes;\r\n      var prefix = start ? 'start' : 'end';\r\n      container = rng[prefix + 'Container'];\r\n      offset = rng[prefix + 'Offset'];\r\n      if (isElement$5(container) && container.nodeName === 'TR') {\r\n        childNodes = container.childNodes;\r\n        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\r\n        if (container) {\r\n          offset = start ? 0 : container.childNodes.length;\r\n          rng['set' + (start ? 'Start' : 'End')](container, offset);\r\n        }\r\n      }\r\n    };\r\n    var normalizeTableCellSelection = function (rng) {\r\n      moveEndPoint$1(rng, true);\r\n      moveEndPoint$1(rng, false);\r\n      return rng;\r\n    };\r\n    var findSibling = function (node, offset) {\r\n      var sibling;\r\n      if (isElement$5(node)) {\r\n        node = getNode$1(node, offset);\r\n        if (isContentEditableFalse$9(node)) {\r\n          return node;\r\n        }\r\n      }\r\n      if (isCaretContainer$2(node)) {\r\n        if (isText$7(node) && isCaretContainerBlock$1(node)) {\r\n          node = node.parentNode;\r\n        }\r\n        sibling = node.previousSibling;\r\n        if (isContentEditableFalse$9(sibling)) {\r\n          return sibling;\r\n        }\r\n        sibling = node.nextSibling;\r\n        if (isContentEditableFalse$9(sibling)) {\r\n          return sibling;\r\n        }\r\n      }\r\n    };\r\n    var findAdjacentContentEditableFalseElm = function (rng) {\r\n      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\r\n    };\r\n    var getOffsetBookmark = function (trim, normalized, selection) {\r\n      var element = selection.getNode();\r\n      var name = element ? element.nodeName : null;\r\n      var rng = selection.getRng();\r\n      if (isContentEditableFalse$9(element) || name === 'IMG') {\r\n        return {\r\n          name: name,\r\n          index: findIndex(selection.dom, name, element)\r\n        };\r\n      }\r\n      var sibling = findAdjacentContentEditableFalseElm(rng);\r\n      if (sibling) {\r\n        name = sibling.tagName;\r\n        return {\r\n          name: name,\r\n          index: findIndex(selection.dom, name, sibling)\r\n        };\r\n      }\r\n      return getLocation(trim, selection, normalized, rng);\r\n    };\r\n    var getCaretBookmark = function (selection) {\r\n      var rng = selection.getRng();\r\n      return {\r\n        start: create$6(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\r\n        end: create$6(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng))\r\n      };\r\n    };\r\n    var getRangeBookmark = function (selection) {\r\n      return { rng: selection.getRng() };\r\n    };\r\n    var createBookmarkSpan = function (dom, id, filled) {\r\n      var args = {\r\n        'data-mce-type': 'bookmark',\r\n        id: id,\r\n        'style': 'overflow:hidden;line-height:0px'\r\n      };\r\n      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\r\n    };\r\n    var getPersistentBookmark = function (selection, filled) {\r\n      var dom = selection.dom;\r\n      var rng = selection.getRng();\r\n      var id = dom.uniqueId();\r\n      var collapsed = selection.isCollapsed();\r\n      var element = selection.getNode();\r\n      var name = element.nodeName;\r\n      if (name === 'IMG') {\r\n        return {\r\n          name: name,\r\n          index: findIndex(dom, name, element)\r\n        };\r\n      }\r\n      var rng2 = normalizeTableCellSelection(rng.cloneRange());\r\n      if (!collapsed) {\r\n        rng2.collapse(false);\r\n        var endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\r\n        rangeInsertNode(dom, rng2, endBookmarkNode);\r\n      }\r\n      rng = normalizeTableCellSelection(rng);\r\n      rng.collapse(true);\r\n      var startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\r\n      rangeInsertNode(dom, rng, startBookmarkNode);\r\n      selection.moveToBookmark({\r\n        id: id,\r\n        keep: true\r\n      });\r\n      return { id: id };\r\n    };\r\n    var getBookmark$2 = function (selection, type, normalized) {\r\n      if (type === 2) {\r\n        return getOffsetBookmark(trim$3, normalized, selection);\r\n      } else if (type === 3) {\r\n        return getCaretBookmark(selection);\r\n      } else if (type) {\r\n        return getRangeBookmark(selection);\r\n      } else {\r\n        return getPersistentBookmark(selection, false);\r\n      }\r\n    };\r\n    var getUndoBookmark = curry(getOffsetBookmark, identity, true);\r\n\r\n    var DOM$9 = DOMUtils.DOM;\r\n    var defaultPreviewStyles = 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow';\r\n    var getBodySetting = function (editor, name, defaultValue) {\r\n      var value = editor.getParam(name, defaultValue);\r\n      if (value.indexOf('=') !== -1) {\r\n        var bodyObj = editor.getParam(name, '', 'hash');\r\n        return get$9(bodyObj, editor.id).getOr(defaultValue);\r\n      } else {\r\n        return value;\r\n      }\r\n    };\r\n    var getIframeAttrs = function (editor) {\r\n      return editor.getParam('iframe_attrs', {});\r\n    };\r\n    var getDocType = function (editor) {\r\n      return editor.getParam('doctype', '<!DOCTYPE html>');\r\n    };\r\n    var getDocumentBaseUrl = function (editor) {\r\n      return editor.getParam('document_base_url', '');\r\n    };\r\n    var getBodyId = function (editor) {\r\n      return getBodySetting(editor, 'body_id', 'tinymce');\r\n    };\r\n    var getBodyClass = function (editor) {\r\n      return getBodySetting(editor, 'body_class', '');\r\n    };\r\n    var getContentSecurityPolicy = function (editor) {\r\n      return editor.getParam('content_security_policy', '');\r\n    };\r\n    var shouldPutBrInPre$1 = function (editor) {\r\n      return editor.getParam('br_in_pre', true);\r\n    };\r\n    var getForcedRootBlock = function (editor) {\r\n      if (editor.getParam('force_p_newlines', false)) {\r\n        return 'p';\r\n      }\r\n      var block = editor.getParam('forced_root_block', 'p');\r\n      if (block === false) {\r\n        return '';\r\n      } else if (block === true) {\r\n        return 'p';\r\n      } else {\r\n        return block;\r\n      }\r\n    };\r\n    var getForcedRootBlockAttrs = function (editor) {\r\n      return editor.getParam('forced_root_block_attrs', {});\r\n    };\r\n    var getBrNewLineSelector = function (editor) {\r\n      return editor.getParam('br_newline_selector', '.mce-toc h2,figcaption,caption');\r\n    };\r\n    var getNoNewLineSelector = function (editor) {\r\n      return editor.getParam('no_newline_selector', '');\r\n    };\r\n    var shouldKeepStyles = function (editor) {\r\n      return editor.getParam('keep_styles', true);\r\n    };\r\n    var shouldEndContainerOnEmptyBlock = function (editor) {\r\n      return editor.getParam('end_container_on_empty_block', false);\r\n    };\r\n    var getFontStyleValues = function (editor) {\r\n      return Tools.explode(editor.getParam('font_size_style_values', 'xx-small,x-small,small,medium,large,x-large,xx-large'));\r\n    };\r\n    var getFontSizeClasses = function (editor) {\r\n      return Tools.explode(editor.getParam('font_size_classes', ''));\r\n    };\r\n    var getImagesDataImgFilter = function (editor) {\r\n      return editor.getParam('images_dataimg_filter', always, 'function');\r\n    };\r\n    var isAutomaticUploadsEnabled = function (editor) {\r\n      return editor.getParam('automatic_uploads', true, 'boolean');\r\n    };\r\n    var shouldReuseFileName = function (editor) {\r\n      return editor.getParam('images_reuse_filename', false, 'boolean');\r\n    };\r\n    var shouldReplaceBlobUris = function (editor) {\r\n      return editor.getParam('images_replace_blob_uris', true, 'boolean');\r\n    };\r\n    var getIconPackName = function (editor) {\r\n      return editor.getParam('icons', '', 'string');\r\n    };\r\n    var getIconsUrl = function (editor) {\r\n      return editor.getParam('icons_url', '', 'string');\r\n    };\r\n    var getImageUploadUrl = function (editor) {\r\n      return editor.getParam('images_upload_url', '', 'string');\r\n    };\r\n    var getImageUploadBasePath = function (editor) {\r\n      return editor.getParam('images_upload_base_path', '', 'string');\r\n    };\r\n    var getImagesUploadCredentials = function (editor) {\r\n      return editor.getParam('images_upload_credentials', false, 'boolean');\r\n    };\r\n    var getImagesUploadHandler = function (editor) {\r\n      return editor.getParam('images_upload_handler', null, 'function');\r\n    };\r\n    var shouldUseContentCssCors = function (editor) {\r\n      return editor.getParam('content_css_cors', false, 'boolean');\r\n    };\r\n    var getReferrerPolicy = function (editor) {\r\n      return editor.getParam('referrer_policy', '', 'string');\r\n    };\r\n    var getLanguageCode = function (editor) {\r\n      return editor.getParam('language', 'en', 'string');\r\n    };\r\n    var getLanguageUrl = function (editor) {\r\n      return editor.getParam('language_url', '', 'string');\r\n    };\r\n    var shouldIndentUseMargin = function (editor) {\r\n      return editor.getParam('indent_use_margin', false);\r\n    };\r\n    var getIndentation = function (editor) {\r\n      return editor.getParam('indentation', '40px', 'string');\r\n    };\r\n    var getContentCss = function (editor) {\r\n      var contentCss = editor.getParam('content_css');\r\n      if (isString$1(contentCss)) {\r\n        return map$3(contentCss.split(','), trim$5);\r\n      } else if (isArray$1(contentCss)) {\r\n        return contentCss;\r\n      } else if (contentCss === false || editor.inline) {\r\n        return [];\r\n      } else {\r\n        return ['default'];\r\n      }\r\n    };\r\n    var getFontCss = function (editor) {\r\n      var fontCss = editor.getParam('font_css', []);\r\n      return isArray$1(fontCss) ? fontCss : map$3(fontCss.split(','), trim$5);\r\n    };\r\n    var getDirectionality = function (editor) {\r\n      return editor.getParam('directionality', I18n.isRtl() ? 'rtl' : undefined);\r\n    };\r\n    var getInlineBoundarySelector = function (editor) {\r\n      return editor.getParam('inline_boundaries_selector', 'a[href],code,.mce-annotation', 'string');\r\n    };\r\n    var getObjectResizing = function (editor) {\r\n      var selector = editor.getParam('object_resizing');\r\n      if (selector === false || Env.iOS) {\r\n        return false;\r\n      } else {\r\n        return isString$1(selector) ? selector : 'table,img,figure.image,div,video,iframe';\r\n      }\r\n    };\r\n    var getResizeImgProportional = function (editor) {\r\n      return editor.getParam('resize_img_proportional', true, 'boolean');\r\n    };\r\n    var getPlaceholder = function (editor) {\r\n      return editor.getParam('placeholder', DOM$9.getAttrib(editor.getElement(), 'placeholder'), 'string');\r\n    };\r\n    var getEventRoot = function (editor) {\r\n      return editor.getParam('event_root');\r\n    };\r\n    var getServiceMessage = function (editor) {\r\n      return editor.getParam('service_message');\r\n    };\r\n    var getTheme = function (editor) {\r\n      return editor.getParam('theme');\r\n    };\r\n    var shouldValidate = function (editor) {\r\n      return editor.getParam('validate');\r\n    };\r\n    var isInlineBoundariesEnabled = function (editor) {\r\n      return editor.getParam('inline_boundaries') !== false;\r\n    };\r\n    var getFormats = function (editor) {\r\n      return editor.getParam('formats');\r\n    };\r\n    var getPreviewStyles = function (editor) {\r\n      var style = editor.getParam('preview_styles', defaultPreviewStyles);\r\n      if (isString$1(style)) {\r\n        return style;\r\n      } else {\r\n        return '';\r\n      }\r\n    };\r\n    var canFormatEmptyLines = function (editor) {\r\n      return editor.getParam('format_empty_lines', false, 'boolean');\r\n    };\r\n    var getCustomUiSelector = function (editor) {\r\n      return editor.getParam('custom_ui_selector', '', 'string');\r\n    };\r\n    var getThemeUrl = function (editor) {\r\n      return editor.getParam('theme_url');\r\n    };\r\n    var isInline = function (editor) {\r\n      return editor.getParam('inline');\r\n    };\r\n    var hasHiddenInput = function (editor) {\r\n      return editor.getParam('hidden_input');\r\n    };\r\n    var shouldPatchSubmit = function (editor) {\r\n      return editor.getParam('submit_patch');\r\n    };\r\n    var isEncodingXml = function (editor) {\r\n      return editor.getParam('encoding') === 'xml';\r\n    };\r\n    var shouldAddFormSubmitTrigger = function (editor) {\r\n      return editor.getParam('add_form_submit_trigger');\r\n    };\r\n    var shouldAddUnloadTrigger = function (editor) {\r\n      return editor.getParam('add_unload_trigger');\r\n    };\r\n    var hasForcedRootBlock = function (editor) {\r\n      return getForcedRootBlock(editor) !== '';\r\n    };\r\n    var getCustomUndoRedoLevels = function (editor) {\r\n      return editor.getParam('custom_undo_redo_levels', 0, 'number');\r\n    };\r\n    var shouldDisableNodeChange = function (editor) {\r\n      return editor.getParam('disable_nodechange');\r\n    };\r\n    var isReadOnly$1 = function (editor) {\r\n      return editor.getParam('readonly');\r\n    };\r\n    var hasContentCssCors = function (editor) {\r\n      return editor.getParam('content_css_cors');\r\n    };\r\n    var getPlugins = function (editor) {\r\n      return editor.getParam('plugins', '', 'string');\r\n    };\r\n    var getExternalPlugins$1 = function (editor) {\r\n      return editor.getParam('external_plugins');\r\n    };\r\n    var shouldBlockUnsupportedDrop = function (editor) {\r\n      return editor.getParam('block_unsupported_drop', true, 'boolean');\r\n    };\r\n    var isVisualAidsEnabled = function (editor) {\r\n      return editor.getParam('visual', true, 'boolean');\r\n    };\r\n    var getVisualAidsTableClass = function (editor) {\r\n      return editor.getParam('visual_table_class', 'mce-item-table', 'string');\r\n    };\r\n    var getVisualAidsAnchorClass = function (editor) {\r\n      return editor.getParam('visual_anchor_class', 'mce-item-anchor', 'string');\r\n    };\r\n    var getIframeAriaText = function (editor) {\r\n      return editor.getParam('iframe_aria_text', 'Rich Text Area. Press ALT-0 for help.', 'string');\r\n    };\r\n\r\n    var isElement$2 = isElement$5;\r\n    var isText$2 = isText$7;\r\n    var removeNode$1 = function (node) {\r\n      var parentNode = node.parentNode;\r\n      if (parentNode) {\r\n        parentNode.removeChild(node);\r\n      }\r\n    };\r\n    var trimCount = function (text) {\r\n      var trimmedText = trim$3(text);\r\n      return {\r\n        count: text.length - trimmedText.length,\r\n        text: trimmedText\r\n      };\r\n    };\r\n    var deleteZwspChars = function (caretContainer) {\r\n      var idx;\r\n      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\r\n        caretContainer.deleteData(idx, 1);\r\n      }\r\n    };\r\n    var removeUnchanged = function (caretContainer, pos) {\r\n      remove$2(caretContainer);\r\n      return pos;\r\n    };\r\n    var removeTextAndReposition = function (caretContainer, pos) {\r\n      var before = trimCount(caretContainer.data.substr(0, pos.offset()));\r\n      var after = trimCount(caretContainer.data.substr(pos.offset()));\r\n      var text = before.text + after.text;\r\n      if (text.length > 0) {\r\n        deleteZwspChars(caretContainer);\r\n        return CaretPosition(caretContainer, pos.offset() - before.count);\r\n      } else {\r\n        return pos;\r\n      }\r\n    };\r\n    var removeElementAndReposition = function (caretContainer, pos) {\r\n      var parentNode = pos.container();\r\n      var newPosition = indexOf$2(from(parentNode.childNodes), caretContainer).map(function (index) {\r\n        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\r\n      }).getOr(pos);\r\n      remove$2(caretContainer);\r\n      return newPosition;\r\n    };\r\n    var removeTextCaretContainer = function (caretContainer, pos) {\r\n      return isText$2(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\r\n    };\r\n    var removeElementCaretContainer = function (caretContainer, pos) {\r\n      return pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\r\n    };\r\n    var removeAndReposition = function (container, pos) {\r\n      return CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\r\n    };\r\n    var remove$2 = function (caretContainerNode) {\r\n      if (isElement$2(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\r\n        if (hasContent(caretContainerNode)) {\r\n          caretContainerNode.removeAttribute('data-mce-caret');\r\n        } else {\r\n          removeNode$1(caretContainerNode);\r\n        }\r\n      }\r\n      if (isText$2(caretContainerNode)) {\r\n        deleteZwspChars(caretContainerNode);\r\n        if (caretContainerNode.data.length === 0) {\r\n          removeNode$1(caretContainerNode);\r\n        }\r\n      }\r\n    };\r\n\r\n    var browser$2 = detect().browser;\r\n    var isContentEditableFalse$8 = isContentEditableFalse$b;\r\n    var isMedia$1 = isMedia$2;\r\n    var isTableCell$3 = isTableCell$5;\r\n    var inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\r\n    var getAbsoluteClientRect = function (root, element, before) {\r\n      var clientRect = collapse(element.getBoundingClientRect(), before);\r\n      var scrollX;\r\n      var scrollY;\r\n      if (root.tagName === 'BODY') {\r\n        var docElm = root.ownerDocument.documentElement;\r\n        scrollX = root.scrollLeft || docElm.scrollLeft;\r\n        scrollY = root.scrollTop || docElm.scrollTop;\r\n      } else {\r\n        var rootRect = root.getBoundingClientRect();\r\n        scrollX = root.scrollLeft - rootRect.left;\r\n        scrollY = root.scrollTop - rootRect.top;\r\n      }\r\n      clientRect.left += scrollX;\r\n      clientRect.right += scrollX;\r\n      clientRect.top += scrollY;\r\n      clientRect.bottom += scrollY;\r\n      clientRect.width = 1;\r\n      var margin = element.offsetWidth - element.clientWidth;\r\n      if (margin > 0) {\r\n        if (before) {\r\n          margin *= -1;\r\n        }\r\n        clientRect.left += margin;\r\n        clientRect.right += margin;\r\n      }\r\n      return clientRect;\r\n    };\r\n    var trimInlineCaretContainers = function (root) {\r\n      var fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\r\n      for (var i = 0; i < fakeCaretTargetNodes.length; i++) {\r\n        var node = fakeCaretTargetNodes[i].dom;\r\n        var sibling = node.previousSibling;\r\n        if (endsWithCaretContainer$1(sibling)) {\r\n          var data = sibling.data;\r\n          if (data.length === 1) {\r\n            sibling.parentNode.removeChild(sibling);\r\n          } else {\r\n            sibling.deleteData(data.length - 1, 1);\r\n          }\r\n        }\r\n        sibling = node.nextSibling;\r\n        if (startsWithCaretContainer$1(sibling)) {\r\n          var data = sibling.data;\r\n          if (data.length === 1) {\r\n            sibling.parentNode.removeChild(sibling);\r\n          } else {\r\n            sibling.deleteData(0, 1);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var FakeCaret = function (editor, root, isBlock, hasFocus) {\r\n      var lastVisualCaret = value();\r\n      var cursorInterval;\r\n      var caretContainerNode;\r\n      var rootBlock = getForcedRootBlock(editor);\r\n      var caretBlock = rootBlock.length > 0 ? rootBlock : 'p';\r\n      var show = function (before, element) {\r\n        var rng;\r\n        hide();\r\n        if (isTableCell$3(element)) {\r\n          return null;\r\n        }\r\n        if (isBlock(element)) {\r\n          caretContainerNode = insertBlock$1(caretBlock, element, before);\r\n          var clientRect = getAbsoluteClientRect(root, element, before);\r\n          DomQuery(caretContainerNode).css('top', clientRect.top);\r\n          var caret = DomQuery('<div class=\"mce-visual-caret\" data-mce-bogus=\"all\"></div>').css(__assign({}, clientRect)).appendTo(root)[0];\r\n          lastVisualCaret.set({\r\n            caret: caret,\r\n            element: element,\r\n            before: before\r\n          });\r\n          if (before) {\r\n            DomQuery(caret).addClass('mce-visual-caret-before');\r\n          }\r\n          startBlink();\r\n          rng = element.ownerDocument.createRange();\r\n          rng.setStart(caretContainerNode, 0);\r\n          rng.setEnd(caretContainerNode, 0);\r\n        } else {\r\n          caretContainerNode = insertInline$1(element, before);\r\n          rng = element.ownerDocument.createRange();\r\n          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\r\n            rng.setStart(caretContainerNode, 0);\r\n            rng.setEnd(caretContainerNode, 0);\r\n          } else {\r\n            rng.setStart(caretContainerNode, 1);\r\n            rng.setEnd(caretContainerNode, 1);\r\n          }\r\n          return rng;\r\n        }\r\n        return rng;\r\n      };\r\n      var hide = function () {\r\n        trimInlineCaretContainers(root);\r\n        if (caretContainerNode) {\r\n          remove$2(caretContainerNode);\r\n          caretContainerNode = null;\r\n        }\r\n        lastVisualCaret.on(function (caretState) {\r\n          DomQuery(caretState.caret).remove();\r\n          lastVisualCaret.clear();\r\n        });\r\n        if (cursorInterval) {\r\n          Delay.clearInterval(cursorInterval);\r\n          cursorInterval = undefined;\r\n        }\r\n      };\r\n      var startBlink = function () {\r\n        cursorInterval = Delay.setInterval(function () {\r\n          if (hasFocus()) {\r\n            DomQuery('div.mce-visual-caret', root).toggleClass('mce-visual-caret-hidden');\r\n          } else {\r\n            DomQuery('div.mce-visual-caret', root).addClass('mce-visual-caret-hidden');\r\n          }\r\n        }, 500);\r\n      };\r\n      var reposition = function () {\r\n        lastVisualCaret.on(function (caretState) {\r\n          var clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\r\n          DomQuery(caretState.caret).css(__assign({}, clientRect));\r\n        });\r\n      };\r\n      var destroy = function () {\r\n        return Delay.clearInterval(cursorInterval);\r\n      };\r\n      var getCss = function () {\r\n        return '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\r\n      };\r\n      return {\r\n        show: show,\r\n        hide: hide,\r\n        getCss: getCss,\r\n        reposition: reposition,\r\n        destroy: destroy\r\n      };\r\n    };\r\n    var isFakeCaretTableBrowser = function () {\r\n      return browser$2.isIE() || browser$2.isEdge() || browser$2.isFirefox();\r\n    };\r\n    var isInlineFakeCaretTarget = function (node) {\r\n      return isContentEditableFalse$8(node) || isMedia$1(node);\r\n    };\r\n    var isFakeCaretTarget = function (node) {\r\n      return isInlineFakeCaretTarget(node) || isTable$3(node) && isFakeCaretTableBrowser();\r\n    };\r\n\r\n    var isContentEditableFalse$7 = isContentEditableFalse$b;\r\n    var isMedia = isMedia$2;\r\n    var isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');\r\n    var isCaretContainer = isCaretContainer$2;\r\n    var isCaretContainerBlock = isCaretContainerBlock$1;\r\n    var isElement$1 = isElement$5;\r\n    var isCaretCandidate$1 = isCaretCandidate$3;\r\n    var isForwards = function (direction) {\r\n      return direction > 0;\r\n    };\r\n    var isBackwards = function (direction) {\r\n      return direction < 0;\r\n    };\r\n    var skipCaretContainers = function (walk, shallow) {\r\n      var node;\r\n      while (node = walk(shallow)) {\r\n        if (!isCaretContainerBlock(node)) {\r\n          return node;\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    var findNode$1 = function (node, direction, predicateFn, rootNode, shallow) {\r\n      var walker = new DomTreeWalker(node, rootNode);\r\n      var isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);\r\n      if (isBackwards(direction)) {\r\n        if (isCefOrCaretContainer) {\r\n          node = skipCaretContainers(walker.prev.bind(walker), true);\r\n          if (predicateFn(node)) {\r\n            return node;\r\n          }\r\n        }\r\n        while (node = skipCaretContainers(walker.prev.bind(walker), shallow)) {\r\n          if (predicateFn(node)) {\r\n            return node;\r\n          }\r\n        }\r\n      }\r\n      if (isForwards(direction)) {\r\n        if (isCefOrCaretContainer) {\r\n          node = skipCaretContainers(walker.next.bind(walker), true);\r\n          if (predicateFn(node)) {\r\n            return node;\r\n          }\r\n        }\r\n        while (node = skipCaretContainers(walker.next.bind(walker), shallow)) {\r\n          if (predicateFn(node)) {\r\n            return node;\r\n          }\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    var getParentBlock$2 = function (node, rootNode) {\r\n      while (node && node !== rootNode) {\r\n        if (isBlockLike(node)) {\r\n          return node;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n    var isInSameBlock = function (caretPosition1, caretPosition2, rootNode) {\r\n      return getParentBlock$2(caretPosition1.container(), rootNode) === getParentBlock$2(caretPosition2.container(), rootNode);\r\n    };\r\n    var getChildNodeAtRelativeOffset = function (relativeOffset, caretPosition) {\r\n      if (!caretPosition) {\r\n        return null;\r\n      }\r\n      var container = caretPosition.container();\r\n      var offset = caretPosition.offset();\r\n      if (!isElement$1(container)) {\r\n        return null;\r\n      }\r\n      return container.childNodes[offset + relativeOffset];\r\n    };\r\n    var beforeAfter = function (before, node) {\r\n      var range = node.ownerDocument.createRange();\r\n      if (before) {\r\n        range.setStartBefore(node);\r\n        range.setEndBefore(node);\r\n      } else {\r\n        range.setStartAfter(node);\r\n        range.setEndAfter(node);\r\n      }\r\n      return range;\r\n    };\r\n    var isNodesInSameBlock = function (root, node1, node2) {\r\n      return getParentBlock$2(node1, root) === getParentBlock$2(node2, root);\r\n    };\r\n    var lean = function (left, root, node) {\r\n      var siblingName = left ? 'previousSibling' : 'nextSibling';\r\n      while (node && node !== root) {\r\n        var sibling = node[siblingName];\r\n        if (isCaretContainer(sibling)) {\r\n          sibling = sibling[siblingName];\r\n        }\r\n        if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {\r\n          if (isNodesInSameBlock(root, sibling, node)) {\r\n            return sibling;\r\n          }\r\n          break;\r\n        }\r\n        if (isCaretCandidate$1(sibling)) {\r\n          break;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n    var before$2 = curry(beforeAfter, true);\r\n    var after$2 = curry(beforeAfter, false);\r\n    var normalizeRange = function (direction, root, range) {\r\n      var node;\r\n      var leanLeft = curry(lean, true, root);\r\n      var leanRight = curry(lean, false, root);\r\n      var container = range.startContainer;\r\n      var offset = range.startOffset;\r\n      if (isCaretContainerBlock$1(container)) {\r\n        if (!isElement$1(container)) {\r\n          container = container.parentNode;\r\n        }\r\n        var location_1 = container.getAttribute('data-mce-caret');\r\n        if (location_1 === 'before') {\r\n          node = container.nextSibling;\r\n          if (isFakeCaretTarget(node)) {\r\n            return before$2(node);\r\n          }\r\n        }\r\n        if (location_1 === 'after') {\r\n          node = container.previousSibling;\r\n          if (isFakeCaretTarget(node)) {\r\n            return after$2(node);\r\n          }\r\n        }\r\n      }\r\n      if (!range.collapsed) {\r\n        return range;\r\n      }\r\n      if (isText$7(container)) {\r\n        if (isCaretContainer(container)) {\r\n          if (direction === 1) {\r\n            node = leanRight(container);\r\n            if (node) {\r\n              return before$2(node);\r\n            }\r\n            node = leanLeft(container);\r\n            if (node) {\r\n              return after$2(node);\r\n            }\r\n          }\r\n          if (direction === -1) {\r\n            node = leanLeft(container);\r\n            if (node) {\r\n              return after$2(node);\r\n            }\r\n            node = leanRight(container);\r\n            if (node) {\r\n              return before$2(node);\r\n            }\r\n          }\r\n          return range;\r\n        }\r\n        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\r\n          if (direction === 1) {\r\n            node = leanRight(container);\r\n            if (node) {\r\n              return before$2(node);\r\n            }\r\n          }\r\n          return range;\r\n        }\r\n        if (startsWithCaretContainer$1(container) && offset <= 1) {\r\n          if (direction === -1) {\r\n            node = leanLeft(container);\r\n            if (node) {\r\n              return after$2(node);\r\n            }\r\n          }\r\n          return range;\r\n        }\r\n        if (offset === container.data.length) {\r\n          node = leanRight(container);\r\n          if (node) {\r\n            return before$2(node);\r\n          }\r\n          return range;\r\n        }\r\n        if (offset === 0) {\r\n          node = leanLeft(container);\r\n          if (node) {\r\n            return after$2(node);\r\n          }\r\n          return range;\r\n        }\r\n      }\r\n      return range;\r\n    };\r\n    var getRelativeCefElm = function (forward, caretPosition) {\r\n      return Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$7);\r\n    };\r\n    var getNormalizedRangeEndPoint = function (direction, root, range) {\r\n      var normalizedRange = normalizeRange(direction, root, range);\r\n      if (direction === -1) {\r\n        return CaretPosition.fromRangeStart(normalizedRange);\r\n      }\r\n      return CaretPosition.fromRangeEnd(normalizedRange);\r\n    };\r\n    var getElementFromPosition = function (pos) {\r\n      return Optional.from(pos.getNode()).map(SugarElement.fromDom);\r\n    };\r\n    var getElementFromPrevPosition = function (pos) {\r\n      return Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\r\n    };\r\n    var getVisualCaretPosition = function (walkFn, caretPosition) {\r\n      while (caretPosition = walkFn(caretPosition)) {\r\n        if (caretPosition.isVisible()) {\r\n          return caretPosition;\r\n        }\r\n      }\r\n      return caretPosition;\r\n    };\r\n    var isMoveInsideSameBlock = function (from, to) {\r\n      var inSameBlock = isInSameBlock(from, to);\r\n      if (!inSameBlock && isBr$5(from.getNode())) {\r\n        return true;\r\n      }\r\n      return inSameBlock;\r\n    };\r\n\r\n    var HDirection;\r\n    (function (HDirection) {\r\n      HDirection[HDirection['Backwards'] = -1] = 'Backwards';\r\n      HDirection[HDirection['Forwards'] = 1] = 'Forwards';\r\n    }(HDirection || (HDirection = {})));\r\n    var isContentEditableFalse$6 = isContentEditableFalse$b;\r\n    var isText$1 = isText$7;\r\n    var isElement = isElement$5;\r\n    var isBr$1 = isBr$5;\r\n    var isCaretCandidate = isCaretCandidate$3;\r\n    var isAtomic = isAtomic$1;\r\n    var isEditableCaretCandidate = isEditableCaretCandidate$1;\r\n    var getParents$3 = function (node, root) {\r\n      var parents = [];\r\n      while (node && node !== root) {\r\n        parents.push(node);\r\n        node = node.parentNode;\r\n      }\r\n      return parents;\r\n    };\r\n    var nodeAtIndex = function (container, offset) {\r\n      if (container.hasChildNodes() && offset < container.childNodes.length) {\r\n        return container.childNodes[offset];\r\n      }\r\n      return null;\r\n    };\r\n    var getCaretCandidatePosition = function (direction, node) {\r\n      if (isForwards(direction)) {\r\n        if (isCaretCandidate(node.previousSibling) && !isText$1(node.previousSibling)) {\r\n          return CaretPosition.before(node);\r\n        }\r\n        if (isText$1(node)) {\r\n          return CaretPosition(node, 0);\r\n        }\r\n      }\r\n      if (isBackwards(direction)) {\r\n        if (isCaretCandidate(node.nextSibling) && !isText$1(node.nextSibling)) {\r\n          return CaretPosition.after(node);\r\n        }\r\n        if (isText$1(node)) {\r\n          return CaretPosition(node, node.data.length);\r\n        }\r\n      }\r\n      if (isBackwards(direction)) {\r\n        if (isBr$1(node)) {\r\n          return CaretPosition.before(node);\r\n        }\r\n        return CaretPosition.after(node);\r\n      }\r\n      return CaretPosition.before(node);\r\n    };\r\n    var moveForwardFromBr = function (root, nextNode) {\r\n      var nextSibling = nextNode.nextSibling;\r\n      if (nextSibling && isCaretCandidate(nextSibling)) {\r\n        if (isText$1(nextSibling)) {\r\n          return CaretPosition(nextSibling, 0);\r\n        } else {\r\n          return CaretPosition.before(nextSibling);\r\n        }\r\n      } else {\r\n        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\r\n      }\r\n    };\r\n    var findCaretPosition$1 = function (direction, startPos, root) {\r\n      var node;\r\n      var nextNode;\r\n      var innerNode;\r\n      var caretPosition;\r\n      if (!isElement(root) || !startPos) {\r\n        return null;\r\n      }\r\n      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\r\n        caretPosition = CaretPosition.after(root.lastChild);\r\n        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement(root.lastChild)) {\r\n          return isBr$1(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\r\n        }\r\n      } else {\r\n        caretPosition = startPos;\r\n      }\r\n      var container = caretPosition.container();\r\n      var offset = caretPosition.offset();\r\n      if (isText$1(container)) {\r\n        if (isBackwards(direction) && offset > 0) {\r\n          return CaretPosition(container, --offset);\r\n        }\r\n        if (isForwards(direction) && offset < container.length) {\r\n          return CaretPosition(container, ++offset);\r\n        }\r\n        node = container;\r\n      } else {\r\n        if (isBackwards(direction) && offset > 0) {\r\n          nextNode = nodeAtIndex(container, offset - 1);\r\n          if (isCaretCandidate(nextNode)) {\r\n            if (!isAtomic(nextNode)) {\r\n              innerNode = findNode$1(nextNode, direction, isEditableCaretCandidate, nextNode);\r\n              if (innerNode) {\r\n                if (isText$1(innerNode)) {\r\n                  return CaretPosition(innerNode, innerNode.data.length);\r\n                }\r\n                return CaretPosition.after(innerNode);\r\n              }\r\n            }\r\n            if (isText$1(nextNode)) {\r\n              return CaretPosition(nextNode, nextNode.data.length);\r\n            }\r\n            return CaretPosition.before(nextNode);\r\n          }\r\n        }\r\n        if (isForwards(direction) && offset < container.childNodes.length) {\r\n          nextNode = nodeAtIndex(container, offset);\r\n          if (isCaretCandidate(nextNode)) {\r\n            if (isBr$1(nextNode)) {\r\n              return moveForwardFromBr(root, nextNode);\r\n            }\r\n            if (!isAtomic(nextNode)) {\r\n              innerNode = findNode$1(nextNode, direction, isEditableCaretCandidate, nextNode);\r\n              if (innerNode) {\r\n                if (isText$1(innerNode)) {\r\n                  return CaretPosition(innerNode, 0);\r\n                }\r\n                return CaretPosition.before(innerNode);\r\n              }\r\n            }\r\n            if (isText$1(nextNode)) {\r\n              return CaretPosition(nextNode, 0);\r\n            }\r\n            return CaretPosition.after(nextNode);\r\n          }\r\n        }\r\n        node = nextNode ? nextNode : caretPosition.getNode();\r\n      }\r\n      if (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart()) {\r\n        node = findNode$1(node, direction, always, root, true);\r\n        if (isEditableCaretCandidate(node, root)) {\r\n          return getCaretCandidatePosition(direction, node);\r\n        }\r\n      }\r\n      nextNode = findNode$1(node, direction, isEditableCaretCandidate, root);\r\n      var rootContentEditableFalseElm = last$1(filter$4(getParents$3(container, root), isContentEditableFalse$6));\r\n      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\r\n        if (isForwards(direction)) {\r\n          caretPosition = CaretPosition.after(rootContentEditableFalseElm);\r\n        } else {\r\n          caretPosition = CaretPosition.before(rootContentEditableFalseElm);\r\n        }\r\n        return caretPosition;\r\n      }\r\n      if (nextNode) {\r\n        return getCaretCandidatePosition(direction, nextNode);\r\n      }\r\n      return null;\r\n    };\r\n    var CaretWalker = function (root) {\r\n      return {\r\n        next: function (caretPosition) {\r\n          return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\r\n        },\r\n        prev: function (caretPosition) {\r\n          return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\r\n        }\r\n      };\r\n    };\r\n\r\n    var walkToPositionIn = function (forward, root, start) {\r\n      var position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\r\n      return fromPosition(forward, root, position);\r\n    };\r\n    var afterElement = function (node) {\r\n      return isBr$5(node) ? CaretPosition.before(node) : CaretPosition.after(node);\r\n    };\r\n    var isBeforeOrStart = function (position) {\r\n      if (CaretPosition.isTextPosition(position)) {\r\n        return position.offset() === 0;\r\n      } else {\r\n        return isCaretCandidate$3(position.getNode());\r\n      }\r\n    };\r\n    var isAfterOrEnd = function (position) {\r\n      if (CaretPosition.isTextPosition(position)) {\r\n        var container = position.container();\r\n        return position.offset() === container.data.length;\r\n      } else {\r\n        return isCaretCandidate$3(position.getNode(true));\r\n      }\r\n    };\r\n    var isBeforeAfterSameElement = function (from, to) {\r\n      return !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\r\n    };\r\n    var isAtBr = function (position) {\r\n      return !CaretPosition.isTextPosition(position) && isBr$5(position.getNode());\r\n    };\r\n    var shouldSkipPosition = function (forward, from, to) {\r\n      if (forward) {\r\n        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\r\n      } else {\r\n        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\r\n      }\r\n    };\r\n    var fromPosition = function (forward, root, pos) {\r\n      var walker = CaretWalker(root);\r\n      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\r\n    };\r\n    var navigate = function (forward, root, from) {\r\n      return fromPosition(forward, root, from).bind(function (to) {\r\n        if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\r\n          return fromPosition(forward, root, to);\r\n        } else {\r\n          return Optional.some(to);\r\n        }\r\n      });\r\n    };\r\n    var navigateIgnore = function (forward, root, from, ignoreFilter) {\r\n      return navigate(forward, root, from).bind(function (pos) {\r\n        return ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos);\r\n      });\r\n    };\r\n    var positionIn = function (forward, element) {\r\n      var startNode = forward ? element.firstChild : element.lastChild;\r\n      if (isText$7(startNode)) {\r\n        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\r\n      } else if (startNode) {\r\n        if (isCaretCandidate$3(startNode)) {\r\n          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\r\n        } else {\r\n          return walkToPositionIn(forward, element, startNode);\r\n        }\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var nextPosition = curry(fromPosition, true);\r\n    var prevPosition = curry(fromPosition, false);\r\n    var firstPositionIn = curry(positionIn, true);\r\n    var lastPositionIn = curry(positionIn, false);\r\n\r\n    var CARET_ID$1 = '_mce_caret';\r\n    var isCaretNode = function (node) {\r\n      return isElement$5(node) && node.id === CARET_ID$1;\r\n    };\r\n    var getParentCaretContainer = function (body, node) {\r\n      while (node && node !== body) {\r\n        if (node.id === CARET_ID$1) {\r\n          return node;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n\r\n    var isStringPathBookmark = function (bookmark) {\r\n      return isString$1(bookmark.start);\r\n    };\r\n    var isRangeBookmark = function (bookmark) {\r\n      return has$2(bookmark, 'rng');\r\n    };\r\n    var isIdBookmark = function (bookmark) {\r\n      return has$2(bookmark, 'id');\r\n    };\r\n    var isIndexBookmark = function (bookmark) {\r\n      return has$2(bookmark, 'name');\r\n    };\r\n    var isPathBookmark = function (bookmark) {\r\n      return Tools.isArray(bookmark.start);\r\n    };\r\n\r\n    var addBogus = function (dom, node) {\r\n      if (isElement$5(node) && dom.isBlock(node) && !node.innerHTML && !Env.ie) {\r\n        node.innerHTML = '<br data-mce-bogus=\"1\" />';\r\n      }\r\n      return node;\r\n    };\r\n    var resolveCaretPositionBookmark = function (dom, bookmark) {\r\n      var pos;\r\n      var rng = dom.createRng();\r\n      pos = resolve$2(dom.getRoot(), bookmark.start);\r\n      rng.setStart(pos.container(), pos.offset());\r\n      pos = resolve$2(dom.getRoot(), bookmark.end);\r\n      rng.setEnd(pos.container(), pos.offset());\r\n      return rng;\r\n    };\r\n    var insertZwsp = function (node, rng) {\r\n      var textNode = node.ownerDocument.createTextNode(ZWSP$1);\r\n      node.appendChild(textNode);\r\n      rng.setStart(textNode, 0);\r\n      rng.setEnd(textNode, 0);\r\n    };\r\n    var isEmpty$1 = function (node) {\r\n      return node.hasChildNodes() === false;\r\n    };\r\n    var tryFindRangePosition = function (node, rng) {\r\n      return lastPositionIn(node).fold(never, function (pos) {\r\n        rng.setStart(pos.container(), pos.offset());\r\n        rng.setEnd(pos.container(), pos.offset());\r\n        return true;\r\n      });\r\n    };\r\n    var padEmptyCaretContainer = function (root, node, rng) {\r\n      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\r\n        insertZwsp(node, rng);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var setEndPoint = function (dom, start, bookmark, rng) {\r\n      var point = bookmark[start ? 'start' : 'end'];\r\n      var i, node, offset, children;\r\n      var root = dom.getRoot();\r\n      if (point) {\r\n        offset = point[0];\r\n        for (node = root, i = point.length - 1; i >= 1; i--) {\r\n          children = node.childNodes;\r\n          if (padEmptyCaretContainer(root, node, rng)) {\r\n            return true;\r\n          }\r\n          if (point[i] > children.length - 1) {\r\n            if (padEmptyCaretContainer(root, node, rng)) {\r\n              return true;\r\n            }\r\n            return tryFindRangePosition(node, rng);\r\n          }\r\n          node = children[point[i]];\r\n        }\r\n        if (node.nodeType === 3) {\r\n          offset = Math.min(point[0], node.nodeValue.length);\r\n        }\r\n        if (node.nodeType === 1) {\r\n          offset = Math.min(point[0], node.childNodes.length);\r\n        }\r\n        if (start) {\r\n          rng.setStart(node, offset);\r\n        } else {\r\n          rng.setEnd(node, offset);\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    var isValidTextNode = function (node) {\r\n      return isText$7(node) && node.data.length > 0;\r\n    };\r\n    var restoreEndPoint = function (dom, suffix, bookmark) {\r\n      var marker = dom.get(bookmark.id + '_' + suffix), node, idx, next, prev;\r\n      var keep = bookmark.keep;\r\n      var container, offset;\r\n      if (marker) {\r\n        node = marker.parentNode;\r\n        if (suffix === 'start') {\r\n          if (!keep) {\r\n            idx = dom.nodeIndex(marker);\r\n          } else {\r\n            if (marker.hasChildNodes()) {\r\n              node = marker.firstChild;\r\n              idx = 1;\r\n            } else if (isValidTextNode(marker.nextSibling)) {\r\n              node = marker.nextSibling;\r\n              idx = 0;\r\n            } else if (isValidTextNode(marker.previousSibling)) {\r\n              node = marker.previousSibling;\r\n              idx = marker.previousSibling.data.length;\r\n            } else {\r\n              node = marker.parentNode;\r\n              idx = dom.nodeIndex(marker) + 1;\r\n            }\r\n          }\r\n          container = node;\r\n          offset = idx;\r\n        } else {\r\n          if (!keep) {\r\n            idx = dom.nodeIndex(marker);\r\n          } else {\r\n            if (marker.hasChildNodes()) {\r\n              node = marker.firstChild;\r\n              idx = 1;\r\n            } else if (isValidTextNode(marker.previousSibling)) {\r\n              node = marker.previousSibling;\r\n              idx = marker.previousSibling.data.length;\r\n            } else {\r\n              node = marker.parentNode;\r\n              idx = dom.nodeIndex(marker);\r\n            }\r\n          }\r\n          container = node;\r\n          offset = idx;\r\n        }\r\n        if (!keep) {\r\n          prev = marker.previousSibling;\r\n          next = marker.nextSibling;\r\n          Tools.each(Tools.grep(marker.childNodes), function (node) {\r\n            if (isText$7(node)) {\r\n              node.nodeValue = node.nodeValue.replace(/\\uFEFF/g, '');\r\n            }\r\n          });\r\n          while (marker = dom.get(bookmark.id + '_' + suffix)) {\r\n            dom.remove(marker, true);\r\n          }\r\n          if (prev && next && prev.nodeType === next.nodeType && isText$7(prev) && !Env.opera) {\r\n            idx = prev.nodeValue.length;\r\n            prev.appendData(next.nodeValue);\r\n            dom.remove(next);\r\n            container = prev;\r\n            offset = idx;\r\n          }\r\n        }\r\n        return Optional.some(CaretPosition(container, offset));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var resolvePaths = function (dom, bookmark) {\r\n      var rng = dom.createRng();\r\n      if (setEndPoint(dom, true, bookmark, rng) && setEndPoint(dom, false, bookmark, rng)) {\r\n        return Optional.some(rng);\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var resolveId = function (dom, bookmark) {\r\n      var startPos = restoreEndPoint(dom, 'start', bookmark);\r\n      var endPos = restoreEndPoint(dom, 'end', bookmark);\r\n      return lift2(startPos, endPos.or(startPos), function (spos, epos) {\r\n        var rng = dom.createRng();\r\n        rng.setStart(addBogus(dom, spos.container()), spos.offset());\r\n        rng.setEnd(addBogus(dom, epos.container()), epos.offset());\r\n        return rng;\r\n      });\r\n    };\r\n    var resolveIndex = function (dom, bookmark) {\r\n      return Optional.from(dom.select(bookmark.name)[bookmark.index]).map(function (elm) {\r\n        var rng = dom.createRng();\r\n        rng.selectNode(elm);\r\n        return rng;\r\n      });\r\n    };\r\n    var resolve$1 = function (selection, bookmark) {\r\n      var dom = selection.dom;\r\n      if (bookmark) {\r\n        if (isPathBookmark(bookmark)) {\r\n          return resolvePaths(dom, bookmark);\r\n        } else if (isStringPathBookmark(bookmark)) {\r\n          return Optional.some(resolveCaretPositionBookmark(dom, bookmark));\r\n        } else if (isIdBookmark(bookmark)) {\r\n          return resolveId(dom, bookmark);\r\n        } else if (isIndexBookmark(bookmark)) {\r\n          return resolveIndex(dom, bookmark);\r\n        } else if (isRangeBookmark(bookmark)) {\r\n          return Optional.some(bookmark.rng);\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n\r\n    var getBookmark$1 = function (selection, type, normalized) {\r\n      return getBookmark$2(selection, type, normalized);\r\n    };\r\n    var moveToBookmark = function (selection, bookmark) {\r\n      resolve$1(selection, bookmark).each(function (rng) {\r\n        selection.setRng(rng);\r\n      });\r\n    };\r\n    var isBookmarkNode$1 = function (node) {\r\n      return isElement$5(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\r\n    };\r\n\r\n    var is = function (expected) {\r\n      return function (actual) {\r\n        return expected === actual;\r\n      };\r\n    };\r\n    var isNbsp = is(nbsp);\r\n    var isWhiteSpace = function (chr) {\r\n      return chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\r\n    };\r\n    var isContent = function (chr) {\r\n      return !isWhiteSpace(chr) && !isNbsp(chr);\r\n    };\r\n\r\n    var isNode = function (node) {\r\n      return !!node.nodeType;\r\n    };\r\n    var isInlineBlock = function (node) {\r\n      return node && /^(IMG)$/.test(node.nodeName);\r\n    };\r\n    var moveStart = function (dom, selection, rng) {\r\n      var offset = rng.startOffset;\r\n      var container = rng.startContainer;\r\n      if (container === rng.endContainer) {\r\n        if (isInlineBlock(container.childNodes[offset])) {\r\n          return;\r\n        }\r\n      }\r\n      if (isElement$5(container)) {\r\n        var nodes = container.childNodes;\r\n        var walker = void 0;\r\n        if (offset < nodes.length) {\r\n          container = nodes[offset];\r\n          walker = new DomTreeWalker(container, dom.getParent(container, dom.isBlock));\r\n        } else {\r\n          container = nodes[nodes.length - 1];\r\n          walker = new DomTreeWalker(container, dom.getParent(container, dom.isBlock));\r\n          walker.next(true);\r\n        }\r\n        for (var node = walker.current(); node; node = walker.next()) {\r\n          if (isText$7(node) && !isWhiteSpaceNode$1(node)) {\r\n            rng.setStart(node, 0);\r\n            selection.setRng(rng);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var getNonWhiteSpaceSibling = function (node, next, inc) {\r\n      if (node) {\r\n        var nextName = next ? 'nextSibling' : 'previousSibling';\r\n        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\r\n          if (isElement$5(node) || !isWhiteSpaceNode$1(node)) {\r\n            return node;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var isTextBlock$1 = function (editor, name) {\r\n      if (isNode(name)) {\r\n        name = name.nodeName;\r\n      }\r\n      return !!editor.schema.getTextBlockElements()[name.toLowerCase()];\r\n    };\r\n    var isValid = function (ed, parent, child) {\r\n      return ed.schema.isValidChild(parent, child);\r\n    };\r\n    var isWhiteSpaceNode$1 = function (node, allowSpaces) {\r\n      if (allowSpaces === void 0) {\r\n        allowSpaces = false;\r\n      }\r\n      if (isNonNullable(node) && isText$7(node)) {\r\n        var data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\r\n        return isWhitespaceText(data);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var isEmptyTextNode$1 = function (node) {\r\n      return isNonNullable(node) && isText$7(node) && node.length === 0;\r\n    };\r\n    var replaceVars = function (value, vars) {\r\n      if (isFunction(value)) {\r\n        value = value(vars);\r\n      } else if (isNonNullable(vars)) {\r\n        value = value.replace(/%(\\w+)/g, function (str, name) {\r\n          return vars[name] || str;\r\n        });\r\n      }\r\n      return value;\r\n    };\r\n    var isEq$5 = function (str1, str2) {\r\n      str1 = str1 || '';\r\n      str2 = str2 || '';\r\n      str1 = '' + (str1.nodeName || str1);\r\n      str2 = '' + (str2.nodeName || str2);\r\n      return str1.toLowerCase() === str2.toLowerCase();\r\n    };\r\n    var normalizeStyleValue = function (dom, value, name) {\r\n      if (name === 'color' || name === 'backgroundColor') {\r\n        value = dom.toHex(value);\r\n      }\r\n      if (name === 'fontWeight' && value === 700) {\r\n        value = 'bold';\r\n      }\r\n      if (name === 'fontFamily') {\r\n        value = value.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\r\n      }\r\n      return '' + value;\r\n    };\r\n    var getStyle = function (dom, node, name) {\r\n      return normalizeStyleValue(dom, dom.getStyle(node, name), name);\r\n    };\r\n    var getTextDecoration = function (dom, node) {\r\n      var decoration;\r\n      dom.getParent(node, function (n) {\r\n        decoration = dom.getStyle(n, 'text-decoration');\r\n        return decoration && decoration !== 'none';\r\n      });\r\n      return decoration;\r\n    };\r\n    var getParents$2 = function (dom, node, selector) {\r\n      return dom.getParents(node, selector, dom.getRoot());\r\n    };\r\n    var isVariableFormatName = function (editor, formatName) {\r\n      var hasVariableValues = function (format) {\r\n        var isVariableValue = function (val) {\r\n          return val.length > 1 && val.charAt(0) === '%';\r\n        };\r\n        return exists([\r\n          'styles',\r\n          'attributes'\r\n        ], function (key) {\r\n          return get$9(format, key).exists(function (field) {\r\n            var fieldValues = isArray$1(field) ? field : values(field);\r\n            return exists(fieldValues, isVariableValue);\r\n          });\r\n        });\r\n      };\r\n      return exists(editor.formatter.get(formatName), hasVariableValues);\r\n    };\r\n    var areSimilarFormats = function (editor, formatName, otherFormatName) {\r\n      var validKeys = [\r\n        'inline',\r\n        'block',\r\n        'selector',\r\n        'attributes',\r\n        'styles',\r\n        'classes'\r\n      ];\r\n      var filterObj = function (format) {\r\n        return filter$3(format, function (_, key) {\r\n          return exists(validKeys, function (validKey) {\r\n            return validKey === key;\r\n          });\r\n        });\r\n      };\r\n      return exists(editor.formatter.get(formatName), function (fmt1) {\r\n        var filteredFmt1 = filterObj(fmt1);\r\n        return exists(editor.formatter.get(otherFormatName), function (fmt2) {\r\n          var filteredFmt2 = filterObj(fmt2);\r\n          return equal$1(filteredFmt1, filteredFmt2);\r\n        });\r\n      });\r\n    };\r\n    var isBlockFormat = function (format) {\r\n      return hasNonNullableKey(format, 'block');\r\n    };\r\n    var isSelectorFormat = function (format) {\r\n      return hasNonNullableKey(format, 'selector');\r\n    };\r\n    var isInlineFormat = function (format) {\r\n      return hasNonNullableKey(format, 'inline');\r\n    };\r\n    var isMixedFormat = function (format) {\r\n      return isSelectorFormat(format) && isInlineFormat(format) && is$1(get$9(format, 'mixed'), true);\r\n    };\r\n    var shouldExpandToSelector = function (format) {\r\n      return isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\r\n    };\r\n\r\n    var isBookmarkNode = isBookmarkNode$1;\r\n    var getParents$1 = getParents$2;\r\n    var isWhiteSpaceNode = isWhiteSpaceNode$1;\r\n    var isTextBlock = isTextBlock$1;\r\n    var isBogusBr = function (node) {\r\n      return isBr$5(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\r\n    };\r\n    var findParentContentEditable = function (dom, node) {\r\n      var parent = node;\r\n      while (parent) {\r\n        if (isElement$5(parent) && dom.getContentEditable(parent)) {\r\n          return dom.getContentEditable(parent) === 'false' ? parent : node;\r\n        }\r\n        parent = parent.parentNode;\r\n      }\r\n      return node;\r\n    };\r\n    var walkText = function (start, node, offset, predicate) {\r\n      var str = node.data;\r\n      for (var i = offset; start ? i >= 0 : i < str.length; start ? i-- : i++) {\r\n        if (predicate(str.charAt(i))) {\r\n          return start ? i + 1 : i;\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    var findSpace = function (start, node, offset) {\r\n      return walkText(start, node, offset, function (c) {\r\n        return isNbsp(c) || isWhiteSpace(c);\r\n      });\r\n    };\r\n    var findContent = function (start, node, offset) {\r\n      return walkText(start, node, offset, isContent);\r\n    };\r\n    var findWordEndPoint = function (dom, body, container, offset, start, includeTrailingSpaces) {\r\n      var lastTextNode;\r\n      var rootNode = dom.getParent(container, dom.isBlock) || body;\r\n      var walk = function (container, offset, pred) {\r\n        var textSeeker = TextSeeker(dom);\r\n        var walker = start ? textSeeker.backwards : textSeeker.forwards;\r\n        return Optional.from(walker(container, offset, function (text, textOffset) {\r\n          if (isBookmarkNode(text.parentNode)) {\r\n            return -1;\r\n          } else {\r\n            lastTextNode = text;\r\n            return pred(start, text, textOffset);\r\n          }\r\n        }, rootNode));\r\n      };\r\n      var spaceResult = walk(container, offset, findSpace);\r\n      return spaceResult.bind(function (result) {\r\n        return includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result);\r\n      }).orThunk(function () {\r\n        return lastTextNode ? Optional.some({\r\n          container: lastTextNode,\r\n          offset: start ? 0 : lastTextNode.length\r\n        }) : Optional.none();\r\n      });\r\n    };\r\n    var findSelectorEndPoint = function (dom, formatList, rng, container, siblingName) {\r\n      if (isText$7(container) && isEmpty$3(container.data) && container[siblingName]) {\r\n        container = container[siblingName];\r\n      }\r\n      var parents = getParents$1(dom, container);\r\n      for (var i = 0; i < parents.length; i++) {\r\n        for (var y = 0; y < formatList.length; y++) {\r\n          var curFormat = formatList[y];\r\n          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\r\n            continue;\r\n          }\r\n          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\r\n            return parents[i];\r\n          }\r\n        }\r\n      }\r\n      return container;\r\n    };\r\n    var findBlockEndPoint = function (editor, formatList, container, siblingName) {\r\n      var node = container;\r\n      var dom = editor.dom;\r\n      var root = dom.getRoot();\r\n      var format = formatList[0];\r\n      if (isBlockFormat(format)) {\r\n        node = format.wrapper ? null : dom.getParent(container, format.block, root);\r\n      }\r\n      if (!node) {\r\n        var scopeRoot = dom.getParent(container, 'LI,TD,TH');\r\n        node = dom.getParent(isText$7(container) ? container.parentNode : container, function (node) {\r\n          return node !== root && isTextBlock(editor, node);\r\n        }, scopeRoot);\r\n      }\r\n      if (node && isBlockFormat(format) && format.wrapper) {\r\n        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\r\n      }\r\n      if (!node) {\r\n        node = container;\r\n        while (node[siblingName] && !dom.isBlock(node[siblingName])) {\r\n          node = node[siblingName];\r\n          if (isEq$5(node, 'br')) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      return node || container;\r\n    };\r\n    var isAtBlockBoundary$1 = function (dom, root, container, siblingName) {\r\n      var parent = container.parentNode;\r\n      if (isNonNullable(container[siblingName])) {\r\n        return false;\r\n      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\r\n        return true;\r\n      } else {\r\n        return isAtBlockBoundary$1(dom, root, parent, siblingName);\r\n      }\r\n    };\r\n    var findParentContainer = function (dom, formatList, container, offset, start) {\r\n      var parent = container;\r\n      var siblingName = start ? 'previousSibling' : 'nextSibling';\r\n      var root = dom.getRoot();\r\n      if (isText$7(container) && !isWhiteSpaceNode(container)) {\r\n        if (start ? offset > 0 : offset < container.data.length) {\r\n          return container;\r\n        }\r\n      }\r\n      while (true) {\r\n        if (!formatList[0].block_expand && dom.isBlock(parent)) {\r\n          return parent;\r\n        }\r\n        for (var sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\r\n          var allowSpaces = isText$7(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\r\n          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\r\n            return parent;\r\n          }\r\n        }\r\n        if (parent === root || parent.parentNode === root) {\r\n          container = parent;\r\n          break;\r\n        }\r\n        parent = parent.parentNode;\r\n      }\r\n      return container;\r\n    };\r\n    var isSelfOrParentBookmark = function (container) {\r\n      return isBookmarkNode(container.parentNode) || isBookmarkNode(container);\r\n    };\r\n    var expandRng = function (editor, rng, formatList, includeTrailingSpace) {\r\n      if (includeTrailingSpace === void 0) {\r\n        includeTrailingSpace = false;\r\n      }\r\n      var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;\r\n      var dom = editor.dom;\r\n      var format = formatList[0];\r\n      if (isElement$5(startContainer) && startContainer.hasChildNodes()) {\r\n        startContainer = getNode$1(startContainer, startOffset);\r\n        if (isText$7(startContainer)) {\r\n          startOffset = 0;\r\n        }\r\n      }\r\n      if (isElement$5(endContainer) && endContainer.hasChildNodes()) {\r\n        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\r\n        if (isText$7(endContainer)) {\r\n          endOffset = endContainer.nodeValue.length;\r\n        }\r\n      }\r\n      startContainer = findParentContentEditable(dom, startContainer);\r\n      endContainer = findParentContentEditable(dom, endContainer);\r\n      if (isSelfOrParentBookmark(startContainer)) {\r\n        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\r\n        if (rng.collapsed) {\r\n          startContainer = startContainer.previousSibling || startContainer;\r\n        } else {\r\n          startContainer = startContainer.nextSibling || startContainer;\r\n        }\r\n        if (isText$7(startContainer)) {\r\n          startOffset = rng.collapsed ? startContainer.length : 0;\r\n        }\r\n      }\r\n      if (isSelfOrParentBookmark(endContainer)) {\r\n        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\r\n        if (rng.collapsed) {\r\n          endContainer = endContainer.nextSibling || endContainer;\r\n        } else {\r\n          endContainer = endContainer.previousSibling || endContainer;\r\n        }\r\n        if (isText$7(endContainer)) {\r\n          endOffset = rng.collapsed ? 0 : endContainer.length;\r\n        }\r\n      }\r\n      if (rng.collapsed) {\r\n        var startPoint = findWordEndPoint(dom, editor.getBody(), startContainer, startOffset, true, includeTrailingSpace);\r\n        startPoint.each(function (_a) {\r\n          var container = _a.container, offset = _a.offset;\r\n          startContainer = container;\r\n          startOffset = offset;\r\n        });\r\n        var endPoint = findWordEndPoint(dom, editor.getBody(), endContainer, endOffset, false, includeTrailingSpace);\r\n        endPoint.each(function (_a) {\r\n          var container = _a.container, offset = _a.offset;\r\n          endContainer = container;\r\n          endOffset = offset;\r\n        });\r\n      }\r\n      if (isInlineFormat(format) || format.block_expand) {\r\n        if (!isInlineFormat(format) || (!isText$7(startContainer) || startOffset === 0)) {\r\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\r\n        }\r\n        if (!isInlineFormat(format) || (!isText$7(endContainer) || endOffset === endContainer.nodeValue.length)) {\r\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\r\n        }\r\n      }\r\n      if (shouldExpandToSelector(format)) {\r\n        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\r\n        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\r\n      }\r\n      if (isBlockFormat(format) || isSelectorFormat(format)) {\r\n        startContainer = findBlockEndPoint(editor, formatList, startContainer, 'previousSibling');\r\n        endContainer = findBlockEndPoint(editor, formatList, endContainer, 'nextSibling');\r\n        if (isBlockFormat(format)) {\r\n          if (!dom.isBlock(startContainer)) {\r\n            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\r\n          }\r\n          if (!dom.isBlock(endContainer)) {\r\n            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\r\n          }\r\n        }\r\n      }\r\n      if (isElement$5(startContainer)) {\r\n        startOffset = dom.nodeIndex(startContainer);\r\n        startContainer = startContainer.parentNode;\r\n      }\r\n      if (isElement$5(endContainer)) {\r\n        endOffset = dom.nodeIndex(endContainer) + 1;\r\n        endContainer = endContainer.parentNode;\r\n      }\r\n      return {\r\n        startContainer: startContainer,\r\n        startOffset: startOffset,\r\n        endContainer: endContainer,\r\n        endOffset: endOffset\r\n      };\r\n    };\r\n\r\n    var walk$2 = function (dom, rng, callback) {\r\n      var startOffset = rng.startOffset;\r\n      var startContainer = getNode$1(rng.startContainer, startOffset);\r\n      var endOffset = rng.endOffset;\r\n      var endContainer = getNode$1(rng.endContainer, endOffset - 1);\r\n      var exclude = function (nodes) {\r\n        var firstNode = nodes[0];\r\n        if (isText$7(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\r\n          nodes.splice(0, 1);\r\n        }\r\n        var lastNode = nodes[nodes.length - 1];\r\n        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$7(lastNode)) {\r\n          nodes.splice(nodes.length - 1, 1);\r\n        }\r\n        return nodes;\r\n      };\r\n      var collectSiblings = function (node, name, endNode) {\r\n        var siblings = [];\r\n        for (; node && node !== endNode; node = node[name]) {\r\n          siblings.push(node);\r\n        }\r\n        return siblings;\r\n      };\r\n      var findEndPoint = function (node, root) {\r\n        return dom.getParent(node, function (node) {\r\n          return node.parentNode === root;\r\n        }, root);\r\n      };\r\n      var walkBoundary = function (startNode, endNode, next) {\r\n        var siblingName = next ? 'nextSibling' : 'previousSibling';\r\n        for (var node = startNode, parent_1 = node.parentNode; node && node !== endNode; node = parent_1) {\r\n          parent_1 = node.parentNode;\r\n          var siblings_1 = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\r\n          if (siblings_1.length) {\r\n            if (!next) {\r\n              siblings_1.reverse();\r\n            }\r\n            callback(exclude(siblings_1));\r\n          }\r\n        }\r\n      };\r\n      if (startContainer === endContainer) {\r\n        return callback(exclude([startContainer]));\r\n      }\r\n      var ancestor = dom.findCommonAncestor(startContainer, endContainer);\r\n      if (dom.isChildOf(startContainer, endContainer)) {\r\n        return walkBoundary(startContainer, ancestor, true);\r\n      }\r\n      if (dom.isChildOf(endContainer, startContainer)) {\r\n        return walkBoundary(endContainer, ancestor);\r\n      }\r\n      var startPoint = findEndPoint(startContainer, ancestor) || startContainer;\r\n      var endPoint = findEndPoint(endContainer, ancestor) || endContainer;\r\n      walkBoundary(startContainer, startPoint, true);\r\n      var siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\r\n      if (siblings.length) {\r\n        callback(exclude(siblings));\r\n      }\r\n      walkBoundary(endContainer, endPoint);\r\n    };\r\n\r\n    var getRanges = function (selection) {\r\n      var ranges = [];\r\n      if (selection) {\r\n        for (var i = 0; i < selection.rangeCount; i++) {\r\n          ranges.push(selection.getRangeAt(i));\r\n        }\r\n      }\r\n      return ranges;\r\n    };\r\n    var getSelectedNodes = function (ranges) {\r\n      return bind(ranges, function (range) {\r\n        var node = getSelectedNode(range);\r\n        return node ? [SugarElement.fromDom(node)] : [];\r\n      });\r\n    };\r\n    var hasMultipleRanges = function (selection) {\r\n      return getRanges(selection).length > 1;\r\n    };\r\n\r\n    var getCellsFromRanges = function (ranges) {\r\n      return filter$4(getSelectedNodes(ranges), isTableCell$4);\r\n    };\r\n    var getCellsFromElement = function (elm) {\r\n      return descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\r\n    };\r\n    var getCellsFromElementOrRanges = function (ranges, element) {\r\n      var selectedCells = getCellsFromElement(element);\r\n      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\r\n    };\r\n    var getCellsFromEditor = function (editor) {\r\n      return getCellsFromElementOrRanges(getRanges(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\r\n    };\r\n    var getClosestTable = function (cell, isRoot) {\r\n      return ancestor$2(cell, 'table', isRoot);\r\n    };\r\n\r\n    var getStartNode = function (rng) {\r\n      var sc = rng.startContainer, so = rng.startOffset;\r\n      if (isText$7(sc)) {\r\n        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\r\n      } else {\r\n        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\r\n      }\r\n    };\r\n    var getEndNode = function (rng) {\r\n      var ec = rng.endContainer, eo = rng.endOffset;\r\n      if (isText$7(ec)) {\r\n        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\r\n      } else {\r\n        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\r\n      }\r\n    };\r\n    var getFirstChildren = function (node) {\r\n      return firstChild(node).fold(constant([node]), function (child) {\r\n        return [node].concat(getFirstChildren(child));\r\n      });\r\n    };\r\n    var getLastChildren$1 = function (node) {\r\n      return lastChild(node).fold(constant([node]), function (child) {\r\n        if (name(child) === 'br') {\r\n          return prevSibling(child).map(function (sibling) {\r\n            return [node].concat(getLastChildren$1(sibling));\r\n          }).getOr([]);\r\n        } else {\r\n          return [node].concat(getLastChildren$1(child));\r\n        }\r\n      });\r\n    };\r\n    var hasAllContentsSelected = function (elm, rng) {\r\n      return lift2(getStartNode(rng), getEndNode(rng), function (startNode, endNode) {\r\n        var start = find$3(getFirstChildren(elm), curry(eq, startNode));\r\n        var end = find$3(getLastChildren$1(elm), curry(eq, endNode));\r\n        return start.isSome() && end.isSome();\r\n      }).getOr(false);\r\n    };\r\n    var moveEndPoint = function (dom, rng, node, start) {\r\n      var root = node, walker = new DomTreeWalker(node, root);\r\n      var moveCaretBeforeOnEnterElementsMap = filter$3(dom.schema.getMoveCaretBeforeOnEnterElements(), function (_, name) {\r\n        return !contains$3([\r\n          'td',\r\n          'th',\r\n          'table'\r\n        ], name.toLowerCase());\r\n      });\r\n      do {\r\n        if (isText$7(node) && Tools.trim(node.nodeValue).length !== 0) {\r\n          if (start) {\r\n            rng.setStart(node, 0);\r\n          } else {\r\n            rng.setEnd(node, node.nodeValue.length);\r\n          }\r\n          return;\r\n        }\r\n        if (moveCaretBeforeOnEnterElementsMap[node.nodeName]) {\r\n          if (start) {\r\n            rng.setStartBefore(node);\r\n          } else {\r\n            if (node.nodeName === 'BR') {\r\n              rng.setEndBefore(node);\r\n            } else {\r\n              rng.setEndAfter(node);\r\n            }\r\n          }\r\n          return;\r\n        }\r\n      } while (node = start ? walker.next() : walker.prev());\r\n      if (root.nodeName === 'BODY') {\r\n        if (start) {\r\n          rng.setStart(root, 0);\r\n        } else {\r\n          rng.setEnd(root, root.childNodes.length);\r\n        }\r\n      }\r\n    };\r\n    var hasAnyRanges = function (editor) {\r\n      var sel = editor.selection.getSel();\r\n      return sel && sel.rangeCount > 0;\r\n    };\r\n    var runOnRanges = function (editor, executor) {\r\n      var fakeSelectionNodes = getCellsFromEditor(editor);\r\n      if (fakeSelectionNodes.length > 0) {\r\n        each$k(fakeSelectionNodes, function (elem) {\r\n          var node = elem.dom;\r\n          var fakeNodeRng = editor.dom.createRng();\r\n          fakeNodeRng.setStartBefore(node);\r\n          fakeNodeRng.setEndAfter(node);\r\n          executor(fakeNodeRng, true);\r\n        });\r\n      } else {\r\n        executor(editor.selection.getRng(), false);\r\n      }\r\n    };\r\n    var preserve = function (selection, fillBookmark, executor) {\r\n      var bookmark = getPersistentBookmark(selection, fillBookmark);\r\n      executor(bookmark);\r\n      selection.moveToBookmark(bookmark);\r\n    };\r\n\r\n    var NodeValue = function (is, name) {\r\n      var get = function (element) {\r\n        if (!is(element)) {\r\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\r\n        }\r\n        return getOption(element).getOr('');\r\n      };\r\n      var getOption = function (element) {\r\n        return is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\r\n      };\r\n      var set = function (element, value) {\r\n        if (!is(element)) {\r\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\r\n        }\r\n        element.dom.nodeValue = value;\r\n      };\r\n      return {\r\n        get: get,\r\n        getOption: getOption,\r\n        set: set\r\n      };\r\n    };\r\n\r\n    var api$1 = NodeValue(isText$8, 'text');\r\n    var get$2 = function (element) {\r\n      return api$1.get(element);\r\n    };\r\n\r\n    var isZeroWidth = function (elem) {\r\n      return isText$8(elem) && get$2(elem) === ZWSP$1;\r\n    };\r\n    var context = function (editor, elem, wrapName, nodeName) {\r\n      return parent(elem).fold(function () {\r\n        return 'skipping';\r\n      }, function (parent) {\r\n        if (nodeName === 'br' || isZeroWidth(elem)) {\r\n          return 'valid';\r\n        } else if (isAnnotation(elem)) {\r\n          return 'existing';\r\n        } else if (isCaretNode(elem.dom)) {\r\n          return 'caret';\r\n        } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\r\n          return 'invalid-child';\r\n        } else {\r\n          return 'valid';\r\n        }\r\n      });\r\n    };\r\n\r\n    var applyWordGrab = function (editor, rng) {\r\n      var r = expandRng(editor, rng, [{ inline: 'span' }]);\r\n      rng.setStart(r.startContainer, r.startOffset);\r\n      rng.setEnd(r.endContainer, r.endOffset);\r\n      editor.selection.setRng(rng);\r\n    };\r\n    var makeAnnotation = function (eDoc, _a, annotationName, decorate) {\r\n      var _b = _a.uid, uid = _b === void 0 ? generate('mce-annotation') : _b, data = __rest(_a, ['uid']);\r\n      var master = SugarElement.fromTag('span', eDoc);\r\n      add$1(master, annotation());\r\n      set$1(master, '' + dataAnnotationId(), uid);\r\n      set$1(master, '' + dataAnnotation(), annotationName);\r\n      var _c = decorate(uid, data), _d = _c.attributes, attributes = _d === void 0 ? {} : _d, _e = _c.classes, classes = _e === void 0 ? [] : _e;\r\n      setAll$1(master, attributes);\r\n      add(master, classes);\r\n      return master;\r\n    };\r\n    var annotate = function (editor, rng, annotationName, decorate, data) {\r\n      var newWrappers = [];\r\n      var master = makeAnnotation(editor.getDoc(), data, annotationName, decorate);\r\n      var wrapper = value();\r\n      var finishWrapper = function () {\r\n        wrapper.clear();\r\n      };\r\n      var getOrOpenWrapper = function () {\r\n        return wrapper.get().getOrThunk(function () {\r\n          var nu = shallow(master);\r\n          newWrappers.push(nu);\r\n          wrapper.set(nu);\r\n          return nu;\r\n        });\r\n      };\r\n      var processElements = function (elems) {\r\n        each$k(elems, processElement);\r\n      };\r\n      var processElement = function (elem) {\r\n        var ctx = context(editor, elem, 'span', name(elem));\r\n        switch (ctx) {\r\n        case 'invalid-child': {\r\n            finishWrapper();\r\n            var children$1 = children(elem);\r\n            processElements(children$1);\r\n            finishWrapper();\r\n            break;\r\n          }\r\n        case 'valid': {\r\n            var w = getOrOpenWrapper();\r\n            wrap$3(elem, w);\r\n            break;\r\n          }\r\n        }\r\n      };\r\n      var processNodes = function (nodes) {\r\n        var elems = map$3(nodes, SugarElement.fromDom);\r\n        processElements(elems);\r\n      };\r\n      walk$2(editor.dom, rng, function (nodes) {\r\n        finishWrapper();\r\n        processNodes(nodes);\r\n      });\r\n      return newWrappers;\r\n    };\r\n    var annotateWithBookmark = function (editor, name, settings, data) {\r\n      editor.undoManager.transact(function () {\r\n        var selection = editor.selection;\r\n        var initialRng = selection.getRng();\r\n        var hasFakeSelection = getCellsFromEditor(editor).length > 0;\r\n        if (initialRng.collapsed && !hasFakeSelection) {\r\n          applyWordGrab(editor, initialRng);\r\n        }\r\n        if (selection.getRng().collapsed && !hasFakeSelection) {\r\n          var wrapper = makeAnnotation(editor.getDoc(), data, name, settings.decorate);\r\n          set(wrapper, nbsp);\r\n          selection.getRng().insertNode(wrapper.dom);\r\n          selection.select(wrapper.dom);\r\n        } else {\r\n          preserve(selection, false, function () {\r\n            runOnRanges(editor, function (selectionRng) {\r\n              annotate(editor, selectionRng, name, settings.decorate, data);\r\n            });\r\n          });\r\n        }\r\n      });\r\n    };\r\n\r\n    var Annotator = function (editor) {\r\n      var registry = create$7();\r\n      setup$m(editor, registry);\r\n      var changes = setup$n(editor);\r\n      return {\r\n        register: function (name, settings) {\r\n          registry.register(name, settings);\r\n        },\r\n        annotate: function (name, data) {\r\n          registry.lookup(name).each(function (settings) {\r\n            annotateWithBookmark(editor, name, settings, data);\r\n          });\r\n        },\r\n        annotationChanged: function (name, callback) {\r\n          changes.addListener(name, callback);\r\n        },\r\n        remove: function (name) {\r\n          identify(editor, Optional.some(name)).each(function (_a) {\r\n            var elements = _a.elements;\r\n            each$k(elements, unwrap);\r\n          });\r\n        },\r\n        getAll: function (name) {\r\n          var directory = findAll(editor, name);\r\n          return map$2(directory, function (elems) {\r\n            return map$3(elems, function (elem) {\r\n              return elem.dom;\r\n            });\r\n          });\r\n        }\r\n      };\r\n    };\r\n\r\n    var BookmarkManager = function (selection) {\r\n      return {\r\n        getBookmark: curry(getBookmark$1, selection),\r\n        moveToBookmark: curry(moveToBookmark, selection)\r\n      };\r\n    };\r\n    BookmarkManager.isBookmarkNode = isBookmarkNode$1;\r\n\r\n    var getContentEditableRoot$1 = function (root, node) {\r\n      while (node && node !== root) {\r\n        if (isContentEditableTrue$4(node) || isContentEditableFalse$b(node)) {\r\n          return node;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n\r\n    var isXYWithinRange = function (clientX, clientY, range) {\r\n      if (range.collapsed) {\r\n        return false;\r\n      }\r\n      if (Env.browser.isIE() && range.startOffset === range.endOffset - 1 && range.startContainer === range.endContainer) {\r\n        var elm = range.startContainer.childNodes[range.startOffset];\r\n        if (isElement$5(elm)) {\r\n          return exists(elm.getClientRects(), function (rect) {\r\n            return containsXY(rect, clientX, clientY);\r\n          });\r\n        }\r\n      }\r\n      return exists(range.getClientRects(), function (rect) {\r\n        return containsXY(rect, clientX, clientY);\r\n      });\r\n    };\r\n\r\n    var firePreProcess = function (editor, args) {\r\n      return editor.fire('PreProcess', args);\r\n    };\r\n    var firePostProcess = function (editor, args) {\r\n      return editor.fire('PostProcess', args);\r\n    };\r\n    var fireRemove = function (editor) {\r\n      return editor.fire('remove');\r\n    };\r\n    var fireDetach = function (editor) {\r\n      return editor.fire('detach');\r\n    };\r\n    var fireSwitchMode = function (editor, mode) {\r\n      return editor.fire('SwitchMode', { mode: mode });\r\n    };\r\n    var fireObjectResizeStart = function (editor, target, width, height, origin) {\r\n      editor.fire('ObjectResizeStart', {\r\n        target: target,\r\n        width: width,\r\n        height: height,\r\n        origin: origin\r\n      });\r\n    };\r\n    var fireObjectResized = function (editor, target, width, height, origin) {\r\n      editor.fire('ObjectResized', {\r\n        target: target,\r\n        width: width,\r\n        height: height,\r\n        origin: origin\r\n      });\r\n    };\r\n    var firePreInit = function (editor) {\r\n      return editor.fire('PreInit');\r\n    };\r\n    var firePostRender = function (editor) {\r\n      return editor.fire('PostRender');\r\n    };\r\n    var fireInit = function (editor) {\r\n      return editor.fire('Init');\r\n    };\r\n    var firePlaceholderToggle = function (editor, state) {\r\n      return editor.fire('PlaceholderToggle', { state: state });\r\n    };\r\n    var fireError = function (editor, errorType, error) {\r\n      return editor.fire(errorType, error);\r\n    };\r\n    var fireFormatApply = function (editor, format, node, vars) {\r\n      return editor.fire('FormatApply', {\r\n        format: format,\r\n        node: node,\r\n        vars: vars\r\n      });\r\n    };\r\n    var fireFormatRemove = function (editor, format, node, vars) {\r\n      return editor.fire('FormatRemove', {\r\n        format: format,\r\n        node: node,\r\n        vars: vars\r\n      });\r\n    };\r\n\r\n    var VK = {\r\n      BACKSPACE: 8,\r\n      DELETE: 46,\r\n      DOWN: 40,\r\n      ENTER: 13,\r\n      ESC: 27,\r\n      LEFT: 37,\r\n      RIGHT: 39,\r\n      SPACEBAR: 32,\r\n      TAB: 9,\r\n      UP: 38,\r\n      PAGE_UP: 33,\r\n      PAGE_DOWN: 34,\r\n      END: 35,\r\n      HOME: 36,\r\n      modifierPressed: function (e) {\r\n        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\r\n      },\r\n      metaKeyPressed: function (e) {\r\n        return Env.mac ? e.metaKey : e.ctrlKey && !e.altKey;\r\n      }\r\n    };\r\n\r\n    var isContentEditableFalse$5 = isContentEditableFalse$b;\r\n    var ControlSelection = function (selection, editor) {\r\n      var elementSelectionAttr = 'data-mce-selected';\r\n      var dom = editor.dom, each = Tools.each;\r\n      var selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\r\n      var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\r\n      var width, height;\r\n      var editableDoc = editor.getDoc(), rootDocument = document;\r\n      var abs = Math.abs, round = Math.round, rootElement = editor.getBody();\r\n      var startScrollWidth, startScrollHeight;\r\n      var resizeHandles = {\r\n        nw: [\r\n          0,\r\n          0,\r\n          -1,\r\n          -1\r\n        ],\r\n        ne: [\r\n          1,\r\n          0,\r\n          1,\r\n          -1\r\n        ],\r\n        se: [\r\n          1,\r\n          1,\r\n          1,\r\n          1\r\n        ],\r\n        sw: [\r\n          0,\r\n          1,\r\n          -1,\r\n          1\r\n        ]\r\n      };\r\n      var isImage = function (elm) {\r\n        return elm && (elm.nodeName === 'IMG' || editor.dom.is(elm, 'figure.image'));\r\n      };\r\n      var isMedia = function (elm) {\r\n        return isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\r\n      };\r\n      var isEventOnImageOutsideRange = function (evt, range) {\r\n        if (evt.type === 'longpress' || evt.type.indexOf('touch') === 0) {\r\n          var touch = evt.touches[0];\r\n          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\r\n        } else {\r\n          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\r\n        }\r\n      };\r\n      var contextMenuSelectImage = function (evt) {\r\n        var target = evt.target;\r\n        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\r\n          editor.selection.select(target);\r\n        }\r\n      };\r\n      var getResizeTargets = function (elm) {\r\n        if (dom.is(elm, 'figure.image')) {\r\n          return [elm.querySelector('img')];\r\n        } else if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\r\n          return [\r\n            elm,\r\n            elm.firstElementChild\r\n          ];\r\n        } else {\r\n          return [elm];\r\n        }\r\n      };\r\n      var isResizable = function (elm) {\r\n        var selector = getObjectResizing(editor);\r\n        if (!selector) {\r\n          return false;\r\n        }\r\n        if (elm.getAttribute('data-mce-resize') === 'false') {\r\n          return false;\r\n        }\r\n        if (elm === editor.getBody()) {\r\n          return false;\r\n        }\r\n        if (dom.hasClass(elm, 'mce-preview-object')) {\r\n          return is$2(SugarElement.fromDom(elm.firstElementChild), selector);\r\n        } else {\r\n          return is$2(SugarElement.fromDom(elm), selector);\r\n        }\r\n      };\r\n      var createGhostElement = function (elm) {\r\n        if (isMedia(elm)) {\r\n          return dom.create('img', { src: Env.transparentSrc });\r\n        } else {\r\n          return elm.cloneNode(true);\r\n        }\r\n      };\r\n      var setSizeProp = function (element, name, value) {\r\n        if (isNonNullable(value)) {\r\n          var targets = getResizeTargets(element);\r\n          each$k(targets, function (target) {\r\n            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\r\n              dom.setStyle(target, name, value);\r\n            } else {\r\n              dom.setAttrib(target, name, '' + value);\r\n            }\r\n          });\r\n        }\r\n      };\r\n      var setGhostElmSize = function (ghostElm, width, height) {\r\n        setSizeProp(ghostElm, 'width', width);\r\n        setSizeProp(ghostElm, 'height', height);\r\n      };\r\n      var resizeGhostElement = function (e) {\r\n        var deltaX, deltaY, proportional;\r\n        var resizeHelperX, resizeHelperY;\r\n        deltaX = e.screenX - startX;\r\n        deltaY = e.screenY - startY;\r\n        width = deltaX * selectedHandle[2] + startW;\r\n        height = deltaY * selectedHandle[3] + startH;\r\n        width = width < 5 ? 5 : width;\r\n        height = height < 5 ? 5 : height;\r\n        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\r\n          proportional = !VK.modifierPressed(e);\r\n        } else {\r\n          proportional = VK.modifierPressed(e);\r\n        }\r\n        if (proportional) {\r\n          if (abs(deltaX) > abs(deltaY)) {\r\n            height = round(width * ratio);\r\n            width = round(height / ratio);\r\n          } else {\r\n            width = round(height / ratio);\r\n            height = round(width * ratio);\r\n          }\r\n        }\r\n        setGhostElmSize(selectedElmGhost, width, height);\r\n        resizeHelperX = selectedHandle.startPos.x + deltaX;\r\n        resizeHelperY = selectedHandle.startPos.y + deltaY;\r\n        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\r\n        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\r\n        dom.setStyles(resizeHelper, {\r\n          left: resizeHelperX,\r\n          top: resizeHelperY,\r\n          display: 'block'\r\n        });\r\n        resizeHelper.innerHTML = width + ' &times; ' + height;\r\n        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\r\n          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\r\n        }\r\n        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\r\n          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\r\n        }\r\n        deltaX = rootElement.scrollWidth - startScrollWidth;\r\n        deltaY = rootElement.scrollHeight - startScrollHeight;\r\n        if (deltaX + deltaY !== 0) {\r\n          dom.setStyles(resizeHelper, {\r\n            left: resizeHelperX - deltaX,\r\n            top: resizeHelperY - deltaY\r\n          });\r\n        }\r\n        if (!resizeStarted) {\r\n          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\r\n          resizeStarted = true;\r\n        }\r\n      };\r\n      var endGhostResize = function () {\r\n        var wasResizeStarted = resizeStarted;\r\n        resizeStarted = false;\r\n        if (wasResizeStarted) {\r\n          setSizeProp(selectedElm, 'width', width);\r\n          setSizeProp(selectedElm, 'height', height);\r\n        }\r\n        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\r\n        dom.unbind(editableDoc, 'mouseup', endGhostResize);\r\n        if (rootDocument !== editableDoc) {\r\n          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\r\n          dom.unbind(rootDocument, 'mouseup', endGhostResize);\r\n        }\r\n        dom.remove(selectedElmGhost);\r\n        dom.remove(resizeHelper);\r\n        dom.remove(resizeBackdrop);\r\n        showResizeRect(selectedElm);\r\n        if (wasResizeStarted) {\r\n          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\r\n          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\r\n        }\r\n        editor.nodeChanged();\r\n      };\r\n      var showResizeRect = function (targetElm) {\r\n        unbindResizeHandleEvents();\r\n        var position = dom.getPos(targetElm, rootElement);\r\n        var selectedElmX = position.x;\r\n        var selectedElmY = position.y;\r\n        var rect = targetElm.getBoundingClientRect();\r\n        var targetWidth = rect.width || rect.right - rect.left;\r\n        var targetHeight = rect.height || rect.bottom - rect.top;\r\n        if (selectedElm !== targetElm) {\r\n          hideResizeRect();\r\n          selectedElm = targetElm;\r\n          width = height = 0;\r\n        }\r\n        var e = editor.fire('ObjectSelected', { target: targetElm });\r\n        var selectedValue = dom.getAttrib(selectedElm, elementSelectionAttr, '1');\r\n        if (isResizable(targetElm) && !e.isDefaultPrevented()) {\r\n          each(resizeHandles, function (handle, name) {\r\n            var handleElm;\r\n            var startDrag = function (e) {\r\n              var target = getResizeTargets(selectedElm)[0];\r\n              startX = e.screenX;\r\n              startY = e.screenY;\r\n              startW = target.clientWidth;\r\n              startH = target.clientHeight;\r\n              ratio = startH / startW;\r\n              selectedHandle = handle;\r\n              selectedHandle.name = name;\r\n              selectedHandle.startPos = {\r\n                x: targetWidth * handle[0] + selectedElmX,\r\n                y: targetHeight * handle[1] + selectedElmY\r\n              };\r\n              startScrollWidth = rootElement.scrollWidth;\r\n              startScrollHeight = rootElement.scrollHeight;\r\n              resizeBackdrop = dom.add(rootElement, 'div', {\r\n                'class': 'mce-resize-backdrop',\r\n                'data-mce-bogus': 'all'\r\n              });\r\n              dom.setStyles(resizeBackdrop, {\r\n                position: 'fixed',\r\n                left: '0',\r\n                top: '0',\r\n                width: '100%',\r\n                height: '100%'\r\n              });\r\n              selectedElmGhost = createGhostElement(selectedElm);\r\n              dom.addClass(selectedElmGhost, 'mce-clonedresizable');\r\n              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\r\n              selectedElmGhost.contentEditable = 'false';\r\n              dom.setStyles(selectedElmGhost, {\r\n                left: selectedElmX,\r\n                top: selectedElmY,\r\n                margin: 0\r\n              });\r\n              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\r\n              selectedElmGhost.removeAttribute(elementSelectionAttr);\r\n              rootElement.appendChild(selectedElmGhost);\r\n              dom.bind(editableDoc, 'mousemove', resizeGhostElement);\r\n              dom.bind(editableDoc, 'mouseup', endGhostResize);\r\n              if (rootDocument !== editableDoc) {\r\n                dom.bind(rootDocument, 'mousemove', resizeGhostElement);\r\n                dom.bind(rootDocument, 'mouseup', endGhostResize);\r\n              }\r\n              resizeHelper = dom.add(rootElement, 'div', {\r\n                'class': 'mce-resize-helper',\r\n                'data-mce-bogus': 'all'\r\n              }, startW + ' &times; ' + startH);\r\n            };\r\n            handleElm = dom.get('mceResizeHandle' + name);\r\n            if (handleElm) {\r\n              dom.remove(handleElm);\r\n            }\r\n            handleElm = dom.add(rootElement, 'div', {\r\n              'id': 'mceResizeHandle' + name,\r\n              'data-mce-bogus': 'all',\r\n              'class': 'mce-resizehandle',\r\n              'unselectable': true,\r\n              'style': 'cursor:' + name + '-resize; margin:0; padding:0'\r\n            });\r\n            if (Env.ie === 11) {\r\n              handleElm.contentEditable = false;\r\n            }\r\n            dom.bind(handleElm, 'mousedown', function (e) {\r\n              e.stopImmediatePropagation();\r\n              e.preventDefault();\r\n              startDrag(e);\r\n            });\r\n            handle.elm = handleElm;\r\n            dom.setStyles(handleElm, {\r\n              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\r\n              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\r\n            });\r\n          });\r\n        } else {\r\n          hideResizeRect();\r\n        }\r\n        if (!dom.getAttrib(selectedElm, elementSelectionAttr)) {\r\n          selectedElm.setAttribute(elementSelectionAttr, selectedValue);\r\n        }\r\n      };\r\n      var hideResizeRect = function () {\r\n        unbindResizeHandleEvents();\r\n        if (selectedElm) {\r\n          selectedElm.removeAttribute(elementSelectionAttr);\r\n        }\r\n        each$j(resizeHandles, function (value, name) {\r\n          var handleElm = dom.get('mceResizeHandle' + name);\r\n          if (handleElm) {\r\n            dom.unbind(handleElm);\r\n            dom.remove(handleElm);\r\n          }\r\n        });\r\n      };\r\n      var updateResizeRect = function (e) {\r\n        var startElm, controlElm;\r\n        var isChildOrEqual = function (node, parent) {\r\n          if (node) {\r\n            do {\r\n              if (node === parent) {\r\n                return true;\r\n              }\r\n            } while (node = node.parentNode);\r\n          }\r\n        };\r\n        if (resizeStarted || editor.removed) {\r\n          return;\r\n        }\r\n        each(dom.select('img[data-mce-selected],hr[data-mce-selected]'), function (img) {\r\n          img.removeAttribute(elementSelectionAttr);\r\n        });\r\n        controlElm = e.type === 'mousedown' ? e.target : selection.getNode();\r\n        controlElm = dom.$(controlElm).closest('table,img,figure.image,hr,video,span.mce-preview-object')[0];\r\n        if (isChildOrEqual(controlElm, rootElement)) {\r\n          disableGeckoResize();\r\n          startElm = selection.getStart(true);\r\n          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\r\n            showResizeRect(controlElm);\r\n            return;\r\n          }\r\n        }\r\n        hideResizeRect();\r\n      };\r\n      var isWithinContentEditableFalse = function (elm) {\r\n        return isContentEditableFalse$5(getContentEditableRoot$1(editor.getBody(), elm));\r\n      };\r\n      var unbindResizeHandleEvents = function () {\r\n        each$j(resizeHandles, function (handle) {\r\n          if (handle.elm) {\r\n            dom.unbind(handle.elm);\r\n            delete handle.elm;\r\n          }\r\n        });\r\n      };\r\n      var disableGeckoResize = function () {\r\n        try {\r\n          editor.getDoc().execCommand('enableObjectResizing', false, 'false');\r\n        } catch (ex) {\r\n        }\r\n      };\r\n      editor.on('init', function () {\r\n        disableGeckoResize();\r\n        if (Env.browser.isIE() || Env.browser.isEdge()) {\r\n          editor.on('mousedown click', function (e) {\r\n            var target = e.target, nodeName = target.nodeName;\r\n            if (!resizeStarted && /^(TABLE|IMG|HR)$/.test(nodeName) && !isWithinContentEditableFalse(target)) {\r\n              if (e.button !== 2) {\r\n                editor.selection.select(target, nodeName === 'TABLE');\r\n              }\r\n              if (e.type === 'mousedown') {\r\n                editor.nodeChanged();\r\n              }\r\n            }\r\n          });\r\n          var handleMSControlSelect_1 = function (e) {\r\n            var delayedSelect = function (node) {\r\n              Delay.setEditorTimeout(editor, function () {\r\n                return editor.selection.select(node);\r\n              });\r\n            };\r\n            if (isWithinContentEditableFalse(e.target) || isMedia$2(e.target)) {\r\n              e.preventDefault();\r\n              delayedSelect(e.target);\r\n              return;\r\n            }\r\n            if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {\r\n              e.preventDefault();\r\n              if (e.target.tagName === 'IMG') {\r\n                delayedSelect(e.target);\r\n              }\r\n            }\r\n          };\r\n          dom.bind(rootElement, 'mscontrolselect', handleMSControlSelect_1);\r\n          editor.on('remove', function () {\r\n            return dom.unbind(rootElement, 'mscontrolselect', handleMSControlSelect_1);\r\n          });\r\n        }\r\n        var throttledUpdateResizeRect = Delay.throttle(function (e) {\r\n          if (!editor.composing) {\r\n            updateResizeRect(e);\r\n          }\r\n        });\r\n        editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', throttledUpdateResizeRect);\r\n        editor.on('keyup compositionend', function (e) {\r\n          if (selectedElm && selectedElm.nodeName === 'TABLE') {\r\n            throttledUpdateResizeRect(e);\r\n          }\r\n        });\r\n        editor.on('hide blur', hideResizeRect);\r\n        editor.on('contextmenu longpress', contextMenuSelectImage, true);\r\n      });\r\n      editor.on('remove', unbindResizeHandleEvents);\r\n      var destroy = function () {\r\n        selectedElm = selectedElmGhost = resizeBackdrop = null;\r\n      };\r\n      return {\r\n        isResizable: isResizable,\r\n        showResizeRect: showResizeRect,\r\n        hideResizeRect: hideResizeRect,\r\n        updateResizeRect: updateResizeRect,\r\n        destroy: destroy\r\n      };\r\n    };\r\n\r\n    var hasCeProperty = function (node) {\r\n      return isContentEditableTrue$4(node) || isContentEditableFalse$b(node);\r\n    };\r\n    var findParent$1 = function (node, rootNode, predicate) {\r\n      while (node && node !== rootNode) {\r\n        if (predicate(node)) {\r\n          return node;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n    var findClosestIeRange = function (clientX, clientY, doc) {\r\n      var rects;\r\n      var element = doc.elementFromPoint(clientX, clientY);\r\n      var rng = doc.body.createTextRange();\r\n      if (!element || element.tagName === 'HTML') {\r\n        element = doc.body;\r\n      }\r\n      rng.moveToElementText(element);\r\n      rects = Tools.toArray(rng.getClientRects());\r\n      rects = rects.sort(function (a, b) {\r\n        a = Math.abs(Math.max(a.top - clientY, a.bottom - clientY));\r\n        b = Math.abs(Math.max(b.top - clientY, b.bottom - clientY));\r\n        return a - b;\r\n      });\r\n      if (rects.length > 0) {\r\n        clientY = (rects[0].bottom + rects[0].top) / 2;\r\n        try {\r\n          rng.moveToPoint(clientX, clientY);\r\n          rng.collapse(true);\r\n          return rng;\r\n        } catch (ex) {\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    var moveOutOfContentEditableFalse = function (rng, rootNode) {\r\n      var parentElement = rng && rng.parentElement ? rng.parentElement() : null;\r\n      return isContentEditableFalse$b(findParent$1(parentElement, rootNode, hasCeProperty)) ? null : rng;\r\n    };\r\n    var fromPoint = function (clientX, clientY, doc) {\r\n      var rng, point;\r\n      var pointDoc = doc;\r\n      if (pointDoc.caretPositionFromPoint) {\r\n        point = pointDoc.caretPositionFromPoint(clientX, clientY);\r\n        if (point) {\r\n          rng = doc.createRange();\r\n          rng.setStart(point.offsetNode, point.offset);\r\n          rng.collapse(true);\r\n        }\r\n      } else if (pointDoc.caretRangeFromPoint) {\r\n        rng = pointDoc.caretRangeFromPoint(clientX, clientY);\r\n      } else if (pointDoc.body.createTextRange) {\r\n        rng = pointDoc.body.createTextRange();\r\n        try {\r\n          rng.moveToPoint(clientX, clientY);\r\n          rng.collapse(true);\r\n        } catch (ex) {\r\n          rng = findClosestIeRange(clientX, clientY, doc);\r\n        }\r\n        return moveOutOfContentEditableFalse(rng, doc.body);\r\n      }\r\n      return rng;\r\n    };\r\n\r\n    var isEq$4 = function (rng1, rng2) {\r\n      return rng1 && rng2 && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);\r\n    };\r\n\r\n    var findParent = function (node, rootNode, predicate) {\r\n      while (node && node !== rootNode) {\r\n        if (predicate(node)) {\r\n          return node;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n    var hasParent$1 = function (node, rootNode, predicate) {\r\n      return findParent(node, rootNode, predicate) !== null;\r\n    };\r\n    var hasParentWithName = function (node, rootNode, name) {\r\n      return hasParent$1(node, rootNode, function (node) {\r\n        return node.nodeName === name;\r\n      });\r\n    };\r\n    var isTable = function (node) {\r\n      return node && node.nodeName === 'TABLE';\r\n    };\r\n    var isTableCell$2 = function (node) {\r\n      return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);\r\n    };\r\n    var isCeFalseCaretContainer = function (node, rootNode) {\r\n      return isCaretContainer$2(node) && hasParent$1(node, rootNode, isCaretNode) === false;\r\n    };\r\n    var hasBrBeforeAfter = function (dom, node, left) {\r\n      var walker = new DomTreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || dom.getRoot());\r\n      while (node = walker[left ? 'prev' : 'next']()) {\r\n        if (isBr$5(node)) {\r\n          return true;\r\n        }\r\n      }\r\n    };\r\n    var isPrevNode = function (node, name) {\r\n      return node.previousSibling && node.previousSibling.nodeName === name;\r\n    };\r\n    var hasContentEditableFalseParent = function (body, node) {\r\n      while (node && node !== body) {\r\n        if (isContentEditableFalse$b(node)) {\r\n          return true;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      return false;\r\n    };\r\n    var findTextNodeRelative = function (dom, isAfterNode, collapsed, left, startNode) {\r\n      var lastInlineElement;\r\n      var body = dom.getRoot();\r\n      var node;\r\n      var nonEmptyElementsMap = dom.schema.getNonEmptyElements();\r\n      var parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;\r\n      if (left && isBr$5(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\r\n        return Optional.some(CaretPosition(startNode.parentNode, dom.nodeIndex(startNode)));\r\n      }\r\n      var walker = new DomTreeWalker(startNode, parentBlockContainer);\r\n      while (node = walker[left ? 'prev' : 'next']()) {\r\n        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\r\n          return Optional.none();\r\n        }\r\n        if (isText$7(node) && node.nodeValue.length > 0) {\r\n          if (hasParentWithName(node, body, 'A') === false) {\r\n            return Optional.some(CaretPosition(node, left ? node.nodeValue.length : 0));\r\n          }\r\n          return Optional.none();\r\n        }\r\n        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\r\n          return Optional.none();\r\n        }\r\n        lastInlineElement = node;\r\n      }\r\n      if (collapsed && lastInlineElement) {\r\n        return Optional.some(CaretPosition(lastInlineElement, 0));\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var normalizeEndPoint = function (dom, collapsed, start, rng) {\r\n      var container, offset;\r\n      var body = dom.getRoot();\r\n      var node;\r\n      var directionLeft, normalized = false;\r\n      container = rng[(start ? 'start' : 'end') + 'Container'];\r\n      offset = rng[(start ? 'start' : 'end') + 'Offset'];\r\n      var isAfterNode = isElement$5(container) && offset === container.childNodes.length;\r\n      var nonEmptyElementsMap = dom.schema.getNonEmptyElements();\r\n      directionLeft = start;\r\n      if (isCaretContainer$2(container)) {\r\n        return Optional.none();\r\n      }\r\n      if (isElement$5(container) && offset > container.childNodes.length - 1) {\r\n        directionLeft = false;\r\n      }\r\n      if (isDocument$1(container)) {\r\n        container = body;\r\n        offset = 0;\r\n      }\r\n      if (container === body) {\r\n        if (directionLeft) {\r\n          node = container.childNodes[offset > 0 ? offset - 1 : 0];\r\n          if (node) {\r\n            if (isCaretContainer$2(node)) {\r\n              return Optional.none();\r\n            }\r\n            if (nonEmptyElementsMap[node.nodeName] || isTable(node)) {\r\n              return Optional.none();\r\n            }\r\n          }\r\n        }\r\n        if (container.hasChildNodes()) {\r\n          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\r\n          container = container.childNodes[offset];\r\n          offset = isText$7(container) && isAfterNode ? container.data.length : 0;\r\n          if (!collapsed && container === body.lastChild && isTable(container)) {\r\n            return Optional.none();\r\n          }\r\n          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {\r\n            return Optional.none();\r\n          }\r\n          if (container.hasChildNodes() && isTable(container) === false) {\r\n            node = container;\r\n            var walker = new DomTreeWalker(container, body);\r\n            do {\r\n              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {\r\n                normalized = false;\r\n                break;\r\n              }\r\n              if (isText$7(node) && node.nodeValue.length > 0) {\r\n                offset = directionLeft ? 0 : node.nodeValue.length;\r\n                container = node;\r\n                normalized = true;\r\n                break;\r\n              }\r\n              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCell$2(node)) {\r\n                offset = dom.nodeIndex(node);\r\n                container = node.parentNode;\r\n                if (!directionLeft) {\r\n                  offset++;\r\n                }\r\n                normalized = true;\r\n                break;\r\n              }\r\n            } while (node = directionLeft ? walker.next() : walker.prev());\r\n          }\r\n        }\r\n      }\r\n      if (collapsed) {\r\n        if (isText$7(container) && offset === 0) {\r\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(function (pos) {\r\n            container = pos.container();\r\n            offset = pos.offset();\r\n            normalized = true;\r\n          });\r\n        }\r\n        if (isElement$5(container)) {\r\n          node = container.childNodes[offset];\r\n          if (!node) {\r\n            node = container.childNodes[offset - 1];\r\n          }\r\n          if (node && isBr$5(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\r\n            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(function (pos) {\r\n              container = pos.container();\r\n              offset = pos.offset();\r\n              normalized = true;\r\n            });\r\n          }\r\n        }\r\n      }\r\n      if (directionLeft && !collapsed && isText$7(container) && offset === container.nodeValue.length) {\r\n        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(function (pos) {\r\n          container = pos.container();\r\n          offset = pos.offset();\r\n          normalized = true;\r\n        });\r\n      }\r\n      return normalized ? Optional.some(CaretPosition(container, offset)) : Optional.none();\r\n    };\r\n    var normalize$2 = function (dom, rng) {\r\n      var collapsed = rng.collapsed, normRng = rng.cloneRange();\r\n      var startPos = CaretPosition.fromRangeStart(rng);\r\n      normalizeEndPoint(dom, collapsed, true, normRng).each(function (pos) {\r\n        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\r\n          normRng.setStart(pos.container(), pos.offset());\r\n        }\r\n      });\r\n      if (!collapsed) {\r\n        normalizeEndPoint(dom, collapsed, false, normRng).each(function (pos) {\r\n          normRng.setEnd(pos.container(), pos.offset());\r\n        });\r\n      }\r\n      if (collapsed) {\r\n        normRng.collapse(true);\r\n      }\r\n      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\r\n    };\r\n\r\n    var splitText = function (node, offset) {\r\n      return node.splitText(offset);\r\n    };\r\n    var split = function (rng) {\r\n      var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;\r\n      if (startContainer === endContainer && isText$7(startContainer)) {\r\n        if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {\r\n          endContainer = splitText(startContainer, startOffset);\r\n          startContainer = endContainer.previousSibling;\r\n          if (endOffset > startOffset) {\r\n            endOffset = endOffset - startOffset;\r\n            startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;\r\n            endOffset = endContainer.nodeValue.length;\r\n            startOffset = 0;\r\n          } else {\r\n            endOffset = 0;\r\n          }\r\n        }\r\n      } else {\r\n        if (isText$7(startContainer) && startOffset > 0 && startOffset < startContainer.nodeValue.length) {\r\n          startContainer = splitText(startContainer, startOffset);\r\n          startOffset = 0;\r\n        }\r\n        if (isText$7(endContainer) && endOffset > 0 && endOffset < endContainer.nodeValue.length) {\r\n          endContainer = splitText(endContainer, endOffset).previousSibling;\r\n          endOffset = endContainer.nodeValue.length;\r\n        }\r\n      }\r\n      return {\r\n        startContainer: startContainer,\r\n        startOffset: startOffset,\r\n        endContainer: endContainer,\r\n        endOffset: endOffset\r\n      };\r\n    };\r\n\r\n    var RangeUtils = function (dom) {\r\n      var walk = function (rng, callback) {\r\n        return walk$2(dom, rng, callback);\r\n      };\r\n      var split$1 = split;\r\n      var normalize = function (rng) {\r\n        return normalize$2(dom, rng).fold(never, function (normalizedRng) {\r\n          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\r\n          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\r\n          return true;\r\n        });\r\n      };\r\n      return {\r\n        walk: walk,\r\n        split: split$1,\r\n        normalize: normalize\r\n      };\r\n    };\r\n    RangeUtils.compareRanges = isEq$4;\r\n    RangeUtils.getCaretRangeFromPoint = fromPoint;\r\n    RangeUtils.getSelectedNode = getSelectedNode;\r\n    RangeUtils.getNode = getNode$1;\r\n\r\n    var Dimension = function (name, getOffset) {\r\n      var set = function (element, h) {\r\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\r\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\r\n        }\r\n        var dom = element.dom;\r\n        if (isSupported(dom)) {\r\n          dom.style[name] = h + 'px';\r\n        }\r\n      };\r\n      var get = function (element) {\r\n        var r = getOffset(element);\r\n        if (r <= 0 || r === null) {\r\n          var css = get$5(element, name);\r\n          return parseFloat(css) || 0;\r\n        }\r\n        return r;\r\n      };\r\n      var getOuter = get;\r\n      var aggregate = function (element, properties) {\r\n        return foldl(properties, function (acc, property) {\r\n          var val = get$5(element, property);\r\n          var value = val === undefined ? 0 : parseInt(val, 10);\r\n          return isNaN(value) ? acc : acc + value;\r\n        }, 0);\r\n      };\r\n      var max = function (element, value, properties) {\r\n        var cumulativeInclusions = aggregate(element, properties);\r\n        var absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\r\n        return absoluteMax;\r\n      };\r\n      return {\r\n        set: set,\r\n        get: get,\r\n        getOuter: getOuter,\r\n        aggregate: aggregate,\r\n        max: max\r\n      };\r\n    };\r\n\r\n    var api = Dimension('height', function (element) {\r\n      var dom = element.dom;\r\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\r\n    });\r\n    var get$1 = function (element) {\r\n      return api.get(element);\r\n    };\r\n\r\n    var walkUp = function (navigation, doc) {\r\n      var frame = navigation.view(doc);\r\n      return frame.fold(constant([]), function (f) {\r\n        var parent = navigation.owner(f);\r\n        var rest = walkUp(navigation, parent);\r\n        return [f].concat(rest);\r\n      });\r\n    };\r\n    var pathTo = function (element, navigation) {\r\n      var d = navigation.owner(element);\r\n      return walkUp(navigation, d);\r\n    };\r\n\r\n    var view = function (doc) {\r\n      var _a;\r\n      var element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\r\n      return element.map(SugarElement.fromDom);\r\n    };\r\n    var owner = function (element) {\r\n      return documentOrOwner(element);\r\n    };\r\n\r\n    var Navigation = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        view: view,\r\n        owner: owner\r\n    });\r\n\r\n    var find$1 = function (element) {\r\n      var doc = SugarElement.fromDom(document);\r\n      var scroll = get$8(doc);\r\n      var frames = pathTo(element, Navigation);\r\n      var offset = viewport(element);\r\n      var r = foldr(frames, function (b, a) {\r\n        var loc = viewport(a);\r\n        return {\r\n          left: b.left + loc.left,\r\n          top: b.top + loc.top\r\n        };\r\n      }, {\r\n        left: 0,\r\n        top: 0\r\n      });\r\n      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\r\n    };\r\n\r\n    var excludeFromDescend = function (element) {\r\n      return name(element) === 'textarea';\r\n    };\r\n    var fireScrollIntoViewEvent = function (editor, data) {\r\n      var scrollEvent = editor.fire('ScrollIntoView', data);\r\n      return scrollEvent.isDefaultPrevented();\r\n    };\r\n    var fireAfterScrollIntoViewEvent = function (editor, data) {\r\n      editor.fire('AfterScrollIntoView', data);\r\n    };\r\n    var descend = function (element, offset) {\r\n      var children$1 = children(element);\r\n      if (children$1.length === 0 || excludeFromDescend(element)) {\r\n        return {\r\n          element: element,\r\n          offset: offset\r\n        };\r\n      } else if (offset < children$1.length && !excludeFromDescend(children$1[offset])) {\r\n        return {\r\n          element: children$1[offset],\r\n          offset: 0\r\n        };\r\n      } else {\r\n        var last = children$1[children$1.length - 1];\r\n        if (excludeFromDescend(last)) {\r\n          return {\r\n            element: element,\r\n            offset: offset\r\n          };\r\n        } else {\r\n          if (name(last) === 'img') {\r\n            return {\r\n              element: last,\r\n              offset: 1\r\n            };\r\n          } else if (isText$8(last)) {\r\n            return {\r\n              element: last,\r\n              offset: get$2(last).length\r\n            };\r\n          } else {\r\n            return {\r\n              element: last,\r\n              offset: children(last).length\r\n            };\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var markerInfo = function (element, cleanupFun) {\r\n      var pos = absolute(element);\r\n      var height = get$1(element);\r\n      return {\r\n        element: element,\r\n        bottom: pos.top + height,\r\n        height: height,\r\n        pos: pos,\r\n        cleanup: cleanupFun\r\n      };\r\n    };\r\n    var createMarker = function (element, offset) {\r\n      var startPoint = descend(element, offset);\r\n      var span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\r\n      before$4(startPoint.element, span);\r\n      return markerInfo(span, function () {\r\n        return remove$7(span);\r\n      });\r\n    };\r\n    var elementMarker = function (element) {\r\n      return markerInfo(SugarElement.fromDom(element), noop);\r\n    };\r\n    var withMarker = function (editor, f, rng, alignToTop) {\r\n      preserveWith(editor, function (_s, _e) {\r\n        return applyWithMarker(editor, f, rng, alignToTop);\r\n      }, rng);\r\n    };\r\n    var withScrollEvents = function (editor, doc, f, marker, alignToTop) {\r\n      var data = {\r\n        elm: marker.element.dom,\r\n        alignToTop: alignToTop\r\n      };\r\n      if (fireScrollIntoViewEvent(editor, data)) {\r\n        return;\r\n      }\r\n      var scrollTop = get$8(doc).top;\r\n      f(doc, scrollTop, marker, alignToTop);\r\n      fireAfterScrollIntoViewEvent(editor, data);\r\n    };\r\n    var applyWithMarker = function (editor, f, rng, alignToTop) {\r\n      var body = SugarElement.fromDom(editor.getBody());\r\n      var doc = SugarElement.fromDom(editor.getDoc());\r\n      reflow(body);\r\n      var marker = createMarker(SugarElement.fromDom(rng.startContainer), rng.startOffset);\r\n      withScrollEvents(editor, doc, f, marker, alignToTop);\r\n      marker.cleanup();\r\n    };\r\n    var withElement = function (editor, element, f, alignToTop) {\r\n      var doc = SugarElement.fromDom(editor.getDoc());\r\n      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\r\n    };\r\n    var preserveWith = function (editor, f, rng) {\r\n      var startElement = rng.startContainer;\r\n      var startOffset = rng.startOffset;\r\n      var endElement = rng.endContainer;\r\n      var endOffset = rng.endOffset;\r\n      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\r\n      var newRng = editor.dom.createRng();\r\n      newRng.setStart(startElement, startOffset);\r\n      newRng.setEnd(endElement, endOffset);\r\n      editor.selection.setRng(rng);\r\n    };\r\n    var scrollToMarker = function (marker, viewHeight, alignToTop, doc) {\r\n      var pos = marker.pos;\r\n      if (alignToTop) {\r\n        to(pos.left, pos.top, doc);\r\n      } else {\r\n        var y = pos.top - viewHeight + marker.height;\r\n        to(pos.left, y, doc);\r\n      }\r\n    };\r\n    var intoWindowIfNeeded = function (doc, scrollTop, viewHeight, marker, alignToTop) {\r\n      var viewportBottom = viewHeight + scrollTop;\r\n      var markerTop = marker.pos.top;\r\n      var markerBottom = marker.bottom;\r\n      var largerThanViewport = markerBottom - markerTop >= viewHeight;\r\n      if (markerTop < scrollTop) {\r\n        scrollToMarker(marker, viewHeight, alignToTop !== false, doc);\r\n      } else if (markerTop > viewportBottom) {\r\n        var align = largerThanViewport ? alignToTop !== false : alignToTop === true;\r\n        scrollToMarker(marker, viewHeight, align, doc);\r\n      } else if (markerBottom > viewportBottom && !largerThanViewport) {\r\n        scrollToMarker(marker, viewHeight, alignToTop === true, doc);\r\n      }\r\n    };\r\n    var intoWindow = function (doc, scrollTop, marker, alignToTop) {\r\n      var viewHeight = doc.dom.defaultView.innerHeight;\r\n      intoWindowIfNeeded(doc, scrollTop, viewHeight, marker, alignToTop);\r\n    };\r\n    var intoFrame = function (doc, scrollTop, marker, alignToTop) {\r\n      var frameViewHeight = doc.dom.defaultView.innerHeight;\r\n      intoWindowIfNeeded(doc, scrollTop, frameViewHeight, marker, alignToTop);\r\n      var op = find$1(marker.element);\r\n      var viewportBounds = getBounds(window);\r\n      if (op.top < viewportBounds.y) {\r\n        intoView(marker.element, alignToTop !== false);\r\n      } else if (op.top > viewportBounds.bottom) {\r\n        intoView(marker.element, alignToTop === true);\r\n      }\r\n    };\r\n    var rangeIntoWindow = function (editor, rng, alignToTop) {\r\n      return withMarker(editor, intoWindow, rng, alignToTop);\r\n    };\r\n    var elementIntoWindow = function (editor, element, alignToTop) {\r\n      return withElement(editor, element, intoWindow, alignToTop);\r\n    };\r\n    var rangeIntoFrame = function (editor, rng, alignToTop) {\r\n      return withMarker(editor, intoFrame, rng, alignToTop);\r\n    };\r\n    var elementIntoFrame = function (editor, element, alignToTop) {\r\n      return withElement(editor, element, intoFrame, alignToTop);\r\n    };\r\n    var scrollElementIntoView = function (editor, element, alignToTop) {\r\n      var scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\r\n      scroller(editor, element, alignToTop);\r\n    };\r\n    var scrollRangeIntoView = function (editor, rng, alignToTop) {\r\n      var scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\r\n      scroller(editor, rng, alignToTop);\r\n    };\r\n\r\n    var getDocument = function () {\r\n      return SugarElement.fromDom(document);\r\n    };\r\n\r\n    var focus$1 = function (element) {\r\n      return element.dom.focus();\r\n    };\r\n    var hasFocus$1 = function (element) {\r\n      var root = getRootNode(element).dom;\r\n      return element.dom === root.activeElement;\r\n    };\r\n    var active = function (root) {\r\n      if (root === void 0) {\r\n        root = getDocument();\r\n      }\r\n      return Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\r\n    };\r\n    var search = function (element) {\r\n      return active(getRootNode(element)).filter(function (e) {\r\n        return element.dom.contains(e.dom);\r\n      });\r\n    };\r\n\r\n    var create$5 = function (start, soffset, finish, foffset) {\r\n      return {\r\n        start: start,\r\n        soffset: soffset,\r\n        finish: finish,\r\n        foffset: foffset\r\n      };\r\n    };\r\n    var SimRange = { create: create$5 };\r\n\r\n    var adt$1 = Adt.generate([\r\n      { before: ['element'] },\r\n      {\r\n        on: [\r\n          'element',\r\n          'offset'\r\n        ]\r\n      },\r\n      { after: ['element'] }\r\n    ]);\r\n    var cata = function (subject, onBefore, onOn, onAfter) {\r\n      return subject.fold(onBefore, onOn, onAfter);\r\n    };\r\n    var getStart$2 = function (situ) {\r\n      return situ.fold(identity, identity, identity);\r\n    };\r\n    var before$1 = adt$1.before;\r\n    var on = adt$1.on;\r\n    var after$1 = adt$1.after;\r\n    var Situ = {\r\n      before: before$1,\r\n      on: on,\r\n      after: after$1,\r\n      cata: cata,\r\n      getStart: getStart$2\r\n    };\r\n\r\n    var adt = Adt.generate([\r\n      { domRange: ['rng'] },\r\n      {\r\n        relative: [\r\n          'startSitu',\r\n          'finishSitu'\r\n        ]\r\n      },\r\n      {\r\n        exact: [\r\n          'start',\r\n          'soffset',\r\n          'finish',\r\n          'foffset'\r\n        ]\r\n      }\r\n    ]);\r\n    var exactFromRange = function (simRange) {\r\n      return adt.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\r\n    };\r\n    var getStart$1 = function (selection) {\r\n      return selection.match({\r\n        domRange: function (rng) {\r\n          return SugarElement.fromDom(rng.startContainer);\r\n        },\r\n        relative: function (startSitu, _finishSitu) {\r\n          return Situ.getStart(startSitu);\r\n        },\r\n        exact: function (start, _soffset, _finish, _foffset) {\r\n          return start;\r\n        }\r\n      });\r\n    };\r\n    var domRange = adt.domRange;\r\n    var relative = adt.relative;\r\n    var exact = adt.exact;\r\n    var getWin = function (selection) {\r\n      var start = getStart$1(selection);\r\n      return defaultView(start);\r\n    };\r\n    var range = SimRange.create;\r\n    var SimSelection = {\r\n      domRange: domRange,\r\n      relative: relative,\r\n      exact: exact,\r\n      exactFromRange: exactFromRange,\r\n      getWin: getWin,\r\n      range: range\r\n    };\r\n\r\n    var browser$1 = detect().browser;\r\n    var clamp$1 = function (offset, element) {\r\n      var max = isText$8(element) ? get$2(element).length : children(element).length + 1;\r\n      if (offset > max) {\r\n        return max;\r\n      } else if (offset < 0) {\r\n        return 0;\r\n      }\r\n      return offset;\r\n    };\r\n    var normalizeRng = function (rng) {\r\n      return SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\r\n    };\r\n    var isOrContains = function (root, elm) {\r\n      return !isRestrictedNode(elm.dom) && (contains$1(root, elm) || eq(root, elm));\r\n    };\r\n    var isRngInRoot = function (root) {\r\n      return function (rng) {\r\n        return isOrContains(root, rng.start) && isOrContains(root, rng.finish);\r\n      };\r\n    };\r\n    var shouldStore = function (editor) {\r\n      return editor.inline === true || browser$1.isIE();\r\n    };\r\n    var nativeRangeToSelectionRange = function (r) {\r\n      return SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\r\n    };\r\n    var readRange = function (win) {\r\n      var selection = win.getSelection();\r\n      var rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\r\n      return rng.map(nativeRangeToSelectionRange);\r\n    };\r\n    var getBookmark = function (root) {\r\n      var win = defaultView(root);\r\n      return readRange(win.dom).filter(isRngInRoot(root));\r\n    };\r\n    var validate = function (root, bookmark) {\r\n      return Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\r\n    };\r\n    var bookmarkToNativeRng = function (bookmark) {\r\n      var rng = document.createRange();\r\n      try {\r\n        rng.setStart(bookmark.start.dom, bookmark.soffset);\r\n        rng.setEnd(bookmark.finish.dom, bookmark.foffset);\r\n        return Optional.some(rng);\r\n      } catch (_) {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var store = function (editor) {\r\n      var newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();\r\n      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\r\n    };\r\n    var storeNative = function (editor, rng) {\r\n      var root = SugarElement.fromDom(editor.getBody());\r\n      var range = shouldStore(editor) ? Optional.from(rng) : Optional.none();\r\n      var newBookmark = range.map(nativeRangeToSelectionRange).filter(isRngInRoot(root));\r\n      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\r\n    };\r\n    var getRng = function (editor) {\r\n      var bookmark = editor.bookmark ? editor.bookmark : Optional.none();\r\n      return bookmark.bind(function (x) {\r\n        return validate(SugarElement.fromDom(editor.getBody()), x);\r\n      }).bind(bookmarkToNativeRng);\r\n    };\r\n    var restore = function (editor) {\r\n      getRng(editor).each(function (rng) {\r\n        return editor.selection.setRng(rng);\r\n      });\r\n    };\r\n\r\n    var isEditorUIElement$1 = function (elm) {\r\n      var className = elm.className.toString();\r\n      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\r\n    };\r\n    var FocusManager = { isEditorUIElement: isEditorUIElement$1 };\r\n\r\n    var isManualNodeChange = function (e) {\r\n      return e.type === 'nodechange' && e.selectionChange;\r\n    };\r\n    var registerPageMouseUp = function (editor, throttledStore) {\r\n      var mouseUpPage = function () {\r\n        throttledStore.throttle();\r\n      };\r\n      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\r\n      editor.on('remove', function () {\r\n        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\r\n      });\r\n    };\r\n    var registerFocusOut = function (editor) {\r\n      editor.on('focusout', function () {\r\n        store(editor);\r\n      });\r\n    };\r\n    var registerMouseUp = function (editor, throttledStore) {\r\n      editor.on('mouseup touchend', function (_e) {\r\n        throttledStore.throttle();\r\n      });\r\n    };\r\n    var registerEditorEvents = function (editor, throttledStore) {\r\n      var browser = detect().browser;\r\n      if (browser.isIE()) {\r\n        registerFocusOut(editor);\r\n      } else {\r\n        registerMouseUp(editor, throttledStore);\r\n      }\r\n      editor.on('keyup NodeChange', function (e) {\r\n        if (!isManualNodeChange(e)) {\r\n          store(editor);\r\n        }\r\n      });\r\n    };\r\n    var register$3 = function (editor) {\r\n      var throttledStore = first(function () {\r\n        store(editor);\r\n      }, 0);\r\n      editor.on('init', function () {\r\n        if (editor.inline) {\r\n          registerPageMouseUp(editor, throttledStore);\r\n        }\r\n        registerEditorEvents(editor, throttledStore);\r\n      });\r\n      editor.on('remove', function () {\r\n        throttledStore.cancel();\r\n      });\r\n    };\r\n\r\n    var documentFocusInHandler;\r\n    var DOM$8 = DOMUtils.DOM;\r\n    var isEditorUIElement = function (elm) {\r\n      return FocusManager.isEditorUIElement(elm);\r\n    };\r\n    var isEditorContentAreaElement = function (elm) {\r\n      var classList = elm.classList;\r\n      if (classList !== undefined) {\r\n        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var isUIElement = function (editor, elm) {\r\n      var customSelector = getCustomUiSelector(editor);\r\n      var parent = DOM$8.getParent(elm, function (elm) {\r\n        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\r\n      });\r\n      return parent !== null;\r\n    };\r\n    var getActiveElement = function (editor) {\r\n      try {\r\n        var root = getRootNode(SugarElement.fromDom(editor.getElement()));\r\n        return active(root).fold(function () {\r\n          return document.body;\r\n        }, function (x) {\r\n          return x.dom;\r\n        });\r\n      } catch (ex) {\r\n        return document.body;\r\n      }\r\n    };\r\n    var registerEvents$1 = function (editorManager, e) {\r\n      var editor = e.editor;\r\n      register$3(editor);\r\n      editor.on('focusin', function () {\r\n        var focusedEditor = editorManager.focusedEditor;\r\n        if (focusedEditor !== editor) {\r\n          if (focusedEditor) {\r\n            focusedEditor.fire('blur', { focusedEditor: editor });\r\n          }\r\n          editorManager.setActive(editor);\r\n          editorManager.focusedEditor = editor;\r\n          editor.fire('focus', { blurredEditor: focusedEditor });\r\n          editor.focus(true);\r\n        }\r\n      });\r\n      editor.on('focusout', function () {\r\n        Delay.setEditorTimeout(editor, function () {\r\n          var focusedEditor = editorManager.focusedEditor;\r\n          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\r\n            editor.fire('blur', { focusedEditor: null });\r\n            editorManager.focusedEditor = null;\r\n          }\r\n        });\r\n      });\r\n      if (!documentFocusInHandler) {\r\n        documentFocusInHandler = function (e) {\r\n          var activeEditor = editorManager.activeEditor;\r\n          if (activeEditor) {\r\n            getOriginalEventTarget(e).each(function (target) {\r\n              if (target.ownerDocument === document) {\r\n                if (target !== document.body && !isUIElement(activeEditor, target) && editorManager.focusedEditor === activeEditor) {\r\n                  activeEditor.fire('blur', { focusedEditor: null });\r\n                  editorManager.focusedEditor = null;\r\n                }\r\n              }\r\n            });\r\n          }\r\n        };\r\n        DOM$8.bind(document, 'focusin', documentFocusInHandler);\r\n      }\r\n    };\r\n    var unregisterDocumentEvents = function (editorManager, e) {\r\n      if (editorManager.focusedEditor === e.editor) {\r\n        editorManager.focusedEditor = null;\r\n      }\r\n      if (!editorManager.activeEditor) {\r\n        DOM$8.unbind(document, 'focusin', documentFocusInHandler);\r\n        documentFocusInHandler = null;\r\n      }\r\n    };\r\n    var setup$l = function (editorManager) {\r\n      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\r\n      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\r\n    };\r\n\r\n    var getContentEditableHost = function (editor, node) {\r\n      return editor.dom.getParent(node, function (node) {\r\n        return editor.dom.getContentEditable(node) === 'true';\r\n      });\r\n    };\r\n    var getCollapsedNode = function (rng) {\r\n      return rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\r\n    };\r\n    var getFocusInElement = function (root, rng) {\r\n      return getCollapsedNode(rng).bind(function (node) {\r\n        if (isTableSection(node)) {\r\n          return Optional.some(node);\r\n        } else if (contains$1(root, node) === false) {\r\n          return Optional.some(root);\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      });\r\n    };\r\n    var normalizeSelection$1 = function (editor, rng) {\r\n      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(function (elm) {\r\n        return firstPositionIn(elm.dom);\r\n      }).fold(function () {\r\n        editor.selection.normalize();\r\n        return;\r\n      }, function (caretPos) {\r\n        return editor.selection.setRng(caretPos.toRange());\r\n      });\r\n    };\r\n    var focusBody = function (body) {\r\n      if (body.setActive) {\r\n        try {\r\n          body.setActive();\r\n        } catch (ex) {\r\n          body.focus();\r\n        }\r\n      } else {\r\n        body.focus();\r\n      }\r\n    };\r\n    var hasElementFocus = function (elm) {\r\n      return hasFocus$1(elm) || search(elm).isSome();\r\n    };\r\n    var hasIframeFocus = function (editor) {\r\n      return editor.iframeElement && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\r\n    };\r\n    var hasInlineFocus = function (editor) {\r\n      var rawBody = editor.getBody();\r\n      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\r\n    };\r\n    var hasUiFocus = function (editor) {\r\n      var dos = getRootNode(SugarElement.fromDom(editor.getElement()));\r\n      return active(dos).filter(function (elem) {\r\n        return !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom);\r\n      }).isSome();\r\n    };\r\n    var hasFocus = function (editor) {\r\n      return editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\r\n    };\r\n    var hasEditorOrUiFocus = function (editor) {\r\n      return hasFocus(editor) || hasUiFocus(editor);\r\n    };\r\n    var focusEditor = function (editor) {\r\n      var selection = editor.selection;\r\n      var body = editor.getBody();\r\n      var rng = selection.getRng();\r\n      editor.quirks.refreshContentEditable();\r\n      if (editor.bookmark !== undefined && hasFocus(editor) === false) {\r\n        getRng(editor).each(function (bookmarkRng) {\r\n          editor.selection.setRng(bookmarkRng);\r\n          rng = bookmarkRng;\r\n        });\r\n      }\r\n      var contentEditableHost = getContentEditableHost(editor, selection.getNode());\r\n      if (editor.$.contains(body, contentEditableHost)) {\r\n        focusBody(contentEditableHost);\r\n        normalizeSelection$1(editor, rng);\r\n        activateEditor(editor);\r\n        return;\r\n      }\r\n      if (!editor.inline) {\r\n        if (!Env.opera) {\r\n          focusBody(body);\r\n        }\r\n        editor.getWin().focus();\r\n      }\r\n      if (Env.gecko || editor.inline) {\r\n        focusBody(body);\r\n        normalizeSelection$1(editor, rng);\r\n      }\r\n      activateEditor(editor);\r\n    };\r\n    var activateEditor = function (editor) {\r\n      return editor.editorManager.setActive(editor);\r\n    };\r\n    var focus = function (editor, skipFocus) {\r\n      if (editor.removed) {\r\n        return;\r\n      }\r\n      if (skipFocus) {\r\n        activateEditor(editor);\r\n      } else {\r\n        focusEditor(editor);\r\n      }\r\n    };\r\n\r\n    var getEndpointElement = function (root, rng, start, real, resolve) {\r\n      var container = start ? rng.startContainer : rng.endContainer;\r\n      var offset = start ? rng.startOffset : rng.endOffset;\r\n      return Optional.from(container).map(SugarElement.fromDom).map(function (elm) {\r\n        return !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm;\r\n      }).bind(function (elm) {\r\n        return isElement$6(elm) ? Optional.some(elm) : parent(elm).filter(isElement$6);\r\n      }).map(function (elm) {\r\n        return elm.dom;\r\n      }).getOr(root);\r\n    };\r\n    var getStart = function (root, rng, real) {\r\n      return getEndpointElement(root, rng, true, real, function (elm, offset) {\r\n        return Math.min(childNodesCount(elm), offset);\r\n      });\r\n    };\r\n    var getEnd = function (root, rng, real) {\r\n      return getEndpointElement(root, rng, false, real, function (elm, offset) {\r\n        return offset > 0 ? offset - 1 : offset;\r\n      });\r\n    };\r\n    var skipEmptyTextNodes = function (node, forwards) {\r\n      var orig = node;\r\n      while (node && isText$7(node) && node.length === 0) {\r\n        node = forwards ? node.nextSibling : node.previousSibling;\r\n      }\r\n      return node || orig;\r\n    };\r\n    var getNode = function (root, rng) {\r\n      var elm, startContainer, endContainer;\r\n      if (!rng) {\r\n        return root;\r\n      }\r\n      startContainer = rng.startContainer;\r\n      endContainer = rng.endContainer;\r\n      var startOffset = rng.startOffset;\r\n      var endOffset = rng.endOffset;\r\n      elm = rng.commonAncestorContainer;\r\n      if (!rng.collapsed) {\r\n        if (startContainer === endContainer) {\r\n          if (endOffset - startOffset < 2) {\r\n            if (startContainer.hasChildNodes()) {\r\n              elm = startContainer.childNodes[startOffset];\r\n            }\r\n          }\r\n        }\r\n        if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {\r\n          if (startContainer.length === startOffset) {\r\n            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\r\n          } else {\r\n            startContainer = startContainer.parentNode;\r\n          }\r\n          if (endOffset === 0) {\r\n            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\r\n          } else {\r\n            endContainer = endContainer.parentNode;\r\n          }\r\n          if (startContainer && startContainer === endContainer) {\r\n            return startContainer;\r\n          }\r\n        }\r\n      }\r\n      if (elm && elm.nodeType === 3) {\r\n        return elm.parentNode;\r\n      }\r\n      return elm;\r\n    };\r\n    var getSelectedBlocks = function (dom, rng, startElm, endElm) {\r\n      var node;\r\n      var selectedBlocks = [];\r\n      var root = dom.getRoot();\r\n      startElm = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\r\n      endElm = dom.getParent(endElm || getEnd(root, rng, rng.collapsed), dom.isBlock);\r\n      if (startElm && startElm !== root) {\r\n        selectedBlocks.push(startElm);\r\n      }\r\n      if (startElm && endElm && startElm !== endElm) {\r\n        node = startElm;\r\n        var walker = new DomTreeWalker(startElm, root);\r\n        while ((node = walker.next()) && node !== endElm) {\r\n          if (dom.isBlock(node)) {\r\n            selectedBlocks.push(node);\r\n          }\r\n        }\r\n      }\r\n      if (endElm && startElm !== endElm && endElm !== root) {\r\n        selectedBlocks.push(endElm);\r\n      }\r\n      return selectedBlocks;\r\n    };\r\n    var select = function (dom, node, content) {\r\n      return Optional.from(node).map(function (node) {\r\n        var idx = dom.nodeIndex(node);\r\n        var rng = dom.createRng();\r\n        rng.setStart(node.parentNode, idx);\r\n        rng.setEnd(node.parentNode, idx + 1);\r\n        if (content) {\r\n          moveEndPoint(dom, rng, node, true);\r\n          moveEndPoint(dom, rng, node, false);\r\n        }\r\n        return rng;\r\n      });\r\n    };\r\n\r\n    var processRanges = function (editor, ranges) {\r\n      return map$3(ranges, function (range) {\r\n        var evt = editor.fire('GetSelectionRange', { range: range });\r\n        return evt.range !== range ? evt.range : range;\r\n      });\r\n    };\r\n\r\n    var typeLookup = {\r\n      '#text': 3,\r\n      '#comment': 8,\r\n      '#cdata': 4,\r\n      '#pi': 7,\r\n      '#doctype': 10,\r\n      '#document-fragment': 11\r\n    };\r\n    var walk$1 = function (node, root, prev) {\r\n      var startName = prev ? 'lastChild' : 'firstChild';\r\n      var siblingName = prev ? 'prev' : 'next';\r\n      if (node[startName]) {\r\n        return node[startName];\r\n      }\r\n      if (node !== root) {\r\n        var sibling = node[siblingName];\r\n        if (sibling) {\r\n          return sibling;\r\n        }\r\n        for (var parent_1 = node.parent; parent_1 && parent_1 !== root; parent_1 = parent_1.parent) {\r\n          sibling = parent_1[siblingName];\r\n          if (sibling) {\r\n            return sibling;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var isEmptyTextNode = function (node) {\r\n      if (!isWhitespaceText(node.value)) {\r\n        return false;\r\n      }\r\n      var parentNode = node.parent;\r\n      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(node.value)) {\r\n        return false;\r\n      }\r\n      return true;\r\n    };\r\n    var isNonEmptyElement = function (node) {\r\n      var isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\r\n      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\r\n    };\r\n    var AstNode = function () {\r\n      function AstNode(name, type) {\r\n        this.name = name;\r\n        this.type = type;\r\n        if (type === 1) {\r\n          this.attributes = [];\r\n          this.attributes.map = {};\r\n        }\r\n      }\r\n      AstNode.create = function (name, attrs) {\r\n        var node = new AstNode(name, typeLookup[name] || 1);\r\n        if (attrs) {\r\n          each$j(attrs, function (value, attrName) {\r\n            node.attr(attrName, value);\r\n          });\r\n        }\r\n        return node;\r\n      };\r\n      AstNode.prototype.replace = function (node) {\r\n        var self = this;\r\n        if (node.parent) {\r\n          node.remove();\r\n        }\r\n        self.insert(node, self);\r\n        self.remove();\r\n        return self;\r\n      };\r\n      AstNode.prototype.attr = function (name, value) {\r\n        var self = this;\r\n        var attrs;\r\n        if (typeof name !== 'string') {\r\n          if (name !== undefined && name !== null) {\r\n            each$j(name, function (value, key) {\r\n              self.attr(key, value);\r\n            });\r\n          }\r\n          return self;\r\n        }\r\n        if (attrs = self.attributes) {\r\n          if (value !== undefined) {\r\n            if (value === null) {\r\n              if (name in attrs.map) {\r\n                delete attrs.map[name];\r\n                var i = attrs.length;\r\n                while (i--) {\r\n                  if (attrs[i].name === name) {\r\n                    attrs.splice(i, 1);\r\n                    return self;\r\n                  }\r\n                }\r\n              }\r\n              return self;\r\n            }\r\n            if (name in attrs.map) {\r\n              var i = attrs.length;\r\n              while (i--) {\r\n                if (attrs[i].name === name) {\r\n                  attrs[i].value = value;\r\n                  break;\r\n                }\r\n              }\r\n            } else {\r\n              attrs.push({\r\n                name: name,\r\n                value: value\r\n              });\r\n            }\r\n            attrs.map[name] = value;\r\n            return self;\r\n          }\r\n          return attrs.map[name];\r\n        }\r\n      };\r\n      AstNode.prototype.clone = function () {\r\n        var self = this;\r\n        var clone = new AstNode(self.name, self.type);\r\n        var selfAttrs;\r\n        if (selfAttrs = self.attributes) {\r\n          var cloneAttrs = [];\r\n          cloneAttrs.map = {};\r\n          for (var i = 0, l = selfAttrs.length; i < l; i++) {\r\n            var selfAttr = selfAttrs[i];\r\n            if (selfAttr.name !== 'id') {\r\n              cloneAttrs[cloneAttrs.length] = {\r\n                name: selfAttr.name,\r\n                value: selfAttr.value\r\n              };\r\n              cloneAttrs.map[selfAttr.name] = selfAttr.value;\r\n            }\r\n          }\r\n          clone.attributes = cloneAttrs;\r\n        }\r\n        clone.value = self.value;\r\n        clone.shortEnded = self.shortEnded;\r\n        return clone;\r\n      };\r\n      AstNode.prototype.wrap = function (wrapper) {\r\n        var self = this;\r\n        self.parent.insert(wrapper, self);\r\n        wrapper.append(self);\r\n        return self;\r\n      };\r\n      AstNode.prototype.unwrap = function () {\r\n        var self = this;\r\n        for (var node = self.firstChild; node;) {\r\n          var next = node.next;\r\n          self.insert(node, self, true);\r\n          node = next;\r\n        }\r\n        self.remove();\r\n      };\r\n      AstNode.prototype.remove = function () {\r\n        var self = this, parent = self.parent, next = self.next, prev = self.prev;\r\n        if (parent) {\r\n          if (parent.firstChild === self) {\r\n            parent.firstChild = next;\r\n            if (next) {\r\n              next.prev = null;\r\n            }\r\n          } else {\r\n            prev.next = next;\r\n          }\r\n          if (parent.lastChild === self) {\r\n            parent.lastChild = prev;\r\n            if (prev) {\r\n              prev.next = null;\r\n            }\r\n          } else {\r\n            next.prev = prev;\r\n          }\r\n          self.parent = self.next = self.prev = null;\r\n        }\r\n        return self;\r\n      };\r\n      AstNode.prototype.append = function (node) {\r\n        var self = this;\r\n        if (node.parent) {\r\n          node.remove();\r\n        }\r\n        var last = self.lastChild;\r\n        if (last) {\r\n          last.next = node;\r\n          node.prev = last;\r\n          self.lastChild = node;\r\n        } else {\r\n          self.lastChild = self.firstChild = node;\r\n        }\r\n        node.parent = self;\r\n        return node;\r\n      };\r\n      AstNode.prototype.insert = function (node, refNode, before) {\r\n        if (node.parent) {\r\n          node.remove();\r\n        }\r\n        var parent = refNode.parent || this;\r\n        if (before) {\r\n          if (refNode === parent.firstChild) {\r\n            parent.firstChild = node;\r\n          } else {\r\n            refNode.prev.next = node;\r\n          }\r\n          node.prev = refNode.prev;\r\n          node.next = refNode;\r\n          refNode.prev = node;\r\n        } else {\r\n          if (refNode === parent.lastChild) {\r\n            parent.lastChild = node;\r\n          } else {\r\n            refNode.next.prev = node;\r\n          }\r\n          node.next = refNode.next;\r\n          node.prev = refNode;\r\n          refNode.next = node;\r\n        }\r\n        node.parent = parent;\r\n        return node;\r\n      };\r\n      AstNode.prototype.getAll = function (name) {\r\n        var self = this;\r\n        var collection = [];\r\n        for (var node = self.firstChild; node; node = walk$1(node, self)) {\r\n          if (node.name === name) {\r\n            collection.push(node);\r\n          }\r\n        }\r\n        return collection;\r\n      };\r\n      AstNode.prototype.children = function () {\r\n        var self = this;\r\n        var collection = [];\r\n        for (var node = self.firstChild; node; node = node.next) {\r\n          collection.push(node);\r\n        }\r\n        return collection;\r\n      };\r\n      AstNode.prototype.empty = function () {\r\n        var self = this;\r\n        if (self.firstChild) {\r\n          var nodes = [];\r\n          for (var node = self.firstChild; node; node = walk$1(node, self)) {\r\n            nodes.push(node);\r\n          }\r\n          var i = nodes.length;\r\n          while (i--) {\r\n            var node = nodes[i];\r\n            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\r\n          }\r\n        }\r\n        self.firstChild = self.lastChild = null;\r\n        return self;\r\n      };\r\n      AstNode.prototype.isEmpty = function (elements, whitespace, predicate) {\r\n        if (whitespace === void 0) {\r\n          whitespace = {};\r\n        }\r\n        var self = this;\r\n        var node = self.firstChild;\r\n        if (isNonEmptyElement(self)) {\r\n          return false;\r\n        }\r\n        if (node) {\r\n          do {\r\n            if (node.type === 1) {\r\n              if (node.attr('data-mce-bogus')) {\r\n                continue;\r\n              }\r\n              if (elements[node.name]) {\r\n                return false;\r\n              }\r\n              if (isNonEmptyElement(node)) {\r\n                return false;\r\n              }\r\n            }\r\n            if (node.type === 8) {\r\n              return false;\r\n            }\r\n            if (node.type === 3 && !isEmptyTextNode(node)) {\r\n              return false;\r\n            }\r\n            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText(node.value)) {\r\n              return false;\r\n            }\r\n            if (predicate && predicate(node)) {\r\n              return false;\r\n            }\r\n          } while (node = walk$1(node, self));\r\n        }\r\n        return true;\r\n      };\r\n      AstNode.prototype.walk = function (prev) {\r\n        return walk$1(this, null, prev);\r\n      };\r\n      return AstNode;\r\n    }();\r\n\r\n    var getTemporaryNodeSelector = function (tempAttrs) {\r\n      return (tempAttrs.length === 0 ? '' : map$3(tempAttrs, function (attr) {\r\n        return '[' + attr + ']';\r\n      }).join(',') + ',') + '[data-mce-bogus=\"all\"]';\r\n    };\r\n    var getTemporaryNodes = function (body, tempAttrs) {\r\n      return body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));\r\n    };\r\n    var createCommentWalker = function (body) {\r\n      return document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, null, false);\r\n    };\r\n    var hasComments = function (body) {\r\n      return createCommentWalker(body).nextNode() !== null;\r\n    };\r\n    var hasTemporaryNodes = function (body, tempAttrs) {\r\n      return body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;\r\n    };\r\n    var trimTemporaryNodes = function (body, tempAttrs) {\r\n      each$k(getTemporaryNodes(body, tempAttrs), function (elm) {\r\n        var element = SugarElement.fromDom(elm);\r\n        if (get$6(element, 'data-mce-bogus') === 'all') {\r\n          remove$7(element);\r\n        } else {\r\n          each$k(tempAttrs, function (attr) {\r\n            if (has$1(element, attr)) {\r\n              remove$6(element, attr);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    };\r\n    var removeCommentsContainingZwsp = function (body) {\r\n      var walker = createCommentWalker(body);\r\n      var nextNode = walker.nextNode();\r\n      while (nextNode !== null) {\r\n        var comment = walker.currentNode;\r\n        nextNode = walker.nextNode();\r\n        if (isString$1(comment.nodeValue) && comment.nodeValue.indexOf(ZWSP$1) !== -1) {\r\n          remove$7(SugarElement.fromDom(comment));\r\n        }\r\n      }\r\n    };\r\n    var deepClone = function (body) {\r\n      return body.cloneNode(true);\r\n    };\r\n    var trim$1 = function (body, tempAttrs) {\r\n      var trimmed = body;\r\n      if (hasComments(body)) {\r\n        trimmed = deepClone(body);\r\n        removeCommentsContainingZwsp(trimmed);\r\n        if (hasTemporaryNodes(trimmed, tempAttrs)) {\r\n          trimTemporaryNodes(trimmed, tempAttrs);\r\n        }\r\n      } else if (hasTemporaryNodes(body, tempAttrs)) {\r\n        trimmed = deepClone(body);\r\n        trimTemporaryNodes(trimmed, tempAttrs);\r\n      }\r\n      return trimmed;\r\n    };\r\n\r\n    var trimEmptyContents = function (editor, html) {\r\n      var blockName = getForcedRootBlock(editor);\r\n      var emptyRegExp = new RegExp('^(<' + blockName + '[^>]*>(&nbsp;|&#160;|\\\\s|\\xA0|<br \\\\/>|)<\\\\/' + blockName + '>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$');\r\n      return html.replace(emptyRegExp, '');\r\n    };\r\n    var setupArgs$3 = function (args, format) {\r\n      return __assign(__assign({}, args), {\r\n        format: format,\r\n        get: true,\r\n        getInner: true\r\n      });\r\n    };\r\n    var getContentFromBody = function (editor, args, format, body) {\r\n      var defaultedArgs = setupArgs$3(args, format);\r\n      var updatedArgs = args.no_events ? defaultedArgs : editor.fire('BeforeGetContent', defaultedArgs);\r\n      var content;\r\n      if (updatedArgs.format === 'raw') {\r\n        content = Tools.trim(trim$3(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));\r\n      } else if (updatedArgs.format === 'text') {\r\n        content = editor.dom.isEmpty(body) ? '' : trim$3(body.innerText || body.textContent);\r\n      } else if (updatedArgs.format === 'tree') {\r\n        content = editor.serializer.serialize(body, updatedArgs);\r\n      } else {\r\n        content = trimEmptyContents(editor, editor.serializer.serialize(body, updatedArgs));\r\n      }\r\n      if (!contains$3([\r\n          'text',\r\n          'tree'\r\n        ], updatedArgs.format) && !isWsPreserveElement(SugarElement.fromDom(body))) {\r\n        updatedArgs.content = Tools.trim(content);\r\n      } else {\r\n        updatedArgs.content = content;\r\n      }\r\n      if (updatedArgs.no_events) {\r\n        return updatedArgs.content;\r\n      } else {\r\n        return editor.fire('GetContent', updatedArgs).content;\r\n      }\r\n    };\r\n    var getContentInternal = function (editor, args, format) {\r\n      return Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), function (body) {\r\n        return getContentFromBody(editor, args, format, body);\r\n      });\r\n    };\r\n\r\n    var each$d = Tools.each;\r\n    var ElementUtils = function (dom) {\r\n      var compare = function (node1, node2) {\r\n        if (node1.nodeName !== node2.nodeName) {\r\n          return false;\r\n        }\r\n        var getAttribs = function (node) {\r\n          var attribs = {};\r\n          each$d(dom.getAttribs(node), function (attr) {\r\n            var name = attr.nodeName.toLowerCase();\r\n            if (name.indexOf('_') !== 0 && name !== 'style' && name.indexOf('data-') !== 0) {\r\n              attribs[name] = dom.getAttrib(node, name);\r\n            }\r\n          });\r\n          return attribs;\r\n        };\r\n        var compareObjects = function (obj1, obj2) {\r\n          var value, name;\r\n          for (name in obj1) {\r\n            if (has$2(obj1, name)) {\r\n              value = obj2[name];\r\n              if (typeof value === 'undefined') {\r\n                return false;\r\n              }\r\n              if (obj1[name] !== value) {\r\n                return false;\r\n              }\r\n              delete obj2[name];\r\n            }\r\n          }\r\n          for (name in obj2) {\r\n            if (has$2(obj2, name)) {\r\n              return false;\r\n            }\r\n          }\r\n          return true;\r\n        };\r\n        if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\r\n          return false;\r\n        }\r\n        if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\r\n          return false;\r\n        }\r\n        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\r\n      };\r\n      return { compare: compare };\r\n    };\r\n\r\n    var makeMap$1 = Tools.makeMap;\r\n    var Writer = function (settings) {\r\n      var html = [];\r\n      settings = settings || {};\r\n      var indent = settings.indent;\r\n      var indentBefore = makeMap$1(settings.indent_before || '');\r\n      var indentAfter = makeMap$1(settings.indent_after || '');\r\n      var encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\r\n      var htmlOutput = settings.element_format === 'html';\r\n      return {\r\n        start: function (name, attrs, empty) {\r\n          var i, l, attr, value;\r\n          if (indent && indentBefore[name] && html.length > 0) {\r\n            value = html[html.length - 1];\r\n            if (value.length > 0 && value !== '\\n') {\r\n              html.push('\\n');\r\n            }\r\n          }\r\n          html.push('<', name);\r\n          if (attrs) {\r\n            for (i = 0, l = attrs.length; i < l; i++) {\r\n              attr = attrs[i];\r\n              html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\r\n            }\r\n          }\r\n          if (!empty || htmlOutput) {\r\n            html[html.length] = '>';\r\n          } else {\r\n            html[html.length] = ' />';\r\n          }\r\n          if (empty && indent && indentAfter[name] && html.length > 0) {\r\n            value = html[html.length - 1];\r\n            if (value.length > 0 && value !== '\\n') {\r\n              html.push('\\n');\r\n            }\r\n          }\r\n        },\r\n        end: function (name) {\r\n          var value;\r\n          html.push('</', name, '>');\r\n          if (indent && indentAfter[name] && html.length > 0) {\r\n            value = html[html.length - 1];\r\n            if (value.length > 0 && value !== '\\n') {\r\n              html.push('\\n');\r\n            }\r\n          }\r\n        },\r\n        text: function (text, raw) {\r\n          if (text.length > 0) {\r\n            html[html.length] = raw ? text : encode(text);\r\n          }\r\n        },\r\n        cdata: function (text) {\r\n          html.push('<![CDATA[', text, ']]>');\r\n        },\r\n        comment: function (text) {\r\n          html.push('<!--', text, '-->');\r\n        },\r\n        pi: function (name, text) {\r\n          if (text) {\r\n            html.push('<?', name, ' ', encode(text), '?>');\r\n          } else {\r\n            html.push('<?', name, '?>');\r\n          }\r\n          if (indent) {\r\n            html.push('\\n');\r\n          }\r\n        },\r\n        doctype: function (text) {\r\n          html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\r\n        },\r\n        reset: function () {\r\n          html.length = 0;\r\n        },\r\n        getContent: function () {\r\n          return html.join('').replace(/\\n$/, '');\r\n        }\r\n      };\r\n    };\r\n\r\n    var HtmlSerializer = function (settings, schema) {\r\n      if (schema === void 0) {\r\n        schema = Schema();\r\n      }\r\n      var writer = Writer(settings);\r\n      settings = settings || {};\r\n      settings.validate = 'validate' in settings ? settings.validate : true;\r\n      var serialize = function (node) {\r\n        var validate = settings.validate;\r\n        var handlers = {\r\n          3: function (node) {\r\n            writer.text(node.value, node.raw);\r\n          },\r\n          8: function (node) {\r\n            writer.comment(node.value);\r\n          },\r\n          7: function (node) {\r\n            writer.pi(node.name, node.value);\r\n          },\r\n          10: function (node) {\r\n            writer.doctype(node.value);\r\n          },\r\n          4: function (node) {\r\n            writer.cdata(node.value);\r\n          },\r\n          11: function (node) {\r\n            if (node = node.firstChild) {\r\n              do {\r\n                walk(node);\r\n              } while (node = node.next);\r\n            }\r\n          }\r\n        };\r\n        writer.reset();\r\n        var walk = function (node) {\r\n          var handler = handlers[node.type];\r\n          if (!handler) {\r\n            var name_1 = node.name;\r\n            var isEmpty = node.shortEnded;\r\n            var attrs = node.attributes;\r\n            if (validate && attrs && attrs.length > 1) {\r\n              var sortedAttrs = [];\r\n              sortedAttrs.map = {};\r\n              var elementRule = schema.getElementRule(node.name);\r\n              if (elementRule) {\r\n                for (var i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\r\n                  var attrName = elementRule.attributesOrder[i];\r\n                  if (attrName in attrs.map) {\r\n                    var attrValue = attrs.map[attrName];\r\n                    sortedAttrs.map[attrName] = attrValue;\r\n                    sortedAttrs.push({\r\n                      name: attrName,\r\n                      value: attrValue\r\n                    });\r\n                  }\r\n                }\r\n                for (var i = 0, l = attrs.length; i < l; i++) {\r\n                  var attrName = attrs[i].name;\r\n                  if (!(attrName in sortedAttrs.map)) {\r\n                    var attrValue = attrs.map[attrName];\r\n                    sortedAttrs.map[attrName] = attrValue;\r\n                    sortedAttrs.push({\r\n                      name: attrName,\r\n                      value: attrValue\r\n                    });\r\n                  }\r\n                }\r\n                attrs = sortedAttrs;\r\n              }\r\n            }\r\n            writer.start(node.name, attrs, isEmpty);\r\n            if (!isEmpty) {\r\n              if (node = node.firstChild) {\r\n                do {\r\n                  walk(node);\r\n                } while (node = node.next);\r\n              }\r\n              writer.end(name_1);\r\n            }\r\n          } else {\r\n            handler(node);\r\n          }\r\n        };\r\n        if (node.type === 1 && !settings.inner) {\r\n          walk(node);\r\n        } else {\r\n          handlers[11](node);\r\n        }\r\n        return writer.getContent();\r\n      };\r\n      return { serialize: serialize };\r\n    };\r\n\r\n    var nonInheritableStyles = new Set();\r\n    (function () {\r\n      var nonInheritableStylesArr = [\r\n        'margin',\r\n        'margin-left',\r\n        'margin-right',\r\n        'margin-top',\r\n        'margin-bottom',\r\n        'padding',\r\n        'padding-left',\r\n        'padding-right',\r\n        'padding-top',\r\n        'padding-bottom',\r\n        'border',\r\n        'border-width',\r\n        'border-style',\r\n        'border-color',\r\n        'background',\r\n        'background-attachment',\r\n        'background-clip',\r\n        'background-color',\r\n        'background-image',\r\n        'background-origin',\r\n        'background-position',\r\n        'background-repeat',\r\n        'background-size',\r\n        'float',\r\n        'position',\r\n        'left',\r\n        'right',\r\n        'top',\r\n        'bottom',\r\n        'z-index',\r\n        'display',\r\n        'transform',\r\n        'width',\r\n        'max-width',\r\n        'min-width',\r\n        'height',\r\n        'max-height',\r\n        'min-height',\r\n        'overflow',\r\n        'overflow-x',\r\n        'overflow-y',\r\n        'text-overflow',\r\n        'vertical-align',\r\n        'transition',\r\n        'transition-delay',\r\n        'transition-duration',\r\n        'transition-property',\r\n        'transition-timing-function'\r\n      ];\r\n      each$k(nonInheritableStylesArr, function (style) {\r\n        nonInheritableStyles.add(style);\r\n      });\r\n    }());\r\n    var shorthandStyleProps = [\r\n      'font',\r\n      'text-decoration',\r\n      'text-emphasis'\r\n    ];\r\n    var getStyleProps = function (dom, node) {\r\n      return keys(dom.parseStyle(dom.getAttrib(node, 'style')));\r\n    };\r\n    var isNonInheritableStyle = function (style) {\r\n      return nonInheritableStyles.has(style);\r\n    };\r\n    var hasInheritableStyles = function (dom, node) {\r\n      return forall(getStyleProps(dom, node), function (style) {\r\n        return !isNonInheritableStyle(style);\r\n      });\r\n    };\r\n    var getLonghandStyleProps = function (styles) {\r\n      return filter$4(styles, function (style) {\r\n        return exists(shorthandStyleProps, function (prop) {\r\n          return startsWith(style, prop);\r\n        });\r\n      });\r\n    };\r\n    var hasStyleConflict = function (dom, node, parentNode) {\r\n      var nodeStyleProps = getStyleProps(dom, node);\r\n      var parentNodeStyleProps = getStyleProps(dom, parentNode);\r\n      var valueMismatch = function (prop) {\r\n        var nodeValue = dom.getStyle(node, prop);\r\n        var parentValue = dom.getStyle(parentNode, prop);\r\n        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\r\n      };\r\n      return exists(nodeStyleProps, function (nodeStyleProp) {\r\n        var propExists = function (props) {\r\n          return exists(props, function (prop) {\r\n            return prop === nodeStyleProp;\r\n          });\r\n        };\r\n        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\r\n          var longhandProps = getLonghandStyleProps(parentNodeStyleProps);\r\n          return exists(longhandProps, valueMismatch);\r\n        } else {\r\n          return valueMismatch(nodeStyleProp);\r\n        }\r\n      });\r\n    };\r\n\r\n    var isChar = function (forward, predicate, pos) {\r\n      return Optional.from(pos.container()).filter(isText$7).exists(function (text) {\r\n        var delta = forward ? 0 : -1;\r\n        return predicate(text.data.charAt(pos.offset() + delta));\r\n      });\r\n    };\r\n    var isBeforeSpace = curry(isChar, true, isWhiteSpace);\r\n    var isAfterSpace = curry(isChar, false, isWhiteSpace);\r\n    var isEmptyText = function (pos) {\r\n      var container = pos.container();\r\n      return isText$7(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\r\n    };\r\n    var matchesElementPosition = function (before, predicate) {\r\n      return function (pos) {\r\n        return Optional.from(getChildNodeAtRelativeOffset(before ? 0 : -1, pos)).filter(predicate).isSome();\r\n      };\r\n    };\r\n    var isImageBlock = function (node) {\r\n      return isImg(node) && get$5(SugarElement.fromDom(node), 'display') === 'block';\r\n    };\r\n    var isCefNode = function (node) {\r\n      return isContentEditableFalse$b(node) && !isBogusAll$1(node);\r\n    };\r\n    var isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\r\n    var isAfterImageBlock = matchesElementPosition(false, isImageBlock);\r\n    var isBeforeMedia = matchesElementPosition(true, isMedia$2);\r\n    var isAfterMedia = matchesElementPosition(false, isMedia$2);\r\n    var isBeforeTable = matchesElementPosition(true, isTable$3);\r\n    var isAfterTable = matchesElementPosition(false, isTable$3);\r\n    var isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\r\n    var isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\r\n\r\n    var getLastChildren = function (elm) {\r\n      var children = [];\r\n      var rawNode = elm.dom;\r\n      while (rawNode) {\r\n        children.push(SugarElement.fromDom(rawNode));\r\n        rawNode = rawNode.lastChild;\r\n      }\r\n      return children;\r\n    };\r\n    var removeTrailingBr = function (elm) {\r\n      var allBrs = descendants(elm, 'br');\r\n      var brs = filter$4(getLastChildren(elm).slice(-1), isBr$4);\r\n      if (allBrs.length === brs.length) {\r\n        each$k(brs, remove$7);\r\n      }\r\n    };\r\n    var fillWithPaddingBr = function (elm) {\r\n      empty(elm);\r\n      append$1(elm, SugarElement.fromHtml('<br data-mce-bogus=\"1\">'));\r\n    };\r\n    var trimBlockTrailingBr = function (elm) {\r\n      lastChild(elm).each(function (lastChild) {\r\n        prevSibling(lastChild).each(function (lastChildPrevSibling) {\r\n          if (isBlock$2(elm) && isBr$4(lastChild) && isBlock$2(lastChildPrevSibling)) {\r\n            remove$7(lastChild);\r\n          }\r\n        });\r\n      });\r\n    };\r\n\r\n    var dropLast = function (xs) {\r\n      return xs.slice(0, -1);\r\n    };\r\n    var parentsUntil = function (start, root, predicate) {\r\n      if (contains$1(root, start)) {\r\n        return dropLast(parents$1(start, function (elm) {\r\n          return predicate(elm) || eq(elm, root);\r\n        }));\r\n      } else {\r\n        return [];\r\n      }\r\n    };\r\n    var parents = function (start, root) {\r\n      return parentsUntil(start, root, never);\r\n    };\r\n    var parentsAndSelf = function (start, root) {\r\n      return [start].concat(parents(start, root));\r\n    };\r\n\r\n    var navigateIgnoreEmptyTextNodes = function (forward, root, from) {\r\n      return navigateIgnore(forward, root, from, isEmptyText);\r\n    };\r\n    var getClosestBlock$1 = function (root, pos) {\r\n      return find$3(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\r\n    };\r\n    var isAtBeforeAfterBlockBoundary = function (forward, root, pos) {\r\n      return navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(function (newPos) {\r\n        return getClosestBlock$1(root, pos).fold(function () {\r\n          return isInSameBlock(newPos, pos, root.dom) === false;\r\n        }, function (fromBlock) {\r\n          return isInSameBlock(newPos, pos, root.dom) === false && contains$1(fromBlock, SugarElement.fromDom(newPos.container()));\r\n        });\r\n      });\r\n    };\r\n    var isAtBlockBoundary = function (forward, root, pos) {\r\n      return getClosestBlock$1(root, pos).fold(function () {\r\n        return navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(function (newPos) {\r\n          return isInSameBlock(newPos, pos, root.dom) === false;\r\n        });\r\n      }, function (parent) {\r\n        return navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone();\r\n      });\r\n    };\r\n    var isAtStartOfBlock = curry(isAtBlockBoundary, false);\r\n    var isAtEndOfBlock = curry(isAtBlockBoundary, true);\r\n    var isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\r\n    var isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\r\n\r\n    var isBr = function (pos) {\r\n      return getElementFromPosition(pos).exists(isBr$4);\r\n    };\r\n    var findBr = function (forward, root, pos) {\r\n      var parentBlocks = filter$4(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\r\n      var scope = head(parentBlocks).getOr(root);\r\n      return fromPosition(forward, scope.dom, pos).filter(isBr);\r\n    };\r\n    var isBeforeBr$1 = function (root, pos) {\r\n      return getElementFromPosition(pos).exists(isBr$4) || findBr(true, root, pos).isSome();\r\n    };\r\n    var isAfterBr = function (root, pos) {\r\n      return getElementFromPrevPosition(pos).exists(isBr$4) || findBr(false, root, pos).isSome();\r\n    };\r\n    var findPreviousBr = curry(findBr, false);\r\n    var findNextBr = curry(findBr, true);\r\n\r\n    var isInMiddleOfText = function (pos) {\r\n      return CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\r\n    };\r\n    var getClosestBlock = function (root, pos) {\r\n      var parentBlocks = filter$4(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);\r\n      return head(parentBlocks).getOr(root);\r\n    };\r\n    var hasSpaceBefore = function (root, pos) {\r\n      if (isInMiddleOfText(pos)) {\r\n        return isAfterSpace(pos);\r\n      } else {\r\n        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos).dom, pos).exists(isAfterSpace);\r\n      }\r\n    };\r\n    var hasSpaceAfter = function (root, pos) {\r\n      if (isInMiddleOfText(pos)) {\r\n        return isBeforeSpace(pos);\r\n      } else {\r\n        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos).dom, pos).exists(isBeforeSpace);\r\n      }\r\n    };\r\n    var isPreValue = function (value) {\r\n      return contains$3([\r\n        'pre',\r\n        'pre-wrap'\r\n      ], value);\r\n    };\r\n    var isInPre = function (pos) {\r\n      return getElementFromPosition(pos).bind(function (elm) {\r\n        return closest$3(elm, isElement$6);\r\n      }).exists(function (elm) {\r\n        return isPreValue(get$5(elm, 'white-space'));\r\n      });\r\n    };\r\n    var isAtBeginningOfBody = function (root, pos) {\r\n      return prevPosition(root.dom, pos).isNone();\r\n    };\r\n    var isAtEndOfBody = function (root, pos) {\r\n      return nextPosition(root.dom, pos).isNone();\r\n    };\r\n    var isAtLineBoundary = function (root, pos) {\r\n      return isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr$1(root, pos);\r\n    };\r\n    var needsToHaveNbsp = function (root, pos) {\r\n      if (isInPre(pos)) {\r\n        return false;\r\n      } else {\r\n        return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);\r\n      }\r\n    };\r\n    var needsToBeNbspLeft = function (root, pos) {\r\n      if (isInPre(pos)) {\r\n        return false;\r\n      } else {\r\n        return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos);\r\n      }\r\n    };\r\n    var leanRight = function (pos) {\r\n      var container = pos.container();\r\n      var offset = pos.offset();\r\n      if (isText$7(container) && offset < container.data.length) {\r\n        return CaretPosition(container, offset + 1);\r\n      } else {\r\n        return pos;\r\n      }\r\n    };\r\n    var needsToBeNbspRight = function (root, pos) {\r\n      if (isInPre(pos)) {\r\n        return false;\r\n      } else {\r\n        return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr$1(root, pos) || hasSpaceAfter(root, pos);\r\n      }\r\n    };\r\n    var needsToBeNbsp = function (root, pos) {\r\n      return needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));\r\n    };\r\n    var isNbspAt = function (text, offset) {\r\n      return isNbsp(text.charAt(offset));\r\n    };\r\n    var hasNbsp = function (pos) {\r\n      var container = pos.container();\r\n      return isText$7(container) && contains$2(container.data, nbsp);\r\n    };\r\n    var normalizeNbspMiddle = function (text) {\r\n      var chars = text.split('');\r\n      return map$3(chars, function (chr, i) {\r\n        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\r\n          return ' ';\r\n        } else {\r\n          return chr;\r\n        }\r\n      }).join('');\r\n    };\r\n    var normalizeNbspAtStart = function (root, node) {\r\n      var text = node.data;\r\n      var firstPos = CaretPosition(node, 0);\r\n      if (isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {\r\n        node.data = ' ' + text.slice(1);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var normalizeNbspInMiddleOfTextNode = function (node) {\r\n      var text = node.data;\r\n      var newText = normalizeNbspMiddle(text);\r\n      if (newText !== text) {\r\n        node.data = newText;\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var normalizeNbspAtEnd = function (root, node) {\r\n      var text = node.data;\r\n      var lastPos = CaretPosition(node, text.length - 1);\r\n      if (isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {\r\n        node.data = text.slice(0, -1) + ' ';\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var normalizeNbsps = function (root, pos) {\r\n      return Optional.some(pos).filter(hasNbsp).bind(function (pos) {\r\n        var container = pos.container();\r\n        var normalized = normalizeNbspAtStart(root, container) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container);\r\n        return normalized ? Optional.some(pos) : Optional.none();\r\n      });\r\n    };\r\n    var normalizeNbspsInEditor = function (editor) {\r\n      var root = SugarElement.fromDom(editor.getBody());\r\n      if (editor.selection.isCollapsed()) {\r\n        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(function (pos) {\r\n          editor.selection.setRng(pos.toRange());\r\n        });\r\n      }\r\n    };\r\n\r\n    var normalizeContent = function (content, isStartOfContent, isEndOfContent) {\r\n      var result = foldl(content, function (acc, c) {\r\n        if (isWhiteSpace(c) || isNbsp(c)) {\r\n          if (acc.previousCharIsSpace || acc.str === '' && isStartOfContent || acc.str.length === content.length - 1 && isEndOfContent) {\r\n            return {\r\n              previousCharIsSpace: false,\r\n              str: acc.str + nbsp\r\n            };\r\n          } else {\r\n            return {\r\n              previousCharIsSpace: true,\r\n              str: acc.str + ' '\r\n            };\r\n          }\r\n        } else {\r\n          return {\r\n            previousCharIsSpace: false,\r\n            str: acc.str + c\r\n          };\r\n        }\r\n      }, {\r\n        previousCharIsSpace: false,\r\n        str: ''\r\n      });\r\n      return result.str;\r\n    };\r\n    var normalize$1 = function (node, offset, count) {\r\n      if (count === 0) {\r\n        return;\r\n      }\r\n      var elm = SugarElement.fromDom(node);\r\n      var root = ancestor$3(elm, isBlock$2).getOr(elm);\r\n      var whitespace = node.data.slice(offset, offset + count);\r\n      var isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));\r\n      var isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));\r\n      node.replaceData(offset, count, normalizeContent(whitespace, isStartOfContent, isEndOfContent));\r\n    };\r\n    var normalizeWhitespaceAfter = function (node, offset) {\r\n      var content = node.data.slice(offset);\r\n      var whitespaceCount = content.length - lTrim(content).length;\r\n      normalize$1(node, offset, whitespaceCount);\r\n    };\r\n    var normalizeWhitespaceBefore = function (node, offset) {\r\n      var content = node.data.slice(0, offset);\r\n      var whitespaceCount = content.length - rTrim(content).length;\r\n      normalize$1(node, offset - whitespaceCount, whitespaceCount);\r\n    };\r\n    var mergeTextNodes = function (prevNode, nextNode, normalizeWhitespace, mergeToPrev) {\r\n      if (mergeToPrev === void 0) {\r\n        mergeToPrev = true;\r\n      }\r\n      var whitespaceOffset = rTrim(prevNode.data).length;\r\n      var newNode = mergeToPrev ? prevNode : nextNode;\r\n      var removeNode = mergeToPrev ? nextNode : prevNode;\r\n      if (mergeToPrev) {\r\n        newNode.appendData(removeNode.data);\r\n      } else {\r\n        newNode.insertData(0, removeNode.data);\r\n      }\r\n      remove$7(SugarElement.fromDom(removeNode));\r\n      if (normalizeWhitespace) {\r\n        normalizeWhitespaceAfter(newNode, whitespaceOffset);\r\n      }\r\n      return newNode;\r\n    };\r\n\r\n    var needsReposition = function (pos, elm) {\r\n      var container = pos.container();\r\n      var offset = pos.offset();\r\n      return CaretPosition.isTextPosition(pos) === false && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\r\n    };\r\n    var reposition = function (elm, pos) {\r\n      return needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\r\n    };\r\n    var beforeOrStartOf = function (node) {\r\n      return isText$7(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\r\n    };\r\n    var afterOrEndOf = function (node) {\r\n      return isText$7(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\r\n    };\r\n    var getPreviousSiblingCaretPosition = function (elm) {\r\n      if (isCaretCandidate$3(elm.previousSibling)) {\r\n        return Optional.some(afterOrEndOf(elm.previousSibling));\r\n      } else {\r\n        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\r\n      }\r\n    };\r\n    var getNextSiblingCaretPosition = function (elm) {\r\n      if (isCaretCandidate$3(elm.nextSibling)) {\r\n        return Optional.some(beforeOrStartOf(elm.nextSibling));\r\n      } else {\r\n        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\r\n      }\r\n    };\r\n    var findCaretPositionBackwardsFromElm = function (rootElement, elm) {\r\n      var startPosition = CaretPosition.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);\r\n      return prevPosition(rootElement, startPosition).fold(function () {\r\n        return nextPosition(rootElement, CaretPosition.after(elm));\r\n      }, Optional.some);\r\n    };\r\n    var findCaretPositionForwardsFromElm = function (rootElement, elm) {\r\n      return nextPosition(rootElement, CaretPosition.after(elm)).fold(function () {\r\n        return prevPosition(rootElement, CaretPosition.before(elm));\r\n      }, Optional.some);\r\n    };\r\n    var findCaretPositionBackwards = function (rootElement, elm) {\r\n      return getPreviousSiblingCaretPosition(elm).orThunk(function () {\r\n        return getNextSiblingCaretPosition(elm);\r\n      }).orThunk(function () {\r\n        return findCaretPositionBackwardsFromElm(rootElement, elm);\r\n      });\r\n    };\r\n    var findCaretPositionForward = function (rootElement, elm) {\r\n      return getNextSiblingCaretPosition(elm).orThunk(function () {\r\n        return getPreviousSiblingCaretPosition(elm);\r\n      }).orThunk(function () {\r\n        return findCaretPositionForwardsFromElm(rootElement, elm);\r\n      });\r\n    };\r\n    var findCaretPosition = function (forward, rootElement, elm) {\r\n      return forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\r\n    };\r\n    var findCaretPosOutsideElmAfterDelete = function (forward, rootElement, elm) {\r\n      return findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\r\n    };\r\n    var setSelection$1 = function (editor, forward, pos) {\r\n      pos.fold(function () {\r\n        editor.focus();\r\n      }, function (pos) {\r\n        editor.selection.setRng(pos.toRange(), forward);\r\n      });\r\n    };\r\n    var eqRawNode = function (rawNode) {\r\n      return function (elm) {\r\n        return elm.dom === rawNode;\r\n      };\r\n    };\r\n    var isBlock = function (editor, elm) {\r\n      return elm && has$2(editor.schema.getBlockElements(), name(elm));\r\n    };\r\n    var paddEmptyBlock = function (elm) {\r\n      if (isEmpty$2(elm)) {\r\n        var br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\r\n        empty(elm);\r\n        append$1(elm, br);\r\n        return Optional.some(CaretPosition.before(br.dom));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var deleteNormalized = function (elm, afterDeletePosOpt, normalizeWhitespace) {\r\n      var prevTextOpt = prevSibling(elm).filter(isText$8);\r\n      var nextTextOpt = nextSibling(elm).filter(isText$8);\r\n      remove$7(elm);\r\n      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, function (prev, next, pos) {\r\n        var prevNode = prev.dom, nextNode = next.dom;\r\n        var offset = prevNode.data.length;\r\n        mergeTextNodes(prevNode, nextNode, normalizeWhitespace);\r\n        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\r\n      }).orThunk(function () {\r\n        if (normalizeWhitespace) {\r\n          prevTextOpt.each(function (elm) {\r\n            return normalizeWhitespaceBefore(elm.dom, elm.dom.length);\r\n          });\r\n          nextTextOpt.each(function (elm) {\r\n            return normalizeWhitespaceAfter(elm.dom, 0);\r\n          });\r\n        }\r\n        return afterDeletePosOpt;\r\n      });\r\n    };\r\n    var isInlineElement = function (editor, element) {\r\n      return has$2(editor.schema.getTextInlineElements(), name(element));\r\n    };\r\n    var deleteElement$2 = function (editor, forward, elm, moveCaret) {\r\n      if (moveCaret === void 0) {\r\n        moveCaret = true;\r\n      }\r\n      var afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\r\n      var parentBlock = ancestor$3(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\r\n      var normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));\r\n      if (editor.dom.isEmpty(editor.getBody())) {\r\n        editor.setContent('');\r\n        editor.selection.setCursorLocation();\r\n      } else {\r\n        parentBlock.bind(paddEmptyBlock).fold(function () {\r\n          if (moveCaret) {\r\n            setSelection$1(editor, forward, normalizedAfterDeletePos);\r\n          }\r\n        }, function (paddPos) {\r\n          if (moveCaret) {\r\n            setSelection$1(editor, forward, Optional.some(paddPos));\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    var isRootFromElement = function (root) {\r\n      return function (cur) {\r\n        return eq(root, cur);\r\n      };\r\n    };\r\n    var getTableCells = function (table) {\r\n      return descendants(table, 'td,th');\r\n    };\r\n    var getTableDetailsFromRange = function (rng, isRoot) {\r\n      var getTable = function (node) {\r\n        return getClosestTable(SugarElement.fromDom(node), isRoot);\r\n      };\r\n      var startTable = getTable(rng.startContainer);\r\n      var endTable = getTable(rng.endContainer);\r\n      var isStartInTable = startTable.isSome();\r\n      var isEndInTable = endTable.isSome();\r\n      var isSameTable = lift2(startTable, endTable, eq).getOr(false);\r\n      var isMultiTable = !isSameTable && isStartInTable && isEndInTable;\r\n      return {\r\n        startTable: startTable,\r\n        endTable: endTable,\r\n        isStartInTable: isStartInTable,\r\n        isEndInTable: isEndInTable,\r\n        isSameTable: isSameTable,\r\n        isMultiTable: isMultiTable\r\n      };\r\n    };\r\n\r\n    var tableCellRng = function (start, end) {\r\n      return {\r\n        start: start,\r\n        end: end\r\n      };\r\n    };\r\n    var tableSelection = function (rng, table, cells) {\r\n      return {\r\n        rng: rng,\r\n        table: table,\r\n        cells: cells\r\n      };\r\n    };\r\n    var deleteAction = Adt.generate([\r\n      {\r\n        singleCellTable: [\r\n          'rng',\r\n          'cell'\r\n        ]\r\n      },\r\n      { fullTable: ['table'] },\r\n      {\r\n        partialTable: [\r\n          'cells',\r\n          'outsideDetails'\r\n        ]\r\n      },\r\n      {\r\n        multiTable: [\r\n          'startTableCells',\r\n          'endTableCells',\r\n          'betweenRng'\r\n        ]\r\n      }\r\n    ]);\r\n    var getClosestCell$1 = function (container, isRoot) {\r\n      return closest$2(SugarElement.fromDom(container), 'td,th', isRoot);\r\n    };\r\n    var isExpandedCellRng = function (cellRng) {\r\n      return !eq(cellRng.start, cellRng.end);\r\n    };\r\n    var getTableFromCellRng = function (cellRng, isRoot) {\r\n      return getClosestTable(cellRng.start, isRoot).bind(function (startParentTable) {\r\n        return getClosestTable(cellRng.end, isRoot).bind(function (endParentTable) {\r\n          return someIf(eq(startParentTable, endParentTable), startParentTable);\r\n        });\r\n      });\r\n    };\r\n    var isSingleCellTable = function (cellRng, isRoot) {\r\n      return !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(function (table) {\r\n        var rows = table.dom.rows;\r\n        return rows.length === 1 && rows[0].cells.length === 1;\r\n      });\r\n    };\r\n    var getCellRng = function (rng, isRoot) {\r\n      var startCell = getClosestCell$1(rng.startContainer, isRoot);\r\n      var endCell = getClosestCell$1(rng.endContainer, isRoot);\r\n      return lift2(startCell, endCell, tableCellRng);\r\n    };\r\n    var getCellRangeFromStartTable = function (isRoot) {\r\n      return function (startCell) {\r\n        return getClosestTable(startCell, isRoot).bind(function (table) {\r\n          return last$2(getTableCells(table)).map(function (endCell) {\r\n            return tableCellRng(startCell, endCell);\r\n          });\r\n        });\r\n      };\r\n    };\r\n    var getCellRangeFromEndTable = function (isRoot) {\r\n      return function (endCell) {\r\n        return getClosestTable(endCell, isRoot).bind(function (table) {\r\n          return head(getTableCells(table)).map(function (startCell) {\r\n            return tableCellRng(startCell, endCell);\r\n          });\r\n        });\r\n      };\r\n    };\r\n    var getTableSelectionFromCellRng = function (isRoot) {\r\n      return function (cellRng) {\r\n        return getTableFromCellRng(cellRng, isRoot).map(function (table) {\r\n          return tableSelection(cellRng, table, getTableCells(table));\r\n        });\r\n      };\r\n    };\r\n    var getTableSelections = function (cellRng, selectionDetails, rng, isRoot) {\r\n      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\r\n        return Optional.none();\r\n      } else if (selectionDetails.isSameTable) {\r\n        var sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\r\n        return Optional.some({\r\n          start: sameTableSelection,\r\n          end: sameTableSelection\r\n        });\r\n      } else {\r\n        var startCell = getClosestCell$1(rng.startContainer, isRoot);\r\n        var endCell = getClosestCell$1(rng.endContainer, isRoot);\r\n        var startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\r\n        var endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\r\n        return Optional.some({\r\n          start: startTableSelection,\r\n          end: endTableSelection\r\n        });\r\n      }\r\n    };\r\n    var getCellIndex = function (cells, cell) {\r\n      return findIndex$2(cells, function (x) {\r\n        return eq(x, cell);\r\n      });\r\n    };\r\n    var getSelectedCells = function (tableSelection) {\r\n      return lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), function (startIndex, endIndex) {\r\n        return tableSelection.cells.slice(startIndex, endIndex + 1);\r\n      });\r\n    };\r\n    var isSingleCellTableContentSelected = function (optCellRng, rng, isRoot) {\r\n      return optCellRng.exists(function (cellRng) {\r\n        return isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng);\r\n      });\r\n    };\r\n    var unselectCells = function (rng, selectionDetails) {\r\n      var startTable = selectionDetails.startTable, endTable = selectionDetails.endTable;\r\n      var otherContentRng = rng.cloneRange();\r\n      startTable.each(function (table) {\r\n        return otherContentRng.setStartAfter(table.dom);\r\n      });\r\n      endTable.each(function (table) {\r\n        return otherContentRng.setEndBefore(table.dom);\r\n      });\r\n      return otherContentRng;\r\n    };\r\n    var handleSingleTable = function (cellRng, selectionDetails, rng, isRoot) {\r\n      return getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(function (_a) {\r\n        var start = _a.start, end = _a.end;\r\n        return start.or(end);\r\n      }).bind(function (tableSelection) {\r\n        var isSameTable = selectionDetails.isSameTable;\r\n        var selectedCells = getSelectedCells(tableSelection).getOr([]);\r\n        if (isSameTable && tableSelection.cells.length === selectedCells.length) {\r\n          return Optional.some(deleteAction.fullTable(tableSelection.table));\r\n        } else if (selectedCells.length > 0) {\r\n          if (isSameTable) {\r\n            return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\r\n          } else {\r\n            var otherContentRng = unselectCells(rng, selectionDetails);\r\n            return Optional.some(deleteAction.partialTable(selectedCells, Optional.some(__assign(__assign({}, selectionDetails), { rng: otherContentRng }))));\r\n          }\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      });\r\n    };\r\n    var handleMultiTable = function (cellRng, selectionDetails, rng, isRoot) {\r\n      return getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(function (_a) {\r\n        var start = _a.start, end = _a.end;\r\n        var startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\r\n        var endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\r\n        if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\r\n          var otherContentRng = unselectCells(rng, selectionDetails);\r\n          return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      });\r\n    };\r\n    var getActionFromRange = function (root, rng) {\r\n      var isRoot = isRootFromElement(root);\r\n      var optCellRng = getCellRng(rng, isRoot);\r\n      var selectionDetails = getTableDetailsFromRange(rng, isRoot);\r\n      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\r\n        return optCellRng.map(function (cellRng) {\r\n          return deleteAction.singleCellTable(rng, cellRng.start);\r\n        });\r\n      } else if (selectionDetails.isMultiTable) {\r\n        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\r\n      } else {\r\n        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\r\n      }\r\n    };\r\n\r\n    var freefallRtl = function (root) {\r\n      var child = isComment$1(root) ? prevSibling(root) : lastChild(root);\r\n      return child.bind(freefallRtl).orThunk(function () {\r\n        return Optional.some(root);\r\n      });\r\n    };\r\n    var cleanCells = function (cells) {\r\n      return each$k(cells, function (cell) {\r\n        remove$6(cell, 'contenteditable');\r\n        fillWithPaddingBr(cell);\r\n      });\r\n    };\r\n    var getOutsideBlock = function (editor, container) {\r\n      return Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\r\n    };\r\n    var handleEmptyBlock = function (editor, startInTable, emptyBlock) {\r\n      emptyBlock.each(function (block) {\r\n        if (startInTable) {\r\n          remove$7(block);\r\n        } else {\r\n          fillWithPaddingBr(block);\r\n          editor.selection.setCursorLocation(block.dom, 0);\r\n        }\r\n      });\r\n    };\r\n    var deleteContentInsideCell = function (editor, cell, rng, isFirstCellInSelection) {\r\n      var insideTableRng = rng.cloneRange();\r\n      if (isFirstCellInSelection) {\r\n        insideTableRng.setStart(rng.startContainer, rng.startOffset);\r\n        insideTableRng.setEndAfter(cell.dom.lastChild);\r\n      } else {\r\n        insideTableRng.setStartBefore(cell.dom.firstChild);\r\n        insideTableRng.setEnd(rng.endContainer, rng.endOffset);\r\n      }\r\n      deleteCellContents(editor, insideTableRng, cell, false);\r\n    };\r\n    var collapseAndRestoreCellSelection = function (editor) {\r\n      var selectedCells = getCellsFromEditor(editor);\r\n      var selectedNode = SugarElement.fromDom(editor.selection.getNode());\r\n      if (isTableCell$5(selectedNode.dom) && isEmpty$2(selectedNode)) {\r\n        editor.selection.setCursorLocation(selectedNode.dom, 0);\r\n      } else {\r\n        editor.selection.collapse(true);\r\n      }\r\n      if (selectedCells.length > 1 && exists(selectedCells, function (cell) {\r\n          return eq(cell, selectedNode);\r\n        })) {\r\n        set$1(selectedNode, 'data-mce-selected', '1');\r\n      }\r\n    };\r\n    var emptySingleTableCells = function (editor, cells, outsideDetails) {\r\n      var editorRng = editor.selection.getRng();\r\n      var cellsToClean = outsideDetails.bind(function (_a) {\r\n        var rng = _a.rng, isStartInTable = _a.isStartInTable;\r\n        var outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\r\n        rng.deleteContents();\r\n        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));\r\n        var endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\r\n        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\r\n        if (!isEmpty$2(endPointCell)) {\r\n          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      }).getOr(cells);\r\n      cleanCells(cellsToClean);\r\n      collapseAndRestoreCellSelection(editor);\r\n      return true;\r\n    };\r\n    var emptyMultiTableCells = function (editor, startTableCells, endTableCells, betweenRng) {\r\n      var rng = editor.selection.getRng();\r\n      var startCell = startTableCells[0];\r\n      var endCell = endTableCells[endTableCells.length - 1];\r\n      deleteContentInsideCell(editor, startCell, rng, true);\r\n      deleteContentInsideCell(editor, endCell, rng, false);\r\n      var startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);\r\n      var endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);\r\n      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\r\n      betweenRng.deleteContents();\r\n      collapseAndRestoreCellSelection(editor);\r\n      return true;\r\n    };\r\n    var deleteCellContents = function (editor, rng, cell, moveSelection) {\r\n      if (moveSelection === void 0) {\r\n        moveSelection = true;\r\n      }\r\n      rng.deleteContents();\r\n      var lastNode = freefallRtl(cell).getOr(cell);\r\n      var lastBlock = SugarElement.fromDom(editor.dom.getParent(lastNode.dom, editor.dom.isBlock));\r\n      if (isEmpty$2(lastBlock)) {\r\n        fillWithPaddingBr(lastBlock);\r\n        if (moveSelection) {\r\n          editor.selection.setCursorLocation(lastBlock.dom, 0);\r\n        }\r\n      }\r\n      if (!eq(cell, lastBlock)) {\r\n        var additionalCleanupNodes = is$1(parent(lastBlock), cell) ? [] : siblings(lastBlock);\r\n        each$k(additionalCleanupNodes.concat(children(cell)), function (node) {\r\n          if (!eq(node, lastBlock) && !contains$1(node, lastBlock) && isEmpty$2(node)) {\r\n            remove$7(node);\r\n          }\r\n        });\r\n      }\r\n      return true;\r\n    };\r\n    var deleteTableElement = function (editor, table) {\r\n      deleteElement$2(editor, false, table);\r\n      return true;\r\n    };\r\n    var deleteCellRange = function (editor, rootElm, rng) {\r\n      return getActionFromRange(rootElm, rng).map(function (action) {\r\n        return action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor));\r\n      });\r\n    };\r\n    var deleteCaptionRange = function (editor, caption) {\r\n      return emptyElement(editor, caption);\r\n    };\r\n    var deleteTableRange = function (editor, rootElm, rng, startElm) {\r\n      return getParentCaption(rootElm, startElm).fold(function () {\r\n        return deleteCellRange(editor, rootElm, rng);\r\n      }, function (caption) {\r\n        return deleteCaptionRange(editor, caption);\r\n      }).getOr(false);\r\n    };\r\n    var deleteRange$2 = function (editor, startElm, selectedCells) {\r\n      var rootNode = SugarElement.fromDom(editor.getBody());\r\n      var rng = editor.selection.getRng();\r\n      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\r\n    };\r\n    var getParentCell = function (rootElm, elm) {\r\n      return find$3(parentsAndSelf(elm, rootElm), isTableCell$4);\r\n    };\r\n    var getParentCaption = function (rootElm, elm) {\r\n      return find$3(parentsAndSelf(elm, rootElm), isTag('caption'));\r\n    };\r\n    var deleteBetweenCells = function (editor, rootElm, forward, fromCell, from) {\r\n      return navigate(forward, editor.getBody(), from).bind(function (to) {\r\n        return getParentCell(rootElm, SugarElement.fromDom(to.getNode())).map(function (toCell) {\r\n          return eq(toCell, fromCell) === false;\r\n        });\r\n      });\r\n    };\r\n    var emptyElement = function (editor, elm) {\r\n      fillWithPaddingBr(elm);\r\n      editor.selection.setCursorLocation(elm.dom, 0);\r\n      return Optional.some(true);\r\n    };\r\n    var isDeleteOfLastCharPos = function (fromCaption, forward, from, to) {\r\n      return firstPositionIn(fromCaption.dom).bind(function (first) {\r\n        return lastPositionIn(fromCaption.dom).map(function (last) {\r\n          return forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first);\r\n        });\r\n      }).getOr(true);\r\n    };\r\n    var emptyCaretCaption = function (editor, elm) {\r\n      return emptyElement(editor, elm);\r\n    };\r\n    var validateCaretCaption = function (rootElm, fromCaption, to) {\r\n      return getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).map(function (toCaption) {\r\n        return eq(toCaption, fromCaption) === false;\r\n      });\r\n    };\r\n    var deleteCaretInsideCaption = function (editor, rootElm, forward, fromCaption, from) {\r\n      return navigate(forward, editor.getBody(), from).bind(function (to) {\r\n        return isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to);\r\n      }).or(Optional.some(true));\r\n    };\r\n    var deleteCaretCells = function (editor, forward, rootElm, startElm) {\r\n      var from = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return getParentCell(rootElm, startElm).bind(function (fromCell) {\r\n        return isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from);\r\n      }).getOr(false);\r\n    };\r\n    var deleteCaretCaption = function (editor, forward, rootElm, fromCaption) {\r\n      var from = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\r\n    };\r\n    var isNearTable = function (forward, pos) {\r\n      return forward ? isBeforeTable(pos) : isAfterTable(pos);\r\n    };\r\n    var isBeforeOrAfterTable = function (editor, forward) {\r\n      var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(function (pos) {\r\n        return isNearTable(forward, pos);\r\n      });\r\n    };\r\n    var deleteCaret$3 = function (editor, forward, startElm) {\r\n      var rootElm = SugarElement.fromDom(editor.getBody());\r\n      return getParentCaption(rootElm, startElm).fold(function () {\r\n        return deleteCaretCells(editor, forward, rootElm, startElm) || isBeforeOrAfterTable(editor, forward);\r\n      }, function (fromCaption) {\r\n        return deleteCaretCaption(editor, forward, rootElm, fromCaption).getOr(false);\r\n      });\r\n    };\r\n    var backspaceDelete$9 = function (editor, forward) {\r\n      var startElm = SugarElement.fromDom(editor.selection.getStart(true));\r\n      var cells = getCellsFromEditor(editor);\r\n      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$2(editor, startElm, cells);\r\n    };\r\n\r\n    var createRange = function (sc, so, ec, eo) {\r\n      var rng = document.createRange();\r\n      rng.setStart(sc, so);\r\n      rng.setEnd(ec, eo);\r\n      return rng;\r\n    };\r\n    var normalizeBlockSelectionRange = function (rng) {\r\n      var startPos = CaretPosition.fromRangeStart(rng);\r\n      var endPos = CaretPosition.fromRangeEnd(rng);\r\n      var rootNode = rng.commonAncestorContainer;\r\n      return fromPosition(false, rootNode, endPos).map(function (newEndPos) {\r\n        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\r\n          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\r\n        } else {\r\n          return rng;\r\n        }\r\n      }).getOr(rng);\r\n    };\r\n    var normalize = function (rng) {\r\n      return rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\r\n    };\r\n\r\n    var hasOnlyOneChild$1 = function (node) {\r\n      return node.firstChild && node.firstChild === node.lastChild;\r\n    };\r\n    var isPaddingNode = function (node) {\r\n      return node.name === 'br' || node.value === nbsp;\r\n    };\r\n    var isPaddedEmptyBlock = function (schema, node) {\r\n      var blockElements = schema.getBlockElements();\r\n      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\r\n    };\r\n    var isEmptyFragmentElement = function (schema, node) {\r\n      var nonEmptyElements = schema.getNonEmptyElements();\r\n      return node && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\r\n    };\r\n    var isListFragment = function (schema, fragment) {\r\n      var firstChild = fragment.firstChild;\r\n      var lastChild = fragment.lastChild;\r\n      if (firstChild && firstChild.name === 'meta') {\r\n        firstChild = firstChild.next;\r\n      }\r\n      if (lastChild && lastChild.attr('id') === 'mce_marker') {\r\n        lastChild = lastChild.prev;\r\n      }\r\n      if (isEmptyFragmentElement(schema, lastChild)) {\r\n        lastChild = lastChild.prev;\r\n      }\r\n      if (!firstChild || firstChild !== lastChild) {\r\n        return false;\r\n      }\r\n      return firstChild.name === 'ul' || firstChild.name === 'ol';\r\n    };\r\n    var cleanupDomFragment = function (domFragment) {\r\n      var firstChild = domFragment.firstChild;\r\n      var lastChild = domFragment.lastChild;\r\n      if (firstChild && firstChild.nodeName === 'META') {\r\n        firstChild.parentNode.removeChild(firstChild);\r\n      }\r\n      if (lastChild && lastChild.id === 'mce_marker') {\r\n        lastChild.parentNode.removeChild(lastChild);\r\n      }\r\n      return domFragment;\r\n    };\r\n    var toDomFragment = function (dom, serializer, fragment) {\r\n      var html = serializer.serialize(fragment);\r\n      var domFragment = dom.createFragment(html);\r\n      return cleanupDomFragment(domFragment);\r\n    };\r\n    var listItems = function (elm) {\r\n      return filter$4(elm.childNodes, function (child) {\r\n        return child.nodeName === 'LI';\r\n      });\r\n    };\r\n    var isPadding = function (node) {\r\n      return node.data === nbsp || isBr$5(node);\r\n    };\r\n    var isListItemPadded = function (node) {\r\n      return node && node.firstChild && node.firstChild === node.lastChild && isPadding(node.firstChild);\r\n    };\r\n    var isEmptyOrPadded = function (elm) {\r\n      return !elm.firstChild || isListItemPadded(elm);\r\n    };\r\n    var trimListItems = function (elms) {\r\n      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\r\n    };\r\n    var getParentLi = function (dom, node) {\r\n      var parentBlock = dom.getParent(node, dom.isBlock);\r\n      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\r\n    };\r\n    var isParentBlockLi = function (dom, node) {\r\n      return !!getParentLi(dom, node);\r\n    };\r\n    var getSplit = function (parentNode, rng) {\r\n      var beforeRng = rng.cloneRange();\r\n      var afterRng = rng.cloneRange();\r\n      beforeRng.setStartBefore(parentNode);\r\n      afterRng.setEndAfter(parentNode);\r\n      return [\r\n        beforeRng.cloneContents(),\r\n        afterRng.cloneContents()\r\n      ];\r\n    };\r\n    var findFirstIn = function (node, rootNode) {\r\n      var caretPos = CaretPosition.before(node);\r\n      var caretWalker = CaretWalker(rootNode);\r\n      var newCaretPos = caretWalker.next(caretPos);\r\n      return newCaretPos ? newCaretPos.toRange() : null;\r\n    };\r\n    var findLastOf = function (node, rootNode) {\r\n      var caretPos = CaretPosition.after(node);\r\n      var caretWalker = CaretWalker(rootNode);\r\n      var newCaretPos = caretWalker.prev(caretPos);\r\n      return newCaretPos ? newCaretPos.toRange() : null;\r\n    };\r\n    var insertMiddle = function (target, elms, rootNode, rng) {\r\n      var parts = getSplit(target, rng);\r\n      var parentElm = target.parentNode;\r\n      parentElm.insertBefore(parts[0], target);\r\n      Tools.each(elms, function (li) {\r\n        parentElm.insertBefore(li, target);\r\n      });\r\n      parentElm.insertBefore(parts[1], target);\r\n      parentElm.removeChild(target);\r\n      return findLastOf(elms[elms.length - 1], rootNode);\r\n    };\r\n    var insertBefore$1 = function (target, elms, rootNode) {\r\n      var parentElm = target.parentNode;\r\n      Tools.each(elms, function (elm) {\r\n        parentElm.insertBefore(elm, target);\r\n      });\r\n      return findFirstIn(target, rootNode);\r\n    };\r\n    var insertAfter$1 = function (target, elms, rootNode, dom) {\r\n      dom.insertAfter(elms.reverse(), target);\r\n      return findLastOf(elms[0], rootNode);\r\n    };\r\n    var insertAtCaret$1 = function (serializer, dom, rng, fragment) {\r\n      var domFragment = toDomFragment(dom, serializer, fragment);\r\n      var liTarget = getParentLi(dom, rng.startContainer);\r\n      var liElms = trimListItems(listItems(domFragment.firstChild));\r\n      var BEGINNING = 1, END = 2;\r\n      var rootNode = dom.getRoot();\r\n      var isAt = function (location) {\r\n        var caretPos = CaretPosition.fromRangeStart(rng);\r\n        var caretWalker = CaretWalker(dom.getRoot());\r\n        var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\r\n        return newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : true;\r\n      };\r\n      if (isAt(BEGINNING)) {\r\n        return insertBefore$1(liTarget, liElms, rootNode);\r\n      } else if (isAt(END)) {\r\n        return insertAfter$1(liTarget, liElms, rootNode, dom);\r\n      }\r\n      return insertMiddle(liTarget, liElms, rootNode, rng);\r\n    };\r\n\r\n    var trimOrPadLeftRight = function (dom, rng, html) {\r\n      var root = SugarElement.fromDom(dom.getRoot());\r\n      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) {\r\n        html = html.replace(/^ /, '&nbsp;');\r\n      } else {\r\n        html = html.replace(/^&nbsp;/, ' ');\r\n      }\r\n      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) {\r\n        html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\r\n      } else {\r\n        html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\r\n      }\r\n      return html;\r\n    };\r\n\r\n    var isTableCell$1 = isTableCell$5;\r\n    var isTableCellContentSelected = function (dom, rng, cell) {\r\n      if (cell !== null) {\r\n        var endCell = dom.getParent(rng.endContainer, isTableCell$1);\r\n        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var validInsertion = function (editor, value, parentNode) {\r\n      if (parentNode.getAttribute('data-mce-bogus') === 'all') {\r\n        parentNode.parentNode.insertBefore(editor.dom.createFragment(value), parentNode);\r\n      } else {\r\n        var node = parentNode.firstChild;\r\n        var node2 = parentNode.lastChild;\r\n        if (!node || node === node2 && node.nodeName === 'BR') {\r\n          editor.dom.setHTML(parentNode, value);\r\n        } else {\r\n          editor.selection.setContent(value);\r\n        }\r\n      }\r\n    };\r\n    var trimBrsFromTableCell = function (dom, elm) {\r\n      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(trimBlockTrailingBr);\r\n    };\r\n    var reduceInlineTextElements = function (editor, merge) {\r\n      var textInlineElements = editor.schema.getTextInlineElements();\r\n      var dom = editor.dom;\r\n      if (merge) {\r\n        var root_1 = editor.getBody();\r\n        var elementUtils_1 = ElementUtils(dom);\r\n        Tools.each(dom.select('*[data-mce-fragment]'), function (node) {\r\n          var isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);\r\n          if (isInline && hasInheritableStyles(dom, node)) {\r\n            for (var parentNode = node.parentNode; isNonNullable(parentNode) && parentNode !== root_1; parentNode = parentNode.parentNode) {\r\n              var styleConflict = hasStyleConflict(dom, node, parentNode);\r\n              if (styleConflict) {\r\n                break;\r\n              }\r\n              if (elementUtils_1.compare(parentNode, node)) {\r\n                dom.remove(node, true);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n    };\r\n    var markFragmentElements = function (fragment) {\r\n      var node = fragment;\r\n      while (node = node.walk()) {\r\n        if (node.type === 1) {\r\n          node.attr('data-mce-fragment', '1');\r\n        }\r\n      }\r\n    };\r\n    var unmarkFragmentElements = function (elm) {\r\n      Tools.each(elm.getElementsByTagName('*'), function (elm) {\r\n        elm.removeAttribute('data-mce-fragment');\r\n      });\r\n    };\r\n    var isPartOfFragment = function (node) {\r\n      return !!node.getAttribute('data-mce-fragment');\r\n    };\r\n    var canHaveChildren = function (editor, node) {\r\n      return node && !editor.schema.getShortEndedElements()[node.nodeName];\r\n    };\r\n    var moveSelectionToMarker = function (editor, marker) {\r\n      var nextRng;\r\n      var dom = editor.dom;\r\n      var selection = editor.selection;\r\n      if (!marker) {\r\n        return;\r\n      }\r\n      selection.scrollIntoView(marker);\r\n      var parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\r\n      if (dom.getContentEditable(parentEditableElm) === 'false') {\r\n        dom.remove(marker);\r\n        selection.select(parentEditableElm);\r\n        return;\r\n      }\r\n      var rng = dom.createRng();\r\n      var node = marker.previousSibling;\r\n      if (isText$7(node)) {\r\n        rng.setStart(node, node.nodeValue.length);\r\n        if (!Env.ie) {\r\n          var node2 = marker.nextSibling;\r\n          if (isText$7(node2)) {\r\n            node.appendData(node2.data);\r\n            node2.parentNode.removeChild(node2);\r\n          }\r\n        }\r\n      } else {\r\n        rng.setStartBefore(marker);\r\n        rng.setEndBefore(marker);\r\n      }\r\n      var findNextCaretRng = function (rng) {\r\n        var caretPos = CaretPosition.fromRangeStart(rng);\r\n        var caretWalker = CaretWalker(editor.getBody());\r\n        caretPos = caretWalker.next(caretPos);\r\n        if (caretPos) {\r\n          return caretPos.toRange();\r\n        }\r\n      };\r\n      var parentBlock = dom.getParent(marker, dom.isBlock);\r\n      dom.remove(marker);\r\n      if (parentBlock && dom.isEmpty(parentBlock)) {\r\n        editor.$(parentBlock).empty();\r\n        rng.setStart(parentBlock, 0);\r\n        rng.setEnd(parentBlock, 0);\r\n        if (!isTableCell$1(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\r\n          rng = nextRng;\r\n          dom.remove(parentBlock);\r\n        } else {\r\n          dom.add(parentBlock, dom.create('br', { 'data-mce-bogus': '1' }));\r\n        }\r\n      }\r\n      selection.setRng(rng);\r\n    };\r\n    var deleteSelectedContent = function (editor) {\r\n      var dom = editor.dom;\r\n      var rng = normalize(editor.selection.getRng());\r\n      editor.selection.setRng(rng);\r\n      var startCell = dom.getParent(rng.startContainer, isTableCell$1);\r\n      if (isTableCellContentSelected(dom, rng, startCell)) {\r\n        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\r\n      } else {\r\n        editor.getDoc().execCommand('Delete', false, null);\r\n      }\r\n    };\r\n    var insertHtmlAtCaret = function (editor, value, details) {\r\n      var parentNode;\r\n      var rng, node;\r\n      var selection = editor.selection;\r\n      var dom = editor.dom;\r\n      if (/^ | $/.test(value)) {\r\n        value = trimOrPadLeftRight(dom, selection.getRng(), value);\r\n      }\r\n      var parser = editor.parser;\r\n      var merge = details.merge;\r\n      var serializer = HtmlSerializer({ validate: shouldValidate(editor) }, editor.schema);\r\n      var bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\r\n      var args = editor.fire('BeforeSetContent', {\r\n        content: value,\r\n        format: 'html',\r\n        selection: true,\r\n        paste: details.paste\r\n      });\r\n      if (args.isDefaultPrevented()) {\r\n        editor.fire('SetContent', {\r\n          content: args.content,\r\n          format: 'html',\r\n          selection: true,\r\n          paste: details.paste\r\n        });\r\n        return;\r\n      }\r\n      value = args.content;\r\n      if (value.indexOf('{$caret}') === -1) {\r\n        value += '{$caret}';\r\n      }\r\n      value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\r\n      rng = selection.getRng();\r\n      var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);\r\n      var body = editor.getBody();\r\n      if (caretElement === body && selection.isCollapsed()) {\r\n        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\r\n          rng = dom.createRng();\r\n          rng.setStart(body.firstChild, 0);\r\n          rng.setEnd(body.firstChild, 0);\r\n          selection.setRng(rng);\r\n        }\r\n      }\r\n      if (!selection.isCollapsed()) {\r\n        deleteSelectedContent(editor);\r\n      }\r\n      parentNode = selection.getNode();\r\n      var parserArgs = {\r\n        context: parentNode.nodeName.toLowerCase(),\r\n        data: details.data,\r\n        insert: true\r\n      };\r\n      var fragment = parser.parse(value, parserArgs);\r\n      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\r\n        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\r\n        selection.setRng(rng);\r\n        editor.fire('SetContent', args);\r\n        return;\r\n      }\r\n      markFragmentElements(fragment);\r\n      node = fragment.lastChild;\r\n      if (node.attr('id') === 'mce_marker') {\r\n        var marker = node;\r\n        for (node = node.prev; node; node = node.walk(true)) {\r\n          if (node.type === 3 || !dom.isBlock(node.name)) {\r\n            if (editor.schema.isValidChild(node.parent.name, 'span')) {\r\n              node.parent.insert(marker, node, node.name === 'br');\r\n            }\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      editor._selectionOverrides.showBlockCaretContainer(parentNode);\r\n      if (!parserArgs.invalid) {\r\n        value = serializer.serialize(fragment);\r\n        validInsertion(editor, value, parentNode);\r\n      } else {\r\n        editor.selection.setContent(bookmarkHtml);\r\n        parentNode = selection.getNode();\r\n        var rootNode = editor.getBody();\r\n        if (parentNode.nodeType === 9) {\r\n          parentNode = node = rootNode;\r\n        } else {\r\n          node = parentNode;\r\n        }\r\n        while (node !== rootNode) {\r\n          parentNode = node;\r\n          node = node.parentNode;\r\n        }\r\n        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\r\n        value = serializer.serialize(parser.parse(value.replace(/<span (id=\"mce_marker\"|id=mce_marker).+?<\\/span>/i, function () {\r\n          return serializer.serialize(fragment);\r\n        })));\r\n        if (parentNode === rootNode) {\r\n          dom.setHTML(rootNode, value);\r\n        } else {\r\n          dom.setOuterHTML(parentNode, value);\r\n        }\r\n      }\r\n      reduceInlineTextElements(editor, merge);\r\n      moveSelectionToMarker(editor, dom.get('mce_marker'));\r\n      unmarkFragmentElements(editor.getBody());\r\n      trimBrsFromTableCell(dom, selection.getStart());\r\n      editor.fire('SetContent', args);\r\n      editor.addVisual();\r\n    };\r\n\r\n    var traverse = function (node, fn) {\r\n      fn(node);\r\n      if (node.firstChild) {\r\n        traverse(node.firstChild, fn);\r\n      }\r\n      if (node.next) {\r\n        traverse(node.next, fn);\r\n      }\r\n    };\r\n    var findMatchingNodes = function (nodeFilters, attributeFilters, node) {\r\n      var nodeMatches = {};\r\n      var attrMatches = {};\r\n      var matches = [];\r\n      if (node.firstChild) {\r\n        traverse(node.firstChild, function (node) {\r\n          each$k(nodeFilters, function (filter) {\r\n            if (filter.name === node.name) {\r\n              if (nodeMatches[filter.name]) {\r\n                nodeMatches[filter.name].nodes.push(node);\r\n              } else {\r\n                nodeMatches[filter.name] = {\r\n                  filter: filter,\r\n                  nodes: [node]\r\n                };\r\n              }\r\n            }\r\n          });\r\n          each$k(attributeFilters, function (filter) {\r\n            if (typeof node.attr(filter.name) === 'string') {\r\n              if (attrMatches[filter.name]) {\r\n                attrMatches[filter.name].nodes.push(node);\r\n              } else {\r\n                attrMatches[filter.name] = {\r\n                  filter: filter,\r\n                  nodes: [node]\r\n                };\r\n              }\r\n            }\r\n          });\r\n        });\r\n      }\r\n      for (var name_1 in nodeMatches) {\r\n        if (has$2(nodeMatches, name_1)) {\r\n          matches.push(nodeMatches[name_1]);\r\n        }\r\n      }\r\n      for (var name_2 in attrMatches) {\r\n        if (has$2(attrMatches, name_2)) {\r\n          matches.push(attrMatches[name_2]);\r\n        }\r\n      }\r\n      return matches;\r\n    };\r\n    var filter$1 = function (nodeFilters, attributeFilters, node) {\r\n      var matches = findMatchingNodes(nodeFilters, attributeFilters, node);\r\n      each$k(matches, function (match) {\r\n        each$k(match.filter.callbacks, function (callback) {\r\n          callback(match.nodes, match.filter.name, {});\r\n        });\r\n      });\r\n    };\r\n\r\n    var defaultFormat$1 = 'html';\r\n    var isTreeNode = function (content) {\r\n      return content instanceof AstNode;\r\n    };\r\n    var moveSelection = function (editor) {\r\n      if (hasFocus(editor)) {\r\n        firstPositionIn(editor.getBody()).each(function (pos) {\r\n          var node = pos.getNode();\r\n          var caretPos = isTable$3(node) ? firstPositionIn(node).getOr(pos) : pos;\r\n          editor.selection.setRng(caretPos.toRange());\r\n        });\r\n      }\r\n    };\r\n    var setEditorHtml = function (editor, html, noSelection) {\r\n      editor.dom.setHTML(editor.getBody(), html);\r\n      if (noSelection !== true) {\r\n        moveSelection(editor);\r\n      }\r\n    };\r\n    var setContentString = function (editor, body, content, args) {\r\n      if (content.length === 0 || /^\\s+$/.test(content)) {\r\n        var padd = '<br data-mce-bogus=\"1\">';\r\n        if (body.nodeName === 'TABLE') {\r\n          content = '<tr><td>' + padd + '</td></tr>';\r\n        } else if (/^(UL|OL)$/.test(body.nodeName)) {\r\n          content = '<li>' + padd + '</li>';\r\n        }\r\n        var forcedRootBlockName = getForcedRootBlock(editor);\r\n        if (forcedRootBlockName && editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\r\n          content = padd;\r\n          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\r\n        } else if (!content) {\r\n          content = '<br data-mce-bogus=\"1\">';\r\n        }\r\n        setEditorHtml(editor, content, args.no_selection);\r\n        editor.fire('SetContent', args);\r\n      } else {\r\n        if (args.format !== 'raw') {\r\n          content = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(editor.parser.parse(content, {\r\n            isRootContent: true,\r\n            insert: true\r\n          }));\r\n        }\r\n        args.content = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\r\n        setEditorHtml(editor, args.content, args.no_selection);\r\n        if (!args.no_events) {\r\n          editor.fire('SetContent', args);\r\n        }\r\n      }\r\n      return args.content;\r\n    };\r\n    var setContentTree = function (editor, body, content, args) {\r\n      filter$1(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\r\n      var html = HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(content);\r\n      args.content = isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html);\r\n      setEditorHtml(editor, args.content, args.no_selection);\r\n      if (!args.no_events) {\r\n        editor.fire('SetContent', args);\r\n      }\r\n      return content;\r\n    };\r\n    var setupArgs$2 = function (args, content) {\r\n      return __assign(__assign({ format: defaultFormat$1 }, args), {\r\n        set: true,\r\n        content: isTreeNode(content) ? '' : content\r\n      });\r\n    };\r\n    var setContentInternal = function (editor, content, args) {\r\n      var defaultedArgs = setupArgs$2(args, content);\r\n      var updatedArgs = args.no_events ? defaultedArgs : editor.fire('BeforeSetContent', defaultedArgs);\r\n      if (!isTreeNode(content)) {\r\n        content = updatedArgs.content;\r\n      }\r\n      return Optional.from(editor.getBody()).fold(constant(content), function (body) {\r\n        return isTreeNode(content) ? setContentTree(editor, body, content, updatedArgs) : setContentString(editor, body, content, updatedArgs);\r\n      });\r\n    };\r\n\r\n    var sibling = function (scope, predicate) {\r\n      return sibling$2(scope, predicate).isSome();\r\n    };\r\n\r\n    var ensureIsRoot = function (isRoot) {\r\n      return isFunction(isRoot) ? isRoot : never;\r\n    };\r\n    var ancestor = function (scope, transform, isRoot) {\r\n      var element = scope.dom;\r\n      var stop = ensureIsRoot(isRoot);\r\n      while (element.parentNode) {\r\n        element = element.parentNode;\r\n        var el = SugarElement.fromDom(element);\r\n        var transformed = transform(el);\r\n        if (transformed.isSome()) {\r\n          return transformed;\r\n        } else if (stop(el)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var closest$1 = function (scope, transform, isRoot) {\r\n      var current = transform(scope);\r\n      var stop = ensureIsRoot(isRoot);\r\n      return current.orThunk(function () {\r\n        return stop(scope) ? Optional.none() : ancestor(scope, transform, stop);\r\n      });\r\n    };\r\n\r\n    var isEq$3 = isEq$5;\r\n    var matchesUnInheritedFormatSelector = function (ed, node, name) {\r\n      var formatList = ed.formatter.get(name);\r\n      if (formatList) {\r\n        for (var i = 0; i < formatList.length; i++) {\r\n          var format = formatList[i];\r\n          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var matchParents = function (editor, node, name, vars, similar) {\r\n      var root = editor.dom.getRoot();\r\n      if (node === root) {\r\n        return false;\r\n      }\r\n      node = editor.dom.getParent(node, function (node) {\r\n        if (matchesUnInheritedFormatSelector(editor, node, name)) {\r\n          return true;\r\n        }\r\n        return node.parentNode === root || !!matchNode(editor, node, name, vars, true);\r\n      });\r\n      return !!matchNode(editor, node, name, vars, similar);\r\n    };\r\n    var matchName$1 = function (dom, node, format) {\r\n      if (isEq$3(node, format.inline)) {\r\n        return true;\r\n      }\r\n      if (isEq$3(node, format.block)) {\r\n        return true;\r\n      }\r\n      if (format.selector) {\r\n        return node.nodeType === 1 && dom.is(node, format.selector);\r\n      }\r\n    };\r\n    var matchItems = function (dom, node, format, itemName, similar, vars) {\r\n      var items = format[itemName];\r\n      if (isFunction(format.onmatch)) {\r\n        return format.onmatch(node, format, itemName);\r\n      }\r\n      if (items) {\r\n        if (isUndefined(items.length)) {\r\n          for (var key in items) {\r\n            if (has$2(items, key)) {\r\n              var value = itemName === 'attributes' ? dom.getAttrib(node, key) : getStyle(dom, node, key);\r\n              var expectedValue = replaceVars(items[key], vars);\r\n              var isEmptyValue = isNullable(value) || isEmpty$3(value);\r\n              if (isEmptyValue && isNullable(expectedValue)) {\r\n                continue;\r\n              }\r\n              if (similar && isEmptyValue && !format.exact) {\r\n                return false;\r\n              }\r\n              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(dom, expectedValue, key))) {\r\n                return false;\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          for (var i = 0; i < items.length; i++) {\r\n            if (itemName === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    var matchNode = function (ed, node, name, vars, similar) {\r\n      var formatList = ed.formatter.get(name);\r\n      var dom = ed.dom;\r\n      if (formatList && node) {\r\n        for (var i = 0; i < formatList.length; i++) {\r\n          var format = formatList[i];\r\n          if (matchName$1(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\r\n            var classes = format.classes;\r\n            if (classes) {\r\n              for (var x = 0; x < classes.length; x++) {\r\n                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\r\n                  return;\r\n                }\r\n              }\r\n            }\r\n            return format;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var match$2 = function (editor, name, vars, node, similar) {\r\n      if (node) {\r\n        return matchParents(editor, node, name, vars, similar);\r\n      }\r\n      node = editor.selection.getNode();\r\n      if (matchParents(editor, node, name, vars, similar)) {\r\n        return true;\r\n      }\r\n      var startNode = editor.selection.getStart();\r\n      if (startNode !== node) {\r\n        if (matchParents(editor, startNode, name, vars, similar)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var matchAll = function (editor, names, vars) {\r\n      var matchedFormatNames = [];\r\n      var checkedMap = {};\r\n      var startElement = editor.selection.getStart();\r\n      editor.dom.getParent(startElement, function (node) {\r\n        for (var i = 0; i < names.length; i++) {\r\n          var name_1 = names[i];\r\n          if (!checkedMap[name_1] && matchNode(editor, node, name_1, vars)) {\r\n            checkedMap[name_1] = true;\r\n            matchedFormatNames.push(name_1);\r\n          }\r\n        }\r\n      }, editor.dom.getRoot());\r\n      return matchedFormatNames;\r\n    };\r\n    var closest = function (editor, names) {\r\n      var isRoot = function (elm) {\r\n        return eq(elm, SugarElement.fromDom(editor.getBody()));\r\n      };\r\n      var match = function (elm, name) {\r\n        return matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\r\n      };\r\n      return Optional.from(editor.selection.getStart(true)).bind(function (rawElm) {\r\n        return closest$1(SugarElement.fromDom(rawElm), function (elm) {\r\n          return findMap(names, function (name) {\r\n            return match(elm, name);\r\n          });\r\n        }, isRoot);\r\n      }).getOrNull();\r\n    };\r\n    var canApply = function (editor, name) {\r\n      var formatList = editor.formatter.get(name);\r\n      var dom = editor.dom;\r\n      if (formatList) {\r\n        var startNode = editor.selection.getStart();\r\n        var parents = getParents$2(dom, startNode);\r\n        for (var x = formatList.length - 1; x >= 0; x--) {\r\n          var format = formatList[x];\r\n          if (!isSelectorFormat(format) || isNonNullable(format.defaultBlock)) {\r\n            return true;\r\n          }\r\n          for (var i = parents.length - 1; i >= 0; i--) {\r\n            if (dom.is(parents[i], format.selector)) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var matchAllOnNode = function (editor, node, formatNames) {\r\n      return foldl(formatNames, function (acc, name) {\r\n        var matchSimilar = isVariableFormatName(editor, name);\r\n        if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\r\n          return acc.concat([name]);\r\n        } else {\r\n          return acc;\r\n        }\r\n      }, []);\r\n    };\r\n\r\n    var ZWSP = ZWSP$1, CARET_ID = '_mce_caret';\r\n    var importNode = function (ownerDocument, node) {\r\n      return ownerDocument.importNode(node, true);\r\n    };\r\n    var getEmptyCaretContainers = function (node) {\r\n      var nodes = [];\r\n      while (node) {\r\n        if (node.nodeType === 3 && node.nodeValue !== ZWSP || node.childNodes.length > 1) {\r\n          return [];\r\n        }\r\n        if (node.nodeType === 1) {\r\n          nodes.push(node);\r\n        }\r\n        node = node.firstChild;\r\n      }\r\n      return nodes;\r\n    };\r\n    var isCaretContainerEmpty = function (node) {\r\n      return getEmptyCaretContainers(node).length > 0;\r\n    };\r\n    var findFirstTextNode = function (node) {\r\n      if (node) {\r\n        var walker = new DomTreeWalker(node, node);\r\n        for (node = walker.current(); node; node = walker.next()) {\r\n          if (isText$7(node)) {\r\n            return node;\r\n          }\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    var createCaretContainer = function (fill) {\r\n      var caretContainer = SugarElement.fromTag('span');\r\n      setAll$1(caretContainer, {\r\n        'id': CARET_ID,\r\n        'data-mce-bogus': '1',\r\n        'data-mce-type': 'format-caret'\r\n      });\r\n      if (fill) {\r\n        append$1(caretContainer, SugarElement.fromText(ZWSP));\r\n      }\r\n      return caretContainer;\r\n    };\r\n    var trimZwspFromCaretContainer = function (caretContainerNode) {\r\n      var textNode = findFirstTextNode(caretContainerNode);\r\n      if (textNode && textNode.nodeValue.charAt(0) === ZWSP) {\r\n        textNode.deleteData(0, 1);\r\n      }\r\n      return textNode;\r\n    };\r\n    var removeCaretContainerNode = function (editor, node, moveCaret) {\r\n      if (moveCaret === void 0) {\r\n        moveCaret = true;\r\n      }\r\n      var dom = editor.dom, selection = editor.selection;\r\n      if (isCaretContainerEmpty(node)) {\r\n        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret);\r\n      } else {\r\n        var rng = selection.getRng();\r\n        var block = dom.getParent(node, dom.isBlock);\r\n        var startContainer = rng.startContainer;\r\n        var startOffset = rng.startOffset;\r\n        var endContainer = rng.endContainer;\r\n        var endOffset = rng.endOffset;\r\n        var textNode = trimZwspFromCaretContainer(node);\r\n        dom.remove(node, true);\r\n        if (startContainer === textNode && startOffset > 0) {\r\n          rng.setStart(textNode, startOffset - 1);\r\n        }\r\n        if (endContainer === textNode && endOffset > 0) {\r\n          rng.setEnd(textNode, endOffset - 1);\r\n        }\r\n        if (block && dom.isEmpty(block)) {\r\n          fillWithPaddingBr(SugarElement.fromDom(block));\r\n        }\r\n        selection.setRng(rng);\r\n      }\r\n    };\r\n    var removeCaretContainer = function (editor, node, moveCaret) {\r\n      if (moveCaret === void 0) {\r\n        moveCaret = true;\r\n      }\r\n      var dom = editor.dom, selection = editor.selection;\r\n      if (!node) {\r\n        node = getParentCaretContainer(editor.getBody(), selection.getStart());\r\n        if (!node) {\r\n          while (node = dom.get(CARET_ID)) {\r\n            removeCaretContainerNode(editor, node, false);\r\n          }\r\n        }\r\n      } else {\r\n        removeCaretContainerNode(editor, node, moveCaret);\r\n      }\r\n    };\r\n    var insertCaretContainerNode = function (editor, caretContainer, formatNode) {\r\n      var dom = editor.dom, block = dom.getParent(formatNode, curry(isTextBlock$1, editor));\r\n      if (block && dom.isEmpty(block)) {\r\n        formatNode.parentNode.replaceChild(caretContainer, formatNode);\r\n      } else {\r\n        removeTrailingBr(SugarElement.fromDom(formatNode));\r\n        if (dom.isEmpty(formatNode)) {\r\n          formatNode.parentNode.replaceChild(caretContainer, formatNode);\r\n        } else {\r\n          dom.insertAfter(caretContainer, formatNode);\r\n        }\r\n      }\r\n    };\r\n    var appendNode = function (parentNode, node) {\r\n      parentNode.appendChild(node);\r\n      return node;\r\n    };\r\n    var insertFormatNodesIntoCaretContainer = function (formatNodes, caretContainer) {\r\n      var innerMostFormatNode = foldr(formatNodes, function (parentNode, formatNode) {\r\n        return appendNode(parentNode, formatNode.cloneNode(false));\r\n      }, caretContainer);\r\n      return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP));\r\n    };\r\n    var cleanFormatNode = function (editor, caretContainer, formatNode, name, vars, similar) {\r\n      var formatter = editor.formatter;\r\n      var dom = editor.dom;\r\n      var validFormats = filter$4(keys(formatter.get()), function (formatName) {\r\n        return formatName !== name && !contains$2(formatName, 'removeformat');\r\n      });\r\n      var matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\r\n      var uniqueFormats = filter$4(matchedFormats, function (fmtName) {\r\n        return !areSimilarFormats(editor, fmtName, name);\r\n      });\r\n      if (uniqueFormats.length > 0) {\r\n        var clonedFormatNode = formatNode.cloneNode(false);\r\n        dom.add(caretContainer, clonedFormatNode);\r\n        formatter.remove(name, vars, clonedFormatNode, similar);\r\n        dom.remove(clonedFormatNode);\r\n        return Optional.some(clonedFormatNode);\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var applyCaretFormat = function (editor, name, vars) {\r\n      var caretContainer, textNode;\r\n      var selection = editor.selection;\r\n      var selectionRng = selection.getRng();\r\n      var offset = selectionRng.startOffset;\r\n      var container = selectionRng.startContainer;\r\n      var text = container.nodeValue;\r\n      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\r\n      if (caretContainer) {\r\n        textNode = findFirstTextNode(caretContainer);\r\n      }\r\n      var wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\r\n      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\r\n        var bookmark = selection.getBookmark();\r\n        selectionRng.collapse(true);\r\n        var rng = expandRng(editor, selectionRng, editor.formatter.get(name));\r\n        rng = split(rng);\r\n        editor.formatter.apply(name, vars, rng);\r\n        selection.moveToBookmark(bookmark);\r\n      } else {\r\n        if (!caretContainer || textNode.nodeValue !== ZWSP) {\r\n          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\r\n          textNode = caretContainer.firstChild;\r\n          selectionRng.insertNode(caretContainer);\r\n          offset = 1;\r\n          editor.formatter.apply(name, vars, caretContainer);\r\n        } else {\r\n          editor.formatter.apply(name, vars, caretContainer);\r\n        }\r\n        selection.setCursorLocation(textNode, offset);\r\n      }\r\n    };\r\n    var removeCaretFormat = function (editor, name, vars, similar) {\r\n      var dom = editor.dom;\r\n      var selection = editor.selection;\r\n      var hasContentAfter, node, formatNode;\r\n      var parents = [];\r\n      var rng = selection.getRng();\r\n      var container = rng.startContainer;\r\n      var offset = rng.startOffset;\r\n      node = container;\r\n      if (container.nodeType === 3) {\r\n        if (offset !== container.nodeValue.length) {\r\n          hasContentAfter = true;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      while (node) {\r\n        if (matchNode(editor, node, name, vars, similar)) {\r\n          formatNode = node;\r\n          break;\r\n        }\r\n        if (node.nextSibling) {\r\n          hasContentAfter = true;\r\n        }\r\n        parents.push(node);\r\n        node = node.parentNode;\r\n      }\r\n      if (!formatNode) {\r\n        return;\r\n      }\r\n      if (hasContentAfter) {\r\n        var bookmark = selection.getBookmark();\r\n        rng.collapse(true);\r\n        var expandedRng = expandRng(editor, rng, editor.formatter.get(name), true);\r\n        expandedRng = split(expandedRng);\r\n        editor.formatter.remove(name, vars, expandedRng, similar);\r\n        selection.moveToBookmark(bookmark);\r\n      } else {\r\n        var caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\r\n        var newCaretContainer = createCaretContainer(false).dom;\r\n        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null ? caretContainer : formatNode);\r\n        var cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\r\n        var caretTextNode = insertFormatNodesIntoCaretContainer(parents.concat(cleanedFormatNode.toArray()), newCaretContainer);\r\n        removeCaretContainerNode(editor, caretContainer, false);\r\n        selection.setCursorLocation(caretTextNode, 1);\r\n        if (dom.isEmpty(formatNode)) {\r\n          dom.remove(formatNode);\r\n        }\r\n      }\r\n    };\r\n    var disableCaretContainer = function (editor, keyCode) {\r\n      var selection = editor.selection, body = editor.getBody();\r\n      removeCaretContainer(editor, null, false);\r\n      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\r\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));\r\n      }\r\n      if (keyCode === 37 || keyCode === 39) {\r\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));\r\n      }\r\n    };\r\n    var setup$k = function (editor) {\r\n      editor.on('mouseup keydown', function (e) {\r\n        disableCaretContainer(editor, e.keyCode);\r\n      });\r\n    };\r\n    var replaceWithCaretFormat = function (targetNode, formatNodes) {\r\n      var caretContainer = createCaretContainer(false);\r\n      var innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\r\n      before$4(SugarElement.fromDom(targetNode), caretContainer);\r\n      remove$7(SugarElement.fromDom(targetNode));\r\n      return CaretPosition(innerMost, 0);\r\n    };\r\n    var isFormatElement = function (editor, element) {\r\n      var inlineElements = editor.schema.getTextInlineElements();\r\n      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);\r\n    };\r\n    var isEmptyCaretFormatElement = function (element) {\r\n      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\r\n    };\r\n\r\n    var postProcessHooks = {};\r\n    var filter = filter$2;\r\n    var each$c = each$i;\r\n    var addPostProcessHook = function (name, hook) {\r\n      var hooks = postProcessHooks[name];\r\n      if (!hooks) {\r\n        postProcessHooks[name] = [];\r\n      }\r\n      postProcessHooks[name].push(hook);\r\n    };\r\n    var postProcess$1 = function (name, editor) {\r\n      each$c(postProcessHooks[name], function (hook) {\r\n        hook(editor);\r\n      });\r\n    };\r\n    addPostProcessHook('pre', function (editor) {\r\n      var rng = editor.selection.getRng();\r\n      var blocks;\r\n      var hasPreSibling = function (pre) {\r\n        return isPre(pre.previousSibling) && indexOf$1(blocks, pre.previousSibling) !== -1;\r\n      };\r\n      var joinPre = function (pre1, pre2) {\r\n        DomQuery(pre2).remove();\r\n        DomQuery(pre1).append('<br><br>').append(pre2.childNodes);\r\n      };\r\n      var isPre = matchNodeNames(['pre']);\r\n      if (!rng.collapsed) {\r\n        blocks = editor.selection.getSelectedBlocks();\r\n        each$c(filter(filter(blocks, isPre), hasPreSibling), function (pre) {\r\n          joinPre(pre.previousSibling, pre);\r\n        });\r\n      }\r\n    });\r\n\r\n    var each$b = Tools.each;\r\n    var isElementNode$1 = function (node) {\r\n      return isElement$5(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\r\n    };\r\n    var findElementSibling = function (node, siblingName) {\r\n      for (var sibling = node; sibling; sibling = sibling[siblingName]) {\r\n        if (isText$7(sibling) && isNotEmpty(sibling.data)) {\r\n          return node;\r\n        }\r\n        if (isElement$5(sibling) && !isBookmarkNode$1(sibling)) {\r\n          return sibling;\r\n        }\r\n      }\r\n      return node;\r\n    };\r\n    var mergeSiblingsNodes = function (dom, prev, next) {\r\n      var elementUtils = ElementUtils(dom);\r\n      if (prev && next) {\r\n        prev = findElementSibling(prev, 'previousSibling');\r\n        next = findElementSibling(next, 'nextSibling');\r\n        if (elementUtils.compare(prev, next)) {\r\n          for (var sibling = prev.nextSibling; sibling && sibling !== next;) {\r\n            var tmpSibling = sibling;\r\n            sibling = sibling.nextSibling;\r\n            prev.appendChild(tmpSibling);\r\n          }\r\n          dom.remove(next);\r\n          Tools.each(Tools.grep(next.childNodes), function (node) {\r\n            prev.appendChild(node);\r\n          });\r\n          return prev;\r\n        }\r\n      }\r\n      return next;\r\n    };\r\n    var mergeSiblings = function (dom, format, vars, node) {\r\n      if (node && format.merge_siblings !== false) {\r\n        var newNode = mergeSiblingsNodes(dom, getNonWhiteSpaceSibling(node), node);\r\n        mergeSiblingsNodes(dom, newNode, getNonWhiteSpaceSibling(newNode, true));\r\n      }\r\n    };\r\n    var clearChildStyles = function (dom, format, node) {\r\n      if (format.clear_child_styles) {\r\n        var selector = format.links ? '*:not(a)' : '*';\r\n        each$b(dom.select(selector, node), function (node) {\r\n          if (isElementNode$1(node)) {\r\n            each$b(format.styles, function (value, name) {\r\n              dom.setStyle(node, name, '');\r\n            });\r\n          }\r\n        });\r\n      }\r\n    };\r\n    var processChildElements = function (node, filter, process) {\r\n      each$b(node.childNodes, function (node) {\r\n        if (isElementNode$1(node)) {\r\n          if (filter(node)) {\r\n            process(node);\r\n          }\r\n          if (node.hasChildNodes()) {\r\n            processChildElements(node, filter, process);\r\n          }\r\n        }\r\n      });\r\n    };\r\n    var unwrapEmptySpan = function (dom, node) {\r\n      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\r\n        dom.remove(node, true);\r\n      }\r\n    };\r\n    var hasStyle = function (dom, name) {\r\n      return function (node) {\r\n        return !!(node && getStyle(dom, node, name));\r\n      };\r\n    };\r\n    var applyStyle = function (dom, name, value) {\r\n      return function (node) {\r\n        dom.setStyle(node, name, value);\r\n        if (node.getAttribute('style') === '') {\r\n          node.removeAttribute('style');\r\n        }\r\n        unwrapEmptySpan(dom, node);\r\n      };\r\n    };\r\n\r\n    var removeResult = Adt.generate([\r\n      { keep: [] },\r\n      { rename: ['name'] },\r\n      { removed: [] }\r\n    ]);\r\n    var MCE_ATTR_RE = /^(src|href|style)$/;\r\n    var each$a = Tools.each;\r\n    var isEq$2 = isEq$5;\r\n    var isTableCellOrRow = function (node) {\r\n      return /^(TR|TH|TD)$/.test(node.nodeName);\r\n    };\r\n    var isChildOfInlineParent = function (dom, node, parent) {\r\n      return dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\r\n    };\r\n    var getContainer = function (ed, rng, start) {\r\n      var container = rng[start ? 'startContainer' : 'endContainer'];\r\n      var offset = rng[start ? 'startOffset' : 'endOffset'];\r\n      if (isElement$5(container)) {\r\n        var lastIdx = container.childNodes.length - 1;\r\n        if (!start && offset) {\r\n          offset--;\r\n        }\r\n        container = container.childNodes[offset > lastIdx ? lastIdx : offset];\r\n      }\r\n      if (isText$7(container) && start && offset >= container.nodeValue.length) {\r\n        container = new DomTreeWalker(container, ed.getBody()).next() || container;\r\n      }\r\n      if (isText$7(container) && !start && offset === 0) {\r\n        container = new DomTreeWalker(container, ed.getBody()).prev() || container;\r\n      }\r\n      return container;\r\n    };\r\n    var normalizeTableSelection = function (node, start) {\r\n      var prop = start ? 'firstChild' : 'lastChild';\r\n      if (isTableCellOrRow(node) && node[prop]) {\r\n        var childNode = node[prop];\r\n        if (node.nodeName === 'TR') {\r\n          return childNode[prop] || childNode;\r\n        } else {\r\n          return childNode;\r\n        }\r\n      }\r\n      return node;\r\n    };\r\n    var wrap$1 = function (dom, node, name, attrs) {\r\n      var wrapper = dom.create(name, attrs);\r\n      node.parentNode.insertBefore(wrapper, node);\r\n      wrapper.appendChild(node);\r\n      return wrapper;\r\n    };\r\n    var wrapWithSiblings = function (dom, node, next, name, attrs) {\r\n      var start = SugarElement.fromDom(node);\r\n      var wrapper = SugarElement.fromDom(dom.create(name, attrs));\r\n      var siblings = next ? nextSiblings(start) : prevSiblings(start);\r\n      append(wrapper, siblings);\r\n      if (next) {\r\n        before$4(start, wrapper);\r\n        prepend(wrapper, start);\r\n      } else {\r\n        after$3(start, wrapper);\r\n        append$1(wrapper, start);\r\n      }\r\n      return wrapper.dom;\r\n    };\r\n    var matchName = function (dom, node, format) {\r\n      if (isInlineFormat(format) && isEq$2(node, format.inline)) {\r\n        return true;\r\n      }\r\n      if (isBlockFormat(format) && isEq$2(node, format.block)) {\r\n        return true;\r\n      }\r\n      if (isSelectorFormat(format)) {\r\n        return isElement$5(node) && dom.is(node, format.selector);\r\n      }\r\n    };\r\n    var isColorFormatAndAnchor = function (node, format) {\r\n      return format.links && node.nodeName === 'A';\r\n    };\r\n    var find = function (dom, node, next, inc) {\r\n      var sibling = getNonWhiteSpaceSibling(node, next, inc);\r\n      return isNullable(sibling) || sibling.nodeName === 'BR' || dom.isBlock(sibling);\r\n    };\r\n    var removeNode = function (ed, node, format) {\r\n      var parentNode = node.parentNode;\r\n      var rootBlockElm;\r\n      var dom = ed.dom, forcedRootBlock = getForcedRootBlock(ed);\r\n      if (isBlockFormat(format)) {\r\n        if (!forcedRootBlock) {\r\n          if (dom.isBlock(node) && !dom.isBlock(parentNode)) {\r\n            if (!find(dom, node, false) && !find(dom, node.firstChild, true, true)) {\r\n              node.insertBefore(dom.create('br'), node.firstChild);\r\n            }\r\n            if (!find(dom, node, true) && !find(dom, node.lastChild, false, true)) {\r\n              node.appendChild(dom.create('br'));\r\n            }\r\n          }\r\n        } else {\r\n          if (parentNode === dom.getRoot()) {\r\n            if (!format.list_block || !isEq$2(node, format.list_block)) {\r\n              each$k(from(node.childNodes), function (node) {\r\n                if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\r\n                  if (!rootBlockElm) {\r\n                    rootBlockElm = wrap$1(dom, node, forcedRootBlock);\r\n                    dom.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);\r\n                  } else {\r\n                    rootBlockElm.appendChild(node);\r\n                  }\r\n                } else {\r\n                  rootBlockElm = null;\r\n                }\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\r\n        return;\r\n      }\r\n      dom.remove(node, true);\r\n    };\r\n    var removeFormatInternal = function (ed, format, vars, node, compareNode) {\r\n      var stylesModified;\r\n      var dom = ed.dom;\r\n      if (!matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\r\n        return removeResult.keep();\r\n      }\r\n      var elm = node;\r\n      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(format.preserve_attributes)) {\r\n        var attrsToPreserve = filter$4(dom.getAttribs(elm), function (attr) {\r\n          return contains$3(format.preserve_attributes, attr.name.toLowerCase());\r\n        });\r\n        dom.removeAllAttribs(elm);\r\n        each$k(attrsToPreserve, function (attr) {\r\n          return dom.setAttrib(elm, attr.name, attr.value);\r\n        });\r\n        if (attrsToPreserve.length > 0) {\r\n          return removeResult.rename('span');\r\n        }\r\n      }\r\n      if (format.remove !== 'all') {\r\n        each$a(format.styles, function (value, name) {\r\n          value = normalizeStyleValue(dom, replaceVars(value, vars), name + '');\r\n          if (isNumber(name)) {\r\n            name = value;\r\n            compareNode = null;\r\n          }\r\n          if (format.remove_similar || (!compareNode || isEq$2(getStyle(dom, compareNode, name), value))) {\r\n            dom.setStyle(elm, name, '');\r\n          }\r\n          stylesModified = true;\r\n        });\r\n        if (stylesModified && dom.getAttrib(elm, 'style') === '') {\r\n          elm.removeAttribute('style');\r\n          elm.removeAttribute('data-mce-style');\r\n        }\r\n        each$a(format.attributes, function (value, name) {\r\n          var valueOut;\r\n          value = replaceVars(value, vars);\r\n          if (isNumber(name)) {\r\n            name = value;\r\n            compareNode = null;\r\n          }\r\n          if (format.remove_similar || (!compareNode || isEq$2(dom.getAttrib(compareNode, name), value))) {\r\n            if (name === 'class') {\r\n              value = dom.getAttrib(elm, name);\r\n              if (value) {\r\n                valueOut = '';\r\n                each$k(value.split(/\\s+/), function (cls) {\r\n                  if (/mce\\-\\w+/.test(cls)) {\r\n                    valueOut += (valueOut ? ' ' : '') + cls;\r\n                  }\r\n                });\r\n                if (valueOut) {\r\n                  dom.setAttrib(elm, name, valueOut);\r\n                  return;\r\n                }\r\n              }\r\n            }\r\n            if (MCE_ATTR_RE.test(name)) {\r\n              elm.removeAttribute('data-mce-' + name);\r\n            }\r\n            if (name === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\r\n              elm.removeAttribute(name);\r\n              dom.setStyle(elm, 'list-style-type', 'none');\r\n              return;\r\n            }\r\n            if (name === 'class') {\r\n              elm.removeAttribute('className');\r\n            }\r\n            elm.removeAttribute(name);\r\n          }\r\n        });\r\n        each$a(format.classes, function (value) {\r\n          value = replaceVars(value, vars);\r\n          if (!compareNode || dom.hasClass(compareNode, value)) {\r\n            dom.removeClass(elm, value);\r\n          }\r\n        });\r\n        var attrs = dom.getAttribs(elm);\r\n        for (var i = 0; i < attrs.length; i++) {\r\n          var attrName = attrs[i].nodeName;\r\n          if (attrName.indexOf('_') !== 0 && attrName.indexOf('data-') !== 0) {\r\n            return removeResult.keep();\r\n          }\r\n        }\r\n      }\r\n      if (format.remove !== 'none') {\r\n        removeNode(ed, elm, format);\r\n        return removeResult.removed();\r\n      }\r\n      return removeResult.keep();\r\n    };\r\n    var removeFormat$1 = function (ed, format, vars, node, compareNode) {\r\n      return removeFormatInternal(ed, format, vars, node, compareNode).fold(never, function (newName) {\r\n        ed.dom.rename(node, newName);\r\n        return true;\r\n      }, always);\r\n    };\r\n    var findFormatRoot = function (editor, container, name, vars, similar) {\r\n      var formatRoot;\r\n      each$k(getParents$2(editor.dom, container.parentNode).reverse(), function (parent) {\r\n        if (!formatRoot && parent.id !== '_start' && parent.id !== '_end') {\r\n          var format = matchNode(editor, parent, name, vars, similar);\r\n          if (format && format.split !== false) {\r\n            formatRoot = parent;\r\n          }\r\n        }\r\n      });\r\n      return formatRoot;\r\n    };\r\n    var removeFormatFromClone = function (editor, format, vars, clone) {\r\n      return removeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), function (newName) {\r\n        var fragment = editor.dom.createFragment();\r\n        fragment.appendChild(clone);\r\n        return editor.dom.rename(clone, newName);\r\n      }, constant(null));\r\n    };\r\n    var wrapAndSplit = function (editor, formatList, formatRoot, container, target, split, format, vars) {\r\n      var clone, lastClone, firstClone;\r\n      var dom = editor.dom;\r\n      if (formatRoot) {\r\n        var formatRootParent = formatRoot.parentNode;\r\n        for (var parent_1 = container.parentNode; parent_1 && parent_1 !== formatRootParent; parent_1 = parent_1.parentNode) {\r\n          clone = dom.clone(parent_1, false);\r\n          for (var i = 0; i < formatList.length; i++) {\r\n            clone = removeFormatFromClone(editor, formatList[i], vars, clone);\r\n            if (clone === null) {\r\n              break;\r\n            }\r\n          }\r\n          if (clone) {\r\n            if (lastClone) {\r\n              clone.appendChild(lastClone);\r\n            }\r\n            if (!firstClone) {\r\n              firstClone = clone;\r\n            }\r\n            lastClone = clone;\r\n          }\r\n        }\r\n        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\r\n          container = dom.split(formatRoot, container);\r\n        }\r\n        if (lastClone) {\r\n          target.parentNode.insertBefore(lastClone, target);\r\n          firstClone.appendChild(target);\r\n          if (isInlineFormat(format)) {\r\n            mergeSiblings(dom, format, vars, lastClone);\r\n          }\r\n        }\r\n      }\r\n      return container;\r\n    };\r\n    var remove$1 = function (ed, name, vars, node, similar) {\r\n      var formatList = ed.formatter.get(name);\r\n      var format = formatList[0];\r\n      var contentEditable = true;\r\n      var dom = ed.dom;\r\n      var selection = ed.selection;\r\n      var splitToFormatRoot = function (container) {\r\n        var formatRoot = findFormatRoot(ed, container, name, vars, similar);\r\n        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\r\n      };\r\n      var isRemoveBookmarkNode = function (node) {\r\n        return isBookmarkNode$1(node) && isElement$5(node) && (node.id === '_start' || node.id === '_end');\r\n      };\r\n      var removeNodeFormat = function (node) {\r\n        return exists(formatList, function (fmt) {\r\n          return removeFormat$1(ed, fmt, vars, node, node);\r\n        });\r\n      };\r\n      var process = function (node) {\r\n        var lastContentEditable = true;\r\n        var hasContentEditableState = false;\r\n        if (isElement$5(node) && dom.getContentEditable(node)) {\r\n          lastContentEditable = contentEditable;\r\n          contentEditable = dom.getContentEditable(node) === 'true';\r\n          hasContentEditableState = true;\r\n        }\r\n        var children = from(node.childNodes);\r\n        if (contentEditable && !hasContentEditableState) {\r\n          var removed = removeNodeFormat(node);\r\n          var currentNodeMatches = removed || exists(formatList, function (f) {\r\n            return matchName$1(dom, node, f);\r\n          });\r\n          var parentNode = node.parentNode;\r\n          if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\r\n            removeNodeFormat(parentNode);\r\n          }\r\n        }\r\n        if (format.deep) {\r\n          if (children.length) {\r\n            for (var i = 0; i < children.length; i++) {\r\n              process(children[i]);\r\n            }\r\n            if (hasContentEditableState) {\r\n              contentEditable = lastContentEditable;\r\n            }\r\n          }\r\n        }\r\n        var textDecorations = [\r\n          'underline',\r\n          'line-through',\r\n          'overline'\r\n        ];\r\n        each$k(textDecorations, function (decoration) {\r\n          if (isElement$5(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\r\n            removeFormat$1(ed, {\r\n              deep: false,\r\n              exact: true,\r\n              inline: 'span',\r\n              styles: { textDecoration: decoration }\r\n            }, null, node);\r\n          }\r\n        });\r\n      };\r\n      var unwrap = function (start) {\r\n        var node = dom.get(start ? '_start' : '_end');\r\n        var out = node[start ? 'firstChild' : 'lastChild'];\r\n        if (isRemoveBookmarkNode(out)) {\r\n          out = out[start ? 'firstChild' : 'lastChild'];\r\n        }\r\n        if (isText$7(out) && out.data.length === 0) {\r\n          out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\r\n        }\r\n        dom.remove(node, true);\r\n        return out;\r\n      };\r\n      var removeRngStyle = function (rng) {\r\n        var startContainer, endContainer;\r\n        var expandedRng = expandRng(ed, rng, formatList, rng.collapsed);\r\n        if (format.split) {\r\n          expandedRng = split(expandedRng);\r\n          startContainer = getContainer(ed, expandedRng, true);\r\n          endContainer = getContainer(ed, expandedRng);\r\n          if (startContainer !== endContainer) {\r\n            startContainer = normalizeTableSelection(startContainer, true);\r\n            endContainer = normalizeTableSelection(endContainer, false);\r\n            if (isChildOfInlineParent(dom, startContainer, endContainer)) {\r\n              var marker = Optional.from(startContainer.firstChild).getOr(startContainer);\r\n              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\r\n                'id': '_start',\r\n                'data-mce-type': 'bookmark'\r\n              }));\r\n              unwrap(true);\r\n              return;\r\n            }\r\n            if (isChildOfInlineParent(dom, endContainer, startContainer)) {\r\n              var marker = Optional.from(endContainer.lastChild).getOr(endContainer);\r\n              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\r\n                'id': '_end',\r\n                'data-mce-type': 'bookmark'\r\n              }));\r\n              unwrap(false);\r\n              return;\r\n            }\r\n            startContainer = wrap$1(dom, startContainer, 'span', {\r\n              'id': '_start',\r\n              'data-mce-type': 'bookmark'\r\n            });\r\n            endContainer = wrap$1(dom, endContainer, 'span', {\r\n              'id': '_end',\r\n              'data-mce-type': 'bookmark'\r\n            });\r\n            var newRng = dom.createRng();\r\n            newRng.setStartAfter(startContainer);\r\n            newRng.setEndBefore(endContainer);\r\n            walk$2(dom, newRng, function (nodes) {\r\n              each$k(nodes, function (n) {\r\n                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\r\n                  splitToFormatRoot(n);\r\n                }\r\n              });\r\n            });\r\n            splitToFormatRoot(startContainer);\r\n            splitToFormatRoot(endContainer);\r\n            startContainer = unwrap(true);\r\n            endContainer = unwrap();\r\n          } else {\r\n            startContainer = endContainer = splitToFormatRoot(startContainer);\r\n          }\r\n          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\r\n          expandedRng.startOffset = dom.nodeIndex(startContainer);\r\n          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\r\n          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\r\n        }\r\n        walk$2(dom, expandedRng, function (nodes) {\r\n          each$k(nodes, process);\r\n        });\r\n      };\r\n      if (node) {\r\n        if (isNode(node)) {\r\n          var rng = dom.createRng();\r\n          rng.setStartBefore(node);\r\n          rng.setEndAfter(node);\r\n          removeRngStyle(rng);\r\n        } else {\r\n          removeRngStyle(node);\r\n        }\r\n        fireFormatRemove(ed, name, node, vars);\r\n        return;\r\n      }\r\n      if (dom.getContentEditable(selection.getNode()) === 'false') {\r\n        node = selection.getNode();\r\n        for (var i = 0; i < formatList.length; i++) {\r\n          if (formatList[i].ceFalseOverride) {\r\n            if (removeFormat$1(ed, formatList[i], vars, node, node)) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        fireFormatRemove(ed, name, node, vars);\r\n        return;\r\n      }\r\n      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\r\n        preserve(selection, true, function () {\r\n          runOnRanges(ed, removeRngStyle);\r\n        });\r\n        if (isInlineFormat(format) && match$2(ed, name, vars, selection.getStart())) {\r\n          moveStart(dom, selection, selection.getRng());\r\n        }\r\n        ed.nodeChanged();\r\n      } else {\r\n        removeCaretFormat(ed, name, vars, similar);\r\n      }\r\n      fireFormatRemove(ed, name, node, vars);\r\n    };\r\n\r\n    var each$9 = Tools.each;\r\n    var mergeTextDecorationsAndColor = function (dom, format, vars, node) {\r\n      var processTextDecorationsAndColor = function (n) {\r\n        if (n.nodeType === 1 && n.parentNode && n.parentNode.nodeType === 1) {\r\n          var textDecoration = getTextDecoration(dom, n.parentNode);\r\n          if (dom.getStyle(n, 'color') && textDecoration) {\r\n            dom.setStyle(n, 'text-decoration', textDecoration);\r\n          } else if (dom.getStyle(n, 'text-decoration') === textDecoration) {\r\n            dom.setStyle(n, 'text-decoration', null);\r\n          }\r\n        }\r\n      };\r\n      if (format.styles && (format.styles.color || format.styles.textDecoration)) {\r\n        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\r\n        processTextDecorationsAndColor(node);\r\n      }\r\n    };\r\n    var mergeBackgroundColorAndFontSize = function (dom, format, vars, node) {\r\n      if (format.styles && format.styles.backgroundColor) {\r\n        processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\r\n      }\r\n    };\r\n    var mergeSubSup = function (dom, format, vars, node) {\r\n      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\r\n        processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'fontSize', ''));\r\n        dom.remove(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), true);\r\n      }\r\n    };\r\n    var mergeWithChildren = function (editor, formatList, vars, node) {\r\n      each$9(formatList, function (format) {\r\n        if (isInlineFormat(format)) {\r\n          each$9(editor.dom.select(format.inline, node), function (child) {\r\n            if (!isElementNode$1(child)) {\r\n              return;\r\n            }\r\n            removeFormat$1(editor, format, vars, child, format.exact ? child : null);\r\n          });\r\n        }\r\n        clearChildStyles(editor.dom, format, node);\r\n      });\r\n    };\r\n    var mergeWithParents = function (editor, format, name, vars, node) {\r\n      if (matchNode(editor, node.parentNode, name, vars)) {\r\n        if (removeFormat$1(editor, format, vars, node)) {\r\n          return;\r\n        }\r\n      }\r\n      if (format.merge_with_parents) {\r\n        editor.dom.getParent(node.parentNode, function (parent) {\r\n          if (matchNode(editor, parent, name, vars)) {\r\n            removeFormat$1(editor, format, vars, node);\r\n            return true;\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    var each$8 = Tools.each;\r\n    var isElementNode = function (node) {\r\n      return isElement$5(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\r\n    };\r\n    var canFormatBR = function (editor, format, node, parentName) {\r\n      if (canFormatEmptyLines(editor) && isInlineFormat(format)) {\r\n        var validBRParentElements = getTextRootBlockElements(editor.schema);\r\n        var hasCaretNodeSibling = sibling(SugarElement.fromDom(node), function (sibling) {\r\n          return isCaretNode(sibling.dom);\r\n        });\r\n        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var applyFormat$1 = function (ed, name, vars, node) {\r\n      var formatList = ed.formatter.get(name);\r\n      var format = formatList[0];\r\n      var isCollapsed = !node && ed.selection.isCollapsed();\r\n      var dom = ed.dom;\r\n      var selection = ed.selection;\r\n      var setElementFormat = function (elm, fmt) {\r\n        if (fmt === void 0) {\r\n          fmt = format;\r\n        }\r\n        if (isFunction(fmt.onformat)) {\r\n          fmt.onformat(elm, fmt, vars, node);\r\n        }\r\n        each$8(fmt.styles, function (value, name) {\r\n          dom.setStyle(elm, name, replaceVars(value, vars));\r\n        });\r\n        if (fmt.styles) {\r\n          var styleVal = dom.getAttrib(elm, 'style');\r\n          if (styleVal) {\r\n            dom.setAttrib(elm, 'data-mce-style', styleVal);\r\n          }\r\n        }\r\n        each$8(fmt.attributes, function (value, name) {\r\n          dom.setAttrib(elm, name, replaceVars(value, vars));\r\n        });\r\n        each$8(fmt.classes, function (value) {\r\n          value = replaceVars(value, vars);\r\n          if (!dom.hasClass(elm, value)) {\r\n            dom.addClass(elm, value);\r\n          }\r\n        });\r\n      };\r\n      var applyNodeStyle = function (formatList, node) {\r\n        var found = false;\r\n        each$8(formatList, function (format) {\r\n          if (!isSelectorFormat(format)) {\r\n            return false;\r\n          }\r\n          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\r\n            return;\r\n          }\r\n          if (dom.is(node, format.selector) && !isCaretNode(node)) {\r\n            setElementFormat(node, format);\r\n            found = true;\r\n            return false;\r\n          }\r\n        });\r\n        return found;\r\n      };\r\n      var createWrapElement = function (wrapName) {\r\n        if (isString$1(wrapName)) {\r\n          var wrapElm = dom.create(wrapName);\r\n          setElementFormat(wrapElm);\r\n          return wrapElm;\r\n        } else {\r\n          return null;\r\n        }\r\n      };\r\n      var applyRngStyle = function (dom, rng, nodeSpecific) {\r\n        var newWrappers = [];\r\n        var contentEditable = true;\r\n        var wrapName = format.inline || format.block;\r\n        var wrapElm = createWrapElement(wrapName);\r\n        walk$2(dom, rng, function (nodes) {\r\n          var currentWrapElm;\r\n          var process = function (node) {\r\n            var hasContentEditableState = false;\r\n            var lastContentEditable = contentEditable;\r\n            var nodeName = node.nodeName.toLowerCase();\r\n            var parentNode = node.parentNode;\r\n            var parentName = parentNode.nodeName.toLowerCase();\r\n            if (isElement$5(node) && dom.getContentEditable(node)) {\r\n              lastContentEditable = contentEditable;\r\n              contentEditable = dom.getContentEditable(node) === 'true';\r\n              hasContentEditableState = true;\r\n            }\r\n            if (isBr$5(node) && !canFormatBR(ed, format, node, parentName)) {\r\n              currentWrapElm = null;\r\n              if (isBlockFormat(format)) {\r\n                dom.remove(node);\r\n              }\r\n              return;\r\n            }\r\n            if (isBlockFormat(format) && format.wrapper && matchNode(ed, node, name, vars)) {\r\n              currentWrapElm = null;\r\n              return;\r\n            }\r\n            if (contentEditable && !hasContentEditableState && isBlockFormat(format) && !format.wrapper && isTextBlock$1(ed, nodeName) && isValid(ed, parentName, wrapName)) {\r\n              var elm = dom.rename(node, wrapName);\r\n              setElementFormat(elm);\r\n              newWrappers.push(elm);\r\n              currentWrapElm = null;\r\n              return;\r\n            }\r\n            if (isSelectorFormat(format)) {\r\n              var found = applyNodeStyle(formatList, node);\r\n              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\r\n                found = applyNodeStyle(formatList, parentNode);\r\n              }\r\n              if (!isInlineFormat(format) || found) {\r\n                currentWrapElm = null;\r\n                return;\r\n              }\r\n            }\r\n            if (contentEditable && !hasContentEditableState && isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName) && !(!nodeSpecific && isText$7(node) && isZwsp(node.data)) && !isCaretNode(node) && (!isInlineFormat(format) || !dom.isBlock(node))) {\r\n              if (!currentWrapElm) {\r\n                currentWrapElm = dom.clone(wrapElm, false);\r\n                node.parentNode.insertBefore(currentWrapElm, node);\r\n                newWrappers.push(currentWrapElm);\r\n              }\r\n              currentWrapElm.appendChild(node);\r\n            } else {\r\n              currentWrapElm = null;\r\n              each$k(from(node.childNodes), process);\r\n              if (hasContentEditableState) {\r\n                contentEditable = lastContentEditable;\r\n              }\r\n              currentWrapElm = null;\r\n            }\r\n          };\r\n          each$k(nodes, process);\r\n        });\r\n        if (format.links === true) {\r\n          each$k(newWrappers, function (node) {\r\n            var process = function (node) {\r\n              if (node.nodeName === 'A') {\r\n                setElementFormat(node, format);\r\n              }\r\n              each$k(from(node.childNodes), process);\r\n            };\r\n            process(node);\r\n          });\r\n        }\r\n        each$k(newWrappers, function (node) {\r\n          var getChildCount = function (node) {\r\n            var count = 0;\r\n            each$k(node.childNodes, function (node) {\r\n              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\r\n                count++;\r\n              }\r\n            });\r\n            return count;\r\n          };\r\n          var mergeStyles = function (node) {\r\n            var childElement = find$3(node.childNodes, isElementNode).filter(function (child) {\r\n              return matchName$1(dom, child, format);\r\n            });\r\n            return childElement.map(function (child) {\r\n              var clone = dom.clone(child, false);\r\n              setElementFormat(clone);\r\n              dom.replace(clone, node, true);\r\n              dom.remove(child, true);\r\n              return clone;\r\n            }).getOr(node);\r\n          };\r\n          var childCount = getChildCount(node);\r\n          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\r\n            dom.remove(node, true);\r\n            return;\r\n          }\r\n          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\r\n            if (!format.exact && childCount === 1) {\r\n              node = mergeStyles(node);\r\n            }\r\n            mergeWithChildren(ed, formatList, vars, node);\r\n            mergeWithParents(ed, format, name, vars, node);\r\n            mergeBackgroundColorAndFontSize(dom, format, vars, node);\r\n            mergeTextDecorationsAndColor(dom, format, vars, node);\r\n            mergeSubSup(dom, format, vars, node);\r\n            mergeSiblings(dom, format, vars, node);\r\n          }\r\n        });\r\n      };\r\n      if (dom.getContentEditable(selection.getNode()) === 'false') {\r\n        node = selection.getNode();\r\n        for (var i = 0, l = formatList.length; i < l; i++) {\r\n          var formatItem = formatList[i];\r\n          if (formatItem.ceFalseOverride && isSelectorFormat(formatItem) && dom.is(node, formatItem.selector)) {\r\n            setElementFormat(node, formatItem);\r\n            break;\r\n          }\r\n        }\r\n        fireFormatApply(ed, name, node, vars);\r\n        return;\r\n      }\r\n      if (format) {\r\n        if (node) {\r\n          if (isNode(node)) {\r\n            if (!applyNodeStyle(formatList, node)) {\r\n              var rng = dom.createRng();\r\n              rng.setStartBefore(node);\r\n              rng.setEndAfter(node);\r\n              applyRngStyle(dom, expandRng(ed, rng, formatList), true);\r\n            }\r\n          } else {\r\n            applyRngStyle(dom, node, true);\r\n          }\r\n        } else {\r\n          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\r\n            var curSelNode = selection.getNode();\r\n            var firstFormat = formatList[0];\r\n            if (!ed.settings.forced_root_block && firstFormat.defaultBlock && !dom.getParent(curSelNode, dom.isBlock)) {\r\n              applyFormat$1(ed, firstFormat.defaultBlock);\r\n            }\r\n            selection.setRng(normalize(selection.getRng()));\r\n            preserve(selection, true, function () {\r\n              runOnRanges(ed, function (selectionRng, fake) {\r\n                var expandedRng = fake ? selectionRng : expandRng(ed, selectionRng, formatList);\r\n                applyRngStyle(dom, expandedRng, false);\r\n              });\r\n            });\r\n            moveStart(dom, selection, selection.getRng());\r\n            ed.nodeChanged();\r\n          } else {\r\n            applyCaretFormat(ed, name, vars);\r\n          }\r\n        }\r\n        postProcess$1(name, ed);\r\n      }\r\n      fireFormatApply(ed, name, node, vars);\r\n    };\r\n\r\n    var hasVars = function (value) {\r\n      return has$2(value, 'vars');\r\n    };\r\n    var setup$j = function (registeredFormatListeners, editor) {\r\n      registeredFormatListeners.set({});\r\n      editor.on('NodeChange', function (e) {\r\n        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\r\n      });\r\n      editor.on('FormatApply FormatRemove', function (e) {\r\n        var element = Optional.from(e.node).map(function (nodeOrRange) {\r\n          return isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer;\r\n        }).bind(function (node) {\r\n          return isElement$5(node) ? Optional.some(node) : Optional.from(node.parentElement);\r\n        }).getOrThunk(function () {\r\n          return fallbackElement(editor);\r\n        });\r\n        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\r\n      });\r\n    };\r\n    var fallbackElement = function (editor) {\r\n      return editor.selection.getStart();\r\n    };\r\n    var matchingNode = function (editor, parents, format, similar, vars) {\r\n      var isMatchingNode = function (node) {\r\n        var matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\r\n        return !isUndefined(matchingFormat);\r\n      };\r\n      var isUnableToMatch = function (node) {\r\n        if (matchesUnInheritedFormatSelector(editor, node, format)) {\r\n          return true;\r\n        } else {\r\n          if (!similar) {\r\n            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\r\n          } else {\r\n            return false;\r\n          }\r\n        }\r\n      };\r\n      return findUntil$1(parents, isMatchingNode, isUnableToMatch);\r\n    };\r\n    var getParents = function (editor, elm) {\r\n      var element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\r\n      return filter$4(getParents$2(editor.dom, element), function (node) {\r\n        return isElement$5(node) && !isBogus$2(node);\r\n      });\r\n    };\r\n    var updateAndFireChangeCallbacks = function (editor, elm, registeredCallbacks) {\r\n      var parents = getParents(editor, elm);\r\n      each$j(registeredCallbacks, function (data, format) {\r\n        var runIfChanged = function (spec) {\r\n          var match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\r\n          var isSet = match.isSome();\r\n          if (spec.state.get() !== isSet) {\r\n            spec.state.set(isSet);\r\n            var node_1 = match.getOr(elm);\r\n            if (hasVars(spec)) {\r\n              spec.callback(isSet, {\r\n                node: node_1,\r\n                format: format,\r\n                parents: parents\r\n              });\r\n            } else {\r\n              each$k(spec.callbacks, function (callback) {\r\n                return callback(isSet, {\r\n                  node: node_1,\r\n                  format: format,\r\n                  parents: parents\r\n                });\r\n              });\r\n            }\r\n          }\r\n        };\r\n        each$k([\r\n          data.withSimilar,\r\n          data.withoutSimilar\r\n        ], runIfChanged);\r\n        each$k(data.withVars, runIfChanged);\r\n      });\r\n    };\r\n    var addListeners = function (editor, registeredFormatListeners, formats, callback, similar, vars) {\r\n      var formatChangeItems = registeredFormatListeners.get();\r\n      each$k(formats.split(','), function (format) {\r\n        var group = get$9(formatChangeItems, format).getOrThunk(function () {\r\n          var base = {\r\n            withSimilar: {\r\n              state: Cell(false),\r\n              similar: true,\r\n              callbacks: []\r\n            },\r\n            withoutSimilar: {\r\n              state: Cell(false),\r\n              similar: false,\r\n              callbacks: []\r\n            },\r\n            withVars: []\r\n          };\r\n          formatChangeItems[format] = base;\r\n          return base;\r\n        });\r\n        var getCurrent = function () {\r\n          var parents = getParents(editor);\r\n          return matchingNode(editor, parents, format, similar, vars).isSome();\r\n        };\r\n        if (isUndefined(vars)) {\r\n          var toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\r\n          toAppendTo.callbacks.push(callback);\r\n          if (toAppendTo.callbacks.length === 1) {\r\n            toAppendTo.state.set(getCurrent());\r\n          }\r\n        } else {\r\n          group.withVars.push({\r\n            state: Cell(getCurrent()),\r\n            similar: similar,\r\n            vars: vars,\r\n            callback: callback\r\n          });\r\n        }\r\n      });\r\n      registeredFormatListeners.set(formatChangeItems);\r\n    };\r\n    var removeListeners = function (registeredFormatListeners, formats, callback) {\r\n      var formatChangeItems = registeredFormatListeners.get();\r\n      each$k(formats.split(','), function (format) {\r\n        return get$9(formatChangeItems, format).each(function (group) {\r\n          formatChangeItems[format] = {\r\n            withSimilar: __assign(__assign({}, group.withSimilar), {\r\n              callbacks: filter$4(group.withSimilar.callbacks, function (cb) {\r\n                return cb !== callback;\r\n              })\r\n            }),\r\n            withoutSimilar: __assign(__assign({}, group.withoutSimilar), {\r\n              callbacks: filter$4(group.withoutSimilar.callbacks, function (cb) {\r\n                return cb !== callback;\r\n              })\r\n            }),\r\n            withVars: filter$4(group.withVars, function (item) {\r\n              return item.callback !== callback;\r\n            })\r\n          };\r\n        });\r\n      });\r\n      registeredFormatListeners.set(formatChangeItems);\r\n    };\r\n    var formatChangedInternal = function (editor, registeredFormatListeners, formats, callback, similar, vars) {\r\n      if (registeredFormatListeners.get() === null) {\r\n        setup$j(registeredFormatListeners, editor);\r\n      }\r\n      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\r\n      return {\r\n        unbind: function () {\r\n          return removeListeners(registeredFormatListeners, formats, callback);\r\n        }\r\n      };\r\n    };\r\n\r\n    var toggle = function (editor, name, vars, node) {\r\n      var fmt = editor.formatter.get(name);\r\n      if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\r\n        remove$1(editor, name, vars, node);\r\n      } else {\r\n        applyFormat$1(editor, name, vars, node);\r\n      }\r\n    };\r\n\r\n    var fromElements = function (elements, scope) {\r\n      var doc = scope || document;\r\n      var fragment = doc.createDocumentFragment();\r\n      each$k(elements, function (element) {\r\n        fragment.appendChild(element.dom);\r\n      });\r\n      return SugarElement.fromDom(fragment);\r\n    };\r\n\r\n    var tableModel = function (element, width, rows) {\r\n      return {\r\n        element: element,\r\n        width: width,\r\n        rows: rows\r\n      };\r\n    };\r\n    var tableRow = function (element, cells) {\r\n      return {\r\n        element: element,\r\n        cells: cells\r\n      };\r\n    };\r\n    var cellPosition = function (x, y) {\r\n      return {\r\n        x: x,\r\n        y: y\r\n      };\r\n    };\r\n    var getSpan = function (td, key) {\r\n      var value = parseInt(get$6(td, key), 10);\r\n      return isNaN(value) ? 1 : value;\r\n    };\r\n    var fillout = function (table, x, y, tr, td) {\r\n      var rowspan = getSpan(td, 'rowspan');\r\n      var colspan = getSpan(td, 'colspan');\r\n      var rows = table.rows;\r\n      for (var y2 = y; y2 < y + rowspan; y2++) {\r\n        if (!rows[y2]) {\r\n          rows[y2] = tableRow(deep$1(tr), []);\r\n        }\r\n        for (var x2 = x; x2 < x + colspan; x2++) {\r\n          var cells = rows[y2].cells;\r\n          cells[x2] = y2 === y && x2 === x ? td : shallow(td);\r\n        }\r\n      }\r\n    };\r\n    var cellExists = function (table, x, y) {\r\n      var rows = table.rows;\r\n      var cells = rows[y] ? rows[y].cells : [];\r\n      return !!cells[x];\r\n    };\r\n    var skipCellsX = function (table, x, y) {\r\n      while (cellExists(table, x, y)) {\r\n        x++;\r\n      }\r\n      return x;\r\n    };\r\n    var getWidth = function (rows) {\r\n      return foldl(rows, function (acc, row) {\r\n        return row.cells.length > acc ? row.cells.length : acc;\r\n      }, 0);\r\n    };\r\n    var findElementPos = function (table, element) {\r\n      var rows = table.rows;\r\n      for (var y = 0; y < rows.length; y++) {\r\n        var cells = rows[y].cells;\r\n        for (var x = 0; x < cells.length; x++) {\r\n          if (eq(cells[x], element)) {\r\n            return Optional.some(cellPosition(x, y));\r\n          }\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var extractRows = function (table, sx, sy, ex, ey) {\r\n      var newRows = [];\r\n      var rows = table.rows;\r\n      for (var y = sy; y <= ey; y++) {\r\n        var cells = rows[y].cells;\r\n        var slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\r\n        newRows.push(tableRow(rows[y].element, slice));\r\n      }\r\n      return newRows;\r\n    };\r\n    var subTable = function (table, startPos, endPos) {\r\n      var sx = startPos.x, sy = startPos.y;\r\n      var ex = endPos.x, ey = endPos.y;\r\n      var newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\r\n      return tableModel(table.element, getWidth(newRows), newRows);\r\n    };\r\n    var createDomTable = function (table, rows) {\r\n      var tableElement = shallow(table.element);\r\n      var tableBody = SugarElement.fromTag('tbody');\r\n      append(tableBody, rows);\r\n      append$1(tableElement, tableBody);\r\n      return tableElement;\r\n    };\r\n    var modelRowsToDomRows = function (table) {\r\n      return map$3(table.rows, function (row) {\r\n        var cells = map$3(row.cells, function (cell) {\r\n          var td = deep$1(cell);\r\n          remove$6(td, 'colspan');\r\n          remove$6(td, 'rowspan');\r\n          return td;\r\n        });\r\n        var tr = shallow(row.element);\r\n        append(tr, cells);\r\n        return tr;\r\n      });\r\n    };\r\n    var fromDom = function (tableElm) {\r\n      var table = tableModel(shallow(tableElm), 0, []);\r\n      each$k(descendants(tableElm, 'tr'), function (tr, y) {\r\n        each$k(descendants(tr, 'td,th'), function (td, x) {\r\n          fillout(table, skipCellsX(table, x, y), y, tr, td);\r\n        });\r\n      });\r\n      return tableModel(table.element, getWidth(table.rows), table.rows);\r\n    };\r\n    var toDom = function (table) {\r\n      return createDomTable(table, modelRowsToDomRows(table));\r\n    };\r\n    var subsection = function (table, startElement, endElement) {\r\n      return findElementPos(table, startElement).bind(function (startPos) {\r\n        return findElementPos(table, endElement).map(function (endPos) {\r\n          return subTable(table, startPos, endPos);\r\n        });\r\n      });\r\n    };\r\n\r\n    var findParentListContainer = function (parents) {\r\n      return find$3(parents, function (elm) {\r\n        return name(elm) === 'ul' || name(elm) === 'ol';\r\n      });\r\n    };\r\n    var getFullySelectedListWrappers = function (parents, rng) {\r\n      return find$3(parents, function (elm) {\r\n        return name(elm) === 'li' && hasAllContentsSelected(elm, rng);\r\n      }).fold(constant([]), function (_li) {\r\n        return findParentListContainer(parents).map(function (listCont) {\r\n          var listElm = SugarElement.fromTag(name(listCont));\r\n          var listStyles = filter$3(getAllRaw(listCont), function (_style, name) {\r\n            return startsWith(name, 'list-style');\r\n          });\r\n          setAll(listElm, listStyles);\r\n          return [\r\n            SugarElement.fromTag('li'),\r\n            listElm\r\n          ];\r\n        }).getOr([]);\r\n      });\r\n    };\r\n    var wrap = function (innerElm, elms) {\r\n      var wrapped = foldl(elms, function (acc, elm) {\r\n        append$1(elm, acc);\r\n        return elm;\r\n      }, innerElm);\r\n      return elms.length > 0 ? fromElements([wrapped]) : wrapped;\r\n    };\r\n    var directListWrappers = function (commonAnchorContainer) {\r\n      if (isListItem(commonAnchorContainer)) {\r\n        return parent(commonAnchorContainer).filter(isList).fold(constant([]), function (listElm) {\r\n          return [\r\n            commonAnchorContainer,\r\n            listElm\r\n          ];\r\n        });\r\n      } else {\r\n        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\r\n      }\r\n    };\r\n    var getWrapElements = function (rootNode, rng) {\r\n      var commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\r\n      var parents = parentsAndSelf(commonAnchorContainer, rootNode);\r\n      var wrapElements = filter$4(parents, function (elm) {\r\n        return isInline$1(elm) || isHeading(elm);\r\n      });\r\n      var listWrappers = getFullySelectedListWrappers(parents, rng);\r\n      var allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\r\n      return map$3(allWrappers, shallow);\r\n    };\r\n    var emptyFragment = function () {\r\n      return fromElements([]);\r\n    };\r\n    var getFragmentFromRange = function (rootNode, rng) {\r\n      return wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));\r\n    };\r\n    var getParentTable = function (rootElm, cell) {\r\n      return ancestor$2(cell, 'table', curry(eq, rootElm));\r\n    };\r\n    var getTableFragment = function (rootNode, selectedTableCells) {\r\n      return getParentTable(rootNode, selectedTableCells[0]).bind(function (tableElm) {\r\n        var firstCell = selectedTableCells[0];\r\n        var lastCell = selectedTableCells[selectedTableCells.length - 1];\r\n        var fullTableModel = fromDom(tableElm);\r\n        return subsection(fullTableModel, firstCell, lastCell).map(function (sectionedTableModel) {\r\n          return fromElements([toDom(sectionedTableModel)]);\r\n        });\r\n      }).getOrThunk(emptyFragment);\r\n    };\r\n    var getSelectionFragment = function (rootNode, ranges) {\r\n      return ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);\r\n    };\r\n    var read$3 = function (rootNode, ranges) {\r\n      var selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\r\n      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);\r\n    };\r\n\r\n    var trimLeadingCollapsibleText = function (text) {\r\n      return text.replace(/^[ \\f\\n\\r\\t\\v]+/, '');\r\n    };\r\n    var isCollapsibleWhitespace = function (text, index) {\r\n      return index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\r\n    };\r\n    var getInnerText = function (bin, shouldTrim) {\r\n      var text = trim$3(bin.innerText);\r\n      return shouldTrim ? trimLeadingCollapsibleText(text) : text;\r\n    };\r\n    var getContextNodeName = function (parentBlockOpt) {\r\n      return parentBlockOpt.map(function (block) {\r\n        return block.nodeName;\r\n      }).getOr('div').toLowerCase();\r\n    };\r\n    var getTextContent = function (editor) {\r\n      return Optional.from(editor.selection.getRng()).map(function (rng) {\r\n        var parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\r\n        var body = editor.getBody();\r\n        var contextNodeName = getContextNodeName(parentBlockOpt);\r\n        var shouldTrimSpaces = Env.browser.isIE() && contextNodeName !== 'pre';\r\n        var bin = editor.dom.add(body, contextNodeName, {\r\n          'data-mce-bogus': 'all',\r\n          'style': 'overflow: hidden; opacity: 0;'\r\n        }, rng.cloneContents());\r\n        var text = getInnerText(bin, shouldTrimSpaces);\r\n        var nonRenderedText = trim$3(bin.textContent);\r\n        editor.dom.remove(bin);\r\n        if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\r\n          var parentBlock = parentBlockOpt.getOr(body);\r\n          var parentBlockText = getInnerText(parentBlock, shouldTrimSpaces);\r\n          var textIndex = parentBlockText.indexOf(text);\r\n          if (textIndex === -1) {\r\n            return text;\r\n          } else {\r\n            var hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\r\n            var hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\r\n            return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\r\n          }\r\n        } else {\r\n          return text;\r\n        }\r\n      }).getOr('');\r\n    };\r\n    var getSerializedContent = function (editor, args) {\r\n      var rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');\r\n      var sel = editor.selection.getSel();\r\n      var ranges = processRanges(editor, getRanges(sel));\r\n      var fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();\r\n      if (fragment) {\r\n        tmpElm.appendChild(fragment);\r\n      }\r\n      return editor.selection.serializer.serialize(tmpElm, args);\r\n    };\r\n    var setupArgs$1 = function (args, format) {\r\n      return __assign(__assign({}, args), {\r\n        format: format,\r\n        get: true,\r\n        selection: true\r\n      });\r\n    };\r\n    var getSelectedContentInternal = function (editor, format, args) {\r\n      if (args === void 0) {\r\n        args = {};\r\n      }\r\n      var defaultedArgs = setupArgs$1(args, format);\r\n      var updatedArgs = editor.fire('BeforeGetContent', defaultedArgs);\r\n      if (updatedArgs.isDefaultPrevented()) {\r\n        editor.fire('GetContent', updatedArgs);\r\n        return updatedArgs.content;\r\n      }\r\n      if (updatedArgs.format === 'text') {\r\n        return getTextContent(editor);\r\n      } else {\r\n        updatedArgs.getInner = true;\r\n        var content = getSerializedContent(editor, updatedArgs);\r\n        if (updatedArgs.format === 'tree') {\r\n          return content;\r\n        } else {\r\n          updatedArgs.content = editor.selection.isCollapsed() ? '' : content;\r\n          editor.fire('GetContent', updatedArgs);\r\n          return updatedArgs.content;\r\n        }\r\n      }\r\n    };\r\n\r\n    var KEEP = 0, INSERT = 1, DELETE = 2;\r\n    var diff = function (left, right) {\r\n      var size = left.length + right.length + 2;\r\n      var vDown = new Array(size);\r\n      var vUp = new Array(size);\r\n      var snake = function (start, end, diag) {\r\n        return {\r\n          start: start,\r\n          end: end,\r\n          diag: diag\r\n        };\r\n      };\r\n      var buildScript = function (start1, end1, start2, end2, script) {\r\n        var middle = getMiddleSnake(start1, end1, start2, end2);\r\n        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\r\n          var i = start1;\r\n          var j = start2;\r\n          while (i < end1 || j < end2) {\r\n            if (i < end1 && j < end2 && left[i] === right[j]) {\r\n              script.push([\r\n                KEEP,\r\n                left[i]\r\n              ]);\r\n              ++i;\r\n              ++j;\r\n            } else {\r\n              if (end1 - start1 > end2 - start2) {\r\n                script.push([\r\n                  DELETE,\r\n                  left[i]\r\n                ]);\r\n                ++i;\r\n              } else {\r\n                script.push([\r\n                  INSERT,\r\n                  right[j]\r\n                ]);\r\n                ++j;\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\r\n          for (var i2 = middle.start; i2 < middle.end; ++i2) {\r\n            script.push([\r\n              KEEP,\r\n              left[i2]\r\n            ]);\r\n          }\r\n          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\r\n        }\r\n      };\r\n      var buildSnake = function (start, diag, end1, end2) {\r\n        var end = start;\r\n        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\r\n          ++end;\r\n        }\r\n        return snake(start, end, diag);\r\n      };\r\n      var getMiddleSnake = function (start1, end1, start2, end2) {\r\n        var m = end1 - start1;\r\n        var n = end2 - start2;\r\n        if (m === 0 || n === 0) {\r\n          return null;\r\n        }\r\n        var delta = m - n;\r\n        var sum = n + m;\r\n        var offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\r\n        vDown[1 + offset] = start1;\r\n        vUp[1 + offset] = end1 + 1;\r\n        var d, k, i, x, y;\r\n        for (d = 0; d <= offset; ++d) {\r\n          for (k = -d; k <= d; k += 2) {\r\n            i = k + offset;\r\n            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\r\n              vDown[i] = vDown[i + 1];\r\n            } else {\r\n              vDown[i] = vDown[i - 1] + 1;\r\n            }\r\n            x = vDown[i];\r\n            y = x - start1 + start2 - k;\r\n            while (x < end1 && y < end2 && left[x] === right[y]) {\r\n              vDown[i] = ++x;\r\n              ++y;\r\n            }\r\n            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\r\n              if (vUp[i - delta] <= vDown[i]) {\r\n                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\r\n              }\r\n            }\r\n          }\r\n          for (k = delta - d; k <= delta + d; k += 2) {\r\n            i = k + offset - delta;\r\n            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\r\n              vUp[i] = vUp[i + 1] - 1;\r\n            } else {\r\n              vUp[i] = vUp[i - 1];\r\n            }\r\n            x = vUp[i] - 1;\r\n            y = x - start1 + start2 - k;\r\n            while (x >= start1 && y >= start2 && left[x] === right[y]) {\r\n              vUp[i] = x--;\r\n              y--;\r\n            }\r\n            if (delta % 2 === 0 && -d <= k && k <= d) {\r\n              if (vUp[i] <= vDown[i + delta]) {\r\n                return buildSnake(vUp[i], k + start1 - start2, end1, end2);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n      var script = [];\r\n      buildScript(0, left.length, 0, right.length, script);\r\n      return script;\r\n    };\r\n\r\n    var getOuterHtml = function (elm) {\r\n      if (isElement$5(elm)) {\r\n        return elm.outerHTML;\r\n      } else if (isText$7(elm)) {\r\n        return Entities.encodeRaw(elm.data, false);\r\n      } else if (isComment(elm)) {\r\n        return '<!--' + elm.data + '-->';\r\n      }\r\n      return '';\r\n    };\r\n    var createFragment = function (html) {\r\n      var node;\r\n      var container = document.createElement('div');\r\n      var frag = document.createDocumentFragment();\r\n      if (html) {\r\n        container.innerHTML = html;\r\n      }\r\n      while (node = container.firstChild) {\r\n        frag.appendChild(node);\r\n      }\r\n      return frag;\r\n    };\r\n    var insertAt = function (elm, html, index) {\r\n      var fragment = createFragment(html);\r\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\r\n        var target = elm.childNodes[index];\r\n        target.parentNode.insertBefore(fragment, target);\r\n      } else {\r\n        elm.appendChild(fragment);\r\n      }\r\n    };\r\n    var removeAt = function (elm, index) {\r\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\r\n        var target = elm.childNodes[index];\r\n        target.parentNode.removeChild(target);\r\n      }\r\n    };\r\n    var applyDiff = function (diff, elm) {\r\n      var index = 0;\r\n      each$k(diff, function (action) {\r\n        if (action[0] === KEEP) {\r\n          index++;\r\n        } else if (action[0] === INSERT) {\r\n          insertAt(elm, action[1], index);\r\n          index++;\r\n        } else if (action[0] === DELETE) {\r\n          removeAt(elm, index);\r\n        }\r\n      });\r\n    };\r\n    var read$2 = function (elm, trimZwsp) {\r\n      return filter$4(map$3(from(elm.childNodes), trimZwsp ? compose(trim$3, getOuterHtml) : getOuterHtml), function (item) {\r\n        return item.length > 0;\r\n      });\r\n    };\r\n    var write = function (fragments, elm) {\r\n      var currentFragments = map$3(from(elm.childNodes), getOuterHtml);\r\n      applyDiff(diff(currentFragments, fragments), elm);\r\n      return elm;\r\n    };\r\n\r\n    var lazyTempDocument$1 = cached(function () {\r\n      return document.implementation.createHTMLDocument('undo');\r\n    });\r\n    var hasIframes = function (body) {\r\n      return body.querySelector('iframe') !== null;\r\n    };\r\n    var createFragmentedLevel = function (fragments) {\r\n      return {\r\n        type: 'fragmented',\r\n        fragments: fragments,\r\n        content: '',\r\n        bookmark: null,\r\n        beforeBookmark: null\r\n      };\r\n    };\r\n    var createCompleteLevel = function (content) {\r\n      return {\r\n        type: 'complete',\r\n        fragments: null,\r\n        content: content,\r\n        bookmark: null,\r\n        beforeBookmark: null\r\n      };\r\n    };\r\n    var createFromEditor = function (editor) {\r\n      var tempAttrs = editor.serializer.getTempAttrs();\r\n      var body = trim$1(editor.getBody(), tempAttrs);\r\n      return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$3(body.innerHTML));\r\n    };\r\n    var applyToEditor = function (editor, level, before) {\r\n      var bookmark = before ? level.beforeBookmark : level.bookmark;\r\n      if (level.type === 'fragmented') {\r\n        write(level.fragments, editor.getBody());\r\n      } else {\r\n        editor.setContent(level.content, {\r\n          format: 'raw',\r\n          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\r\n        });\r\n      }\r\n      editor.selection.moveToBookmark(bookmark);\r\n    };\r\n    var getLevelContent = function (level) {\r\n      return level.type === 'fragmented' ? level.fragments.join('') : level.content;\r\n    };\r\n    var getCleanLevelContent = function (level) {\r\n      var elm = SugarElement.fromTag('body', lazyTempDocument$1());\r\n      set(elm, getLevelContent(level));\r\n      each$k(descendants(elm, '*[data-mce-bogus]'), unwrap);\r\n      return get$3(elm);\r\n    };\r\n    var hasEqualContent = function (level1, level2) {\r\n      return getLevelContent(level1) === getLevelContent(level2);\r\n    };\r\n    var hasEqualCleanedContent = function (level1, level2) {\r\n      return getCleanLevelContent(level1) === getCleanLevelContent(level2);\r\n    };\r\n    var isEq$1 = function (level1, level2) {\r\n      if (!level1 || !level2) {\r\n        return false;\r\n      } else if (hasEqualContent(level1, level2)) {\r\n        return true;\r\n      } else {\r\n        return hasEqualCleanedContent(level1, level2);\r\n      }\r\n    };\r\n\r\n    var isUnlocked = function (locks) {\r\n      return locks.get() === 0;\r\n    };\r\n\r\n    var setTyping = function (undoManager, typing, locks) {\r\n      if (isUnlocked(locks)) {\r\n        undoManager.typing = typing;\r\n      }\r\n    };\r\n    var endTyping = function (undoManager, locks) {\r\n      if (undoManager.typing) {\r\n        setTyping(undoManager, false, locks);\r\n        undoManager.add();\r\n      }\r\n    };\r\n    var endTypingLevelIgnoreLocks = function (undoManager) {\r\n      if (undoManager.typing) {\r\n        undoManager.typing = false;\r\n        undoManager.add();\r\n      }\r\n    };\r\n\r\n    var beforeChange$1 = function (editor, locks, beforeBookmark) {\r\n      if (isUnlocked(locks)) {\r\n        beforeBookmark.set(getUndoBookmark(editor.selection));\r\n      }\r\n    };\r\n    var addUndoLevel$1 = function (editor, undoManager, index, locks, beforeBookmark, level, event) {\r\n      var currentLevel = createFromEditor(editor);\r\n      level = level || {};\r\n      level = Tools.extend(level, currentLevel);\r\n      if (isUnlocked(locks) === false || editor.removed) {\r\n        return null;\r\n      }\r\n      var lastLevel = undoManager.data[index.get()];\r\n      if (editor.fire('BeforeAddUndo', {\r\n          level: level,\r\n          lastLevel: lastLevel,\r\n          originalEvent: event\r\n        }).isDefaultPrevented()) {\r\n        return null;\r\n      }\r\n      if (lastLevel && isEq$1(lastLevel, level)) {\r\n        return null;\r\n      }\r\n      if (undoManager.data[index.get()]) {\r\n        beforeBookmark.get().each(function (bm) {\r\n          undoManager.data[index.get()].beforeBookmark = bm;\r\n        });\r\n      }\r\n      var customUndoRedoLevels = getCustomUndoRedoLevels(editor);\r\n      if (customUndoRedoLevels) {\r\n        if (undoManager.data.length > customUndoRedoLevels) {\r\n          for (var i = 0; i < undoManager.data.length - 1; i++) {\r\n            undoManager.data[i] = undoManager.data[i + 1];\r\n          }\r\n          undoManager.data.length--;\r\n          index.set(undoManager.data.length);\r\n        }\r\n      }\r\n      level.bookmark = getUndoBookmark(editor.selection);\r\n      if (index.get() < undoManager.data.length - 1) {\r\n        undoManager.data.length = index.get() + 1;\r\n      }\r\n      undoManager.data.push(level);\r\n      index.set(undoManager.data.length - 1);\r\n      var args = {\r\n        level: level,\r\n        lastLevel: lastLevel,\r\n        originalEvent: event\r\n      };\r\n      if (index.get() > 0) {\r\n        editor.setDirty(true);\r\n        editor.fire('AddUndo', args);\r\n        editor.fire('change', args);\r\n      } else {\r\n        editor.fire('AddUndo', args);\r\n      }\r\n      return level;\r\n    };\r\n    var clear$1 = function (editor, undoManager, index) {\r\n      undoManager.data = [];\r\n      index.set(0);\r\n      undoManager.typing = false;\r\n      editor.fire('ClearUndos');\r\n    };\r\n    var extra$1 = function (editor, undoManager, index, callback1, callback2) {\r\n      if (undoManager.transact(callback1)) {\r\n        var bookmark = undoManager.data[index.get()].bookmark;\r\n        var lastLevel = undoManager.data[index.get() - 1];\r\n        applyToEditor(editor, lastLevel, true);\r\n        if (undoManager.transact(callback2)) {\r\n          undoManager.data[index.get() - 1].beforeBookmark = bookmark;\r\n        }\r\n      }\r\n    };\r\n    var redo$1 = function (editor, index, data) {\r\n      var level;\r\n      if (index.get() < data.length - 1) {\r\n        index.set(index.get() + 1);\r\n        level = data[index.get()];\r\n        applyToEditor(editor, level, false);\r\n        editor.setDirty(true);\r\n        editor.fire('Redo', { level: level });\r\n      }\r\n      return level;\r\n    };\r\n    var undo$1 = function (editor, undoManager, locks, index) {\r\n      var level;\r\n      if (undoManager.typing) {\r\n        undoManager.add();\r\n        undoManager.typing = false;\r\n        setTyping(undoManager, false, locks);\r\n      }\r\n      if (index.get() > 0) {\r\n        index.set(index.get() - 1);\r\n        level = undoManager.data[index.get()];\r\n        applyToEditor(editor, level, true);\r\n        editor.setDirty(true);\r\n        editor.fire('Undo', { level: level });\r\n      }\r\n      return level;\r\n    };\r\n    var reset$1 = function (undoManager) {\r\n      undoManager.clear();\r\n      undoManager.add();\r\n    };\r\n    var hasUndo$1 = function (editor, undoManager, index) {\r\n      return index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\r\n    };\r\n    var hasRedo$1 = function (undoManager, index) {\r\n      return index.get() < undoManager.data.length - 1 && !undoManager.typing;\r\n    };\r\n    var transact$1 = function (undoManager, locks, callback) {\r\n      endTyping(undoManager, locks);\r\n      undoManager.beforeChange();\r\n      undoManager.ignore(callback);\r\n      return undoManager.add();\r\n    };\r\n    var ignore$1 = function (locks, callback) {\r\n      try {\r\n        locks.set(locks.get() + 1);\r\n        callback();\r\n      } finally {\r\n        locks.set(locks.get() - 1);\r\n      }\r\n    };\r\n\r\n    var addVisualInternal = function (editor, elm) {\r\n      var dom = editor.dom;\r\n      var scope = isNonNullable(elm) ? elm : editor.getBody();\r\n      if (isUndefined(editor.hasVisual)) {\r\n        editor.hasVisual = isVisualAidsEnabled(editor);\r\n      }\r\n      each$k(dom.select('table,a', scope), function (matchedElm) {\r\n        switch (matchedElm.nodeName) {\r\n        case 'TABLE':\r\n          var cls = getVisualAidsTableClass(editor);\r\n          var value = dom.getAttrib(matchedElm, 'border');\r\n          if ((!value || value === '0') && editor.hasVisual) {\r\n            dom.addClass(matchedElm, cls);\r\n          } else {\r\n            dom.removeClass(matchedElm, cls);\r\n          }\r\n          break;\r\n        case 'A':\r\n          if (!dom.getAttrib(matchedElm, 'href')) {\r\n            var value_1 = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\r\n            var cls_1 = getVisualAidsAnchorClass(editor);\r\n            if (value_1 && editor.hasVisual) {\r\n              dom.addClass(matchedElm, cls_1);\r\n            } else {\r\n              dom.removeClass(matchedElm, cls_1);\r\n            }\r\n          }\r\n          break;\r\n        }\r\n      });\r\n      editor.fire('VisualAid', {\r\n        element: elm,\r\n        hasVisual: editor.hasVisual\r\n      });\r\n    };\r\n\r\n    var makePlainAdaptor = function (editor) {\r\n      return {\r\n        undoManager: {\r\n          beforeChange: function (locks, beforeBookmark) {\r\n            return beforeChange$1(editor, locks, beforeBookmark);\r\n          },\r\n          add: function (undoManager, index, locks, beforeBookmark, level, event) {\r\n            return addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event);\r\n          },\r\n          undo: function (undoManager, locks, index) {\r\n            return undo$1(editor, undoManager, locks, index);\r\n          },\r\n          redo: function (index, data) {\r\n            return redo$1(editor, index, data);\r\n          },\r\n          clear: function (undoManager, index) {\r\n            return clear$1(editor, undoManager, index);\r\n          },\r\n          reset: function (undoManager) {\r\n            return reset$1(undoManager);\r\n          },\r\n          hasUndo: function (undoManager, index) {\r\n            return hasUndo$1(editor, undoManager, index);\r\n          },\r\n          hasRedo: function (undoManager, index) {\r\n            return hasRedo$1(undoManager, index);\r\n          },\r\n          transact: function (undoManager, locks, callback) {\r\n            return transact$1(undoManager, locks, callback);\r\n          },\r\n          ignore: function (locks, callback) {\r\n            return ignore$1(locks, callback);\r\n          },\r\n          extra: function (undoManager, index, callback1, callback2) {\r\n            return extra$1(editor, undoManager, index, callback1, callback2);\r\n          }\r\n        },\r\n        formatter: {\r\n          match: function (name, vars, node, similar) {\r\n            return match$2(editor, name, vars, node, similar);\r\n          },\r\n          matchAll: function (names, vars) {\r\n            return matchAll(editor, names, vars);\r\n          },\r\n          matchNode: function (node, name, vars, similar) {\r\n            return matchNode(editor, node, name, vars, similar);\r\n          },\r\n          canApply: function (name) {\r\n            return canApply(editor, name);\r\n          },\r\n          closest: function (names) {\r\n            return closest(editor, names);\r\n          },\r\n          apply: function (name, vars, node) {\r\n            return applyFormat$1(editor, name, vars, node);\r\n          },\r\n          remove: function (name, vars, node, similar) {\r\n            return remove$1(editor, name, vars, node, similar);\r\n          },\r\n          toggle: function (name, vars, node) {\r\n            return toggle(editor, name, vars, node);\r\n          },\r\n          formatChanged: function (registeredFormatListeners, formats, callback, similar, vars) {\r\n            return formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars);\r\n          }\r\n        },\r\n        editor: {\r\n          getContent: function (args, format) {\r\n            return getContentInternal(editor, args, format);\r\n          },\r\n          setContent: function (content, args) {\r\n            return setContentInternal(editor, content, args);\r\n          },\r\n          insertContent: function (value, details) {\r\n            return insertHtmlAtCaret(editor, value, details);\r\n          },\r\n          addVisual: function (elm) {\r\n            return addVisualInternal(editor, elm);\r\n          }\r\n        },\r\n        selection: {\r\n          getContent: function (format, args) {\r\n            return getSelectedContentInternal(editor, format, args);\r\n          }\r\n        },\r\n        raw: {\r\n          getModel: function () {\r\n            return Optional.none();\r\n          }\r\n        }\r\n      };\r\n    };\r\n    var makeRtcAdaptor = function (rtcEditor) {\r\n      var defaultVars = function (vars) {\r\n        return isObject(vars) ? vars : {};\r\n      };\r\n      var undoManager = rtcEditor.undoManager, formatter = rtcEditor.formatter, editor = rtcEditor.editor, selection = rtcEditor.selection, raw = rtcEditor.raw;\r\n      return {\r\n        undoManager: {\r\n          beforeChange: undoManager.beforeChange,\r\n          add: undoManager.add,\r\n          undo: undoManager.undo,\r\n          redo: undoManager.redo,\r\n          clear: undoManager.clear,\r\n          reset: undoManager.reset,\r\n          hasUndo: undoManager.hasUndo,\r\n          hasRedo: undoManager.hasRedo,\r\n          transact: function (_undoManager, _locks, fn) {\r\n            return undoManager.transact(fn);\r\n          },\r\n          ignore: function (_locks, callback) {\r\n            return undoManager.ignore(callback);\r\n          },\r\n          extra: function (_undoManager, _index, callback1, callback2) {\r\n            return undoManager.extra(callback1, callback2);\r\n          }\r\n        },\r\n        formatter: {\r\n          match: function (name, vars, _node, similar) {\r\n            return formatter.match(name, defaultVars(vars), similar);\r\n          },\r\n          matchAll: formatter.matchAll,\r\n          matchNode: formatter.matchNode,\r\n          canApply: function (name) {\r\n            return formatter.canApply(name);\r\n          },\r\n          closest: function (names) {\r\n            return formatter.closest(names);\r\n          },\r\n          apply: function (name, vars, _node) {\r\n            return formatter.apply(name, defaultVars(vars));\r\n          },\r\n          remove: function (name, vars, _node, _similar) {\r\n            return formatter.remove(name, defaultVars(vars));\r\n          },\r\n          toggle: function (name, vars, _node) {\r\n            return formatter.toggle(name, defaultVars(vars));\r\n          },\r\n          formatChanged: function (_rfl, formats, callback, similar, vars) {\r\n            return formatter.formatChanged(formats, callback, similar, vars);\r\n          }\r\n        },\r\n        editor: {\r\n          getContent: function (args, _format) {\r\n            return editor.getContent(args);\r\n          },\r\n          setContent: function (content, args) {\r\n            return editor.setContent(content, args);\r\n          },\r\n          insertContent: function (content, _details) {\r\n            return editor.insertContent(content);\r\n          },\r\n          addVisual: editor.addVisual\r\n        },\r\n        selection: {\r\n          getContent: function (_format, args) {\r\n            return selection.getContent(args);\r\n          }\r\n        },\r\n        raw: {\r\n          getModel: function () {\r\n            return Optional.some(raw.getRawModel());\r\n          }\r\n        }\r\n      };\r\n    };\r\n    var makeNoopAdaptor = function () {\r\n      var nul = constant(null);\r\n      var empty = constant('');\r\n      return {\r\n        undoManager: {\r\n          beforeChange: noop,\r\n          add: nul,\r\n          undo: nul,\r\n          redo: nul,\r\n          clear: noop,\r\n          reset: noop,\r\n          hasUndo: never,\r\n          hasRedo: never,\r\n          transact: nul,\r\n          ignore: noop,\r\n          extra: noop\r\n        },\r\n        formatter: {\r\n          match: never,\r\n          matchAll: constant([]),\r\n          matchNode: constant(undefined),\r\n          canApply: never,\r\n          closest: empty,\r\n          apply: noop,\r\n          remove: noop,\r\n          toggle: noop,\r\n          formatChanged: constant({ unbind: noop })\r\n        },\r\n        editor: {\r\n          getContent: empty,\r\n          setContent: empty,\r\n          insertContent: noop,\r\n          addVisual: noop\r\n        },\r\n        selection: { getContent: empty },\r\n        raw: { getModel: constant(Optional.none()) }\r\n      };\r\n    };\r\n    var isRtc = function (editor) {\r\n      return has$2(editor.plugins, 'rtc');\r\n    };\r\n    var getRtcSetup = function (editor) {\r\n      return get$9(editor.plugins, 'rtc').bind(function (rtcPlugin) {\r\n        return Optional.from(rtcPlugin.setup);\r\n      });\r\n    };\r\n    var setup$i = function (editor) {\r\n      var editorCast = editor;\r\n      return getRtcSetup(editor).fold(function () {\r\n        editorCast.rtcInstance = makePlainAdaptor(editor);\r\n        return Optional.none();\r\n      }, function (setup) {\r\n        editorCast.rtcInstance = makeNoopAdaptor();\r\n        return Optional.some(function () {\r\n          return setup().then(function (rtcEditor) {\r\n            editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\r\n            return rtcEditor.rtc.isRemote;\r\n          });\r\n        });\r\n      });\r\n    };\r\n    var getRtcInstanceWithFallback = function (editor) {\r\n      return editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\r\n    };\r\n    var getRtcInstanceWithError = function (editor) {\r\n      var rtcInstance = editor.rtcInstance;\r\n      if (!rtcInstance) {\r\n        throw new Error('Failed to get RTC instance not yet initialized.');\r\n      } else {\r\n        return rtcInstance;\r\n      }\r\n    };\r\n    var beforeChange = function (editor, locks, beforeBookmark) {\r\n      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\r\n    };\r\n    var addUndoLevel = function (editor, undoManager, index, locks, beforeBookmark, level, event) {\r\n      return getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\r\n    };\r\n    var undo = function (editor, undoManager, locks, index) {\r\n      return getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\r\n    };\r\n    var redo = function (editor, index, data) {\r\n      return getRtcInstanceWithError(editor).undoManager.redo(index, data);\r\n    };\r\n    var clear = function (editor, undoManager, index) {\r\n      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\r\n    };\r\n    var reset = function (editor, undoManager) {\r\n      getRtcInstanceWithError(editor).undoManager.reset(undoManager);\r\n    };\r\n    var hasUndo = function (editor, undoManager, index) {\r\n      return getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\r\n    };\r\n    var hasRedo = function (editor, undoManager, index) {\r\n      return getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\r\n    };\r\n    var transact = function (editor, undoManager, locks, callback) {\r\n      return getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\r\n    };\r\n    var ignore = function (editor, locks, callback) {\r\n      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\r\n    };\r\n    var extra = function (editor, undoManager, index, callback1, callback2) {\r\n      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\r\n    };\r\n    var matchFormat = function (editor, name, vars, node, similar) {\r\n      return getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\r\n    };\r\n    var matchAllFormats = function (editor, names, vars) {\r\n      return getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\r\n    };\r\n    var matchNodeFormat = function (editor, node, name, vars, similar) {\r\n      return getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\r\n    };\r\n    var canApplyFormat = function (editor, name) {\r\n      return getRtcInstanceWithError(editor).formatter.canApply(name);\r\n    };\r\n    var closestFormat = function (editor, names) {\r\n      return getRtcInstanceWithError(editor).formatter.closest(names);\r\n    };\r\n    var applyFormat = function (editor, name, vars, node) {\r\n      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\r\n    };\r\n    var removeFormat = function (editor, name, vars, node, similar) {\r\n      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\r\n    };\r\n    var toggleFormat = function (editor, name, vars, node) {\r\n      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\r\n    };\r\n    var formatChanged = function (editor, registeredFormatListeners, formats, callback, similar, vars) {\r\n      return getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\r\n    };\r\n    var getContent$2 = function (editor, args, format) {\r\n      return getRtcInstanceWithFallback(editor).editor.getContent(args, format);\r\n    };\r\n    var setContent$2 = function (editor, content, args) {\r\n      return getRtcInstanceWithFallback(editor).editor.setContent(content, args);\r\n    };\r\n    var insertContent = function (editor, value, details) {\r\n      return getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\r\n    };\r\n    var getSelectedContent = function (editor, format, args) {\r\n      return getRtcInstanceWithError(editor).selection.getContent(format, args);\r\n    };\r\n    var addVisual$1 = function (editor, elm) {\r\n      return getRtcInstanceWithError(editor).editor.addVisual(elm);\r\n    };\r\n\r\n    var getContent$1 = function (editor, args) {\r\n      if (args === void 0) {\r\n        args = {};\r\n      }\r\n      var format = args.format ? args.format : 'html';\r\n      return getSelectedContent(editor, format, args);\r\n    };\r\n\r\n    var removeEmpty = function (text) {\r\n      if (text.dom.length === 0) {\r\n        remove$7(text);\r\n        return Optional.none();\r\n      } else {\r\n        return Optional.some(text);\r\n      }\r\n    };\r\n    var walkPastBookmark = function (node, start) {\r\n      return node.filter(function (elm) {\r\n        return BookmarkManager.isBookmarkNode(elm.dom);\r\n      }).bind(start ? nextSibling : prevSibling);\r\n    };\r\n    var merge = function (outer, inner, rng, start) {\r\n      var outerElm = outer.dom;\r\n      var innerElm = inner.dom;\r\n      var oldLength = start ? outerElm.length : innerElm.length;\r\n      if (start) {\r\n        mergeTextNodes(outerElm, innerElm, false, !start);\r\n        rng.setStart(innerElm, oldLength);\r\n      } else {\r\n        mergeTextNodes(innerElm, outerElm, false, !start);\r\n        rng.setEnd(innerElm, oldLength);\r\n      }\r\n    };\r\n    var normalizeTextIfRequired = function (inner, start) {\r\n      parent(inner).each(function (root) {\r\n        var text = inner.dom;\r\n        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0))) {\r\n          normalizeWhitespaceAfter(text, 0);\r\n        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length))) {\r\n          normalizeWhitespaceBefore(text, text.length);\r\n        }\r\n      });\r\n    };\r\n    var mergeAndNormalizeText = function (outerNode, innerNode, rng, start) {\r\n      outerNode.bind(function (outer) {\r\n        var normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\r\n        normalizer(outer.dom, start ? outer.dom.length : 0);\r\n        return innerNode.filter(isText$8).map(function (inner) {\r\n          return merge(outer, inner, rng, start);\r\n        });\r\n      }).orThunk(function () {\r\n        var innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$8);\r\n        return innerTextNode.map(function (inner) {\r\n          return normalizeTextIfRequired(inner, start);\r\n        });\r\n      });\r\n    };\r\n    var rngSetContent = function (rng, fragment) {\r\n      var firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\r\n      var lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\r\n      rng.deleteContents();\r\n      rng.insertNode(fragment);\r\n      var prevText = firstChild.bind(prevSibling).filter(isText$8).bind(removeEmpty);\r\n      var nextText = lastChild.bind(nextSibling).filter(isText$8).bind(removeEmpty);\r\n      mergeAndNormalizeText(prevText, firstChild, rng, true);\r\n      mergeAndNormalizeText(nextText, lastChild, rng, false);\r\n      rng.collapse(false);\r\n    };\r\n    var setupArgs = function (args, content) {\r\n      return __assign(__assign({ format: 'html' }, args), {\r\n        set: true,\r\n        selection: true,\r\n        content: content\r\n      });\r\n    };\r\n    var cleanContent = function (editor, args) {\r\n      if (args.format !== 'raw') {\r\n        var rng = editor.selection.getRng();\r\n        var contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\r\n        var contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};\r\n        var node = editor.parser.parse(args.content, __assign(__assign({\r\n          isRootContent: true,\r\n          forced_root_block: false\r\n        }, contextArgs), args));\r\n        return HtmlSerializer({ validate: editor.validate }, editor.schema).serialize(node);\r\n      } else {\r\n        return args.content;\r\n      }\r\n    };\r\n    var setContent$1 = function (editor, content, args) {\r\n      if (args === void 0) {\r\n        args = {};\r\n      }\r\n      var defaultedArgs = setupArgs(args, content);\r\n      var updatedArgs = defaultedArgs;\r\n      if (!defaultedArgs.no_events) {\r\n        var eventArgs = editor.fire('BeforeSetContent', defaultedArgs);\r\n        if (eventArgs.isDefaultPrevented()) {\r\n          editor.fire('SetContent', eventArgs);\r\n          return;\r\n        } else {\r\n          updatedArgs = eventArgs;\r\n        }\r\n      }\r\n      updatedArgs.content = cleanContent(editor, updatedArgs);\r\n      var rng = editor.selection.getRng();\r\n      rngSetContent(rng, rng.createContextualFragment(updatedArgs.content));\r\n      editor.selection.setRng(rng);\r\n      scrollRangeIntoView(editor, rng);\r\n      if (!updatedArgs.no_events) {\r\n        editor.fire('SetContent', updatedArgs);\r\n      }\r\n    };\r\n\r\n    var deleteFromCallbackMap = function (callbackMap, selector, callback) {\r\n      if (callbackMap && has$2(callbackMap, selector)) {\r\n        var newCallbacks = filter$4(callbackMap[selector], function (cb) {\r\n          return cb !== callback;\r\n        });\r\n        if (newCallbacks.length === 0) {\r\n          delete callbackMap[selector];\r\n        } else {\r\n          callbackMap[selector] = newCallbacks;\r\n        }\r\n      }\r\n    };\r\n    function SelectorChanged (dom, editor) {\r\n      var selectorChangedData;\r\n      var currentSelectors;\r\n      var findMatchingNode = function (selector, nodes) {\r\n        return find$3(nodes, function (node) {\r\n          return dom.is(node, selector);\r\n        });\r\n      };\r\n      var getParents = function (elem) {\r\n        return dom.getParents(elem, null, dom.getRoot());\r\n      };\r\n      return {\r\n        selectorChangedWithUnbind: function (selector, callback) {\r\n          if (!selectorChangedData) {\r\n            selectorChangedData = {};\r\n            currentSelectors = {};\r\n            editor.on('NodeChange', function (e) {\r\n              var node = e.element;\r\n              var parents = getParents(node);\r\n              var matchedSelectors = {};\r\n              Tools.each(selectorChangedData, function (callbacks, selector) {\r\n                findMatchingNode(selector, parents).each(function (node) {\r\n                  if (!currentSelectors[selector]) {\r\n                    each$k(callbacks, function (callback) {\r\n                      callback(true, {\r\n                        node: node,\r\n                        selector: selector,\r\n                        parents: parents\r\n                      });\r\n                    });\r\n                    currentSelectors[selector] = callbacks;\r\n                  }\r\n                  matchedSelectors[selector] = callbacks;\r\n                });\r\n              });\r\n              Tools.each(currentSelectors, function (callbacks, selector) {\r\n                if (!matchedSelectors[selector]) {\r\n                  delete currentSelectors[selector];\r\n                  Tools.each(callbacks, function (callback) {\r\n                    callback(false, {\r\n                      node: node,\r\n                      selector: selector,\r\n                      parents: parents\r\n                    });\r\n                  });\r\n                }\r\n              });\r\n            });\r\n          }\r\n          if (!selectorChangedData[selector]) {\r\n            selectorChangedData[selector] = [];\r\n          }\r\n          selectorChangedData[selector].push(callback);\r\n          findMatchingNode(selector, getParents(editor.selection.getStart())).each(function () {\r\n            currentSelectors[selector] = selectorChangedData[selector];\r\n          });\r\n          return {\r\n            unbind: function () {\r\n              deleteFromCallbackMap(selectorChangedData, selector, callback);\r\n              deleteFromCallbackMap(currentSelectors, selector, callback);\r\n            }\r\n          };\r\n        }\r\n      };\r\n    }\r\n\r\n    var isNativeIeSelection = function (rng) {\r\n      return !!rng.select;\r\n    };\r\n    var isAttachedToDom = function (node) {\r\n      return !!(node && node.ownerDocument) && contains$1(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\r\n    };\r\n    var isValidRange = function (rng) {\r\n      if (!rng) {\r\n        return false;\r\n      } else if (isNativeIeSelection(rng)) {\r\n        return true;\r\n      } else {\r\n        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\r\n      }\r\n    };\r\n    var EditorSelection = function (dom, win, serializer, editor) {\r\n      var selectedRange;\r\n      var explicitRange;\r\n      var selectorChangedWithUnbind = SelectorChanged(dom, editor).selectorChangedWithUnbind;\r\n      var setCursorLocation = function (node, offset) {\r\n        var rng = dom.createRng();\r\n        if (isNonNullable(node) && isNonNullable(offset)) {\r\n          rng.setStart(node, offset);\r\n          rng.setEnd(node, offset);\r\n          setRng(rng);\r\n          collapse(false);\r\n        } else {\r\n          moveEndPoint(dom, rng, editor.getBody(), true);\r\n          setRng(rng);\r\n        }\r\n      };\r\n      var getContent = function (args) {\r\n        return getContent$1(editor, args);\r\n      };\r\n      var setContent = function (content, args) {\r\n        return setContent$1(editor, content, args);\r\n      };\r\n      var getStart$1 = function (real) {\r\n        return getStart(editor.getBody(), getRng$1(), real);\r\n      };\r\n      var getEnd$1 = function (real) {\r\n        return getEnd(editor.getBody(), getRng$1(), real);\r\n      };\r\n      var getBookmark = function (type, normalized) {\r\n        return bookmarkManager.getBookmark(type, normalized);\r\n      };\r\n      var moveToBookmark = function (bookmark) {\r\n        return bookmarkManager.moveToBookmark(bookmark);\r\n      };\r\n      var select$1 = function (node, content) {\r\n        select(dom, node, content).each(setRng);\r\n        return node;\r\n      };\r\n      var isCollapsed = function () {\r\n        var rng = getRng$1(), sel = getSel();\r\n        if (!rng || rng.item) {\r\n          return false;\r\n        }\r\n        if (rng.compareEndPoints) {\r\n          return rng.compareEndPoints('StartToEnd', rng) === 0;\r\n        }\r\n        return !sel || rng.collapsed;\r\n      };\r\n      var collapse = function (toStart) {\r\n        var rng = getRng$1();\r\n        rng.collapse(!!toStart);\r\n        setRng(rng);\r\n      };\r\n      var getSel = function () {\r\n        return win.getSelection ? win.getSelection() : win.document.selection;\r\n      };\r\n      var getRng$1 = function () {\r\n        var selection, rng, elm;\r\n        var tryCompareBoundaryPoints = function (how, sourceRange, destinationRange) {\r\n          try {\r\n            return sourceRange.compareBoundaryPoints(how, destinationRange);\r\n          } catch (ex) {\r\n            return -1;\r\n          }\r\n        };\r\n        var doc = win.document;\r\n        if (editor.bookmark !== undefined && hasFocus(editor) === false) {\r\n          var bookmark = getRng(editor);\r\n          if (bookmark.isSome()) {\r\n            return bookmark.map(function (r) {\r\n              return processRanges(editor, [r])[0];\r\n            }).getOr(doc.createRange());\r\n          }\r\n        }\r\n        try {\r\n          if ((selection = getSel()) && !isRestrictedNode(selection.anchorNode)) {\r\n            if (selection.rangeCount > 0) {\r\n              rng = selection.getRangeAt(0);\r\n            } else {\r\n              rng = selection.createRange ? selection.createRange() : doc.createRange();\r\n            }\r\n            rng = processRanges(editor, [rng])[0];\r\n          }\r\n        } catch (ex) {\r\n        }\r\n        if (!rng) {\r\n          rng = doc.createRange ? doc.createRange() : doc.body.createTextRange();\r\n        }\r\n        if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {\r\n          elm = dom.getRoot();\r\n          rng.setStart(elm, 0);\r\n          rng.setEnd(elm, 0);\r\n        }\r\n        if (selectedRange && explicitRange) {\r\n          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\r\n            rng = explicitRange;\r\n          } else {\r\n            selectedRange = null;\r\n            explicitRange = null;\r\n          }\r\n        }\r\n        return rng;\r\n      };\r\n      var setRng = function (rng, forward) {\r\n        var node;\r\n        if (!isValidRange(rng)) {\r\n          return;\r\n        }\r\n        var ieRange = isNativeIeSelection(rng) ? rng : null;\r\n        if (ieRange) {\r\n          explicitRange = null;\r\n          try {\r\n            ieRange.select();\r\n          } catch (ex) {\r\n          }\r\n          return;\r\n        }\r\n        var sel = getSel();\r\n        var evt = editor.fire('SetSelectionRange', {\r\n          range: rng,\r\n          forward: forward\r\n        });\r\n        rng = evt.range;\r\n        if (sel) {\r\n          explicitRange = rng;\r\n          try {\r\n            sel.removeAllRanges();\r\n            sel.addRange(rng);\r\n          } catch (ex) {\r\n          }\r\n          if (forward === false && sel.extend) {\r\n            sel.collapse(rng.endContainer, rng.endOffset);\r\n            sel.extend(rng.startContainer, rng.startOffset);\r\n          }\r\n          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\r\n        }\r\n        if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent && !Env.ie) {\r\n          if (rng.endOffset - rng.startOffset < 2) {\r\n            if (rng.startContainer.hasChildNodes()) {\r\n              node = rng.startContainer.childNodes[rng.startOffset];\r\n              if (node && node.tagName === 'IMG') {\r\n                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\r\n                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\r\n                  sel.setBaseAndExtent(node, 0, node, 1);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        editor.fire('AfterSetSelectionRange', {\r\n          range: rng,\r\n          forward: forward\r\n        });\r\n      };\r\n      var setNode = function (elm) {\r\n        setContent(dom.getOuterHTML(elm));\r\n        return elm;\r\n      };\r\n      var getNode$1 = function () {\r\n        return getNode(editor.getBody(), getRng$1());\r\n      };\r\n      var getSelectedBlocks$1 = function (startElm, endElm) {\r\n        return getSelectedBlocks(dom, getRng$1(), startElm, endElm);\r\n      };\r\n      var isForward = function () {\r\n        var sel = getSel();\r\n        var anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\r\n        var focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\r\n        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\r\n          return true;\r\n        }\r\n        var anchorRange = dom.createRng();\r\n        anchorRange.setStart(anchorNode, sel.anchorOffset);\r\n        anchorRange.collapse(true);\r\n        var focusRange = dom.createRng();\r\n        focusRange.setStart(focusNode, sel.focusOffset);\r\n        focusRange.collapse(true);\r\n        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\r\n      };\r\n      var normalize = function () {\r\n        var rng = getRng$1();\r\n        var sel = getSel();\r\n        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\r\n          var normRng = normalize$2(dom, rng);\r\n          normRng.each(function (normRng) {\r\n            setRng(normRng, isForward());\r\n          });\r\n          return normRng.getOr(rng);\r\n        }\r\n        return rng;\r\n      };\r\n      var selectorChanged = function (selector, callback) {\r\n        selectorChangedWithUnbind(selector, callback);\r\n        return exports;\r\n      };\r\n      var getScrollContainer = function () {\r\n        var scrollContainer;\r\n        var node = dom.getRoot();\r\n        while (node && node.nodeName !== 'BODY') {\r\n          if (node.scrollHeight > node.clientHeight) {\r\n            scrollContainer = node;\r\n            break;\r\n          }\r\n          node = node.parentNode;\r\n        }\r\n        return scrollContainer;\r\n      };\r\n      var scrollIntoView = function (elm, alignToTop) {\r\n        if (isNonNullable(elm)) {\r\n          scrollElementIntoView(editor, elm, alignToTop);\r\n        } else {\r\n          scrollRangeIntoView(editor, getRng$1(), alignToTop);\r\n        }\r\n      };\r\n      var placeCaretAt = function (clientX, clientY) {\r\n        return setRng(fromPoint(clientX, clientY, editor.getDoc()));\r\n      };\r\n      var getBoundingClientRect = function () {\r\n        var rng = getRng$1();\r\n        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\r\n      };\r\n      var destroy = function () {\r\n        win = selectedRange = explicitRange = null;\r\n        controlSelection.destroy();\r\n      };\r\n      var exports = {\r\n        bookmarkManager: null,\r\n        controlSelection: null,\r\n        dom: dom,\r\n        win: win,\r\n        serializer: serializer,\r\n        editor: editor,\r\n        collapse: collapse,\r\n        setCursorLocation: setCursorLocation,\r\n        getContent: getContent,\r\n        setContent: setContent,\r\n        getBookmark: getBookmark,\r\n        moveToBookmark: moveToBookmark,\r\n        select: select$1,\r\n        isCollapsed: isCollapsed,\r\n        isForward: isForward,\r\n        setNode: setNode,\r\n        getNode: getNode$1,\r\n        getSel: getSel,\r\n        setRng: setRng,\r\n        getRng: getRng$1,\r\n        getStart: getStart$1,\r\n        getEnd: getEnd$1,\r\n        getSelectedBlocks: getSelectedBlocks$1,\r\n        normalize: normalize,\r\n        selectorChanged: selectorChanged,\r\n        selectorChangedWithUnbind: selectorChangedWithUnbind,\r\n        getScrollContainer: getScrollContainer,\r\n        scrollIntoView: scrollIntoView,\r\n        placeCaretAt: placeCaretAt,\r\n        getBoundingClientRect: getBoundingClientRect,\r\n        destroy: destroy\r\n      };\r\n      var bookmarkManager = BookmarkManager(exports);\r\n      var controlSelection = ControlSelection(exports, editor);\r\n      exports.bookmarkManager = bookmarkManager;\r\n      exports.controlSelection = controlSelection;\r\n      return exports;\r\n    };\r\n\r\n    var removeAttrs = function (node, names) {\r\n      each$k(names, function (name) {\r\n        node.attr(name, null);\r\n      });\r\n    };\r\n    var addFontToSpansFilter = function (domParser, styles, fontSizes) {\r\n      domParser.addNodeFilter('font', function (nodes) {\r\n        each$k(nodes, function (node) {\r\n          var props = styles.parse(node.attr('style'));\r\n          var color = node.attr('color');\r\n          var face = node.attr('face');\r\n          var size = node.attr('size');\r\n          if (color) {\r\n            props.color = color;\r\n          }\r\n          if (face) {\r\n            props['font-family'] = face;\r\n          }\r\n          if (size) {\r\n            props['font-size'] = fontSizes[parseInt(node.attr('size'), 10) - 1];\r\n          }\r\n          node.name = 'span';\r\n          node.attr('style', styles.serialize(props));\r\n          removeAttrs(node, [\r\n            'color',\r\n            'face',\r\n            'size'\r\n          ]);\r\n        });\r\n      });\r\n    };\r\n    var addStrikeToSpanFilter = function (domParser, styles) {\r\n      domParser.addNodeFilter('strike', function (nodes) {\r\n        each$k(nodes, function (node) {\r\n          var props = styles.parse(node.attr('style'));\r\n          props['text-decoration'] = 'line-through';\r\n          node.name = 'span';\r\n          node.attr('style', styles.serialize(props));\r\n        });\r\n      });\r\n    };\r\n    var addFilters = function (domParser, settings) {\r\n      var styles = Styles();\r\n      if (settings.convert_fonts_to_spans) {\r\n        addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));\r\n      }\r\n      addStrikeToSpanFilter(domParser, styles);\r\n    };\r\n    var register$2 = function (domParser, settings) {\r\n      if (settings.inline_styles) {\r\n        addFilters(domParser, settings);\r\n      }\r\n    };\r\n\r\n    var blobUriToBlob = function (url) {\r\n      return new promiseObj(function (resolve, reject) {\r\n        var rejectWithError = function () {\r\n          reject('Cannot convert ' + url + ' to Blob. Resource might not exist or is inaccessible.');\r\n        };\r\n        try {\r\n          var xhr_1 = new XMLHttpRequest();\r\n          xhr_1.open('GET', url, true);\r\n          xhr_1.responseType = 'blob';\r\n          xhr_1.onload = function () {\r\n            if (xhr_1.status === 200) {\r\n              resolve(xhr_1.response);\r\n            } else {\r\n              rejectWithError();\r\n            }\r\n          };\r\n          xhr_1.onerror = rejectWithError;\r\n          xhr_1.send();\r\n        } catch (ex) {\r\n          rejectWithError();\r\n        }\r\n      });\r\n    };\r\n    var parseDataUri$1 = function (uri) {\r\n      var type;\r\n      var uriParts = decodeURIComponent(uri).split(',');\r\n      var matches = /data:([^;]+)/.exec(uriParts[0]);\r\n      if (matches) {\r\n        type = matches[1];\r\n      }\r\n      return {\r\n        type: type,\r\n        data: uriParts[1]\r\n      };\r\n    };\r\n    var buildBlob = function (type, data) {\r\n      var str;\r\n      try {\r\n        str = atob(data);\r\n      } catch (e) {\r\n        return Optional.none();\r\n      }\r\n      var arr = new Uint8Array(str.length);\r\n      for (var i = 0; i < arr.length; i++) {\r\n        arr[i] = str.charCodeAt(i);\r\n      }\r\n      return Optional.some(new Blob([arr], { type: type }));\r\n    };\r\n    var dataUriToBlob = function (uri) {\r\n      return new promiseObj(function (resolve) {\r\n        var _a = parseDataUri$1(uri), type = _a.type, data = _a.data;\r\n        buildBlob(type, data).fold(function () {\r\n          return resolve(new Blob([]));\r\n        }, resolve);\r\n      });\r\n    };\r\n    var uriToBlob = function (url) {\r\n      if (url.indexOf('blob:') === 0) {\r\n        return blobUriToBlob(url);\r\n      }\r\n      if (url.indexOf('data:') === 0) {\r\n        return dataUriToBlob(url);\r\n      }\r\n      return null;\r\n    };\r\n    var blobToDataUri = function (blob) {\r\n      return new promiseObj(function (resolve) {\r\n        var reader = new FileReader();\r\n        reader.onloadend = function () {\r\n          resolve(reader.result);\r\n        };\r\n        reader.readAsDataURL(blob);\r\n      });\r\n    };\r\n\r\n    var count$1 = 0;\r\n    var uniqueId = function (prefix) {\r\n      return (prefix || 'blobid') + count$1++;\r\n    };\r\n    var imageToBlobInfo = function (blobCache, img, resolve, reject) {\r\n      var base64, blobInfo;\r\n      if (img.src.indexOf('blob:') === 0) {\r\n        blobInfo = blobCache.getByUri(img.src);\r\n        if (blobInfo) {\r\n          resolve({\r\n            image: img,\r\n            blobInfo: blobInfo\r\n          });\r\n        } else {\r\n          uriToBlob(img.src).then(function (blob) {\r\n            blobToDataUri(blob).then(function (dataUri) {\r\n              base64 = parseDataUri$1(dataUri).data;\r\n              blobInfo = blobCache.create(uniqueId(), blob, base64);\r\n              blobCache.add(blobInfo);\r\n              resolve({\r\n                image: img,\r\n                blobInfo: blobInfo\r\n              });\r\n            });\r\n          }, function (err) {\r\n            reject(err);\r\n          });\r\n        }\r\n        return;\r\n      }\r\n      var _a = parseDataUri$1(img.src), data = _a.data, type = _a.type;\r\n      base64 = data;\r\n      blobInfo = blobCache.getByData(base64, type);\r\n      if (blobInfo) {\r\n        resolve({\r\n          image: img,\r\n          blobInfo: blobInfo\r\n        });\r\n      } else {\r\n        uriToBlob(img.src).then(function (blob) {\r\n          blobInfo = blobCache.create(uniqueId(), blob, base64);\r\n          blobCache.add(blobInfo);\r\n          resolve({\r\n            image: img,\r\n            blobInfo: blobInfo\r\n          });\r\n        }, function (err) {\r\n          reject(err);\r\n        });\r\n      }\r\n    };\r\n    var getAllImages = function (elm) {\r\n      return elm ? from(elm.getElementsByTagName('img')) : [];\r\n    };\r\n    var ImageScanner = function (uploadStatus, blobCache) {\r\n      var cachedPromises = {};\r\n      var findAll = function (elm, predicate) {\r\n        if (!predicate) {\r\n          predicate = always;\r\n        }\r\n        var images = filter$4(getAllImages(elm), function (img) {\r\n          var src = img.src;\r\n          if (!Env.fileApi) {\r\n            return false;\r\n          }\r\n          if (img.hasAttribute('data-mce-bogus')) {\r\n            return false;\r\n          }\r\n          if (img.hasAttribute('data-mce-placeholder')) {\r\n            return false;\r\n          }\r\n          if (!src || src === Env.transparentSrc) {\r\n            return false;\r\n          }\r\n          if (src.indexOf('blob:') === 0) {\r\n            return !uploadStatus.isUploaded(src) && predicate(img);\r\n          }\r\n          if (src.indexOf('data:') === 0) {\r\n            return predicate(img);\r\n          }\r\n          return false;\r\n        });\r\n        var promises = map$3(images, function (img) {\r\n          if (cachedPromises[img.src] !== undefined) {\r\n            return new promiseObj(function (resolve) {\r\n              cachedPromises[img.src].then(function (imageInfo) {\r\n                if (typeof imageInfo === 'string') {\r\n                  return imageInfo;\r\n                }\r\n                resolve({\r\n                  image: img,\r\n                  blobInfo: imageInfo.blobInfo\r\n                });\r\n              });\r\n            });\r\n          }\r\n          var newPromise = new promiseObj(function (resolve, reject) {\r\n            imageToBlobInfo(blobCache, img, resolve, reject);\r\n          }).then(function (result) {\r\n            delete cachedPromises[result.image.src];\r\n            return result;\r\n          }).catch(function (error) {\r\n            delete cachedPromises[img.src];\r\n            return error;\r\n          });\r\n          cachedPromises[img.src] = newPromise;\r\n          return newPromise;\r\n        });\r\n        return promiseObj.all(promises);\r\n      };\r\n      return { findAll: findAll };\r\n    };\r\n\r\n    var extractBase64DataUris = function (html) {\r\n      var dataImageUri = /data:[^;<\"'\\s]+;base64,([a-z0-9\\+\\/=\\s]+)/gi;\r\n      var chunks = [];\r\n      var uris = {};\r\n      var prefix = generate('img');\r\n      var matches;\r\n      var index = 0;\r\n      var count = 0;\r\n      while (matches = dataImageUri.exec(html)) {\r\n        var uri = matches[0];\r\n        var imageId = prefix + '_' + count++;\r\n        uris[imageId] = uri;\r\n        if (index < matches.index) {\r\n          chunks.push(html.substr(index, matches.index - index));\r\n        }\r\n        chunks.push(imageId);\r\n        index = matches.index + uri.length;\r\n      }\r\n      var re = new RegExp(prefix + '_[0-9]+', 'g');\r\n      if (index === 0) {\r\n        return {\r\n          prefix: prefix,\r\n          uris: uris,\r\n          html: html,\r\n          re: re\r\n        };\r\n      } else {\r\n        if (index < html.length) {\r\n          chunks.push(html.substr(index));\r\n        }\r\n        return {\r\n          prefix: prefix,\r\n          uris: uris,\r\n          html: chunks.join(''),\r\n          re: re\r\n        };\r\n      }\r\n    };\r\n    var restoreDataUris = function (html, result) {\r\n      return html.replace(result.re, function (imageId) {\r\n        return get$9(result.uris, imageId).getOr(imageId);\r\n      });\r\n    };\r\n    var parseDataUri = function (uri) {\r\n      var matches = /data:([^;]+);base64,([a-z0-9\\+\\/=\\s]+)/i.exec(uri);\r\n      if (matches) {\r\n        return Optional.some({\r\n          type: matches[1],\r\n          data: decodeURIComponent(matches[2])\r\n        });\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n\r\n    var paddEmptyNode = function (settings, args, blockElements, node) {\r\n      var brPreferred = settings.padd_empty_with_br || args.insert;\r\n      if (brPreferred && blockElements[node.name]) {\r\n        node.empty().append(new AstNode('br', 1)).shortEnded = true;\r\n      } else {\r\n        node.empty().append(new AstNode('#text', 3)).value = nbsp;\r\n      }\r\n    };\r\n    var isPaddedWithNbsp = function (node) {\r\n      return hasOnlyChild(node, '#text') && node.firstChild.value === nbsp;\r\n    };\r\n    var hasOnlyChild = function (node, name) {\r\n      return node && node.firstChild && node.firstChild === node.lastChild && node.firstChild.name === name;\r\n    };\r\n    var isPadded = function (schema, node) {\r\n      var rule = schema.getElementRule(node.name);\r\n      return rule && rule.paddEmpty;\r\n    };\r\n    var isEmpty = function (schema, nonEmptyElements, whitespaceElements, node) {\r\n      return node.isEmpty(nonEmptyElements, whitespaceElements, function (node) {\r\n        return isPadded(schema, node);\r\n      });\r\n    };\r\n    var isLineBreakNode = function (node, blockElements) {\r\n      return node && (has$2(blockElements, node.name) || node.name === 'br');\r\n    };\r\n\r\n    var isBogusImage = function (img) {\r\n      return isNonNullable(img.attr('data-mce-bogus'));\r\n    };\r\n    var isInternalImageSource = function (img) {\r\n      return img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\r\n    };\r\n    var isValidDataImg = function (img, settings) {\r\n      if (settings.images_dataimg_filter) {\r\n        var imgElem_1 = new Image();\r\n        imgElem_1.src = img.attr('src');\r\n        each$j(img.attributes.map, function (value, key) {\r\n          imgElem_1.setAttribute(key, value);\r\n        });\r\n        return settings.images_dataimg_filter(imgElem_1);\r\n      } else {\r\n        return true;\r\n      }\r\n    };\r\n    var registerBase64ImageFilter = function (parser, settings) {\r\n      var blobCache = settings.blob_cache;\r\n      var processImage = function (img) {\r\n        var inputSrc = img.attr('src');\r\n        if (isInternalImageSource(img) || isBogusImage(img)) {\r\n          return;\r\n        }\r\n        parseDataUri(inputSrc).filter(function () {\r\n          return isValidDataImg(img, settings);\r\n        }).bind(function (_a) {\r\n          var type = _a.type, data = _a.data;\r\n          return Optional.from(blobCache.getByData(data, type)).orThunk(function () {\r\n            return buildBlob(type, data).map(function (blob) {\r\n              var blobInfo = blobCache.create(uniqueId(), blob, data);\r\n              blobCache.add(blobInfo);\r\n              return blobInfo;\r\n            });\r\n          });\r\n        }).each(function (blobInfo) {\r\n          img.attr('src', blobInfo.blobUri());\r\n        });\r\n      };\r\n      if (blobCache) {\r\n        parser.addAttributeFilter('src', function (nodes) {\r\n          return each$k(nodes, processImage);\r\n        });\r\n      }\r\n    };\r\n    var register$1 = function (parser, settings) {\r\n      var schema = parser.schema;\r\n      if (settings.remove_trailing_brs) {\r\n        parser.addNodeFilter('br', function (nodes, _, args) {\r\n          var i;\r\n          var l = nodes.length;\r\n          var node;\r\n          var blockElements = Tools.extend({}, schema.getBlockElements());\r\n          var nonEmptyElements = schema.getNonEmptyElements();\r\n          var parent, lastParent, prev, prevName;\r\n          var whiteSpaceElements = schema.getWhiteSpaceElements();\r\n          var elementRule, textNode;\r\n          blockElements.body = 1;\r\n          for (i = 0; i < l; i++) {\r\n            node = nodes[i];\r\n            parent = node.parent;\r\n            if (blockElements[node.parent.name] && node === parent.lastChild) {\r\n              prev = node.prev;\r\n              while (prev) {\r\n                prevName = prev.name;\r\n                if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\r\n                  if (prevName === 'br') {\r\n                    node = null;\r\n                  }\r\n                  break;\r\n                }\r\n                prev = prev.prev;\r\n              }\r\n              if (node) {\r\n                node.remove();\r\n                if (isEmpty(schema, nonEmptyElements, whiteSpaceElements, parent)) {\r\n                  elementRule = schema.getElementRule(parent.name);\r\n                  if (elementRule) {\r\n                    if (elementRule.removeEmpty) {\r\n                      parent.remove();\r\n                    } else if (elementRule.paddEmpty) {\r\n                      paddEmptyNode(settings, args, blockElements, parent);\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            } else {\r\n              lastParent = node;\r\n              while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\r\n                lastParent = parent;\r\n                if (blockElements[parent.name]) {\r\n                  break;\r\n                }\r\n                parent = parent.parent;\r\n              }\r\n              if (lastParent === parent && settings.padd_empty_with_br !== true) {\r\n                textNode = new AstNode('#text', 3);\r\n                textNode.value = nbsp;\r\n                node.replace(textNode);\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n      parser.addAttributeFilter('href', function (nodes) {\r\n        var i = nodes.length;\r\n        var appendRel = function (rel) {\r\n          var parts = rel.split(' ').filter(function (p) {\r\n            return p.length > 0;\r\n          });\r\n          return parts.concat(['noopener']).sort().join(' ');\r\n        };\r\n        var addNoOpener = function (rel) {\r\n          var newRel = rel ? Tools.trim(rel) : '';\r\n          if (!/\\b(noopener)\\b/g.test(newRel)) {\r\n            return appendRel(newRel);\r\n          } else {\r\n            return newRel;\r\n          }\r\n        };\r\n        if (!settings.allow_unsafe_link_target) {\r\n          while (i--) {\r\n            var node = nodes[i];\r\n            if (node.name === 'a' && node.attr('target') === '_blank') {\r\n              node.attr('rel', addNoOpener(node.attr('rel')));\r\n            }\r\n          }\r\n        }\r\n      });\r\n      if (!settings.allow_html_in_named_anchor) {\r\n        parser.addAttributeFilter('id,name', function (nodes) {\r\n          var i = nodes.length, sibling, prevSibling, parent, node;\r\n          while (i--) {\r\n            node = nodes[i];\r\n            if (node.name === 'a' && node.firstChild && !node.attr('href')) {\r\n              parent = node.parent;\r\n              sibling = node.lastChild;\r\n              do {\r\n                prevSibling = sibling.prev;\r\n                parent.insert(sibling, node);\r\n                sibling = prevSibling;\r\n              } while (sibling);\r\n            }\r\n          }\r\n        });\r\n      }\r\n      if (settings.fix_list_elements) {\r\n        parser.addNodeFilter('ul,ol', function (nodes) {\r\n          var i = nodes.length, node, parentNode;\r\n          while (i--) {\r\n            node = nodes[i];\r\n            parentNode = node.parent;\r\n            if (parentNode.name === 'ul' || parentNode.name === 'ol') {\r\n              if (node.prev && node.prev.name === 'li') {\r\n                node.prev.append(node);\r\n              } else {\r\n                var li = new AstNode('li', 1);\r\n                li.attr('style', 'list-style-type: none');\r\n                node.wrap(li);\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n      if (settings.validate && schema.getValidClasses()) {\r\n        parser.addAttributeFilter('class', function (nodes) {\r\n          var validClasses = schema.getValidClasses();\r\n          var i = nodes.length;\r\n          while (i--) {\r\n            var node = nodes[i];\r\n            var classList = node.attr('class').split(' ');\r\n            var classValue = '';\r\n            for (var ci = 0; ci < classList.length; ci++) {\r\n              var className = classList[ci];\r\n              var valid = false;\r\n              var validClassesMap = validClasses['*'];\r\n              if (validClassesMap && validClassesMap[className]) {\r\n                valid = true;\r\n              }\r\n              validClassesMap = validClasses[node.name];\r\n              if (!valid && validClassesMap && validClassesMap[className]) {\r\n                valid = true;\r\n              }\r\n              if (valid) {\r\n                if (classValue) {\r\n                  classValue += ' ';\r\n                }\r\n                classValue += className;\r\n              }\r\n            }\r\n            if (!classValue.length) {\r\n              classValue = null;\r\n            }\r\n            node.attr('class', classValue);\r\n          }\r\n        });\r\n      }\r\n      registerBase64ImageFilter(parser, settings);\r\n    };\r\n\r\n    var each$7 = Tools.each, trim = Tools.trim;\r\n    var queryParts = 'source protocol authority userInfo user password host port relative path directory file query anchor'.split(' ');\r\n    var DEFAULT_PORTS = {\r\n      ftp: 21,\r\n      http: 80,\r\n      https: 443,\r\n      mailto: 25\r\n    };\r\n    var safeSvgDataUrlElements = [\r\n      'img',\r\n      'video'\r\n    ];\r\n    var blockSvgDataUris = function (allowSvgDataUrls, tagName) {\r\n      if (isNonNullable(allowSvgDataUrls)) {\r\n        return !allowSvgDataUrls;\r\n      } else {\r\n        return isNonNullable(tagName) ? !contains$3(safeSvgDataUrlElements, tagName) : true;\r\n      }\r\n    };\r\n    var isInvalidUri = function (settings, uri, tagName) {\r\n      if (settings.allow_html_data_urls) {\r\n        return false;\r\n      } else if (/^data:image\\//i.test(uri)) {\r\n        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(uri);\r\n      } else {\r\n        return /^data:/i.test(uri);\r\n      }\r\n    };\r\n    var URI = function () {\r\n      function URI(url, settings) {\r\n        url = trim(url);\r\n        this.settings = settings || {};\r\n        var baseUri = this.settings.base_uri;\r\n        var self = this;\r\n        if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\r\n          self.source = url;\r\n          return;\r\n        }\r\n        var isProtocolRelative = url.indexOf('//') === 0;\r\n        if (url.indexOf('/') === 0 && !isProtocolRelative) {\r\n          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\r\n        }\r\n        if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\r\n          var baseUrl = this.settings.base_uri ? this.settings.base_uri.path : new URI(document.location.href).directory;\r\n          if (this.settings.base_uri && this.settings.base_uri.protocol == '') {\r\n            url = '//mce_host' + self.toAbsPath(baseUrl, url);\r\n          } else {\r\n            var match = /([^#?]*)([#?]?.*)/.exec(url);\r\n            url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\r\n          }\r\n        }\r\n        url = url.replace(/@@/g, '(mce_at)');\r\n        var urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\r\n        each$7(queryParts, function (v, i) {\r\n          var part = urlMatch[i];\r\n          if (part) {\r\n            part = part.replace(/\\(mce_at\\)/g, '@@');\r\n          }\r\n          self[v] = part;\r\n        });\r\n        if (baseUri) {\r\n          if (!self.protocol) {\r\n            self.protocol = baseUri.protocol;\r\n          }\r\n          if (!self.userInfo) {\r\n            self.userInfo = baseUri.userInfo;\r\n          }\r\n          if (!self.port && self.host === 'mce_host') {\r\n            self.port = baseUri.port;\r\n          }\r\n          if (!self.host || self.host === 'mce_host') {\r\n            self.host = baseUri.host;\r\n          }\r\n          self.source = '';\r\n        }\r\n        if (isProtocolRelative) {\r\n          self.protocol = '';\r\n        }\r\n      }\r\n      URI.parseDataUri = function (uri) {\r\n        var type;\r\n        var uriComponents = decodeURIComponent(uri).split(',');\r\n        var matches = /data:([^;]+)/.exec(uriComponents[0]);\r\n        if (matches) {\r\n          type = matches[1];\r\n        }\r\n        return {\r\n          type: type,\r\n          data: uriComponents[1]\r\n        };\r\n      };\r\n      URI.isDomSafe = function (uri, context, options) {\r\n        if (options === void 0) {\r\n          options = {};\r\n        }\r\n        if (options.allow_script_urls) {\r\n          return true;\r\n        } else {\r\n          var decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\r\n          try {\r\n            decodedUri = decodeURIComponent(decodedUri);\r\n          } catch (ex) {\r\n            decodedUri = unescape(decodedUri);\r\n          }\r\n          if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\r\n            return false;\r\n          }\r\n          return !isInvalidUri(options, decodedUri, context);\r\n        }\r\n      };\r\n      URI.getDocumentBaseUrl = function (loc) {\r\n        var baseUrl;\r\n        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\r\n          baseUrl = loc.href;\r\n        } else {\r\n          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\r\n        }\r\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\r\n          baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\r\n          if (!/[\\/\\\\]$/.test(baseUrl)) {\r\n            baseUrl += '/';\r\n          }\r\n        }\r\n        return baseUrl;\r\n      };\r\n      URI.prototype.setPath = function (path) {\r\n        var pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\r\n        this.path = pathMatch[0];\r\n        this.directory = pathMatch[1];\r\n        this.file = pathMatch[2];\r\n        this.source = '';\r\n        this.getURI();\r\n      };\r\n      URI.prototype.toRelative = function (uri) {\r\n        var output;\r\n        if (uri === './') {\r\n          return uri;\r\n        }\r\n        var relativeUri = new URI(uri, { base_uri: this });\r\n        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\r\n          return relativeUri.getURI();\r\n        }\r\n        var tu = this.getURI(), uu = relativeUri.getURI();\r\n        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\r\n          return tu;\r\n        }\r\n        output = this.toRelPath(this.path, relativeUri.path);\r\n        if (relativeUri.query) {\r\n          output += '?' + relativeUri.query;\r\n        }\r\n        if (relativeUri.anchor) {\r\n          output += '#' + relativeUri.anchor;\r\n        }\r\n        return output;\r\n      };\r\n      URI.prototype.toAbsolute = function (uri, noHost) {\r\n        var absoluteUri = new URI(uri, { base_uri: this });\r\n        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\r\n      };\r\n      URI.prototype.isSameOrigin = function (uri) {\r\n        if (this.host == uri.host && this.protocol == uri.protocol) {\r\n          if (this.port == uri.port) {\r\n            return true;\r\n          }\r\n          var defaultPort = DEFAULT_PORTS[this.protocol];\r\n          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      URI.prototype.toRelPath = function (base, path) {\r\n        var breakPoint = 0, out = '', i, l;\r\n        var normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\r\n        var items = path.split('/');\r\n        if (normalizedBase.length >= items.length) {\r\n          for (i = 0, l = normalizedBase.length; i < l; i++) {\r\n            if (i >= items.length || normalizedBase[i] !== items[i]) {\r\n              breakPoint = i + 1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (normalizedBase.length < items.length) {\r\n          for (i = 0, l = items.length; i < l; i++) {\r\n            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\r\n              breakPoint = i + 1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (breakPoint === 1) {\r\n          return path;\r\n        }\r\n        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\r\n          out += '../';\r\n        }\r\n        for (i = breakPoint - 1, l = items.length; i < l; i++) {\r\n          if (i !== breakPoint - 1) {\r\n            out += '/' + items[i];\r\n          } else {\r\n            out += items[i];\r\n          }\r\n        }\r\n        return out;\r\n      };\r\n      URI.prototype.toAbsPath = function (base, path) {\r\n        var i, nb = 0, o = [], outPath;\r\n        var tr = /\\/$/.test(path) ? '/' : '';\r\n        var normalizedBase = base.split('/');\r\n        var normalizedPath = path.split('/');\r\n        each$7(normalizedBase, function (k) {\r\n          if (k) {\r\n            o.push(k);\r\n          }\r\n        });\r\n        normalizedBase = o;\r\n        for (i = normalizedPath.length - 1, o = []; i >= 0; i--) {\r\n          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\r\n            continue;\r\n          }\r\n          if (normalizedPath[i] === '..') {\r\n            nb++;\r\n            continue;\r\n          }\r\n          if (nb > 0) {\r\n            nb--;\r\n            continue;\r\n          }\r\n          o.push(normalizedPath[i]);\r\n        }\r\n        i = normalizedBase.length - nb;\r\n        if (i <= 0) {\r\n          outPath = reverse(o).join('/');\r\n        } else {\r\n          outPath = normalizedBase.slice(0, i).join('/') + '/' + reverse(o).join('/');\r\n        }\r\n        if (outPath.indexOf('/') !== 0) {\r\n          outPath = '/' + outPath;\r\n        }\r\n        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\r\n          outPath += tr;\r\n        }\r\n        return outPath;\r\n      };\r\n      URI.prototype.getURI = function (noProtoHost) {\r\n        if (noProtoHost === void 0) {\r\n          noProtoHost = false;\r\n        }\r\n        var s;\r\n        if (!this.source || noProtoHost) {\r\n          s = '';\r\n          if (!noProtoHost) {\r\n            if (this.protocol) {\r\n              s += this.protocol + '://';\r\n            } else {\r\n              s += '//';\r\n            }\r\n            if (this.userInfo) {\r\n              s += this.userInfo + '@';\r\n            }\r\n            if (this.host) {\r\n              s += this.host;\r\n            }\r\n            if (this.port) {\r\n              s += ':' + this.port;\r\n            }\r\n          }\r\n          if (this.path) {\r\n            s += this.path;\r\n          }\r\n          if (this.query) {\r\n            s += '?' + this.query;\r\n          }\r\n          if (this.anchor) {\r\n            s += '#' + this.anchor;\r\n          }\r\n          this.source = s;\r\n        }\r\n        return this.source;\r\n      };\r\n      return URI;\r\n    }();\r\n\r\n    var filteredClobberElements = Tools.makeMap('button,fieldset,form,iframe,img,image,input,object,output,select,textarea');\r\n    var isValidPrefixAttrName = function (name) {\r\n      return name.indexOf('data-') === 0 || name.indexOf('aria-') === 0;\r\n    };\r\n    var lazyTempDocument = cached(function () {\r\n      return document.implementation.createHTMLDocument('parser');\r\n    });\r\n    var findMatchingEndTagIndex = function (schema, html, startIndex) {\r\n      var startTagRegExp = /<([!?\\/])?([A-Za-z0-9\\-_:.]+)/g;\r\n      var endTagRegExp = /(?:\\s(?:[^'\">]+(?:\"[^\"]*\"|'[^']*'))*[^\"'>]*(?:\"[^\">]*|'[^'>]*)?|\\s*|\\/)>/g;\r\n      var shortEndedElements = schema.getShortEndedElements();\r\n      var count = 1, index = startIndex;\r\n      while (count !== 0) {\r\n        startTagRegExp.lastIndex = index;\r\n        while (true) {\r\n          var startMatch = startTagRegExp.exec(html);\r\n          if (startMatch === null) {\r\n            return index;\r\n          } else if (startMatch[1] === '!') {\r\n            if (startsWith(startMatch[2], '--')) {\r\n              index = findCommentEndIndex(html, false, startMatch.index + '!--'.length);\r\n            } else {\r\n              index = findCommentEndIndex(html, true, startMatch.index + 1);\r\n            }\r\n            break;\r\n          } else {\r\n            endTagRegExp.lastIndex = startTagRegExp.lastIndex;\r\n            var endMatch = endTagRegExp.exec(html);\r\n            if (isNull(endMatch) || endMatch.index !== startTagRegExp.lastIndex) {\r\n              continue;\r\n            }\r\n            if (startMatch[1] === '/') {\r\n              count -= 1;\r\n            } else if (!has$2(shortEndedElements, startMatch[2])) {\r\n              count += 1;\r\n            }\r\n            index = startTagRegExp.lastIndex + endMatch[0].length;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      return index;\r\n    };\r\n    var isConditionalComment = function (html, startIndex) {\r\n      return /^\\s*\\[if [\\w\\W]+\\]>.*<!\\[endif\\](--!?)?>/.test(html.substr(startIndex));\r\n    };\r\n    var findCommentEndIndex = function (html, isBogus, startIndex) {\r\n      if (startIndex === void 0) {\r\n        startIndex = 0;\r\n      }\r\n      var lcHtml = html.toLowerCase();\r\n      if (lcHtml.indexOf('[if ', startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {\r\n        var endIfIndex = lcHtml.indexOf('[endif]', startIndex);\r\n        return lcHtml.indexOf('>', endIfIndex);\r\n      } else {\r\n        if (isBogus) {\r\n          var endIndex = lcHtml.indexOf('>', startIndex);\r\n          return endIndex !== -1 ? endIndex : lcHtml.length;\r\n        } else {\r\n          var endCommentRegexp = /--!?>/g;\r\n          endCommentRegexp.lastIndex = startIndex;\r\n          var match = endCommentRegexp.exec(html);\r\n          return match ? match.index + match[0].length : lcHtml.length;\r\n        }\r\n      }\r\n    };\r\n    var checkBogusAttribute = function (regExp, attrString) {\r\n      var matches = regExp.exec(attrString);\r\n      if (matches) {\r\n        var name_1 = matches[1];\r\n        var value = matches[2];\r\n        return typeof name_1 === 'string' && name_1.toLowerCase() === 'data-mce-bogus' ? value : null;\r\n      } else {\r\n        return null;\r\n      }\r\n    };\r\n    var SaxParser = function (settings, schema) {\r\n      if (schema === void 0) {\r\n        schema = Schema();\r\n      }\r\n      settings = settings || {};\r\n      var doc = lazyTempDocument();\r\n      var form = doc.createElement('form');\r\n      if (settings.fix_self_closing !== false) {\r\n        settings.fix_self_closing = true;\r\n      }\r\n      var comment = settings.comment ? settings.comment : noop;\r\n      var cdata = settings.cdata ? settings.cdata : noop;\r\n      var text = settings.text ? settings.text : noop;\r\n      var start = settings.start ? settings.start : noop;\r\n      var end = settings.end ? settings.end : noop;\r\n      var pi = settings.pi ? settings.pi : noop;\r\n      var doctype = settings.doctype ? settings.doctype : noop;\r\n      var parseInternal = function (base64Extract, format) {\r\n        if (format === void 0) {\r\n          format = 'html';\r\n        }\r\n        var html = base64Extract.html;\r\n        var matches, index = 0, value, endRegExp;\r\n        var stack = [];\r\n        var attrList, i, textData, name;\r\n        var isInternalElement, isShortEnded;\r\n        var elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;\r\n        var attributesRequired, attributesDefault, attributesForced;\r\n        var anyAttributesRequired, attrValue, idCount = 0;\r\n        var decode = Entities.decode;\r\n        var filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\r\n        var parsingMode = format === 'html' ? 0 : 1;\r\n        var processEndTag = function (name) {\r\n          var pos, i;\r\n          pos = stack.length;\r\n          while (pos--) {\r\n            if (stack[pos].name === name) {\r\n              break;\r\n            }\r\n          }\r\n          if (pos >= 0) {\r\n            for (i = stack.length - 1; i >= pos; i--) {\r\n              name = stack[i];\r\n              if (name.valid) {\r\n                end(name.name);\r\n              }\r\n            }\r\n            stack.length = pos;\r\n          }\r\n        };\r\n        var processText = function (value, raw) {\r\n          return text(restoreDataUris(value, base64Extract), raw);\r\n        };\r\n        var processComment = function (value) {\r\n          if (value === '') {\r\n            return;\r\n          }\r\n          if (value.charAt(0) === '>') {\r\n            value = ' ' + value;\r\n          }\r\n          if (!settings.allow_conditional_comments && value.substr(0, 3).toLowerCase() === '[if') {\r\n            value = ' ' + value;\r\n          }\r\n          comment(restoreDataUris(value, base64Extract));\r\n        };\r\n        var processAttr = function (value) {\r\n          return restoreDataUris(value, base64Extract);\r\n        };\r\n        var processMalformedComment = function (value, startIndex) {\r\n          var startTag = value || '';\r\n          var isBogus = !startsWith(startTag, '--');\r\n          var endIndex = findCommentEndIndex(html, isBogus, startIndex);\r\n          value = html.substr(startIndex, endIndex - startIndex);\r\n          processComment(isBogus ? startTag + value : value);\r\n          return endIndex + 1;\r\n        };\r\n        var parseAttribute = function (tagName, name, value, val2, val3) {\r\n          name = name.toLowerCase();\r\n          value = processAttr(name in fillAttrsMap ? name : decode(value || val2 || val3 || ''));\r\n          if (validate && !isInternalElement && isValidPrefixAttrName(name) === false) {\r\n            var attrRule = validAttributesMap[name];\r\n            if (!attrRule && validAttributePatterns) {\r\n              var i_1 = validAttributePatterns.length;\r\n              while (i_1--) {\r\n                attrRule = validAttributePatterns[i_1];\r\n                if (attrRule.pattern.test(name)) {\r\n                  break;\r\n                }\r\n              }\r\n              if (i_1 === -1) {\r\n                attrRule = null;\r\n              }\r\n            }\r\n            if (!attrRule) {\r\n              return;\r\n            }\r\n            if (attrRule.validValues && !(value in attrRule.validValues)) {\r\n              return;\r\n            }\r\n          }\r\n          var isNameOrId = name === 'name' || name === 'id';\r\n          if (isNameOrId && tagName in filteredClobberElements && (value in doc || value in form)) {\r\n            return;\r\n          }\r\n          if (filteredUrlAttrs[name] && !URI.isDomSafe(value, tagName, settings)) {\r\n            return;\r\n          }\r\n          if (isInternalElement && (name in filteredUrlAttrs || name.indexOf('on') === 0)) {\r\n            return;\r\n          }\r\n          attrList.map[name] = value;\r\n          attrList.push({\r\n            name: name,\r\n            value: value\r\n          });\r\n        };\r\n        var tokenRegExp = new RegExp('<(?:' + '(?:!--([\\\\w\\\\W]*?)--!?>)|' + '(?:!\\\\[CDATA\\\\[([\\\\w\\\\W]*?)\\\\]\\\\]>)|' + '(?:![Dd][Oo][Cc][Tt][Yy][Pp][Ee]([\\\\w\\\\W]*?)>)|' + '(?:!(--)?)|' + '(?:\\\\?([^\\\\s\\\\/<>]+) ?([\\\\w\\\\W]*?)[?/]>)|' + '(?:\\\\/([A-Za-z][A-Za-z0-9\\\\-_\\\\:\\\\.]*)>)|' + '(?:([A-Za-z][A-Za-z0-9\\\\-_:.]*)(\\\\s(?:[^\\'\">]+(?:\"[^\"]*\"|\\'[^\\']*\\'))*[^\"\\'>]*(?:\"[^\">]*|\\'[^\\'>]*)?|\\\\s*|\\\\/)>)' + ')', 'g');\r\n        var attrRegExp = /([\\w:\\-]+)(?:\\s*=\\s*(?:(?:\\\"((?:[^\\\"])*)\\\")|(?:\\'((?:[^\\'])*)\\')|([^>\\s]+)))?/g;\r\n        var shortEndedElements = schema.getShortEndedElements();\r\n        var selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();\r\n        var fillAttrsMap = schema.getBoolAttrs();\r\n        var validate = settings.validate;\r\n        var removeInternalElements = settings.remove_internals;\r\n        var fixSelfClosing = settings.fix_self_closing;\r\n        var specialElements = schema.getSpecialElements();\r\n        var processHtml = html + '>';\r\n        while (matches = tokenRegExp.exec(processHtml)) {\r\n          var matchText = matches[0];\r\n          if (index < matches.index) {\r\n            processText(decode(html.substr(index, matches.index - index)));\r\n          }\r\n          if (value = matches[7]) {\r\n            value = value.toLowerCase();\r\n            if (value.charAt(0) === ':') {\r\n              value = value.substr(1);\r\n            }\r\n            processEndTag(value);\r\n          } else if (value = matches[8]) {\r\n            if (matches.index + matchText.length > html.length) {\r\n              processText(decode(html.substr(matches.index)));\r\n              index = matches.index + matchText.length;\r\n              continue;\r\n            }\r\n            value = value.toLowerCase();\r\n            if (value.charAt(0) === ':') {\r\n              value = value.substr(1);\r\n            }\r\n            isShortEnded = value in shortEndedElements;\r\n            if (fixSelfClosing && selfClosing[value] && stack.length > 0 && stack[stack.length - 1].name === value) {\r\n              processEndTag(value);\r\n            }\r\n            var bogusValue = checkBogusAttribute(attrRegExp, matches[9]);\r\n            if (bogusValue !== null) {\r\n              if (bogusValue === 'all') {\r\n                index = findMatchingEndTagIndex(schema, html, tokenRegExp.lastIndex);\r\n                tokenRegExp.lastIndex = index;\r\n                continue;\r\n              }\r\n              isValidElement = false;\r\n            }\r\n            if (!validate || (elementRule = schema.getElementRule(value))) {\r\n              isValidElement = true;\r\n              if (validate) {\r\n                validAttributesMap = elementRule.attributes;\r\n                validAttributePatterns = elementRule.attributePatterns;\r\n              }\r\n              if (attribsValue = matches[9]) {\r\n                isInternalElement = attribsValue.indexOf('data-mce-type') !== -1;\r\n                if (isInternalElement && removeInternalElements) {\r\n                  isValidElement = false;\r\n                }\r\n                attrList = [];\r\n                attrList.map = {};\r\n                attribsValue.replace(attrRegExp, function (match, name, val, val2, val3) {\r\n                  parseAttribute(value, name, val, val2, val3);\r\n                  return '';\r\n                });\r\n              } else {\r\n                attrList = [];\r\n                attrList.map = {};\r\n              }\r\n              if (validate && !isInternalElement) {\r\n                attributesRequired = elementRule.attributesRequired;\r\n                attributesDefault = elementRule.attributesDefault;\r\n                attributesForced = elementRule.attributesForced;\r\n                anyAttributesRequired = elementRule.removeEmptyAttrs;\r\n                if (anyAttributesRequired && !attrList.length) {\r\n                  isValidElement = false;\r\n                }\r\n                if (attributesForced) {\r\n                  i = attributesForced.length;\r\n                  while (i--) {\r\n                    attr = attributesForced[i];\r\n                    name = attr.name;\r\n                    attrValue = attr.value;\r\n                    if (attrValue === '{$uid}') {\r\n                      attrValue = 'mce_' + idCount++;\r\n                    }\r\n                    attrList.map[name] = attrValue;\r\n                    attrList.push({\r\n                      name: name,\r\n                      value: attrValue\r\n                    });\r\n                  }\r\n                }\r\n                if (attributesDefault) {\r\n                  i = attributesDefault.length;\r\n                  while (i--) {\r\n                    attr = attributesDefault[i];\r\n                    name = attr.name;\r\n                    if (!(name in attrList.map)) {\r\n                      attrValue = attr.value;\r\n                      if (attrValue === '{$uid}') {\r\n                        attrValue = 'mce_' + idCount++;\r\n                      }\r\n                      attrList.map[name] = attrValue;\r\n                      attrList.push({\r\n                        name: name,\r\n                        value: attrValue\r\n                      });\r\n                    }\r\n                  }\r\n                }\r\n                if (attributesRequired) {\r\n                  i = attributesRequired.length;\r\n                  while (i--) {\r\n                    if (attributesRequired[i] in attrList.map) {\r\n                      break;\r\n                    }\r\n                  }\r\n                  if (i === -1) {\r\n                    isValidElement = false;\r\n                  }\r\n                }\r\n                if (attr = attrList.map['data-mce-bogus']) {\r\n                  if (attr === 'all') {\r\n                    index = findMatchingEndTagIndex(schema, html, tokenRegExp.lastIndex);\r\n                    tokenRegExp.lastIndex = index;\r\n                    continue;\r\n                  }\r\n                  isValidElement = false;\r\n                }\r\n              }\r\n              if (isValidElement) {\r\n                start(value, attrList, isShortEnded);\r\n              }\r\n            } else {\r\n              isValidElement = false;\r\n            }\r\n            if (endRegExp = specialElements[value]) {\r\n              endRegExp.lastIndex = index = matches.index + matchText.length;\r\n              if (matches = endRegExp.exec(html)) {\r\n                if (isValidElement) {\r\n                  textData = html.substr(index, matches.index - index);\r\n                }\r\n                index = matches.index + matches[0].length;\r\n              } else {\r\n                textData = html.substr(index);\r\n                index = html.length;\r\n              }\r\n              if (isValidElement) {\r\n                if (textData.length > 0) {\r\n                  processText(textData, true);\r\n                }\r\n                end(value);\r\n              }\r\n              tokenRegExp.lastIndex = index;\r\n              continue;\r\n            }\r\n            if (!isShortEnded) {\r\n              if (!attribsValue || attribsValue.indexOf('/') !== attribsValue.length - 1) {\r\n                stack.push({\r\n                  name: value,\r\n                  valid: isValidElement\r\n                });\r\n              } else if (isValidElement) {\r\n                end(value);\r\n              }\r\n            }\r\n          } else if (value = matches[1]) {\r\n            processComment(value);\r\n          } else if (value = matches[2]) {\r\n            var isValidCdataSection = parsingMode === 1 || settings.preserve_cdata || stack.length > 0 && schema.isValidChild(stack[stack.length - 1].name, '#cdata');\r\n            if (isValidCdataSection) {\r\n              cdata(value);\r\n            } else {\r\n              index = processMalformedComment('', matches.index + 2);\r\n              tokenRegExp.lastIndex = index;\r\n              continue;\r\n            }\r\n          } else if (value = matches[3]) {\r\n            doctype(value);\r\n          } else if ((value = matches[4]) || matchText === '<!') {\r\n            index = processMalformedComment(value, matches.index + matchText.length);\r\n            tokenRegExp.lastIndex = index;\r\n            continue;\r\n          } else if (value = matches[5]) {\r\n            if (parsingMode === 1) {\r\n              pi(value, matches[6]);\r\n            } else {\r\n              index = processMalformedComment('?', matches.index + 2);\r\n              tokenRegExp.lastIndex = index;\r\n              continue;\r\n            }\r\n          }\r\n          index = matches.index + matchText.length;\r\n        }\r\n        if (index < html.length) {\r\n          processText(decode(html.substr(index)));\r\n        }\r\n        for (i = stack.length - 1; i >= 0; i--) {\r\n          value = stack[i];\r\n          if (value.valid) {\r\n            end(value.name);\r\n          }\r\n        }\r\n      };\r\n      var parse = function (html, format) {\r\n        if (format === void 0) {\r\n          format = 'html';\r\n        }\r\n        parseInternal(extractBase64DataUris(html), format);\r\n      };\r\n      return { parse: parse };\r\n    };\r\n    SaxParser.findEndTag = findMatchingEndTagIndex;\r\n\r\n    var makeMap = Tools.makeMap, each$6 = Tools.each, explode$2 = Tools.explode, extend$4 = Tools.extend;\r\n    var DomParser = function (settings, schema) {\r\n      if (schema === void 0) {\r\n        schema = Schema();\r\n      }\r\n      var nodeFilters = {};\r\n      var attributeFilters = [];\r\n      var matchedNodes = {};\r\n      var matchedAttributes = {};\r\n      settings = settings || {};\r\n      settings.validate = 'validate' in settings ? settings.validate : true;\r\n      settings.root_name = settings.root_name || 'body';\r\n      var fixInvalidChildren = function (nodes) {\r\n        var nonSplitableElements = makeMap('tr,td,th,tbody,thead,tfoot,table');\r\n        var nonEmptyElements = schema.getNonEmptyElements();\r\n        var whitespaceElements = schema.getWhiteSpaceElements();\r\n        var textBlockElements = schema.getTextBlockElements();\r\n        var specialElements = schema.getSpecialElements();\r\n        var removeOrUnwrapInvalidNode = function (node, originalNodeParent) {\r\n          if (originalNodeParent === void 0) {\r\n            originalNodeParent = node.parent;\r\n          }\r\n          if (specialElements[node.name]) {\r\n            node.empty().remove();\r\n          } else {\r\n            var children = node.children();\r\n            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\r\n              var childNode = children_1[_i];\r\n              if (!schema.isValidChild(originalNodeParent.name, childNode.name)) {\r\n                removeOrUnwrapInvalidNode(childNode, originalNodeParent);\r\n              }\r\n            }\r\n            node.unwrap();\r\n          }\r\n        };\r\n        for (var ni = 0; ni < nodes.length; ni++) {\r\n          var node = nodes[ni];\r\n          var parent_1 = void 0, newParent = void 0, tempNode = void 0;\r\n          if (!node.parent || node.fixed) {\r\n            continue;\r\n          }\r\n          if (textBlockElements[node.name] && node.parent.name === 'li') {\r\n            var sibling = node.next;\r\n            while (sibling) {\r\n              if (textBlockElements[sibling.name]) {\r\n                sibling.name = 'li';\r\n                sibling.fixed = true;\r\n                node.parent.insert(sibling, node.parent);\r\n              } else {\r\n                break;\r\n              }\r\n              sibling = sibling.next;\r\n            }\r\n            node.unwrap();\r\n            continue;\r\n          }\r\n          var parents = [node];\r\n          for (parent_1 = node.parent; parent_1 && !schema.isValidChild(parent_1.name, node.name) && !nonSplitableElements[parent_1.name]; parent_1 = parent_1.parent) {\r\n            parents.push(parent_1);\r\n          }\r\n          if (parent_1 && parents.length > 1) {\r\n            if (schema.isValidChild(parent_1.name, node.name)) {\r\n              parents.reverse();\r\n              newParent = filterNode(parents[0].clone());\r\n              var currentNode = newParent;\r\n              for (var i = 0; i < parents.length - 1; i++) {\r\n                if (schema.isValidChild(currentNode.name, parents[i].name)) {\r\n                  tempNode = filterNode(parents[i].clone());\r\n                  currentNode.append(tempNode);\r\n                } else {\r\n                  tempNode = currentNode;\r\n                }\r\n                for (var childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\r\n                  var nextNode = childNode.next;\r\n                  tempNode.append(childNode);\r\n                  childNode = nextNode;\r\n                }\r\n                currentNode = tempNode;\r\n              }\r\n              if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\r\n                parent_1.insert(newParent, parents[0], true);\r\n                parent_1.insert(node, newParent);\r\n              } else {\r\n                parent_1.insert(node, parents[0], true);\r\n              }\r\n              parent_1 = parents[0];\r\n              if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent_1) || hasOnlyChild(parent_1, 'br')) {\r\n                parent_1.empty().remove();\r\n              }\r\n            } else {\r\n              removeOrUnwrapInvalidNode(node);\r\n            }\r\n          } else if (node.parent) {\r\n            if (node.name === 'li') {\r\n              var sibling = node.prev;\r\n              if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\r\n                sibling.append(node);\r\n                continue;\r\n              }\r\n              sibling = node.next;\r\n              if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\r\n                sibling.insert(node, sibling.firstChild, true);\r\n                continue;\r\n              }\r\n              node.wrap(filterNode(new AstNode('ul', 1)));\r\n              continue;\r\n            }\r\n            if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\r\n              node.wrap(filterNode(new AstNode('div', 1)));\r\n            } else {\r\n              removeOrUnwrapInvalidNode(node);\r\n            }\r\n          }\r\n        }\r\n      };\r\n      var filterNode = function (node) {\r\n        var name = node.name;\r\n        if (name in nodeFilters) {\r\n          var list = matchedNodes[name];\r\n          if (list) {\r\n            list.push(node);\r\n          } else {\r\n            matchedNodes[name] = [node];\r\n          }\r\n        }\r\n        var i = attributeFilters.length;\r\n        while (i--) {\r\n          var attrName = attributeFilters[i].name;\r\n          if (attrName in node.attributes.map) {\r\n            var list = matchedAttributes[attrName];\r\n            if (list) {\r\n              list.push(node);\r\n            } else {\r\n              matchedAttributes[attrName] = [node];\r\n            }\r\n          }\r\n        }\r\n        return node;\r\n      };\r\n      var addNodeFilter = function (name, callback) {\r\n        each$6(explode$2(name), function (name) {\r\n          var list = nodeFilters[name];\r\n          if (!list) {\r\n            nodeFilters[name] = list = [];\r\n          }\r\n          list.push(callback);\r\n        });\r\n      };\r\n      var getNodeFilters = function () {\r\n        var out = [];\r\n        for (var name_1 in nodeFilters) {\r\n          if (has$2(nodeFilters, name_1)) {\r\n            out.push({\r\n              name: name_1,\r\n              callbacks: nodeFilters[name_1]\r\n            });\r\n          }\r\n        }\r\n        return out;\r\n      };\r\n      var addAttributeFilter = function (name, callback) {\r\n        each$6(explode$2(name), function (name) {\r\n          var i;\r\n          for (i = 0; i < attributeFilters.length; i++) {\r\n            if (attributeFilters[i].name === name) {\r\n              attributeFilters[i].callbacks.push(callback);\r\n              return;\r\n            }\r\n          }\r\n          attributeFilters.push({\r\n            name: name,\r\n            callbacks: [callback]\r\n          });\r\n        });\r\n      };\r\n      var getAttributeFilters = function () {\r\n        return [].concat(attributeFilters);\r\n      };\r\n      var parse = function (html, args) {\r\n        var nodes, i, l, fi, fl, list, name;\r\n        var invalidChildren = [];\r\n        var node;\r\n        var getRootBlockName = function (name) {\r\n          if (name === false) {\r\n            return '';\r\n          } else if (name === true) {\r\n            return 'p';\r\n          } else {\r\n            return name;\r\n          }\r\n        };\r\n        args = args || {};\r\n        matchedNodes = {};\r\n        matchedAttributes = {};\r\n        var blockElements = extend$4(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\r\n        var textRootBlockElements = getTextRootBlockElements(schema);\r\n        var nonEmptyElements = schema.getNonEmptyElements();\r\n        var children = schema.children;\r\n        var validate = settings.validate;\r\n        var forcedRootBlockName = 'forced_root_block' in args ? args.forced_root_block : settings.forced_root_block;\r\n        var rootBlockName = getRootBlockName(forcedRootBlockName);\r\n        var whiteSpaceElements = schema.getWhiteSpaceElements();\r\n        var startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\r\n        var endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\r\n        var allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\r\n        var isAllWhiteSpaceRegExp = /^[ \\t\\r\\n]+$/;\r\n        var isInWhiteSpacePreservedElement = has$2(whiteSpaceElements, args.context) || has$2(whiteSpaceElements, settings.root_name);\r\n        var addRootBlocks = function () {\r\n          var node = rootNode.firstChild, rootBlockNode = null;\r\n          var trim = function (rootBlock) {\r\n            if (rootBlock) {\r\n              node = rootBlock.firstChild;\r\n              if (node && node.type === 3) {\r\n                node.value = node.value.replace(startWhiteSpaceRegExp, '');\r\n              }\r\n              node = rootBlock.lastChild;\r\n              if (node && node.type === 3) {\r\n                node.value = node.value.replace(endWhiteSpaceRegExp, '');\r\n              }\r\n            }\r\n          };\r\n          if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\r\n            return;\r\n          }\r\n          while (node) {\r\n            var next = node.next;\r\n            if (node.type === 3 || node.type === 1 && node.name !== 'p' && !blockElements[node.name] && !node.attr('data-mce-type')) {\r\n              if (!rootBlockNode) {\r\n                rootBlockNode = createNode(rootBlockName, 1);\r\n                rootBlockNode.attr(settings.forced_root_block_attrs);\r\n                rootNode.insert(rootBlockNode, node);\r\n                rootBlockNode.append(node);\r\n              } else {\r\n                rootBlockNode.append(node);\r\n              }\r\n            } else {\r\n              trim(rootBlockNode);\r\n              rootBlockNode = null;\r\n            }\r\n            node = next;\r\n          }\r\n          trim(rootBlockNode);\r\n        };\r\n        var createNode = function (name, type) {\r\n          var node = new AstNode(name, type);\r\n          var list;\r\n          if (name in nodeFilters) {\r\n            list = matchedNodes[name];\r\n            if (list) {\r\n              list.push(node);\r\n            } else {\r\n              matchedNodes[name] = [node];\r\n            }\r\n          }\r\n          return node;\r\n        };\r\n        var removeWhitespaceBefore = function (node) {\r\n          var blockElements = schema.getBlockElements();\r\n          for (var textNode = node.prev; textNode && textNode.type === 3;) {\r\n            var textVal = textNode.value.replace(endWhiteSpaceRegExp, '');\r\n            if (textVal.length > 0) {\r\n              textNode.value = textVal;\r\n              return;\r\n            }\r\n            var textNodeNext = textNode.next;\r\n            if (textNodeNext) {\r\n              if (textNodeNext.type === 3 && textNodeNext.value.length) {\r\n                textNode = textNode.prev;\r\n                continue;\r\n              }\r\n              if (!blockElements[textNodeNext.name] && textNodeNext.name !== 'script' && textNodeNext.name !== 'style') {\r\n                textNode = textNode.prev;\r\n                continue;\r\n              }\r\n            }\r\n            var sibling = textNode.prev;\r\n            textNode.remove();\r\n            textNode = sibling;\r\n          }\r\n        };\r\n        var cloneAndExcludeBlocks = function (input) {\r\n          var output = {};\r\n          for (var name_2 in input) {\r\n            if (name_2 !== 'li' && name_2 !== 'p') {\r\n              output[name_2] = input[name_2];\r\n            }\r\n          }\r\n          return output;\r\n        };\r\n        var isTextRootBlockEmpty = function (node) {\r\n          var tempNode = node;\r\n          while (isNonNullable(tempNode)) {\r\n            if (tempNode.name in textRootBlockElements) {\r\n              return isEmpty(schema, nonEmptyElements, whiteSpaceElements, tempNode);\r\n            } else {\r\n              tempNode = tempNode.parent;\r\n            }\r\n          }\r\n          return false;\r\n        };\r\n        var parser = SaxParser({\r\n          validate: validate,\r\n          document: settings.document,\r\n          allow_html_data_urls: settings.allow_html_data_urls,\r\n          allow_svg_data_urls: settings.allow_svg_data_urls,\r\n          allow_script_urls: settings.allow_script_urls,\r\n          allow_conditional_comments: settings.allow_conditional_comments,\r\n          preserve_cdata: settings.preserve_cdata,\r\n          self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),\r\n          cdata: function (text) {\r\n            node.append(createNode('#cdata', 4)).value = text;\r\n          },\r\n          text: function (text, raw) {\r\n            var textNode;\r\n            if (!isInWhiteSpacePreservedElement) {\r\n              text = text.replace(allWhiteSpaceRegExp, ' ');\r\n              if (isLineBreakNode(node.lastChild, blockElements)) {\r\n                text = text.replace(startWhiteSpaceRegExp, '');\r\n              }\r\n            }\r\n            if (text.length !== 0) {\r\n              textNode = createNode('#text', 3);\r\n              textNode.raw = !!raw;\r\n              node.append(textNode).value = text;\r\n            }\r\n          },\r\n          comment: function (text) {\r\n            node.append(createNode('#comment', 8)).value = text;\r\n          },\r\n          pi: function (name, text) {\r\n            node.append(createNode(name, 7)).value = text;\r\n            removeWhitespaceBefore(node);\r\n          },\r\n          doctype: function (text) {\r\n            var newNode = node.append(createNode('#doctype', 10));\r\n            newNode.value = text;\r\n            removeWhitespaceBefore(node);\r\n          },\r\n          start: function (name, attrs, empty) {\r\n            var elementRule = validate ? schema.getElementRule(name) : {};\r\n            if (elementRule) {\r\n              var newNode = createNode(elementRule.outputName || name, 1);\r\n              newNode.attributes = attrs;\r\n              newNode.shortEnded = empty;\r\n              node.append(newNode);\r\n              var parent_2 = children[node.name];\r\n              if (parent_2 && children[newNode.name] && !parent_2[newNode.name]) {\r\n                invalidChildren.push(newNode);\r\n              }\r\n              var attrFiltersLen = attributeFilters.length;\r\n              while (attrFiltersLen--) {\r\n                var attrName = attributeFilters[attrFiltersLen].name;\r\n                if (attrName in attrs.map) {\r\n                  list = matchedAttributes[attrName];\r\n                  if (list) {\r\n                    list.push(newNode);\r\n                  } else {\r\n                    matchedAttributes[attrName] = [newNode];\r\n                  }\r\n                }\r\n              }\r\n              if (blockElements[name]) {\r\n                removeWhitespaceBefore(newNode);\r\n              }\r\n              if (!empty) {\r\n                node = newNode;\r\n              }\r\n              if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {\r\n                isInWhiteSpacePreservedElement = true;\r\n              }\r\n            }\r\n          },\r\n          end: function (name) {\r\n            var textNode, text, sibling;\r\n            var elementRule = validate ? schema.getElementRule(name) : {};\r\n            if (elementRule) {\r\n              if (blockElements[name]) {\r\n                if (!isInWhiteSpacePreservedElement) {\r\n                  textNode = node.firstChild;\r\n                  if (textNode && textNode.type === 3) {\r\n                    text = textNode.value.replace(startWhiteSpaceRegExp, '');\r\n                    if (text.length > 0) {\r\n                      textNode.value = text;\r\n                      textNode = textNode.next;\r\n                    } else {\r\n                      sibling = textNode.next;\r\n                      textNode.remove();\r\n                      textNode = sibling;\r\n                      while (textNode && textNode.type === 3) {\r\n                        text = textNode.value;\r\n                        sibling = textNode.next;\r\n                        if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {\r\n                          textNode.remove();\r\n                          textNode = sibling;\r\n                        }\r\n                        textNode = sibling;\r\n                      }\r\n                    }\r\n                  }\r\n                  textNode = node.lastChild;\r\n                  if (textNode && textNode.type === 3) {\r\n                    text = textNode.value.replace(endWhiteSpaceRegExp, '');\r\n                    if (text.length > 0) {\r\n                      textNode.value = text;\r\n                      textNode = textNode.prev;\r\n                    } else {\r\n                      sibling = textNode.prev;\r\n                      textNode.remove();\r\n                      textNode = sibling;\r\n                      while (textNode && textNode.type === 3) {\r\n                        text = textNode.value;\r\n                        sibling = textNode.prev;\r\n                        if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {\r\n                          textNode.remove();\r\n                          textNode = sibling;\r\n                        }\r\n                        textNode = sibling;\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              if (isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {\r\n                isInWhiteSpacePreservedElement = false;\r\n              }\r\n              var isNodeEmpty = isEmpty(schema, nonEmptyElements, whiteSpaceElements, node);\r\n              var parentNode = node.parent;\r\n              if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {\r\n                paddEmptyNode(settings, args, blockElements, node);\r\n              } else if (elementRule.removeEmpty && isNodeEmpty) {\r\n                if (blockElements[node.name]) {\r\n                  node.empty().remove();\r\n                } else {\r\n                  node.unwrap();\r\n                }\r\n              } else if (elementRule.paddEmpty && (isPaddedWithNbsp(node) || isNodeEmpty)) {\r\n                paddEmptyNode(settings, args, blockElements, node);\r\n              }\r\n              node = parentNode;\r\n            }\r\n          }\r\n        }, schema);\r\n        var rootNode = node = new AstNode(args.context || settings.root_name, 11);\r\n        parser.parse(html, args.format);\r\n        if (validate && invalidChildren.length) {\r\n          if (!args.context) {\r\n            fixInvalidChildren(invalidChildren);\r\n          } else {\r\n            args.invalid = true;\r\n          }\r\n        }\r\n        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\r\n          addRootBlocks();\r\n        }\r\n        if (!args.invalid) {\r\n          for (name in matchedNodes) {\r\n            if (!has$2(matchedNodes, name)) {\r\n              continue;\r\n            }\r\n            list = nodeFilters[name];\r\n            nodes = matchedNodes[name];\r\n            fi = nodes.length;\r\n            while (fi--) {\r\n              if (!nodes[fi].parent) {\r\n                nodes.splice(fi, 1);\r\n              }\r\n            }\r\n            for (i = 0, l = list.length; i < l; i++) {\r\n              list[i](nodes, name, args);\r\n            }\r\n          }\r\n          for (i = 0, l = attributeFilters.length; i < l; i++) {\r\n            list = attributeFilters[i];\r\n            if (list.name in matchedAttributes) {\r\n              nodes = matchedAttributes[list.name];\r\n              fi = nodes.length;\r\n              while (fi--) {\r\n                if (!nodes[fi].parent) {\r\n                  nodes.splice(fi, 1);\r\n                }\r\n              }\r\n              for (fi = 0, fl = list.callbacks.length; fi < fl; fi++) {\r\n                list.callbacks[fi](nodes, list.name, args);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return rootNode;\r\n      };\r\n      var exports = {\r\n        schema: schema,\r\n        addAttributeFilter: addAttributeFilter,\r\n        getAttributeFilters: getAttributeFilters,\r\n        addNodeFilter: addNodeFilter,\r\n        getNodeFilters: getNodeFilters,\r\n        filterNode: filterNode,\r\n        parse: parse\r\n      };\r\n      register$1(exports, settings);\r\n      register$2(exports, settings);\r\n      return exports;\r\n    };\r\n\r\n    var register = function (htmlParser, settings, dom) {\r\n      htmlParser.addAttributeFilter('data-mce-tabindex', function (nodes, name) {\r\n        var i = nodes.length;\r\n        while (i--) {\r\n          var node = nodes[i];\r\n          node.attr('tabindex', node.attr('data-mce-tabindex'));\r\n          node.attr(name, null);\r\n        }\r\n      });\r\n      htmlParser.addAttributeFilter('src,href,style', function (nodes, name) {\r\n        var internalName = 'data-mce-' + name;\r\n        var urlConverter = settings.url_converter;\r\n        var urlConverterScope = settings.url_converter_scope;\r\n        var i = nodes.length;\r\n        while (i--) {\r\n          var node = nodes[i];\r\n          var value = node.attr(internalName);\r\n          if (value !== undefined) {\r\n            node.attr(name, value.length > 0 ? value : null);\r\n            node.attr(internalName, null);\r\n          } else {\r\n            value = node.attr(name);\r\n            if (name === 'style') {\r\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\r\n            } else if (urlConverter) {\r\n              value = urlConverter.call(urlConverterScope, value, name, node.name);\r\n            }\r\n            node.attr(name, value.length > 0 ? value : null);\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addAttributeFilter('class', function (nodes) {\r\n        var i = nodes.length;\r\n        while (i--) {\r\n          var node = nodes[i];\r\n          var value = node.attr('class');\r\n          if (value) {\r\n            value = node.attr('class').replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\r\n            node.attr('class', value.length > 0 ? value : null);\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addAttributeFilter('data-mce-type', function (nodes, name, args) {\r\n        var i = nodes.length;\r\n        while (i--) {\r\n          var node = nodes[i];\r\n          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\r\n            var hasChildren = Optional.from(node.firstChild).exists(function (firstChild) {\r\n              return !isZwsp(firstChild.value);\r\n            });\r\n            if (hasChildren) {\r\n              node.unwrap();\r\n            } else {\r\n              node.remove();\r\n            }\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addNodeFilter('noscript', function (nodes) {\r\n        var i = nodes.length;\r\n        while (i--) {\r\n          var node = nodes[i].firstChild;\r\n          if (node) {\r\n            node.value = Entities.decode(node.value);\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addNodeFilter('script,style', function (nodes, name) {\r\n        var trim = function (value) {\r\n          return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\r\n        };\r\n        var i = nodes.length;\r\n        while (i--) {\r\n          var node = nodes[i];\r\n          var value = node.firstChild ? node.firstChild.value : '';\r\n          if (name === 'script') {\r\n            var type = node.attr('type');\r\n            if (type) {\r\n              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\r\n            }\r\n            if (settings.element_format === 'xhtml' && value.length > 0) {\r\n              node.firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\r\n            }\r\n          } else {\r\n            if (settings.element_format === 'xhtml' && value.length > 0) {\r\n              node.firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\r\n            }\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addNodeFilter('#comment', function (nodes) {\r\n        var i = nodes.length;\r\n        while (i--) {\r\n          var node = nodes[i];\r\n          if (settings.preserve_cdata && node.value.indexOf('[CDATA[') === 0) {\r\n            node.name = '#cdata';\r\n            node.type = 4;\r\n            node.value = dom.decode(node.value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\r\n          } else if (node.value.indexOf('mce:protected ') === 0) {\r\n            node.name = '#text';\r\n            node.type = 3;\r\n            node.raw = true;\r\n            node.value = unescape(node.value).substr(14);\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addNodeFilter('xml:namespace,input', function (nodes, name) {\r\n        var i = nodes.length;\r\n        while (i--) {\r\n          var node = nodes[i];\r\n          if (node.type === 7) {\r\n            node.remove();\r\n          } else if (node.type === 1) {\r\n            if (name === 'input' && !node.attr('type')) {\r\n              node.attr('type', 'text');\r\n            }\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addAttributeFilter('data-mce-type', function (nodes) {\r\n        each$k(nodes, function (node) {\r\n          if (node.attr('data-mce-type') === 'format-caret') {\r\n            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\r\n              node.remove();\r\n            } else {\r\n              node.unwrap();\r\n            }\r\n          }\r\n        });\r\n      });\r\n      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', function (nodes, name) {\r\n        var i = nodes.length;\r\n        while (i--) {\r\n          nodes[i].attr(name, null);\r\n        }\r\n      });\r\n    };\r\n    var trimTrailingBr = function (rootNode) {\r\n      var isBr = function (node) {\r\n        return node && node.name === 'br';\r\n      };\r\n      var brNode1 = rootNode.lastChild;\r\n      if (isBr(brNode1)) {\r\n        var brNode2 = brNode1.prev;\r\n        if (isBr(brNode2)) {\r\n          brNode1.remove();\r\n          brNode2.remove();\r\n        }\r\n      }\r\n    };\r\n\r\n    var preProcess = function (editor, node, args) {\r\n      var oldDoc;\r\n      var dom = editor.dom;\r\n      var clonedNode = node.cloneNode(true);\r\n      var impl = document.implementation;\r\n      if (impl.createHTMLDocument) {\r\n        var doc_1 = impl.createHTMLDocument('');\r\n        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], function (node) {\r\n          doc_1.body.appendChild(doc_1.importNode(node, true));\r\n        });\r\n        if (clonedNode.nodeName !== 'BODY') {\r\n          clonedNode = doc_1.body.firstChild;\r\n        } else {\r\n          clonedNode = doc_1.body;\r\n        }\r\n        oldDoc = dom.doc;\r\n        dom.doc = doc_1;\r\n      }\r\n      firePreProcess(editor, __assign(__assign({}, args), { node: clonedNode }));\r\n      if (oldDoc) {\r\n        dom.doc = oldDoc;\r\n      }\r\n      return clonedNode;\r\n    };\r\n    var shouldFireEvent = function (editor, args) {\r\n      return editor && editor.hasEventListeners('PreProcess') && !args.no_events;\r\n    };\r\n    var process = function (editor, node, args) {\r\n      return shouldFireEvent(editor, args) ? preProcess(editor, node, args) : node;\r\n    };\r\n\r\n    var addTempAttr = function (htmlParser, tempAttrs, name) {\r\n      if (Tools.inArray(tempAttrs, name) === -1) {\r\n        htmlParser.addAttributeFilter(name, function (nodes, name) {\r\n          var i = nodes.length;\r\n          while (i--) {\r\n            nodes[i].attr(name, null);\r\n          }\r\n        });\r\n        tempAttrs.push(name);\r\n      }\r\n    };\r\n    var postProcess = function (editor, args, content) {\r\n      if (!args.no_events && editor) {\r\n        var outArgs = firePostProcess(editor, __assign(__assign({}, args), { content: content }));\r\n        return outArgs.content;\r\n      } else {\r\n        return content;\r\n      }\r\n    };\r\n    var getHtmlFromNode = function (dom, node, args) {\r\n      var html = trim$3(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\r\n      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\r\n    };\r\n    var parseHtml = function (htmlParser, html, args) {\r\n      var parserArgs = args.selection ? __assign({ forced_root_block: false }, args) : args;\r\n      var rootNode = htmlParser.parse(html, parserArgs);\r\n      trimTrailingBr(rootNode);\r\n      return rootNode;\r\n    };\r\n    var serializeNode = function (settings, schema, node) {\r\n      var htmlSerializer = HtmlSerializer(settings, schema);\r\n      return htmlSerializer.serialize(node);\r\n    };\r\n    var toHtml = function (editor, settings, schema, rootNode, args) {\r\n      var content = serializeNode(settings, schema, rootNode);\r\n      return postProcess(editor, args, content);\r\n    };\r\n    var DomSerializerImpl = function (settings, editor) {\r\n      var tempAttrs = ['data-mce-selected'];\r\n      var dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\r\n      var schema = editor && editor.schema ? editor.schema : Schema(settings);\r\n      settings.entity_encoding = settings.entity_encoding || 'named';\r\n      settings.remove_trailing_brs = 'remove_trailing_brs' in settings ? settings.remove_trailing_brs : true;\r\n      var htmlParser = DomParser(settings, schema);\r\n      register(htmlParser, settings, dom);\r\n      var serialize = function (node, parserArgs) {\r\n        if (parserArgs === void 0) {\r\n          parserArgs = {};\r\n        }\r\n        var args = __assign({ format: 'html' }, parserArgs);\r\n        var targetNode = process(editor, node, args);\r\n        var html = getHtmlFromNode(dom, targetNode, args);\r\n        var rootNode = parseHtml(htmlParser, html, args);\r\n        return args.format === 'tree' ? rootNode : toHtml(editor, settings, schema, rootNode, args);\r\n      };\r\n      return {\r\n        schema: schema,\r\n        addNodeFilter: htmlParser.addNodeFilter,\r\n        addAttributeFilter: htmlParser.addAttributeFilter,\r\n        serialize: serialize,\r\n        addRules: schema.addValidElements,\r\n        setRules: schema.setValidElements,\r\n        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\r\n        getTempAttrs: constant(tempAttrs),\r\n        getNodeFilters: htmlParser.getNodeFilters,\r\n        getAttributeFilters: htmlParser.getAttributeFilters\r\n      };\r\n    };\r\n\r\n    var DomSerializer = function (settings, editor) {\r\n      var domSerializer = DomSerializerImpl(settings, editor);\r\n      return {\r\n        schema: domSerializer.schema,\r\n        addNodeFilter: domSerializer.addNodeFilter,\r\n        addAttributeFilter: domSerializer.addAttributeFilter,\r\n        serialize: domSerializer.serialize,\r\n        addRules: domSerializer.addRules,\r\n        setRules: domSerializer.setRules,\r\n        addTempAttr: domSerializer.addTempAttr,\r\n        getTempAttrs: domSerializer.getTempAttrs,\r\n        getNodeFilters: domSerializer.getNodeFilters,\r\n        getAttributeFilters: domSerializer.getAttributeFilters\r\n      };\r\n    };\r\n\r\n    var defaultFormat = 'html';\r\n    var getContent = function (editor, args) {\r\n      if (args === void 0) {\r\n        args = {};\r\n      }\r\n      var format = args.format ? args.format : defaultFormat;\r\n      return getContent$2(editor, args, format);\r\n    };\r\n\r\n    var setContent = function (editor, content, args) {\r\n      if (args === void 0) {\r\n        args = {};\r\n      }\r\n      return setContent$2(editor, content, args);\r\n    };\r\n\r\n    var DOM$7 = DOMUtils.DOM;\r\n    var restoreOriginalStyles = function (editor) {\r\n      DOM$7.setStyle(editor.id, 'display', editor.orgDisplay);\r\n    };\r\n    var safeDestroy = function (x) {\r\n      return Optional.from(x).each(function (x) {\r\n        return x.destroy();\r\n      });\r\n    };\r\n    var clearDomReferences = function (editor) {\r\n      editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;\r\n      editor.bodyElement = editor.contentDocument = editor.contentWindow = null;\r\n      editor.iframeElement = editor.targetElm = null;\r\n      if (editor.selection) {\r\n        editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;\r\n      }\r\n    };\r\n    var restoreForm = function (editor) {\r\n      var form = editor.formElement;\r\n      if (form) {\r\n        if (form._mceOldSubmit) {\r\n          form.submit = form._mceOldSubmit;\r\n          form._mceOldSubmit = null;\r\n        }\r\n        DOM$7.unbind(form, 'submit reset', editor.formEventDelegate);\r\n      }\r\n    };\r\n    var remove = function (editor) {\r\n      if (!editor.removed) {\r\n        var _selectionOverrides = editor._selectionOverrides, editorUpload = editor.editorUpload;\r\n        var body = editor.getBody();\r\n        var element = editor.getElement();\r\n        if (body) {\r\n          editor.save({ is_removing: true });\r\n        }\r\n        editor.removed = true;\r\n        editor.unbindAllNativeEvents();\r\n        if (editor.hasHiddenInput && element) {\r\n          DOM$7.remove(element.nextSibling);\r\n        }\r\n        fireRemove(editor);\r\n        editor.editorManager.remove(editor);\r\n        if (!editor.inline && body) {\r\n          restoreOriginalStyles(editor);\r\n        }\r\n        fireDetach(editor);\r\n        DOM$7.remove(editor.getContainer());\r\n        safeDestroy(_selectionOverrides);\r\n        safeDestroy(editorUpload);\r\n        editor.destroy();\r\n      }\r\n    };\r\n    var destroy = function (editor, automatic) {\r\n      var selection = editor.selection, dom = editor.dom;\r\n      if (editor.destroyed) {\r\n        return;\r\n      }\r\n      if (!automatic && !editor.removed) {\r\n        editor.remove();\r\n        return;\r\n      }\r\n      if (!automatic) {\r\n        editor.editorManager.off('beforeunload', editor._beforeUnload);\r\n        if (editor.theme && editor.theme.destroy) {\r\n          editor.theme.destroy();\r\n        }\r\n        safeDestroy(selection);\r\n        safeDestroy(dom);\r\n      }\r\n      restoreForm(editor);\r\n      clearDomReferences(editor);\r\n      editor.destroyed = true;\r\n    };\r\n\r\n    var deep = function (old, nu) {\r\n      var bothObjects = isObject(old) && isObject(nu);\r\n      return bothObjects ? deepMerge(old, nu) : nu;\r\n    };\r\n    var baseMerge = function (merger) {\r\n      return function () {\r\n        var objects = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          objects[_i] = arguments[_i];\r\n        }\r\n        if (objects.length === 0) {\r\n          throw new Error('Can\\'t merge zero objects');\r\n        }\r\n        var ret = {};\r\n        for (var j = 0; j < objects.length; j++) {\r\n          var curObject = objects[j];\r\n          for (var key in curObject) {\r\n            if (has$2(curObject, key)) {\r\n              ret[key] = merger(ret[key], curObject[key]);\r\n            }\r\n          }\r\n        }\r\n        return ret;\r\n      };\r\n    };\r\n    var deepMerge = baseMerge(deep);\r\n\r\n    var deprecatedSettings = ('autoresize_on_init,content_editable_state,convert_fonts_to_spans,inline_styles,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');\r\n    var deprecatedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');\r\n    var movedToPremiumPlugins = 'imagetools,toc'.split(',');\r\n    var getDeprecatedSettings = function (settings) {\r\n      var settingNames = filter$4(deprecatedSettings, function (setting) {\r\n        return has$2(settings, setting);\r\n      });\r\n      var forcedRootBlock = settings.forced_root_block;\r\n      if (forcedRootBlock === false || forcedRootBlock === '') {\r\n        settingNames.push('forced_root_block (false only)');\r\n      }\r\n      return sort(settingNames);\r\n    };\r\n    var getDeprecatedPlugins = function (settings) {\r\n      var plugins = Tools.makeMap(settings.plugins, ' ');\r\n      var hasPlugin = function (plugin) {\r\n        return has$2(plugins, plugin);\r\n      };\r\n      var pluginNames = __spreadArray(__spreadArray([], filter$4(deprecatedPlugins, hasPlugin), true), bind(movedToPremiumPlugins, function (plugin) {\r\n        return hasPlugin(plugin) ? [plugin + ' (moving to premium)'] : [];\r\n      }), true);\r\n      return sort(pluginNames);\r\n    };\r\n    var logDeprecationsWarning = function (rawSettings, finalSettings) {\r\n      var deprecatedSettings = getDeprecatedSettings(rawSettings);\r\n      var deprecatedPlugins = getDeprecatedPlugins(finalSettings);\r\n      var hasDeprecatedPlugins = deprecatedPlugins.length > 0;\r\n      var hasDeprecatedSettings = deprecatedSettings.length > 0;\r\n      var isLegacyMobileTheme = finalSettings.theme === 'mobile';\r\n      if (hasDeprecatedPlugins || hasDeprecatedSettings || isLegacyMobileTheme) {\r\n        var listJoiner = '\\n- ';\r\n        var themesMessage = isLegacyMobileTheme ? '\\n\\nThemes:' + listJoiner + 'mobile' : '';\r\n        var pluginsMessage = hasDeprecatedPlugins ? '\\n\\nPlugins:' + listJoiner + deprecatedPlugins.join(listJoiner) : '';\r\n        var settingsMessage = hasDeprecatedSettings ? '\\n\\nSettings:' + listJoiner + deprecatedSettings.join(listJoiner) : '';\r\n        console.warn('The following deprecated features are currently enabled, these will be removed in TinyMCE 6.0. ' + 'See https://www.tiny.cloud/docs/release-notes/6.0-upcoming-changes/ for more information.' + themesMessage + pluginsMessage + settingsMessage);\r\n      }\r\n    };\r\n\r\n    var sectionResult = function (sections, settings) {\r\n      return {\r\n        sections: constant(sections),\r\n        settings: constant(settings)\r\n      };\r\n    };\r\n    var deviceDetection = detect().deviceType;\r\n    var isTouch = deviceDetection.isTouch();\r\n    var isPhone = deviceDetection.isPhone();\r\n    var isTablet = deviceDetection.isTablet();\r\n    var legacyMobilePlugins = [\r\n      'lists',\r\n      'autolink',\r\n      'autosave'\r\n    ];\r\n    var defaultTouchSettings = {\r\n      table_grid: false,\r\n      object_resizing: false,\r\n      resize: false\r\n    };\r\n    var normalizePlugins = function (plugins) {\r\n      var pluginNames = isArray$1(plugins) ? plugins.join(' ') : plugins;\r\n      var trimmedPlugins = map$3(isString$1(pluginNames) ? pluginNames.split(' ') : [], trim$5);\r\n      return filter$4(trimmedPlugins, function (item) {\r\n        return item.length > 0;\r\n      });\r\n    };\r\n    var filterLegacyMobilePlugins = function (plugins) {\r\n      return filter$4(plugins, curry(contains$3, legacyMobilePlugins));\r\n    };\r\n    var extractSections = function (keys, settings) {\r\n      var result = bifilter(settings, function (value, key) {\r\n        return contains$3(keys, key);\r\n      });\r\n      return sectionResult(result.t, result.f);\r\n    };\r\n    var getSection = function (sectionResult, name, defaults) {\r\n      if (defaults === void 0) {\r\n        defaults = {};\r\n      }\r\n      var sections = sectionResult.sections();\r\n      var sectionSettings = get$9(sections, name).getOr({});\r\n      return Tools.extend({}, defaults, sectionSettings);\r\n    };\r\n    var hasSection = function (sectionResult, name) {\r\n      return has$2(sectionResult.sections(), name);\r\n    };\r\n    var isSectionTheme = function (sectionResult, name, theme) {\r\n      var section = sectionResult.sections();\r\n      return hasSection(sectionResult, name) && section[name].theme === theme;\r\n    };\r\n    var getSectionConfig = function (sectionResult, name) {\r\n      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\r\n    };\r\n    var getToolbarMode = function (settings, defaultVal) {\r\n      return get$9(settings, 'toolbar_mode').orThunk(function () {\r\n        return get$9(settings, 'toolbar_drawer').map(function (val) {\r\n          return val === false ? 'wrap' : val;\r\n        });\r\n      }).getOr(defaultVal);\r\n    };\r\n    var getDefaultSettings = function (settings, id, documentBaseUrl, isTouch, editor) {\r\n      var baseDefaults = {\r\n        id: id,\r\n        theme: 'silver',\r\n        toolbar_mode: getToolbarMode(settings, 'floating'),\r\n        plugins: '',\r\n        document_base_url: documentBaseUrl,\r\n        add_form_submit_trigger: true,\r\n        submit_patch: true,\r\n        add_unload_trigger: true,\r\n        convert_urls: true,\r\n        relative_urls: true,\r\n        remove_script_host: true,\r\n        object_resizing: true,\r\n        doctype: '<!DOCTYPE html>',\r\n        visual: true,\r\n        font_size_legacy_values: 'xx-small,small,medium,large,x-large,xx-large,300%',\r\n        forced_root_block: 'p',\r\n        hidden_input: true,\r\n        inline_styles: true,\r\n        convert_fonts_to_spans: true,\r\n        indent: true,\r\n        indent_before: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist',\r\n        indent_after: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist',\r\n        entity_encoding: 'named',\r\n        url_converter: editor.convertURL,\r\n        url_converter_scope: editor\r\n      };\r\n      return __assign(__assign({}, baseDefaults), isTouch ? defaultTouchSettings : {});\r\n    };\r\n    var getDefaultMobileSettings = function (mobileSettings, isPhone) {\r\n      var defaultMobileSettings = {\r\n        resize: false,\r\n        toolbar_mode: getToolbarMode(mobileSettings, 'scrolling'),\r\n        toolbar_sticky: false\r\n      };\r\n      var defaultPhoneSettings = { menubar: false };\r\n      return __assign(__assign(__assign({}, defaultTouchSettings), defaultMobileSettings), isPhone ? defaultPhoneSettings : {});\r\n    };\r\n    var getExternalPlugins = function (overrideSettings, settings) {\r\n      var userDefinedExternalPlugins = settings.external_plugins ? settings.external_plugins : {};\r\n      if (overrideSettings && overrideSettings.external_plugins) {\r\n        return Tools.extend({}, overrideSettings.external_plugins, userDefinedExternalPlugins);\r\n      } else {\r\n        return userDefinedExternalPlugins;\r\n      }\r\n    };\r\n    var combinePlugins = function (forcedPlugins, plugins) {\r\n      return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));\r\n    };\r\n    var getPlatformPlugins = function (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) {\r\n      if (isMobileDevice && isSectionTheme(sectionResult, 'mobile', 'mobile')) {\r\n        return filterLegacyMobilePlugins(mobilePlugins);\r\n      } else if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\r\n        return mobilePlugins;\r\n      } else {\r\n        return desktopPlugins;\r\n      }\r\n    };\r\n    var processPlugins = function (isMobileDevice, sectionResult, defaultOverrideSettings, settings) {\r\n      var forcedPlugins = normalizePlugins(defaultOverrideSettings.forced_plugins);\r\n      var desktopPlugins = normalizePlugins(settings.plugins);\r\n      var mobileConfig = getSectionConfig(sectionResult, 'mobile');\r\n      var mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\r\n      var platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\r\n      var combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\r\n      if (Env.browser.isIE() && contains$3(combinedPlugins, 'rtc')) {\r\n        throw new Error('RTC plugin is not supported on IE 11.');\r\n      }\r\n      return Tools.extend(settings, { plugins: combinedPlugins.join(' ') });\r\n    };\r\n    var isOnMobile = function (isMobileDevice, sectionResult) {\r\n      return isMobileDevice && hasSection(sectionResult, 'mobile');\r\n    };\r\n    var combineSettings = function (isMobileDevice, isPhone, defaultSettings, defaultOverrideSettings, settings) {\r\n      var defaultDeviceSettings = isMobileDevice ? { mobile: getDefaultMobileSettings(settings.mobile || {}, isPhone) } : {};\r\n      var sectionResult = extractSections(['mobile'], deepMerge(defaultDeviceSettings, settings));\r\n      var extendedSettings = Tools.extend(defaultSettings, defaultOverrideSettings, sectionResult.settings(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, {\r\n        validate: true,\r\n        external_plugins: getExternalPlugins(defaultOverrideSettings, sectionResult.settings())\r\n      });\r\n      return processPlugins(isMobileDevice, sectionResult, defaultOverrideSettings, extendedSettings);\r\n    };\r\n    var getEditorSettings = function (editor, id, documentBaseUrl, defaultOverrideSettings, settings) {\r\n      var defaultSettings = getDefaultSettings(settings, id, documentBaseUrl, isTouch, editor);\r\n      var finalSettings = combineSettings(isPhone || isTablet, isPhone, defaultSettings, defaultOverrideSettings, settings);\r\n      if (finalSettings.deprecation_warnings !== false) {\r\n        logDeprecationsWarning(settings, finalSettings);\r\n      }\r\n      return finalSettings;\r\n    };\r\n    var getFiltered = function (predicate, editor, name) {\r\n      return Optional.from(editor.settings[name]).filter(predicate);\r\n    };\r\n    var getParamObject = function (value) {\r\n      var output = {};\r\n      if (typeof value === 'string') {\r\n        each$k(value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(','), function (val) {\r\n          var arr = val.split('=');\r\n          if (arr.length > 1) {\r\n            output[Tools.trim(arr[0])] = Tools.trim(arr[1]);\r\n          } else {\r\n            output[Tools.trim(arr[0])] = Tools.trim(arr[0]);\r\n          }\r\n        });\r\n      } else {\r\n        output = value;\r\n      }\r\n      return output;\r\n    };\r\n    var isArrayOf = function (p) {\r\n      return function (a) {\r\n        return isArray$1(a) && forall(a, p);\r\n      };\r\n    };\r\n    var getParam = function (editor, name, defaultVal, type) {\r\n      var value = name in editor.settings ? editor.settings[name] : defaultVal;\r\n      if (type === 'hash') {\r\n        return getParamObject(value);\r\n      } else if (type === 'string') {\r\n        return getFiltered(isString$1, editor, name).getOr(defaultVal);\r\n      } else if (type === 'number') {\r\n        return getFiltered(isNumber, editor, name).getOr(defaultVal);\r\n      } else if (type === 'boolean') {\r\n        return getFiltered(isBoolean, editor, name).getOr(defaultVal);\r\n      } else if (type === 'object') {\r\n        return getFiltered(isObject, editor, name).getOr(defaultVal);\r\n      } else if (type === 'array') {\r\n        return getFiltered(isArray$1, editor, name).getOr(defaultVal);\r\n      } else if (type === 'string[]') {\r\n        return getFiltered(isArrayOf(isString$1), editor, name).getOr(defaultVal);\r\n      } else if (type === 'function') {\r\n        return getFiltered(isFunction, editor, name).getOr(defaultVal);\r\n      } else {\r\n        return value;\r\n      }\r\n    };\r\n\r\n    var CreateIconManager = function () {\r\n      var lookup = {};\r\n      var add = function (id, iconPack) {\r\n        lookup[id] = iconPack;\r\n      };\r\n      var get = function (id) {\r\n        if (lookup[id]) {\r\n          return lookup[id];\r\n        }\r\n        return { icons: {} };\r\n      };\r\n      var has = function (id) {\r\n        return has$2(lookup, id);\r\n      };\r\n      return {\r\n        add: add,\r\n        get: get,\r\n        has: has\r\n      };\r\n    };\r\n    var IconManager = CreateIconManager();\r\n\r\n    var getProp = function (propName, elm) {\r\n      var rawElm = elm.dom;\r\n      return rawElm[propName];\r\n    };\r\n    var getComputedSizeProp = function (propName, elm) {\r\n      return parseInt(get$5(elm, propName), 10);\r\n    };\r\n    var getClientWidth = curry(getProp, 'clientWidth');\r\n    var getClientHeight = curry(getProp, 'clientHeight');\r\n    var getMarginTop = curry(getComputedSizeProp, 'margin-top');\r\n    var getMarginLeft = curry(getComputedSizeProp, 'margin-left');\r\n    var getBoundingClientRect = function (elm) {\r\n      return elm.dom.getBoundingClientRect();\r\n    };\r\n    var isInsideElementContentArea = function (bodyElm, clientX, clientY) {\r\n      var clientWidth = getClientWidth(bodyElm);\r\n      var clientHeight = getClientHeight(bodyElm);\r\n      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\r\n    };\r\n    var transpose = function (inline, elm, clientX, clientY) {\r\n      var clientRect = getBoundingClientRect(elm);\r\n      var deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\r\n      var deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\r\n      var x = clientX - deltaX;\r\n      var y = clientY - deltaY;\r\n      return {\r\n        x: x,\r\n        y: y\r\n      };\r\n    };\r\n    var isXYInContentArea = function (editor, clientX, clientY) {\r\n      var bodyElm = SugarElement.fromDom(editor.getBody());\r\n      var targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\r\n      var transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\r\n      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\r\n    };\r\n    var fromDomSafe = function (node) {\r\n      return Optional.from(node).map(SugarElement.fromDom);\r\n    };\r\n    var isEditorAttachedToDom = function (editor) {\r\n      var rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\r\n      return fromDomSafe(rawContainer).map(inBody).getOr(false);\r\n    };\r\n\r\n    var NotificationManagerImpl = function () {\r\n      var unimplemented = function () {\r\n        throw new Error('Theme did not provide a NotificationManager implementation.');\r\n      };\r\n      return {\r\n        open: unimplemented,\r\n        close: unimplemented,\r\n        reposition: unimplemented,\r\n        getArgs: unimplemented\r\n      };\r\n    };\r\n\r\n    var NotificationManager = function (editor) {\r\n      var notifications = [];\r\n      var getImplementation = function () {\r\n        var theme = editor.theme;\r\n        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\r\n      };\r\n      var getTopNotification = function () {\r\n        return Optional.from(notifications[0]);\r\n      };\r\n      var isEqual = function (a, b) {\r\n        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\r\n      };\r\n      var reposition = function () {\r\n        if (notifications.length > 0) {\r\n          getImplementation().reposition(notifications);\r\n        }\r\n      };\r\n      var addNotification = function (notification) {\r\n        notifications.push(notification);\r\n      };\r\n      var closeNotification = function (notification) {\r\n        findIndex$2(notifications, function (otherNotification) {\r\n          return otherNotification === notification;\r\n        }).each(function (index) {\r\n          notifications.splice(index, 1);\r\n        });\r\n      };\r\n      var open = function (spec, fireEvent) {\r\n        if (fireEvent === void 0) {\r\n          fireEvent = true;\r\n        }\r\n        if (editor.removed || !isEditorAttachedToDom(editor)) {\r\n          return;\r\n        }\r\n        if (fireEvent) {\r\n          editor.fire('BeforeOpenNotification', { notification: spec });\r\n        }\r\n        return find$3(notifications, function (notification) {\r\n          return isEqual(getImplementation().getArgs(notification), spec);\r\n        }).getOrThunk(function () {\r\n          editor.editorManager.setActive(editor);\r\n          var notification = getImplementation().open(spec, function () {\r\n            closeNotification(notification);\r\n            reposition();\r\n            getTopNotification().fold(function () {\r\n              return editor.focus();\r\n            }, function (top) {\r\n              return focus$1(SugarElement.fromDom(top.getEl()));\r\n            });\r\n          });\r\n          addNotification(notification);\r\n          reposition();\r\n          editor.fire('OpenNotification', { notification: __assign({}, notification) });\r\n          return notification;\r\n        });\r\n      };\r\n      var close = function () {\r\n        getTopNotification().each(function (notification) {\r\n          getImplementation().close(notification);\r\n          closeNotification(notification);\r\n          reposition();\r\n        });\r\n      };\r\n      var getNotifications = constant(notifications);\r\n      var registerEvents = function (editor) {\r\n        editor.on('SkinLoaded', function () {\r\n          var serviceMessage = getServiceMessage(editor);\r\n          if (serviceMessage) {\r\n            open({\r\n              text: serviceMessage,\r\n              type: 'warning',\r\n              timeout: 0\r\n            }, false);\r\n          }\r\n          reposition();\r\n        });\r\n        editor.on('show ResizeEditor ResizeWindow NodeChange', function () {\r\n          Delay.requestAnimationFrame(reposition);\r\n        });\r\n        editor.on('remove', function () {\r\n          each$k(notifications.slice(), function (notification) {\r\n            getImplementation().close(notification);\r\n          });\r\n        });\r\n      };\r\n      registerEvents(editor);\r\n      return {\r\n        open: open,\r\n        close: close,\r\n        getNotifications: getNotifications\r\n      };\r\n    };\r\n\r\n    var PluginManager = AddOnManager.PluginManager;\r\n\r\n    var ThemeManager = AddOnManager.ThemeManager;\r\n\r\n    function WindowManagerImpl () {\r\n      var unimplemented = function () {\r\n        throw new Error('Theme did not provide a WindowManager implementation.');\r\n      };\r\n      return {\r\n        open: unimplemented,\r\n        openUrl: unimplemented,\r\n        alert: unimplemented,\r\n        confirm: unimplemented,\r\n        close: unimplemented,\r\n        getParams: unimplemented,\r\n        setParams: unimplemented\r\n      };\r\n    }\r\n\r\n    var WindowManager = function (editor) {\r\n      var dialogs = [];\r\n      var getImplementation = function () {\r\n        var theme = editor.theme;\r\n        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\r\n      };\r\n      var funcBind = function (scope, f) {\r\n        return function () {\r\n          var args = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n          }\r\n          return f ? f.apply(scope, args) : undefined;\r\n        };\r\n      };\r\n      var fireOpenEvent = function (dialog) {\r\n        editor.fire('OpenWindow', { dialog: dialog });\r\n      };\r\n      var fireCloseEvent = function (dialog) {\r\n        editor.fire('CloseWindow', { dialog: dialog });\r\n      };\r\n      var addDialog = function (dialog) {\r\n        dialogs.push(dialog);\r\n        fireOpenEvent(dialog);\r\n      };\r\n      var closeDialog = function (dialog) {\r\n        fireCloseEvent(dialog);\r\n        dialogs = filter$4(dialogs, function (otherDialog) {\r\n          return otherDialog !== dialog;\r\n        });\r\n        if (dialogs.length === 0) {\r\n          editor.focus();\r\n        }\r\n      };\r\n      var getTopDialog = function () {\r\n        return Optional.from(dialogs[dialogs.length - 1]);\r\n      };\r\n      var storeSelectionAndOpenDialog = function (openDialog) {\r\n        editor.editorManager.setActive(editor);\r\n        store(editor);\r\n        var dialog = openDialog();\r\n        addDialog(dialog);\r\n        return dialog;\r\n      };\r\n      var open = function (args, params) {\r\n        return storeSelectionAndOpenDialog(function () {\r\n          return getImplementation().open(args, params, closeDialog);\r\n        });\r\n      };\r\n      var openUrl = function (args) {\r\n        return storeSelectionAndOpenDialog(function () {\r\n          return getImplementation().openUrl(args, closeDialog);\r\n        });\r\n      };\r\n      var alert = function (message, callback, scope) {\r\n        var windowManagerImpl = getImplementation();\r\n        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\r\n      };\r\n      var confirm = function (message, callback, scope) {\r\n        var windowManagerImpl = getImplementation();\r\n        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\r\n      };\r\n      var close = function () {\r\n        getTopDialog().each(function (dialog) {\r\n          getImplementation().close(dialog);\r\n          closeDialog(dialog);\r\n        });\r\n      };\r\n      editor.on('remove', function () {\r\n        each$k(dialogs, function (dialog) {\r\n          getImplementation().close(dialog);\r\n        });\r\n      });\r\n      return {\r\n        open: open,\r\n        openUrl: openUrl,\r\n        alert: alert,\r\n        confirm: confirm,\r\n        close: close\r\n      };\r\n    };\r\n\r\n    var displayNotification = function (editor, message) {\r\n      editor.notificationManager.open({\r\n        type: 'error',\r\n        text: message\r\n      });\r\n    };\r\n    var displayError = function (editor, message) {\r\n      if (editor._skinLoaded) {\r\n        displayNotification(editor, message);\r\n      } else {\r\n        editor.on('SkinLoaded', function () {\r\n          displayNotification(editor, message);\r\n        });\r\n      }\r\n    };\r\n    var uploadError = function (editor, message) {\r\n      displayError(editor, I18n.translate([\r\n        'Failed to upload image: {0}',\r\n        message\r\n      ]));\r\n    };\r\n    var logError = function (editor, errorType, msg) {\r\n      fireError(editor, errorType, { message: msg });\r\n      console.error(msg);\r\n    };\r\n    var createLoadError = function (type, url, name) {\r\n      return name ? 'Failed to load ' + type + ': ' + name + ' from url ' + url : 'Failed to load ' + type + ' url: ' + url;\r\n    };\r\n    var pluginLoadError = function (editor, url, name) {\r\n      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\r\n    };\r\n    var iconsLoadError = function (editor, url, name) {\r\n      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\r\n    };\r\n    var languageLoadError = function (editor, url, name) {\r\n      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\r\n    };\r\n    var pluginInitError = function (editor, name, err) {\r\n      var message = I18n.translate([\r\n        'Failed to initialize plugin: {0}',\r\n        name\r\n      ]);\r\n      fireError(editor, 'PluginLoadError', { message: message });\r\n      initError(message, err);\r\n      displayError(editor, message);\r\n    };\r\n    var initError = function (message) {\r\n      var x = [];\r\n      for (var _i = 1; _i < arguments.length; _i++) {\r\n        x[_i - 1] = arguments[_i];\r\n      }\r\n      var console = window.console;\r\n      if (console) {\r\n        if (console.error) {\r\n          console.error.apply(console, __spreadArray([message], x, false));\r\n        } else {\r\n          console.log.apply(console, __spreadArray([message], x, false));\r\n        }\r\n      }\r\n    };\r\n\r\n    var isContentCssSkinName = function (url) {\r\n      return /^[a-z0-9\\-]+$/i.test(url);\r\n    };\r\n    var getContentCssUrls = function (editor) {\r\n      return transformToUrls(editor, getContentCss(editor));\r\n    };\r\n    var getFontCssUrls = function (editor) {\r\n      return transformToUrls(editor, getFontCss(editor));\r\n    };\r\n    var transformToUrls = function (editor, cssLinks) {\r\n      var skinUrl = editor.editorManager.baseURL + '/skins/content';\r\n      var suffix = editor.editorManager.suffix;\r\n      var contentCssFile = 'content' + suffix + '.css';\r\n      var inline = editor.inline === true;\r\n      return map$3(cssLinks, function (url) {\r\n        if (isContentCssSkinName(url) && !inline) {\r\n          return skinUrl + '/' + url + '/' + contentCssFile;\r\n        } else {\r\n          return editor.documentBaseURI.toAbsolute(url);\r\n        }\r\n      });\r\n    };\r\n    var appendContentCssFromSettings = function (editor) {\r\n      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\r\n    };\r\n\r\n    var UploadStatus = function () {\r\n      var PENDING = 1, UPLOADED = 2;\r\n      var blobUriStatuses = {};\r\n      var createStatus = function (status, resultUri) {\r\n        return {\r\n          status: status,\r\n          resultUri: resultUri\r\n        };\r\n      };\r\n      var hasBlobUri = function (blobUri) {\r\n        return blobUri in blobUriStatuses;\r\n      };\r\n      var getResultUri = function (blobUri) {\r\n        var result = blobUriStatuses[blobUri];\r\n        return result ? result.resultUri : null;\r\n      };\r\n      var isPending = function (blobUri) {\r\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\r\n      };\r\n      var isUploaded = function (blobUri) {\r\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\r\n      };\r\n      var markPending = function (blobUri) {\r\n        blobUriStatuses[blobUri] = createStatus(PENDING, null);\r\n      };\r\n      var markUploaded = function (blobUri, resultUri) {\r\n        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\r\n      };\r\n      var removeFailed = function (blobUri) {\r\n        delete blobUriStatuses[blobUri];\r\n      };\r\n      var destroy = function () {\r\n        blobUriStatuses = {};\r\n      };\r\n      return {\r\n        hasBlobUri: hasBlobUri,\r\n        getResultUri: getResultUri,\r\n        isPending: isPending,\r\n        isUploaded: isUploaded,\r\n        markPending: markPending,\r\n        markUploaded: markUploaded,\r\n        removeFailed: removeFailed,\r\n        destroy: destroy\r\n      };\r\n    };\r\n\r\n    var count = 0;\r\n    var seed = function () {\r\n      var rnd = function () {\r\n        return Math.round(Math.random() * 4294967295).toString(36);\r\n      };\r\n      var now = new Date().getTime();\r\n      return 's' + now.toString(36) + rnd() + rnd() + rnd();\r\n    };\r\n    var uuid = function (prefix) {\r\n      return prefix + count++ + seed();\r\n    };\r\n\r\n    var BlobCache = function () {\r\n      var cache = [];\r\n      var mimeToExt = function (mime) {\r\n        var mimes = {\r\n          'image/jpeg': 'jpg',\r\n          'image/jpg': 'jpg',\r\n          'image/gif': 'gif',\r\n          'image/png': 'png',\r\n          'image/apng': 'apng',\r\n          'image/avif': 'avif',\r\n          'image/svg+xml': 'svg',\r\n          'image/webp': 'webp',\r\n          'image/bmp': 'bmp',\r\n          'image/tiff': 'tiff'\r\n        };\r\n        return mimes[mime.toLowerCase()] || 'dat';\r\n      };\r\n      var create = function (o, blob, base64, name, filename) {\r\n        if (isString$1(o)) {\r\n          var id = o;\r\n          return toBlobInfo({\r\n            id: id,\r\n            name: name,\r\n            filename: filename,\r\n            blob: blob,\r\n            base64: base64\r\n          });\r\n        } else if (isObject(o)) {\r\n          return toBlobInfo(o);\r\n        } else {\r\n          throw new Error('Unknown input type');\r\n        }\r\n      };\r\n      var toBlobInfo = function (o) {\r\n        if (!o.blob || !o.base64) {\r\n          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\r\n        }\r\n        var id = o.id || uuid('blobid');\r\n        var name = o.name || id;\r\n        var blob = o.blob;\r\n        return {\r\n          id: constant(id),\r\n          name: constant(name),\r\n          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\r\n          blob: constant(blob),\r\n          base64: constant(o.base64),\r\n          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\r\n          uri: constant(o.uri)\r\n        };\r\n      };\r\n      var add = function (blobInfo) {\r\n        if (!get(blobInfo.id())) {\r\n          cache.push(blobInfo);\r\n        }\r\n      };\r\n      var findFirst = function (predicate) {\r\n        return find$3(cache, predicate).getOrUndefined();\r\n      };\r\n      var get = function (id) {\r\n        return findFirst(function (cachedBlobInfo) {\r\n          return cachedBlobInfo.id() === id;\r\n        });\r\n      };\r\n      var getByUri = function (blobUri) {\r\n        return findFirst(function (blobInfo) {\r\n          return blobInfo.blobUri() === blobUri;\r\n        });\r\n      };\r\n      var getByData = function (base64, type) {\r\n        return findFirst(function (blobInfo) {\r\n          return blobInfo.base64() === base64 && blobInfo.blob().type === type;\r\n        });\r\n      };\r\n      var removeByUri = function (blobUri) {\r\n        cache = filter$4(cache, function (blobInfo) {\r\n          if (blobInfo.blobUri() === blobUri) {\r\n            URL.revokeObjectURL(blobInfo.blobUri());\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n      };\r\n      var destroy = function () {\r\n        each$k(cache, function (cachedBlobInfo) {\r\n          URL.revokeObjectURL(cachedBlobInfo.blobUri());\r\n        });\r\n        cache = [];\r\n      };\r\n      return {\r\n        create: create,\r\n        add: add,\r\n        get: get,\r\n        getByUri: getByUri,\r\n        getByData: getByData,\r\n        findFirst: findFirst,\r\n        removeByUri: removeByUri,\r\n        destroy: destroy\r\n      };\r\n    };\r\n\r\n    var Uploader = function (uploadStatus, settings) {\r\n      var pendingPromises = {};\r\n      var pathJoin = function (path1, path2) {\r\n        if (path1) {\r\n          return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\r\n        }\r\n        return path2;\r\n      };\r\n      var defaultHandler = function (blobInfo, success, failure, progress) {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('POST', settings.url);\r\n        xhr.withCredentials = settings.credentials;\r\n        xhr.upload.onprogress = function (e) {\r\n          progress(e.loaded / e.total * 100);\r\n        };\r\n        xhr.onerror = function () {\r\n          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\r\n        };\r\n        xhr.onload = function () {\r\n          if (xhr.status < 200 || xhr.status >= 300) {\r\n            failure('HTTP Error: ' + xhr.status);\r\n            return;\r\n          }\r\n          var json = JSON.parse(xhr.responseText);\r\n          if (!json || typeof json.location !== 'string') {\r\n            failure('Invalid JSON: ' + xhr.responseText);\r\n            return;\r\n          }\r\n          success(pathJoin(settings.basePath, json.location));\r\n        };\r\n        var formData = new FormData();\r\n        formData.append('file', blobInfo.blob(), blobInfo.filename());\r\n        xhr.send(formData);\r\n      };\r\n      var noUpload = function () {\r\n        return new promiseObj(function (resolve) {\r\n          resolve([]);\r\n        });\r\n      };\r\n      var handlerSuccess = function (blobInfo, url) {\r\n        return {\r\n          url: url,\r\n          blobInfo: blobInfo,\r\n          status: true\r\n        };\r\n      };\r\n      var handlerFailure = function (blobInfo, message, options) {\r\n        return {\r\n          url: '',\r\n          blobInfo: blobInfo,\r\n          status: false,\r\n          error: {\r\n            message: message,\r\n            options: options\r\n          }\r\n        };\r\n      };\r\n      var resolvePending = function (blobUri, result) {\r\n        Tools.each(pendingPromises[blobUri], function (resolve) {\r\n          resolve(result);\r\n        });\r\n        delete pendingPromises[blobUri];\r\n      };\r\n      var uploadBlobInfo = function (blobInfo, handler, openNotification) {\r\n        uploadStatus.markPending(blobInfo.blobUri());\r\n        return new promiseObj(function (resolve) {\r\n          var notification, progress;\r\n          try {\r\n            var closeNotification_1 = function () {\r\n              if (notification) {\r\n                notification.close();\r\n                progress = noop;\r\n              }\r\n            };\r\n            var success = function (url) {\r\n              closeNotification_1();\r\n              uploadStatus.markUploaded(blobInfo.blobUri(), url);\r\n              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\r\n              resolve(handlerSuccess(blobInfo, url));\r\n            };\r\n            var failure = function (error, options) {\r\n              var failureOptions = options ? options : {};\r\n              closeNotification_1();\r\n              uploadStatus.removeFailed(blobInfo.blobUri());\r\n              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error, failureOptions));\r\n              resolve(handlerFailure(blobInfo, error, failureOptions));\r\n            };\r\n            progress = function (percent) {\r\n              if (percent < 0 || percent > 100) {\r\n                return;\r\n              }\r\n              Optional.from(notification).orThunk(function () {\r\n                return Optional.from(openNotification).map(apply);\r\n              }).each(function (n) {\r\n                notification = n;\r\n                n.progressBar.value(percent);\r\n              });\r\n            };\r\n            handler(blobInfo, success, failure, progress);\r\n          } catch (ex) {\r\n            resolve(handlerFailure(blobInfo, ex.message, {}));\r\n          }\r\n        });\r\n      };\r\n      var isDefaultHandler = function (handler) {\r\n        return handler === defaultHandler;\r\n      };\r\n      var pendingUploadBlobInfo = function (blobInfo) {\r\n        var blobUri = blobInfo.blobUri();\r\n        return new promiseObj(function (resolve) {\r\n          pendingPromises[blobUri] = pendingPromises[blobUri] || [];\r\n          pendingPromises[blobUri].push(resolve);\r\n        });\r\n      };\r\n      var uploadBlobs = function (blobInfos, openNotification) {\r\n        blobInfos = Tools.grep(blobInfos, function (blobInfo) {\r\n          return !uploadStatus.isUploaded(blobInfo.blobUri());\r\n        });\r\n        return promiseObj.all(Tools.map(blobInfos, function (blobInfo) {\r\n          return uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification);\r\n        }));\r\n      };\r\n      var upload = function (blobInfos, openNotification) {\r\n        return !settings.url && isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\r\n      };\r\n      if (isFunction(settings.handler) === false) {\r\n        settings.handler = defaultHandler;\r\n      }\r\n      return { upload: upload };\r\n    };\r\n\r\n    var openNotification = function (editor) {\r\n      return function () {\r\n        return editor.notificationManager.open({\r\n          text: editor.translate('Image uploading...'),\r\n          type: 'info',\r\n          timeout: -1,\r\n          progressBar: true\r\n        });\r\n      };\r\n    };\r\n    var createUploader = function (editor, uploadStatus) {\r\n      return Uploader(uploadStatus, {\r\n        url: getImageUploadUrl(editor),\r\n        basePath: getImageUploadBasePath(editor),\r\n        credentials: getImagesUploadCredentials(editor),\r\n        handler: getImagesUploadHandler(editor)\r\n      });\r\n    };\r\n    var ImageUploader = function (editor) {\r\n      var uploadStatus = UploadStatus();\r\n      var uploader = createUploader(editor, uploadStatus);\r\n      return {\r\n        upload: function (blobInfos, showNotification) {\r\n          if (showNotification === void 0) {\r\n            showNotification = true;\r\n          }\r\n          return uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined);\r\n        }\r\n      };\r\n    };\r\n\r\n    var UploadChangeHandler = function (editor) {\r\n      var lastChangedLevel = Cell(null);\r\n      editor.on('change AddUndo', function (e) {\r\n        lastChangedLevel.set(__assign({}, e.level));\r\n      });\r\n      var fireIfChanged = function () {\r\n        var data = editor.undoManager.data;\r\n        last$2(data).filter(function (level) {\r\n          return !isEq$1(lastChangedLevel.get(), level);\r\n        }).each(function (level) {\r\n          editor.setDirty(true);\r\n          editor.fire('change', {\r\n            level: level,\r\n            lastLevel: get$a(data, data.length - 2).getOrNull()\r\n          });\r\n        });\r\n      };\r\n      return { fireIfChanged: fireIfChanged };\r\n    };\r\n    var EditorUpload = function (editor) {\r\n      var blobCache = BlobCache();\r\n      var uploader, imageScanner;\r\n      var uploadStatus = UploadStatus();\r\n      var urlFilters = [];\r\n      var changeHandler = UploadChangeHandler(editor);\r\n      var aliveGuard = function (callback) {\r\n        return function (result) {\r\n          if (editor.selection) {\r\n            return callback(result);\r\n          }\r\n          return [];\r\n        };\r\n      };\r\n      var cacheInvalidator = function (url) {\r\n        return url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\r\n      };\r\n      var replaceString = function (content, search, replace) {\r\n        var index = 0;\r\n        do {\r\n          index = content.indexOf(search, index);\r\n          if (index !== -1) {\r\n            content = content.substring(0, index) + replace + content.substr(index + search.length);\r\n            index += replace.length - search.length + 1;\r\n          }\r\n        } while (index !== -1);\r\n        return content;\r\n      };\r\n      var replaceImageUrl = function (content, targetUrl, replacementUrl) {\r\n        var replacementString = 'src=\"' + replacementUrl + '\"' + (replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : '');\r\n        content = replaceString(content, 'src=\"' + targetUrl + '\"', replacementString);\r\n        content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\r\n        return content;\r\n      };\r\n      var replaceUrlInUndoStack = function (targetUrl, replacementUrl) {\r\n        each$k(editor.undoManager.data, function (level) {\r\n          if (level.type === 'fragmented') {\r\n            level.fragments = map$3(level.fragments, function (fragment) {\r\n              return replaceImageUrl(fragment, targetUrl, replacementUrl);\r\n            });\r\n          } else {\r\n            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\r\n          }\r\n        });\r\n      };\r\n      var replaceImageUriInView = function (image, resultUri) {\r\n        var src = editor.convertURL(resultUri, 'src');\r\n        replaceUrlInUndoStack(image.src, resultUri);\r\n        editor.$(image).attr({\r\n          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\r\n          'data-mce-src': src\r\n        });\r\n      };\r\n      var uploadImages = function (callback) {\r\n        if (!uploader) {\r\n          uploader = createUploader(editor, uploadStatus);\r\n        }\r\n        return scanForImages().then(aliveGuard(function (imageInfos) {\r\n          var blobInfos = map$3(imageInfos, function (imageInfo) {\r\n            return imageInfo.blobInfo;\r\n          });\r\n          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(function (result) {\r\n            var imagesToRemove = [];\r\n            var filteredResult = map$3(result, function (uploadInfo, index) {\r\n              var blobInfo = imageInfos[index].blobInfo;\r\n              var image = imageInfos[index].image;\r\n              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\r\n                blobCache.removeByUri(image.src);\r\n                if (isRtc(editor)) ; else {\r\n                  replaceImageUriInView(image, uploadInfo.url);\r\n                }\r\n              } else if (uploadInfo.error) {\r\n                if (uploadInfo.error.options.remove) {\r\n                  replaceUrlInUndoStack(image.getAttribute('src'), Env.transparentSrc);\r\n                  imagesToRemove.push(image);\r\n                }\r\n                uploadError(editor, uploadInfo.error.message);\r\n              }\r\n              return {\r\n                element: image,\r\n                status: uploadInfo.status,\r\n                uploadUri: uploadInfo.url,\r\n                blobInfo: blobInfo\r\n              };\r\n            });\r\n            if (filteredResult.length > 0) {\r\n              changeHandler.fireIfChanged();\r\n            }\r\n            if (imagesToRemove.length > 0) {\r\n              if (isRtc(editor)) {\r\n                console.error('Removing images on failed uploads is currently unsupported for RTC');\r\n              } else {\r\n                editor.undoManager.transact(function () {\r\n                  each$k(imagesToRemove, function (element) {\r\n                    editor.dom.remove(element);\r\n                    blobCache.removeByUri(element.src);\r\n                  });\r\n                });\r\n              }\r\n            }\r\n            if (callback) {\r\n              callback(filteredResult);\r\n            }\r\n            return filteredResult;\r\n          }));\r\n        }));\r\n      };\r\n      var uploadImagesAuto = function (callback) {\r\n        if (isAutomaticUploadsEnabled(editor)) {\r\n          return uploadImages(callback);\r\n        }\r\n      };\r\n      var isValidDataUriImage = function (imgElm) {\r\n        if (forall(urlFilters, function (filter) {\r\n            return filter(imgElm);\r\n          }) === false) {\r\n          return false;\r\n        }\r\n        if (imgElm.getAttribute('src').indexOf('data:') === 0) {\r\n          var dataImgFilter = getImagesDataImgFilter(editor);\r\n          return dataImgFilter(imgElm);\r\n        }\r\n        return true;\r\n      };\r\n      var addFilter = function (filter) {\r\n        urlFilters.push(filter);\r\n      };\r\n      var scanForImages = function () {\r\n        if (!imageScanner) {\r\n          imageScanner = ImageScanner(uploadStatus, blobCache);\r\n        }\r\n        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(function (result) {\r\n          result = filter$4(result, function (resultItem) {\r\n            if (typeof resultItem === 'string') {\r\n              displayError(editor, resultItem);\r\n              return false;\r\n            }\r\n            return true;\r\n          });\r\n          if (isRtc(editor)) ; else {\r\n            each$k(result, function (resultItem) {\r\n              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\r\n              resultItem.image.src = resultItem.blobInfo.blobUri();\r\n              resultItem.image.removeAttribute('data-mce-src');\r\n            });\r\n          }\r\n          return result;\r\n        }));\r\n      };\r\n      var destroy = function () {\r\n        blobCache.destroy();\r\n        uploadStatus.destroy();\r\n        imageScanner = uploader = null;\r\n      };\r\n      var replaceBlobUris = function (content) {\r\n        return content.replace(/src=\"(blob:[^\"]+)\"/g, function (match, blobUri) {\r\n          var resultUri = uploadStatus.getResultUri(blobUri);\r\n          if (resultUri) {\r\n            return 'src=\"' + resultUri + '\"';\r\n          }\r\n          var blobInfo = blobCache.getByUri(blobUri);\r\n          if (!blobInfo) {\r\n            blobInfo = foldl(editor.editorManager.get(), function (result, editor) {\r\n              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\r\n            }, null);\r\n          }\r\n          if (blobInfo) {\r\n            var blob = blobInfo.blob();\r\n            return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\r\n          }\r\n          return match;\r\n        });\r\n      };\r\n      editor.on('SetContent', function () {\r\n        if (isAutomaticUploadsEnabled(editor)) {\r\n          uploadImagesAuto();\r\n        } else {\r\n          scanForImages();\r\n        }\r\n      });\r\n      editor.on('RawSaveContent', function (e) {\r\n        e.content = replaceBlobUris(e.content);\r\n      });\r\n      editor.on('GetContent', function (e) {\r\n        if (e.source_view || e.format === 'raw' || e.format === 'tree') {\r\n          return;\r\n        }\r\n        e.content = replaceBlobUris(e.content);\r\n      });\r\n      editor.on('PostRender', function () {\r\n        editor.parser.addNodeFilter('img', function (images) {\r\n          each$k(images, function (img) {\r\n            var src = img.attr('src');\r\n            if (blobCache.getByUri(src)) {\r\n              return;\r\n            }\r\n            var resultUri = uploadStatus.getResultUri(src);\r\n            if (resultUri) {\r\n              img.attr('src', resultUri);\r\n            }\r\n          });\r\n        });\r\n      });\r\n      return {\r\n        blobCache: blobCache,\r\n        addFilter: addFilter,\r\n        uploadImages: uploadImages,\r\n        uploadImagesAuto: uploadImagesAuto,\r\n        scanForImages: scanForImages,\r\n        destroy: destroy\r\n      };\r\n    };\r\n\r\n    var get = function (dom) {\r\n      var formats = {\r\n        valigntop: [{\r\n            selector: 'td,th',\r\n            styles: { verticalAlign: 'top' }\r\n          }],\r\n        valignmiddle: [{\r\n            selector: 'td,th',\r\n            styles: { verticalAlign: 'middle' }\r\n          }],\r\n        valignbottom: [{\r\n            selector: 'td,th',\r\n            styles: { verticalAlign: 'bottom' }\r\n          }],\r\n        alignleft: [\r\n          {\r\n            selector: 'figure.image',\r\n            collapsed: false,\r\n            classes: 'align-left',\r\n            ceFalseOverride: true,\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\r\n            styles: { textAlign: 'left' },\r\n            inherit: false,\r\n            preview: false,\r\n            defaultBlock: 'div'\r\n          },\r\n          {\r\n            selector: 'img,table,audio,video',\r\n            collapsed: false,\r\n            styles: { float: 'left' },\r\n            preview: 'font-family font-size'\r\n          }\r\n        ],\r\n        aligncenter: [\r\n          {\r\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\r\n            styles: { textAlign: 'center' },\r\n            inherit: false,\r\n            preview: 'font-family font-size',\r\n            defaultBlock: 'div'\r\n          },\r\n          {\r\n            selector: 'figure.image',\r\n            collapsed: false,\r\n            classes: 'align-center',\r\n            ceFalseOverride: true,\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: 'img,audio,video',\r\n            collapsed: false,\r\n            styles: {\r\n              display: 'block',\r\n              marginLeft: 'auto',\r\n              marginRight: 'auto'\r\n            },\r\n            preview: false\r\n          },\r\n          {\r\n            selector: 'table',\r\n            collapsed: false,\r\n            styles: {\r\n              marginLeft: 'auto',\r\n              marginRight: 'auto'\r\n            },\r\n            preview: 'font-family font-size'\r\n          }\r\n        ],\r\n        alignright: [\r\n          {\r\n            selector: 'figure.image',\r\n            collapsed: false,\r\n            classes: 'align-right',\r\n            ceFalseOverride: true,\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\r\n            styles: { textAlign: 'right' },\r\n            inherit: false,\r\n            preview: 'font-family font-size',\r\n            defaultBlock: 'div'\r\n          },\r\n          {\r\n            selector: 'img,table,audio,video',\r\n            collapsed: false,\r\n            styles: { float: 'right' },\r\n            preview: 'font-family font-size'\r\n          }\r\n        ],\r\n        alignjustify: [{\r\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',\r\n            styles: { textAlign: 'justify' },\r\n            inherit: false,\r\n            defaultBlock: 'div',\r\n            preview: 'font-family font-size'\r\n          }],\r\n        bold: [\r\n          {\r\n            inline: 'strong',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          },\r\n          {\r\n            inline: 'span',\r\n            styles: { fontWeight: 'bold' }\r\n          },\r\n          {\r\n            inline: 'b',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          }\r\n        ],\r\n        italic: [\r\n          {\r\n            inline: 'em',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          },\r\n          {\r\n            inline: 'span',\r\n            styles: { fontStyle: 'italic' }\r\n          },\r\n          {\r\n            inline: 'i',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          }\r\n        ],\r\n        underline: [\r\n          {\r\n            inline: 'span',\r\n            styles: { textDecoration: 'underline' },\r\n            exact: true\r\n          },\r\n          {\r\n            inline: 'u',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          }\r\n        ],\r\n        strikethrough: [\r\n          {\r\n            inline: 'span',\r\n            styles: { textDecoration: 'line-through' },\r\n            exact: true\r\n          },\r\n          {\r\n            inline: 'strike',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          },\r\n          {\r\n            inline: 's',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          }\r\n        ],\r\n        forecolor: {\r\n          inline: 'span',\r\n          styles: { color: '%value' },\r\n          links: true,\r\n          remove_similar: true,\r\n          clear_child_styles: true\r\n        },\r\n        hilitecolor: {\r\n          inline: 'span',\r\n          styles: { backgroundColor: '%value' },\r\n          links: true,\r\n          remove_similar: true,\r\n          clear_child_styles: true\r\n        },\r\n        fontname: {\r\n          inline: 'span',\r\n          toggle: false,\r\n          styles: { fontFamily: '%value' },\r\n          clear_child_styles: true\r\n        },\r\n        fontsize: {\r\n          inline: 'span',\r\n          toggle: false,\r\n          styles: { fontSize: '%value' },\r\n          clear_child_styles: true\r\n        },\r\n        lineheight: {\r\n          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\r\n          defaultBlock: 'p',\r\n          styles: { lineHeight: '%value' }\r\n        },\r\n        fontsize_class: {\r\n          inline: 'span',\r\n          attributes: { class: '%value' }\r\n        },\r\n        blockquote: {\r\n          block: 'blockquote',\r\n          wrapper: true,\r\n          remove: 'all'\r\n        },\r\n        subscript: { inline: 'sub' },\r\n        superscript: { inline: 'sup' },\r\n        code: { inline: 'code' },\r\n        link: {\r\n          inline: 'a',\r\n          selector: 'a',\r\n          remove: 'all',\r\n          split: true,\r\n          deep: true,\r\n          onmatch: function (node, _fmt, _itemName) {\r\n            return isElement$5(node) && node.hasAttribute('href');\r\n          },\r\n          onformat: function (elm, _fmt, vars) {\r\n            Tools.each(vars, function (value, key) {\r\n              dom.setAttrib(elm, key, value);\r\n            });\r\n          }\r\n        },\r\n        lang: {\r\n          inline: 'span',\r\n          clear_child_styles: true,\r\n          remove_similar: true,\r\n          attributes: {\r\n            'lang': '%value',\r\n            'data-mce-lang': function (vars) {\r\n              var _a;\r\n              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\r\n            }\r\n          }\r\n        },\r\n        removeformat: [\r\n          {\r\n            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\r\n            remove: 'all',\r\n            split: true,\r\n            expand: false,\r\n            block_expand: true,\r\n            deep: true\r\n          },\r\n          {\r\n            selector: 'span',\r\n            attributes: [\r\n              'style',\r\n              'class'\r\n            ],\r\n            remove: 'empty',\r\n            split: true,\r\n            expand: false,\r\n            deep: true\r\n          },\r\n          {\r\n            selector: '*',\r\n            attributes: [\r\n              'style',\r\n              'class'\r\n            ],\r\n            split: false,\r\n            expand: false,\r\n            deep: true\r\n          }\r\n        ]\r\n      };\r\n      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), function (name) {\r\n        formats[name] = {\r\n          block: name,\r\n          remove: 'all'\r\n        };\r\n      });\r\n      return formats;\r\n    };\r\n\r\n    var FormatRegistry = function (editor) {\r\n      var formats = {};\r\n      var get$1 = function (name) {\r\n        return isNonNullable(name) ? formats[name] : formats;\r\n      };\r\n      var has = function (name) {\r\n        return has$2(formats, name);\r\n      };\r\n      var register = function (name, format) {\r\n        if (name) {\r\n          if (!isString$1(name)) {\r\n            each$j(name, function (format, name) {\r\n              register(name, format);\r\n            });\r\n          } else {\r\n            if (!isArray$1(format)) {\r\n              format = [format];\r\n            }\r\n            each$k(format, function (format) {\r\n              if (isUndefined(format.deep)) {\r\n                format.deep = !isSelectorFormat(format);\r\n              }\r\n              if (isUndefined(format.split)) {\r\n                format.split = !isSelectorFormat(format) || isInlineFormat(format);\r\n              }\r\n              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\r\n                format.remove = 'none';\r\n              }\r\n              if (isSelectorFormat(format) && isInlineFormat(format)) {\r\n                format.mixed = true;\r\n                format.block_expand = true;\r\n              }\r\n              if (isString$1(format.classes)) {\r\n                format.classes = format.classes.split(/\\s+/);\r\n              }\r\n            });\r\n            formats[name] = format;\r\n          }\r\n        }\r\n      };\r\n      var unregister = function (name) {\r\n        if (name && formats[name]) {\r\n          delete formats[name];\r\n        }\r\n        return formats;\r\n      };\r\n      register(get(editor.dom));\r\n      register(getFormats(editor));\r\n      return {\r\n        get: get$1,\r\n        has: has,\r\n        register: register,\r\n        unregister: unregister\r\n      };\r\n    };\r\n\r\n    var each$5 = Tools.each;\r\n    var dom = DOMUtils.DOM;\r\n    var parsedSelectorToHtml = function (ancestry, editor) {\r\n      var elm, item, fragment;\r\n      var schema = editor && editor.schema || Schema({});\r\n      var decorate = function (elm, item) {\r\n        if (item.classes.length) {\r\n          dom.addClass(elm, item.classes.join(' '));\r\n        }\r\n        dom.setAttribs(elm, item.attrs);\r\n      };\r\n      var createElement = function (sItem) {\r\n        item = typeof sItem === 'string' ? {\r\n          name: sItem,\r\n          classes: [],\r\n          attrs: {}\r\n        } : sItem;\r\n        var elm = dom.create(item.name);\r\n        decorate(elm, item);\r\n        return elm;\r\n      };\r\n      var getRequiredParent = function (elm, candidate) {\r\n        var name = typeof elm !== 'string' ? elm.nodeName.toLowerCase() : elm;\r\n        var elmRule = schema.getElementRule(name);\r\n        var parentsRequired = elmRule && elmRule.parentsRequired;\r\n        if (parentsRequired && parentsRequired.length) {\r\n          return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];\r\n        } else {\r\n          return false;\r\n        }\r\n      };\r\n      var wrapInHtml = function (elm, ancestry, siblings) {\r\n        var parent, parentCandidate;\r\n        var ancestor = ancestry.length > 0 && ancestry[0];\r\n        var ancestorName = ancestor && ancestor.name;\r\n        var parentRequired = getRequiredParent(elm, ancestorName);\r\n        if (parentRequired) {\r\n          if (ancestorName === parentRequired) {\r\n            parentCandidate = ancestry[0];\r\n            ancestry = ancestry.slice(1);\r\n          } else {\r\n            parentCandidate = parentRequired;\r\n          }\r\n        } else if (ancestor) {\r\n          parentCandidate = ancestry[0];\r\n          ancestry = ancestry.slice(1);\r\n        } else if (!siblings) {\r\n          return elm;\r\n        }\r\n        if (parentCandidate) {\r\n          parent = createElement(parentCandidate);\r\n          parent.appendChild(elm);\r\n        }\r\n        if (siblings) {\r\n          if (!parent) {\r\n            parent = dom.create('div');\r\n            parent.appendChild(elm);\r\n          }\r\n          Tools.each(siblings, function (sibling) {\r\n            var siblingElm = createElement(sibling);\r\n            parent.insertBefore(siblingElm, elm);\r\n          });\r\n        }\r\n        return wrapInHtml(parent, ancestry, parentCandidate && parentCandidate.siblings);\r\n      };\r\n      if (ancestry && ancestry.length) {\r\n        item = ancestry[0];\r\n        elm = createElement(item);\r\n        fragment = dom.create('div');\r\n        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));\r\n        return fragment;\r\n      } else {\r\n        return '';\r\n      }\r\n    };\r\n    var parseSelectorItem = function (item) {\r\n      var tagName;\r\n      var obj = {\r\n        classes: [],\r\n        attrs: {}\r\n      };\r\n      item = obj.selector = Tools.trim(item);\r\n      if (item !== '*') {\r\n        tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, function ($0, $1, $2, $3, $4) {\r\n          switch ($1) {\r\n          case '#':\r\n            obj.attrs.id = $2;\r\n            break;\r\n          case '.':\r\n            obj.classes.push($2);\r\n            break;\r\n          case ':':\r\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\r\n              obj.attrs[$2] = $2;\r\n            }\r\n            break;\r\n          }\r\n          if ($3 === '[') {\r\n            var m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\r\n            if (m) {\r\n              obj.attrs[m[1]] = m[2];\r\n            }\r\n          }\r\n          return '';\r\n        });\r\n      }\r\n      obj.name = tagName || 'div';\r\n      return obj;\r\n    };\r\n    var parseSelector = function (selector) {\r\n      if (!selector || typeof selector !== 'string') {\r\n        return [];\r\n      }\r\n      selector = selector.split(/\\s*,\\s*/)[0];\r\n      selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\r\n      return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), function (item) {\r\n        var siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\r\n        var obj = siblings.pop();\r\n        if (siblings.length) {\r\n          obj.siblings = siblings;\r\n        }\r\n        return obj;\r\n      }).reverse();\r\n    };\r\n    var getCssText = function (editor, format) {\r\n      var name, previewFrag;\r\n      var previewCss = '', parentFontSize;\r\n      var previewStyles = getPreviewStyles(editor);\r\n      if (previewStyles === '') {\r\n        return '';\r\n      }\r\n      var removeVars = function (val) {\r\n        return val.replace(/%(\\w+)/g, '');\r\n      };\r\n      if (typeof format === 'string') {\r\n        format = editor.formatter.get(format);\r\n        if (!format) {\r\n          return;\r\n        }\r\n        format = format[0];\r\n      }\r\n      if ('preview' in format) {\r\n        var previewOpt = get$9(format, 'preview');\r\n        if (is$1(previewOpt, false)) {\r\n          return '';\r\n        } else {\r\n          previewStyles = previewOpt.getOr(previewStyles);\r\n        }\r\n      }\r\n      name = format.block || format.inline || 'span';\r\n      var items = parseSelector(format.selector);\r\n      if (items.length) {\r\n        if (!items[0].name) {\r\n          items[0].name = name;\r\n        }\r\n        name = format.selector;\r\n        previewFrag = parsedSelectorToHtml(items, editor);\r\n      } else {\r\n        previewFrag = parsedSelectorToHtml([name], editor);\r\n      }\r\n      var previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\r\n      each$5(format.styles, function (value, name) {\r\n        var newValue = removeVars(value);\r\n        if (newValue) {\r\n          dom.setStyle(previewElm, name, newValue);\r\n        }\r\n      });\r\n      each$5(format.attributes, function (value, name) {\r\n        var newValue = removeVars(value);\r\n        if (newValue) {\r\n          dom.setAttrib(previewElm, name, newValue);\r\n        }\r\n      });\r\n      each$5(format.classes, function (value) {\r\n        var newValue = removeVars(value);\r\n        if (!dom.hasClass(previewElm, newValue)) {\r\n          dom.addClass(previewElm, newValue);\r\n        }\r\n      });\r\n      editor.fire('PreviewFormats');\r\n      dom.setStyles(previewFrag, {\r\n        position: 'absolute',\r\n        left: -65535\r\n      });\r\n      editor.getBody().appendChild(previewFrag);\r\n      parentFontSize = dom.getStyle(editor.getBody(), 'fontSize', true);\r\n      parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;\r\n      each$5(previewStyles.split(' '), function (name) {\r\n        var value = dom.getStyle(previewElm, name, true);\r\n        if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\r\n          value = dom.getStyle(editor.getBody(), name, true);\r\n          if (dom.toHex(value).toLowerCase() === '#ffffff') {\r\n            return;\r\n          }\r\n        }\r\n        if (name === 'color') {\r\n          if (dom.toHex(value).toLowerCase() === '#000000') {\r\n            return;\r\n          }\r\n        }\r\n        if (name === 'font-size') {\r\n          if (/em|%$/.test(value)) {\r\n            if (parentFontSize === 0) {\r\n              return;\r\n            }\r\n            var numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\r\n            value = numValue * parentFontSize + 'px';\r\n          }\r\n        }\r\n        if (name === 'border' && value) {\r\n          previewCss += 'padding:0 2px;';\r\n        }\r\n        previewCss += name + ':' + value + ';';\r\n      });\r\n      editor.fire('AfterPreviewFormats');\r\n      dom.remove(previewFrag);\r\n      return previewCss;\r\n    };\r\n\r\n    var setup$h = function (editor) {\r\n      editor.addShortcut('meta+b', '', 'Bold');\r\n      editor.addShortcut('meta+i', '', 'Italic');\r\n      editor.addShortcut('meta+u', '', 'Underline');\r\n      for (var i = 1; i <= 6; i++) {\r\n        editor.addShortcut('access+' + i, '', [\r\n          'FormatBlock',\r\n          false,\r\n          'h' + i\r\n        ]);\r\n      }\r\n      editor.addShortcut('access+7', '', [\r\n        'FormatBlock',\r\n        false,\r\n        'p'\r\n      ]);\r\n      editor.addShortcut('access+8', '', [\r\n        'FormatBlock',\r\n        false,\r\n        'div'\r\n      ]);\r\n      editor.addShortcut('access+9', '', [\r\n        'FormatBlock',\r\n        false,\r\n        'address'\r\n      ]);\r\n    };\r\n\r\n    var Formatter = function (editor) {\r\n      var formats = FormatRegistry(editor);\r\n      var formatChangeState = Cell(null);\r\n      setup$h(editor);\r\n      setup$k(editor);\r\n      return {\r\n        get: formats.get,\r\n        has: formats.has,\r\n        register: formats.register,\r\n        unregister: formats.unregister,\r\n        apply: function (name, vars, node) {\r\n          applyFormat(editor, name, vars, node);\r\n        },\r\n        remove: function (name, vars, node, similar) {\r\n          removeFormat(editor, name, vars, node, similar);\r\n        },\r\n        toggle: function (name, vars, node) {\r\n          toggleFormat(editor, name, vars, node);\r\n        },\r\n        match: function (name, vars, node, similar) {\r\n          return matchFormat(editor, name, vars, node, similar);\r\n        },\r\n        closest: function (names) {\r\n          return closestFormat(editor, names);\r\n        },\r\n        matchAll: function (names, vars) {\r\n          return matchAllFormats(editor, names, vars);\r\n        },\r\n        matchNode: function (node, name, vars, similar) {\r\n          return matchNodeFormat(editor, node, name, vars, similar);\r\n        },\r\n        canApply: function (name) {\r\n          return canApplyFormat(editor, name);\r\n        },\r\n        formatChanged: function (formats, callback, similar, vars) {\r\n          return formatChanged(editor, formatChangeState, formats, callback, similar, vars);\r\n        },\r\n        getCssText: curry(getCssText, editor)\r\n      };\r\n    };\r\n\r\n    var shouldIgnoreCommand = function (cmd) {\r\n      switch (cmd.toLowerCase()) {\r\n      case 'undo':\r\n      case 'redo':\r\n      case 'mcerepaint':\r\n      case 'mcefocus':\r\n        return true;\r\n      default:\r\n        return false;\r\n      }\r\n    };\r\n    var registerEvents = function (editor, undoManager, locks) {\r\n      var isFirstTypedCharacter = Cell(false);\r\n      var addNonTypingUndoLevel = function (e) {\r\n        setTyping(undoManager, false, locks);\r\n        undoManager.add({}, e);\r\n      };\r\n      editor.on('init', function () {\r\n        undoManager.add();\r\n      });\r\n      editor.on('BeforeExecCommand', function (e) {\r\n        var cmd = e.command;\r\n        if (!shouldIgnoreCommand(cmd)) {\r\n          endTyping(undoManager, locks);\r\n          undoManager.beforeChange();\r\n        }\r\n      });\r\n      editor.on('ExecCommand', function (e) {\r\n        var cmd = e.command;\r\n        if (!shouldIgnoreCommand(cmd)) {\r\n          addNonTypingUndoLevel(e);\r\n        }\r\n      });\r\n      editor.on('ObjectResizeStart cut', function () {\r\n        undoManager.beforeChange();\r\n      });\r\n      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\r\n      editor.on('dragend', addNonTypingUndoLevel);\r\n      editor.on('keyup', function (e) {\r\n        var keyCode = e.keyCode;\r\n        if (e.isDefaultPrevented()) {\r\n          return;\r\n        }\r\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {\r\n          addNonTypingUndoLevel();\r\n          editor.nodeChanged();\r\n        }\r\n        if (keyCode === 46 || keyCode === 8) {\r\n          editor.nodeChanged();\r\n        }\r\n        if (isFirstTypedCharacter.get() && undoManager.typing && isEq$1(createFromEditor(editor), undoManager.data[0]) === false) {\r\n          if (editor.isDirty() === false) {\r\n            editor.setDirty(true);\r\n            editor.fire('change', {\r\n              level: undoManager.data[0],\r\n              lastLevel: null\r\n            });\r\n          }\r\n          editor.fire('TypingUndo');\r\n          isFirstTypedCharacter.set(false);\r\n          editor.nodeChanged();\r\n        }\r\n      });\r\n      editor.on('keydown', function (e) {\r\n        var keyCode = e.keyCode;\r\n        if (e.isDefaultPrevented()) {\r\n          return;\r\n        }\r\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\r\n          if (undoManager.typing) {\r\n            addNonTypingUndoLevel(e);\r\n          }\r\n          return;\r\n        }\r\n        var modKey = e.ctrlKey && !e.altKey || e.metaKey;\r\n        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\r\n          undoManager.beforeChange();\r\n          setTyping(undoManager, true, locks);\r\n          undoManager.add({}, e);\r\n          isFirstTypedCharacter.set(true);\r\n        }\r\n      });\r\n      editor.on('mousedown', function (e) {\r\n        if (undoManager.typing) {\r\n          addNonTypingUndoLevel(e);\r\n        }\r\n      });\r\n      var isInsertReplacementText = function (event) {\r\n        return event.inputType === 'insertReplacementText';\r\n      };\r\n      var isInsertTextDataNull = function (event) {\r\n        return event.inputType === 'insertText' && event.data === null;\r\n      };\r\n      var isInsertFromPasteOrDrop = function (event) {\r\n        return event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\r\n      };\r\n      editor.on('input', function (e) {\r\n        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\r\n          addNonTypingUndoLevel(e);\r\n        }\r\n      });\r\n      editor.on('AddUndo Undo Redo ClearUndos', function (e) {\r\n        if (!e.isDefaultPrevented()) {\r\n          editor.nodeChanged();\r\n        }\r\n      });\r\n    };\r\n    var addKeyboardShortcuts = function (editor) {\r\n      editor.addShortcut('meta+z', '', 'Undo');\r\n      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\r\n    };\r\n\r\n    var UndoManager = function (editor) {\r\n      var beforeBookmark = value();\r\n      var locks = Cell(0);\r\n      var index = Cell(0);\r\n      var undoManager = {\r\n        data: [],\r\n        typing: false,\r\n        beforeChange: function () {\r\n          beforeChange(editor, locks, beforeBookmark);\r\n        },\r\n        add: function (level, event) {\r\n          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\r\n        },\r\n        undo: function () {\r\n          return undo(editor, undoManager, locks, index);\r\n        },\r\n        redo: function () {\r\n          return redo(editor, index, undoManager.data);\r\n        },\r\n        clear: function () {\r\n          clear(editor, undoManager, index);\r\n        },\r\n        reset: function () {\r\n          reset(editor, undoManager);\r\n        },\r\n        hasUndo: function () {\r\n          return hasUndo(editor, undoManager, index);\r\n        },\r\n        hasRedo: function () {\r\n          return hasRedo(editor, undoManager, index);\r\n        },\r\n        transact: function (callback) {\r\n          return transact(editor, undoManager, locks, callback);\r\n        },\r\n        ignore: function (callback) {\r\n          ignore(editor, locks, callback);\r\n        },\r\n        extra: function (callback1, callback2) {\r\n          extra(editor, undoManager, index, callback1, callback2);\r\n        }\r\n      };\r\n      if (!isRtc(editor)) {\r\n        registerEvents(editor, undoManager, locks);\r\n      }\r\n      addKeyboardShortcuts(editor);\r\n      return undoManager;\r\n    };\r\n\r\n    var nonTypingKeycodes = [\r\n      9,\r\n      27,\r\n      VK.HOME,\r\n      VK.END,\r\n      19,\r\n      20,\r\n      44,\r\n      144,\r\n      145,\r\n      33,\r\n      34,\r\n      45,\r\n      16,\r\n      17,\r\n      18,\r\n      91,\r\n      92,\r\n      93,\r\n      VK.DOWN,\r\n      VK.UP,\r\n      VK.LEFT,\r\n      VK.RIGHT\r\n    ].concat(Env.browser.isFirefox() ? [224] : []);\r\n    var placeholderAttr = 'data-mce-placeholder';\r\n    var isKeyboardEvent = function (e) {\r\n      return e.type === 'keydown' || e.type === 'keyup';\r\n    };\r\n    var isDeleteEvent = function (e) {\r\n      var keyCode = e.keyCode;\r\n      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\r\n    };\r\n    var isNonTypingKeyboardEvent = function (e) {\r\n      if (isKeyboardEvent(e)) {\r\n        var keyCode = e.keyCode;\r\n        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$3(nonTypingKeycodes, keyCode));\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var isTypingKeyboardEvent = function (e) {\r\n      return isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\r\n    };\r\n    var isVisuallyEmpty = function (dom, rootElm, forcedRootBlock) {\r\n      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {\r\n        var isForcedRootBlockFalse = forcedRootBlock === '';\r\n        var firstElement = rootElm.firstElementChild;\r\n        if (!firstElement) {\r\n          return true;\r\n        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\r\n          return false;\r\n        } else {\r\n          return isForcedRootBlockFalse ? !dom.isBlock(firstElement) : forcedRootBlock === firstElement.nodeName.toLowerCase();\r\n        }\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var setup$g = function (editor) {\r\n      var dom = editor.dom;\r\n      var rootBlock = getForcedRootBlock(editor);\r\n      var placeholder = getPlaceholder(editor);\r\n      var updatePlaceholder = function (e, initial) {\r\n        if (isNonTypingKeyboardEvent(e)) {\r\n          return;\r\n        }\r\n        var body = editor.getBody();\r\n        var showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\r\n        var isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\r\n        if (isPlaceholderShown !== showPlaceholder || initial) {\r\n          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\r\n          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);\r\n          firePlaceholderToggle(editor, showPlaceholder);\r\n          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\r\n          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\r\n        }\r\n      };\r\n      if (placeholder) {\r\n        editor.on('init', function (e) {\r\n          updatePlaceholder(e, true);\r\n          editor.on('change SetContent ExecCommand', updatePlaceholder);\r\n          editor.on('paste', function (e) {\r\n            return Delay.setEditorTimeout(editor, function () {\r\n              return updatePlaceholder(e);\r\n            });\r\n          });\r\n        });\r\n      }\r\n    };\r\n\r\n    var strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\r\n    var hasStrongRtl = function (text) {\r\n      return strongRtl.test(text);\r\n    };\r\n\r\n    var isInlineTarget = function (editor, elm) {\r\n      return is$2(SugarElement.fromDom(elm), getInlineBoundarySelector(editor));\r\n    };\r\n    var isRtl = function (element) {\r\n      return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl(element.textContent);\r\n    };\r\n    var findInlineParents = function (isInlineTarget, rootNode, pos) {\r\n      return filter$4(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\r\n    };\r\n    var findRootInline = function (isInlineTarget, rootNode, pos) {\r\n      var parents = findInlineParents(isInlineTarget, rootNode, pos);\r\n      return Optional.from(parents[parents.length - 1]);\r\n    };\r\n    var hasSameParentBlock = function (rootNode, node1, node2) {\r\n      var block1 = getParentBlock$2(node1, rootNode);\r\n      var block2 = getParentBlock$2(node2, rootNode);\r\n      return block1 && block1 === block2;\r\n    };\r\n    var isAtZwsp = function (pos) {\r\n      return isBeforeInline(pos) || isAfterInline(pos);\r\n    };\r\n    var normalizePosition = function (forward, pos) {\r\n      if (!pos) {\r\n        return pos;\r\n      }\r\n      var container = pos.container(), offset = pos.offset();\r\n      if (forward) {\r\n        if (isCaretContainerInline(container)) {\r\n          if (isText$7(container.nextSibling)) {\r\n            return CaretPosition(container.nextSibling, 0);\r\n          } else {\r\n            return CaretPosition.after(container);\r\n          }\r\n        } else {\r\n          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\r\n        }\r\n      } else {\r\n        if (isCaretContainerInline(container)) {\r\n          if (isText$7(container.previousSibling)) {\r\n            return CaretPosition(container.previousSibling, container.previousSibling.data.length);\r\n          } else {\r\n            return CaretPosition.before(container);\r\n          }\r\n        } else {\r\n          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\r\n        }\r\n      }\r\n    };\r\n    var normalizeForwards = curry(normalizePosition, true);\r\n    var normalizeBackwards = curry(normalizePosition, false);\r\n\r\n    var isBeforeRoot = function (rootNode) {\r\n      return function (elm) {\r\n        return eq(rootNode, SugarElement.fromDom(elm.dom.parentNode));\r\n      };\r\n    };\r\n    var isTextBlockOrListItem = function (element) {\r\n      return isTextBlock$2(element) || isListItem(element);\r\n    };\r\n    var getParentBlock$1 = function (rootNode, elm) {\r\n      if (contains$1(rootNode, elm)) {\r\n        return closest$3(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var placeCaretInEmptyBody = function (editor) {\r\n      var body = editor.getBody();\r\n      var node = body.firstChild && editor.dom.isBlock(body.firstChild) ? body.firstChild : body;\r\n      editor.selection.setCursorLocation(node, 0);\r\n    };\r\n    var paddEmptyBody = function (editor) {\r\n      if (editor.dom.isEmpty(editor.getBody())) {\r\n        editor.setContent('');\r\n        placeCaretInEmptyBody(editor);\r\n      }\r\n    };\r\n    var willDeleteLastPositionInElement = function (forward, fromPos, elm) {\r\n      return lift2(firstPositionIn(elm), lastPositionIn(elm), function (firstPos, lastPos) {\r\n        var normalizedFirstPos = normalizePosition(true, firstPos);\r\n        var normalizedLastPos = normalizePosition(false, lastPos);\r\n        var normalizedFromPos = normalizePosition(false, fromPos);\r\n        if (forward) {\r\n          return nextPosition(elm, normalizedFromPos).exists(function (nextPos) {\r\n            return nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos);\r\n          });\r\n        } else {\r\n          return prevPosition(elm, normalizedFromPos).exists(function (prevPos) {\r\n            return prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos);\r\n          });\r\n        }\r\n      }).getOr(true);\r\n    };\r\n\r\n    var blockPosition = function (block, position) {\r\n      return {\r\n        block: block,\r\n        position: position\r\n      };\r\n    };\r\n    var blockBoundary = function (from, to) {\r\n      return {\r\n        from: from,\r\n        to: to\r\n      };\r\n    };\r\n    var getBlockPosition = function (rootNode, pos) {\r\n      var rootElm = SugarElement.fromDom(rootNode);\r\n      var containerElm = SugarElement.fromDom(pos.container());\r\n      return getParentBlock$1(rootElm, containerElm).map(function (block) {\r\n        return blockPosition(block, pos);\r\n      });\r\n    };\r\n    var isDifferentBlocks = function (blockBoundary) {\r\n      return eq(blockBoundary.from.block, blockBoundary.to.block) === false;\r\n    };\r\n    var hasSameParent = function (blockBoundary) {\r\n      return parent(blockBoundary.from.block).bind(function (parent1) {\r\n        return parent(blockBoundary.to.block).filter(function (parent2) {\r\n          return eq(parent1, parent2);\r\n        });\r\n      }).isSome();\r\n    };\r\n    var isEditable$1 = function (blockBoundary) {\r\n      return isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;\r\n    };\r\n    var skipLastBr = function (rootNode, forward, blockPosition) {\r\n      if (isBr$5(blockPosition.position.getNode()) && isEmpty$2(blockPosition.block) === false) {\r\n        return positionIn(false, blockPosition.block.dom).bind(function (lastPositionInBlock) {\r\n          if (lastPositionInBlock.isEqual(blockPosition.position)) {\r\n            return fromPosition(forward, rootNode, lastPositionInBlock).bind(function (to) {\r\n              return getBlockPosition(rootNode, to);\r\n            });\r\n          } else {\r\n            return Optional.some(blockPosition);\r\n          }\r\n        }).getOr(blockPosition);\r\n      } else {\r\n        return blockPosition;\r\n      }\r\n    };\r\n    var readFromRange = function (rootNode, forward, rng) {\r\n      var fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\r\n      var toBlockPos = fromBlockPos.bind(function (blockPos) {\r\n        return fromPosition(forward, rootNode, blockPos.position).bind(function (to) {\r\n          return getBlockPosition(rootNode, to).map(function (blockPos) {\r\n            return skipLastBr(rootNode, forward, blockPos);\r\n          });\r\n        });\r\n      });\r\n      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(function (blockBoundary) {\r\n        return isDifferentBlocks(blockBoundary) && hasSameParent(blockBoundary) && isEditable$1(blockBoundary);\r\n      });\r\n    };\r\n    var read$1 = function (rootNode, forward, rng) {\r\n      return rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();\r\n    };\r\n\r\n    var getChildrenUntilBlockBoundary = function (block) {\r\n      var children$1 = children(block);\r\n      return findIndex$2(children$1, isBlock$2).fold(constant(children$1), function (index) {\r\n        return children$1.slice(0, index);\r\n      });\r\n    };\r\n    var extractChildren = function (block) {\r\n      var children = getChildrenUntilBlockBoundary(block);\r\n      each$k(children, remove$7);\r\n      return children;\r\n    };\r\n    var removeEmptyRoot = function (rootNode, block) {\r\n      var parents = parentsAndSelf(block, rootNode);\r\n      return find$3(parents.reverse(), function (element) {\r\n        return isEmpty$2(element);\r\n      }).each(remove$7);\r\n    };\r\n    var isEmptyBefore = function (el) {\r\n      return filter$4(prevSiblings(el), function (el) {\r\n        return !isEmpty$2(el);\r\n      }).length === 0;\r\n    };\r\n    var nestedBlockMerge = function (rootNode, fromBlock, toBlock, insertionPoint) {\r\n      if (isEmpty$2(toBlock)) {\r\n        fillWithPaddingBr(toBlock);\r\n        return firstPositionIn(toBlock.dom);\r\n      }\r\n      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {\r\n        before$4(insertionPoint, SugarElement.fromTag('br'));\r\n      }\r\n      var position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\r\n      each$k(extractChildren(fromBlock), function (child) {\r\n        before$4(insertionPoint, child);\r\n      });\r\n      removeEmptyRoot(rootNode, fromBlock);\r\n      return position;\r\n    };\r\n    var sidelongBlockMerge = function (rootNode, fromBlock, toBlock) {\r\n      if (isEmpty$2(toBlock)) {\r\n        remove$7(toBlock);\r\n        if (isEmpty$2(fromBlock)) {\r\n          fillWithPaddingBr(fromBlock);\r\n        }\r\n        return firstPositionIn(fromBlock.dom);\r\n      }\r\n      var position = lastPositionIn(toBlock.dom);\r\n      each$k(extractChildren(fromBlock), function (child) {\r\n        append$1(toBlock, child);\r\n      });\r\n      removeEmptyRoot(rootNode, fromBlock);\r\n      return position;\r\n    };\r\n    var findInsertionPoint = function (toBlock, block) {\r\n      var parentsAndSelf$1 = parentsAndSelf(block, toBlock);\r\n      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\r\n    };\r\n    var getInsertionPoint = function (fromBlock, toBlock) {\r\n      return contains$1(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\r\n    };\r\n    var trimBr = function (first, block) {\r\n      positionIn(first, block.dom).map(function (position) {\r\n        return position.getNode();\r\n      }).map(SugarElement.fromDom).filter(isBr$4).each(remove$7);\r\n    };\r\n    var mergeBlockInto = function (rootNode, fromBlock, toBlock) {\r\n      trimBr(true, fromBlock);\r\n      trimBr(false, toBlock);\r\n      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));\r\n    };\r\n    var mergeBlocks = function (rootNode, forward, block1, block2) {\r\n      return forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);\r\n    };\r\n\r\n    var backspaceDelete$8 = function (editor, forward) {\r\n      var rootNode = SugarElement.fromDom(editor.getBody());\r\n      var position = read$1(rootNode.dom, forward, editor.selection.getRng()).bind(function (blockBoundary) {\r\n        return mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block);\r\n      });\r\n      position.each(function (pos) {\r\n        editor.selection.setRng(pos.toRange());\r\n      });\r\n      return position.isSome();\r\n    };\r\n\r\n    var deleteRangeMergeBlocks = function (rootNode, selection) {\r\n      var rng = selection.getRng();\r\n      return lift2(getParentBlock$1(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$1(rootNode, SugarElement.fromDom(rng.endContainer)), function (block1, block2) {\r\n        if (eq(block1, block2) === false) {\r\n          rng.deleteContents();\r\n          mergeBlocks(rootNode, true, block1, block2).each(function (pos) {\r\n            selection.setRng(pos.toRange());\r\n          });\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      }).getOr(false);\r\n    };\r\n    var isRawNodeInTable = function (root, rawNode) {\r\n      var node = SugarElement.fromDom(rawNode);\r\n      var isRoot = curry(eq, root);\r\n      return ancestor$3(node, isTableCell$4, isRoot).isSome();\r\n    };\r\n    var isSelectionInTable = function (root, rng) {\r\n      return isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\r\n    };\r\n    var isEverythingSelected = function (root, rng) {\r\n      var noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\r\n      var noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\r\n      return !isSelectionInTable(root, rng) && noPrevious && noNext;\r\n    };\r\n    var emptyEditor = function (editor) {\r\n      editor.setContent('');\r\n      editor.selection.setCursorLocation();\r\n      return true;\r\n    };\r\n    var deleteRange$1 = function (editor) {\r\n      var rootNode = SugarElement.fromDom(editor.getBody());\r\n      var rng = editor.selection.getRng();\r\n      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);\r\n    };\r\n    var backspaceDelete$7 = function (editor, _forward) {\r\n      return editor.selection.isCollapsed() ? false : deleteRange$1(editor);\r\n    };\r\n\r\n    var isContentEditableTrue$2 = isContentEditableTrue$4;\r\n    var isContentEditableFalse$4 = isContentEditableFalse$b;\r\n    var showCaret = function (direction, editor, node, before, scrollIntoView) {\r\n      return Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\r\n    };\r\n    var getNodeRange = function (node) {\r\n      var rng = node.ownerDocument.createRange();\r\n      rng.selectNode(node);\r\n      return rng;\r\n    };\r\n    var selectNode = function (editor, node) {\r\n      var e = editor.fire('BeforeObjectSelected', { target: node });\r\n      if (e.isDefaultPrevented()) {\r\n        return Optional.none();\r\n      }\r\n      return Optional.some(getNodeRange(node));\r\n    };\r\n    var renderCaretAtRange = function (editor, range, scrollIntoView) {\r\n      var normalizedRange = normalizeRange(1, editor.getBody(), range);\r\n      var caretPosition = CaretPosition.fromRangeStart(normalizedRange);\r\n      var caretPositionNode = caretPosition.getNode();\r\n      if (isInlineFakeCaretTarget(caretPositionNode)) {\r\n        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\r\n      }\r\n      var caretPositionBeforeNode = caretPosition.getNode(true);\r\n      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\r\n        return showCaret(1, editor, caretPositionBeforeNode, false, false);\r\n      }\r\n      var ceRoot = editor.dom.getParent(caretPosition.getNode(), function (node) {\r\n        return isContentEditableFalse$4(node) || isContentEditableTrue$2(node);\r\n      });\r\n      if (isInlineFakeCaretTarget(ceRoot)) {\r\n        return showCaret(1, editor, ceRoot, false, scrollIntoView);\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var renderRangeCaret = function (editor, range, scrollIntoView) {\r\n      return range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\r\n    };\r\n\r\n    var isBeforeBoundary = function (pos) {\r\n      return isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\r\n    };\r\n    var isAfterBoundary = function (pos) {\r\n      return isAfterContentEditableFalse(pos) || isAfterMedia(pos);\r\n    };\r\n    var trimEmptyTextNode = function (dom, node) {\r\n      if (isText$7(node) && node.data.length === 0) {\r\n        dom.remove(node);\r\n      }\r\n    };\r\n    var deleteContentAndShowCaret = function (editor, range, node, direction, forward, peekCaretPosition) {\r\n      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(function (caretRange) {\r\n        if (range.collapsed) {\r\n          var deleteRange = range.cloneRange();\r\n          if (forward) {\r\n            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\r\n          } else {\r\n            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\r\n          }\r\n          deleteRange.deleteContents();\r\n        } else {\r\n          range.deleteContents();\r\n        }\r\n        editor.selection.setRng(caretRange);\r\n      });\r\n      trimEmptyTextNode(editor.dom, node);\r\n      return true;\r\n    };\r\n    var deleteBoundaryText = function (editor, forward) {\r\n      var range = editor.selection.getRng();\r\n      if (!isText$7(range.commonAncestorContainer)) {\r\n        return false;\r\n      }\r\n      var direction = forward ? HDirection.Forwards : HDirection.Backwards;\r\n      var caretWalker = CaretWalker(editor.getBody());\r\n      var getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\r\n      var isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\r\n      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\r\n      var nextCaretPosition = normalizePosition(forward, getNextPosFn(caretPosition));\r\n      if (!nextCaretPosition || !isMoveInsideSameBlock(caretPosition, nextCaretPosition)) {\r\n        return false;\r\n      } else if (isBeforeFn(nextCaretPosition)) {\r\n        return deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, nextCaretPosition);\r\n      }\r\n      var peekCaretPosition = getNextPosFn(nextCaretPosition);\r\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\r\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\r\n          return deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition);\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var backspaceDelete$6 = function (editor, forward) {\r\n      return deleteBoundaryText(editor, forward);\r\n    };\r\n\r\n    var isCompoundElement = function (node) {\r\n      return isTableCell$4(SugarElement.fromDom(node)) || isListItem(SugarElement.fromDom(node));\r\n    };\r\n    var DeleteAction = Adt.generate([\r\n      { remove: ['element'] },\r\n      { moveToElement: ['element'] },\r\n      { moveToPosition: ['position'] }\r\n    ]);\r\n    var isAtContentEditableBlockCaret = function (forward, from) {\r\n      var elm = from.getNode(forward === false);\r\n      var caretLocation = forward ? 'after' : 'before';\r\n      return isElement$5(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\r\n    };\r\n    var isDeleteFromCefDifferentBlocks = function (root, forward, from, to) {\r\n      var inSameBlock = function (elm) {\r\n        return isInline$1(SugarElement.fromDom(elm)) && !isInSameBlock(from, to, root);\r\n      };\r\n      return getRelativeCefElm(!forward, from).fold(function () {\r\n        return getRelativeCefElm(forward, to).fold(never, inSameBlock);\r\n      }, inSameBlock);\r\n    };\r\n    var deleteEmptyBlockOrMoveToCef = function (root, forward, from, to) {\r\n      var toCefElm = to.getNode(forward === false);\r\n      return getParentBlock$1(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(function (blockElm) {\r\n        return isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm);\r\n      }).orThunk(function () {\r\n        return Optional.some(DeleteAction.moveToElement(toCefElm));\r\n      });\r\n    };\r\n    var findCefPosition = function (root, forward, from) {\r\n      return fromPosition(forward, root, from).bind(function (to) {\r\n        if (isCompoundElement(to.getNode())) {\r\n          return Optional.none();\r\n        } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to)) {\r\n          return Optional.none();\r\n        } else if (forward && isContentEditableFalse$b(to.getNode())) {\r\n          return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\r\n        } else if (forward === false && isContentEditableFalse$b(to.getNode(true))) {\r\n          return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\r\n        } else if (forward && isAfterContentEditableFalse(from)) {\r\n          return Optional.some(DeleteAction.moveToPosition(to));\r\n        } else if (forward === false && isBeforeContentEditableFalse(from)) {\r\n          return Optional.some(DeleteAction.moveToPosition(to));\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      });\r\n    };\r\n    var getContentEditableBlockAction = function (forward, elm) {\r\n      if (forward && isContentEditableFalse$b(elm.nextSibling)) {\r\n        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\r\n      } else if (forward === false && isContentEditableFalse$b(elm.previousSibling)) {\r\n        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    var skipMoveToActionFromInlineCefToContent = function (root, from, deleteAction) {\r\n      return deleteAction.fold(function (elm) {\r\n        return Optional.some(DeleteAction.remove(elm));\r\n      }, function (elm) {\r\n        return Optional.some(DeleteAction.moveToElement(elm));\r\n      }, function (to) {\r\n        if (isInSameBlock(from, to, root)) {\r\n          return Optional.none();\r\n        } else {\r\n          return Optional.some(DeleteAction.moveToPosition(to));\r\n        }\r\n      });\r\n    };\r\n    var getContentEditableAction = function (root, forward, from) {\r\n      if (isAtContentEditableBlockCaret(forward, from)) {\r\n        return getContentEditableBlockAction(forward, from.getNode(forward === false)).fold(function () {\r\n          return findCefPosition(root, forward, from);\r\n        }, Optional.some);\r\n      } else {\r\n        return findCefPosition(root, forward, from).bind(function (deleteAction) {\r\n          return skipMoveToActionFromInlineCefToContent(root, from, deleteAction);\r\n        });\r\n      }\r\n    };\r\n    var read = function (root, forward, rng) {\r\n      var normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\r\n      var from = CaretPosition.fromRangeStart(normalizedRange);\r\n      var rootElement = SugarElement.fromDom(root);\r\n      if (forward === false && isAfterContentEditableFalse(from)) {\r\n        return Optional.some(DeleteAction.remove(from.getNode(true)));\r\n      } else if (forward && isBeforeContentEditableFalse(from)) {\r\n        return Optional.some(DeleteAction.remove(from.getNode()));\r\n      } else if (forward === false && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from)) {\r\n        return findPreviousBr(rootElement, from).map(function (br) {\r\n          return DeleteAction.remove(br.getNode());\r\n        });\r\n      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from)) {\r\n        return findNextBr(rootElement, from).map(function (br) {\r\n          return DeleteAction.remove(br.getNode());\r\n        });\r\n      } else {\r\n        return getContentEditableAction(root, forward, from);\r\n      }\r\n    };\r\n\r\n    var deleteElement$1 = function (editor, forward) {\r\n      return function (element) {\r\n        editor._selectionOverrides.hideFakeCaret();\r\n        deleteElement$2(editor, forward, SugarElement.fromDom(element));\r\n        return true;\r\n      };\r\n    };\r\n    var moveToElement = function (editor, forward) {\r\n      return function (element) {\r\n        var pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\r\n        editor.selection.setRng(pos.toRange());\r\n        return true;\r\n      };\r\n    };\r\n    var moveToPosition = function (editor) {\r\n      return function (pos) {\r\n        editor.selection.setRng(pos.toRange());\r\n        return true;\r\n      };\r\n    };\r\n    var getAncestorCe = function (editor, node) {\r\n      return Optional.from(getContentEditableRoot$1(editor.getBody(), node));\r\n    };\r\n    var backspaceDeleteCaret = function (editor, forward) {\r\n      var selectedNode = editor.selection.getNode();\r\n      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(function () {\r\n        return read(editor.getBody(), forward, editor.selection.getRng()).exists(function (deleteAction) {\r\n          return deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor));\r\n        });\r\n      }, always);\r\n    };\r\n    var deleteOffscreenSelection = function (rootElement) {\r\n      each$k(descendants(rootElement, '.mce-offscreen-selection'), remove$7);\r\n    };\r\n    var backspaceDeleteRange = function (editor, forward) {\r\n      var selectedNode = editor.selection.getNode();\r\n      if (isContentEditableFalse$b(selectedNode) && !isTableCell$5(selectedNode)) {\r\n        var hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);\r\n        return hasCefAncestor.fold(function () {\r\n          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\r\n          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\r\n          paddEmptyBody(editor);\r\n          return true;\r\n        }, always);\r\n      }\r\n      return false;\r\n    };\r\n    var paddEmptyElement = function (editor) {\r\n      var dom = editor.dom, selection = editor.selection;\r\n      var ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\r\n      if (isContentEditableTrue$4(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\r\n        var br = dom.create('br', { 'data-mce-bogus': '1' });\r\n        dom.setHTML(ceRoot, '');\r\n        ceRoot.appendChild(br);\r\n        selection.setRng(CaretPosition.before(br).toRange());\r\n      }\r\n      return true;\r\n    };\r\n    var backspaceDelete$5 = function (editor, forward) {\r\n      if (editor.selection.isCollapsed()) {\r\n        return backspaceDeleteCaret(editor, forward);\r\n      } else {\r\n        return backspaceDeleteRange(editor, forward);\r\n      }\r\n    };\r\n\r\n    var deleteCaret$2 = function (editor, forward) {\r\n      var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return fromPosition(forward, editor.getBody(), fromPos).filter(function (pos) {\r\n        return forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos);\r\n      }).bind(function (pos) {\r\n        return Optional.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, pos));\r\n      }).exists(function (elm) {\r\n        editor.selection.select(elm);\r\n        return true;\r\n      });\r\n    };\r\n    var backspaceDelete$4 = function (editor, forward) {\r\n      return editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : false;\r\n    };\r\n\r\n    var isText = isText$7;\r\n    var startsWithCaretContainer = function (node) {\r\n      return isText(node) && node.data[0] === ZWSP$1;\r\n    };\r\n    var endsWithCaretContainer = function (node) {\r\n      return isText(node) && node.data[node.data.length - 1] === ZWSP$1;\r\n    };\r\n    var createZwsp = function (node) {\r\n      return node.ownerDocument.createTextNode(ZWSP$1);\r\n    };\r\n    var insertBefore = function (node) {\r\n      if (isText(node.previousSibling)) {\r\n        if (endsWithCaretContainer(node.previousSibling)) {\r\n          return node.previousSibling;\r\n        } else {\r\n          node.previousSibling.appendData(ZWSP$1);\r\n          return node.previousSibling;\r\n        }\r\n      } else if (isText(node)) {\r\n        if (startsWithCaretContainer(node)) {\r\n          return node;\r\n        } else {\r\n          node.insertData(0, ZWSP$1);\r\n          return node;\r\n        }\r\n      } else {\r\n        var newNode = createZwsp(node);\r\n        node.parentNode.insertBefore(newNode, node);\r\n        return newNode;\r\n      }\r\n    };\r\n    var insertAfter = function (node) {\r\n      if (isText(node.nextSibling)) {\r\n        if (startsWithCaretContainer(node.nextSibling)) {\r\n          return node.nextSibling;\r\n        } else {\r\n          node.nextSibling.insertData(0, ZWSP$1);\r\n          return node.nextSibling;\r\n        }\r\n      } else if (isText(node)) {\r\n        if (endsWithCaretContainer(node)) {\r\n          return node;\r\n        } else {\r\n          node.appendData(ZWSP$1);\r\n          return node;\r\n        }\r\n      } else {\r\n        var newNode = createZwsp(node);\r\n        if (node.nextSibling) {\r\n          node.parentNode.insertBefore(newNode, node.nextSibling);\r\n        } else {\r\n          node.parentNode.appendChild(newNode);\r\n        }\r\n        return newNode;\r\n      }\r\n    };\r\n    var insertInline = function (before, node) {\r\n      return before ? insertBefore(node) : insertAfter(node);\r\n    };\r\n    var insertInlineBefore = curry(insertInline, true);\r\n    var insertInlineAfter = curry(insertInline, false);\r\n\r\n    var insertInlinePos = function (pos, before) {\r\n      if (isText$7(pos.container())) {\r\n        return insertInline(before, pos.container());\r\n      } else {\r\n        return insertInline(before, pos.getNode());\r\n      }\r\n    };\r\n    var isPosCaretContainer = function (pos, caret) {\r\n      var caretNode = caret.get();\r\n      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\r\n    };\r\n    var renderCaret = function (caret, location) {\r\n      return location.fold(function (element) {\r\n        remove$2(caret.get());\r\n        var text = insertInlineBefore(element);\r\n        caret.set(text);\r\n        return Optional.some(CaretPosition(text, text.length - 1));\r\n      }, function (element) {\r\n        return firstPositionIn(element).map(function (pos) {\r\n          if (!isPosCaretContainer(pos, caret)) {\r\n            remove$2(caret.get());\r\n            var text = insertInlinePos(pos, true);\r\n            caret.set(text);\r\n            return CaretPosition(text, 1);\r\n          } else {\r\n            return CaretPosition(caret.get(), 1);\r\n          }\r\n        });\r\n      }, function (element) {\r\n        return lastPositionIn(element).map(function (pos) {\r\n          if (!isPosCaretContainer(pos, caret)) {\r\n            remove$2(caret.get());\r\n            var text = insertInlinePos(pos, false);\r\n            caret.set(text);\r\n            return CaretPosition(text, text.length - 1);\r\n          } else {\r\n            return CaretPosition(caret.get(), caret.get().length - 1);\r\n          }\r\n        });\r\n      }, function (element) {\r\n        remove$2(caret.get());\r\n        var text = insertInlineAfter(element);\r\n        caret.set(text);\r\n        return Optional.some(CaretPosition(text, 1));\r\n      });\r\n    };\r\n\r\n    var evaluateUntil = function (fns, args) {\r\n      for (var i = 0; i < fns.length; i++) {\r\n        var result = fns[i].apply(null, args);\r\n        if (result.isSome()) {\r\n          return result;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n\r\n    var Location = Adt.generate([\r\n      { before: ['element'] },\r\n      { start: ['element'] },\r\n      { end: ['element'] },\r\n      { after: ['element'] }\r\n    ]);\r\n    var rescope$1 = function (rootNode, node) {\r\n      var parentBlock = getParentBlock$2(node, rootNode);\r\n      return parentBlock ? parentBlock : rootNode;\r\n    };\r\n    var before = function (isInlineTarget, rootNode, pos) {\r\n      var nPos = normalizeForwards(pos);\r\n      var scope = rescope$1(rootNode, nPos.container());\r\n      return findRootInline(isInlineTarget, scope, nPos).fold(function () {\r\n        return nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(function (inline) {\r\n          return Location.before(inline);\r\n        });\r\n      }, Optional.none);\r\n    };\r\n    var isNotInsideFormatCaretContainer = function (rootNode, elm) {\r\n      return getParentCaretContainer(rootNode, elm) === null;\r\n    };\r\n    var findInsideRootInline = function (isInlineTarget, rootNode, pos) {\r\n      return findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\r\n    };\r\n    var start$1 = function (isInlineTarget, rootNode, pos) {\r\n      var nPos = normalizeBackwards(pos);\r\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(function (inline) {\r\n        var prevPos = prevPosition(inline, nPos);\r\n        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\r\n      });\r\n    };\r\n    var end = function (isInlineTarget, rootNode, pos) {\r\n      var nPos = normalizeForwards(pos);\r\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(function (inline) {\r\n        var nextPos = nextPosition(inline, nPos);\r\n        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\r\n      });\r\n    };\r\n    var after = function (isInlineTarget, rootNode, pos) {\r\n      var nPos = normalizeBackwards(pos);\r\n      var scope = rescope$1(rootNode, nPos.container());\r\n      return findRootInline(isInlineTarget, scope, nPos).fold(function () {\r\n        return prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(function (inline) {\r\n          return Location.after(inline);\r\n        });\r\n      }, Optional.none);\r\n    };\r\n    var isValidLocation = function (location) {\r\n      return isRtl(getElement(location)) === false;\r\n    };\r\n    var readLocation = function (isInlineTarget, rootNode, pos) {\r\n      var location = evaluateUntil([\r\n        before,\r\n        start$1,\r\n        end,\r\n        after\r\n      ], [\r\n        isInlineTarget,\r\n        rootNode,\r\n        pos\r\n      ]);\r\n      return location.filter(isValidLocation);\r\n    };\r\n    var getElement = function (location) {\r\n      return location.fold(identity, identity, identity, identity);\r\n    };\r\n    var getName = function (location) {\r\n      return location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\r\n    };\r\n    var outside = function (location) {\r\n      return location.fold(Location.before, Location.before, Location.after, Location.after);\r\n    };\r\n    var inside = function (location) {\r\n      return location.fold(Location.start, Location.start, Location.end, Location.end);\r\n    };\r\n    var isEq = function (location1, location2) {\r\n      return getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\r\n    };\r\n    var betweenInlines = function (forward, isInlineTarget, rootNode, from, to, location) {\r\n      return lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), function (fromInline, toInline) {\r\n        if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\r\n          return Location.after(forward ? fromInline : toInline);\r\n        } else {\r\n          return location;\r\n        }\r\n      }).getOr(location);\r\n    };\r\n    var skipNoMovement = function (fromLocation, toLocation) {\r\n      return fromLocation.fold(always, function (fromLocation) {\r\n        return !isEq(fromLocation, toLocation);\r\n      });\r\n    };\r\n    var findLocationTraverse = function (forward, isInlineTarget, rootNode, fromLocation, pos) {\r\n      var from = normalizePosition(forward, pos);\r\n      var to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\r\n      var location = to.fold(function () {\r\n        return fromLocation.map(outside);\r\n      }, function (to) {\r\n        return readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation));\r\n      });\r\n      return location.filter(isValidLocation);\r\n    };\r\n    var findLocationSimple = function (forward, location) {\r\n      if (forward) {\r\n        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\r\n      } else {\r\n        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\r\n      }\r\n    };\r\n    var findLocation$1 = function (forward, isInlineTarget, rootNode, pos) {\r\n      var from = normalizePosition(forward, pos);\r\n      var fromLocation = readLocation(isInlineTarget, rootNode, from);\r\n      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(function () {\r\n        return findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos);\r\n      });\r\n    };\r\n    curry(findLocation$1, false);\r\n    curry(findLocation$1, true);\r\n\r\n    var hasSelectionModifyApi = function (editor) {\r\n      return isFunction(editor.selection.getSel().modify);\r\n    };\r\n    var moveRel = function (forward, selection, pos) {\r\n      var delta = forward ? 1 : -1;\r\n      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\r\n      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\r\n      return true;\r\n    };\r\n    var moveByWord = function (forward, editor) {\r\n      var rng = editor.selection.getRng();\r\n      var pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\r\n      if (!hasSelectionModifyApi(editor)) {\r\n        return false;\r\n      } else if (forward && isBeforeInline(pos)) {\r\n        return moveRel(true, editor.selection, pos);\r\n      } else if (!forward && isAfterInline(pos)) {\r\n        return moveRel(false, editor.selection, pos);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    var BreakType;\r\n    (function (BreakType) {\r\n      BreakType[BreakType['Br'] = 0] = 'Br';\r\n      BreakType[BreakType['Block'] = 1] = 'Block';\r\n      BreakType[BreakType['Wrap'] = 2] = 'Wrap';\r\n      BreakType[BreakType['Eol'] = 3] = 'Eol';\r\n    }(BreakType || (BreakType = {})));\r\n    var flip = function (direction, positions) {\r\n      return direction === HDirection.Backwards ? reverse(positions) : positions;\r\n    };\r\n    var walk = function (direction, caretWalker, pos) {\r\n      return direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\r\n    };\r\n    var getBreakType = function (scope, direction, currentPos, nextPos) {\r\n      if (isBr$5(nextPos.getNode(direction === HDirection.Forwards))) {\r\n        return BreakType.Br;\r\n      } else if (isInSameBlock(currentPos, nextPos) === false) {\r\n        return BreakType.Block;\r\n      } else {\r\n        return BreakType.Wrap;\r\n      }\r\n    };\r\n    var getPositionsUntil = function (predicate, direction, scope, start) {\r\n      var caretWalker = CaretWalker(scope);\r\n      var currentPos = start;\r\n      var positions = [];\r\n      while (currentPos) {\r\n        var nextPos = walk(direction, caretWalker, currentPos);\r\n        if (!nextPos) {\r\n          break;\r\n        }\r\n        if (isBr$5(nextPos.getNode(false))) {\r\n          if (direction === HDirection.Forwards) {\r\n            return {\r\n              positions: flip(direction, positions).concat([nextPos]),\r\n              breakType: BreakType.Br,\r\n              breakAt: Optional.some(nextPos)\r\n            };\r\n          } else {\r\n            return {\r\n              positions: flip(direction, positions),\r\n              breakType: BreakType.Br,\r\n              breakAt: Optional.some(nextPos)\r\n            };\r\n          }\r\n        }\r\n        if (!nextPos.isVisible()) {\r\n          currentPos = nextPos;\r\n          continue;\r\n        }\r\n        if (predicate(currentPos, nextPos)) {\r\n          var breakType = getBreakType(scope, direction, currentPos, nextPos);\r\n          return {\r\n            positions: flip(direction, positions),\r\n            breakType: breakType,\r\n            breakAt: Optional.some(nextPos)\r\n          };\r\n        }\r\n        positions.push(nextPos);\r\n        currentPos = nextPos;\r\n      }\r\n      return {\r\n        positions: flip(direction, positions),\r\n        breakType: BreakType.Eol,\r\n        breakAt: Optional.none()\r\n      };\r\n    };\r\n    var getAdjacentLinePositions = function (direction, getPositionsUntilBreak, scope, start) {\r\n      return getPositionsUntilBreak(scope, start).breakAt.map(function (pos) {\r\n        var positions = getPositionsUntilBreak(scope, pos).positions;\r\n        return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\r\n      }).getOr([]);\r\n    };\r\n    var findClosestHorizontalPositionFromPoint = function (positions, x) {\r\n      return foldl(positions, function (acc, newPos) {\r\n        return acc.fold(function () {\r\n          return Optional.some(newPos);\r\n        }, function (lastPos) {\r\n          return lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), function (lastRect, newRect) {\r\n            var lastDist = Math.abs(x - lastRect.left);\r\n            var newDist = Math.abs(x - newRect.left);\r\n            return newDist <= lastDist ? newPos : lastPos;\r\n          }).or(acc);\r\n        });\r\n      }, Optional.none());\r\n    };\r\n    var findClosestHorizontalPosition = function (positions, pos) {\r\n      return head(pos.getClientRects()).bind(function (targetRect) {\r\n        return findClosestHorizontalPositionFromPoint(positions, targetRect.left);\r\n      });\r\n    };\r\n    var getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\r\n    var getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\r\n    var getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\r\n    var getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\r\n    var isAtFirstLine = function (scope, pos) {\r\n      return getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\r\n    };\r\n    var isAtLastLine = function (scope, pos) {\r\n      return getPositionsUntilNextLine(scope, pos).breakAt.isNone();\r\n    };\r\n    var getFirstLinePositions = function (scope) {\r\n      return firstPositionIn(scope).map(function (pos) {\r\n        return [pos].concat(getPositionsUntilNextLine(scope, pos).positions);\r\n      }).getOr([]);\r\n    };\r\n    var getLastLinePositions = function (scope) {\r\n      return lastPositionIn(scope).map(function (pos) {\r\n        return getPositionsUntilPreviousLine(scope, pos).positions.concat(pos);\r\n      }).getOr([]);\r\n    };\r\n\r\n    var getNodeClientRects = function (node) {\r\n      var toArrayWithNode = function (clientRects) {\r\n        return map$3(clientRects, function (rect) {\r\n          var clientRect = clone(rect);\r\n          clientRect.node = node;\r\n          return clientRect;\r\n        });\r\n      };\r\n      if (isElement$5(node)) {\r\n        return toArrayWithNode(node.getClientRects());\r\n      }\r\n      if (isText$7(node)) {\r\n        var rng = node.ownerDocument.createRange();\r\n        rng.setStart(node, 0);\r\n        rng.setEnd(node, node.data.length);\r\n        return toArrayWithNode(rng.getClientRects());\r\n      }\r\n    };\r\n    var getClientRects = function (nodes) {\r\n      return bind(nodes, getNodeClientRects);\r\n    };\r\n\r\n    var VDirection;\r\n    (function (VDirection) {\r\n      VDirection[VDirection['Up'] = -1] = 'Up';\r\n      VDirection[VDirection['Down'] = 1] = 'Down';\r\n    }(VDirection || (VDirection = {})));\r\n    var findUntil = function (direction, root, predicateFn, node) {\r\n      while (node = findNode$1(node, direction, isEditableCaretCandidate$1, root)) {\r\n        if (predicateFn(node)) {\r\n          return;\r\n        }\r\n      }\r\n    };\r\n    var walkUntil$1 = function (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) {\r\n      var line = 0;\r\n      var result = [];\r\n      var add = function (node) {\r\n        var clientRects = getClientRects([node]);\r\n        if (direction === -1) {\r\n          clientRects = clientRects.reverse();\r\n        }\r\n        for (var i = 0; i < clientRects.length; i++) {\r\n          var clientRect = clientRects[i];\r\n          if (isBeflowFn(clientRect, targetClientRect)) {\r\n            continue;\r\n          }\r\n          if (result.length > 0 && isAboveFn(clientRect, last$1(result))) {\r\n            line++;\r\n          }\r\n          clientRect.line = line;\r\n          if (predicateFn(clientRect)) {\r\n            return true;\r\n          }\r\n          result.push(clientRect);\r\n        }\r\n      };\r\n      var targetClientRect = last$1(caretPosition.getClientRects());\r\n      if (!targetClientRect) {\r\n        return result;\r\n      }\r\n      var node = caretPosition.getNode();\r\n      add(node);\r\n      findUntil(direction, root, add, node);\r\n      return result;\r\n    };\r\n    var aboveLineNumber = function (lineNumber, clientRect) {\r\n      return clientRect.line > lineNumber;\r\n    };\r\n    var isLineNumber = function (lineNumber, clientRect) {\r\n      return clientRect.line === lineNumber;\r\n    };\r\n    var upUntil = curry(walkUntil$1, VDirection.Up, isAbove$1, isBelow$1);\r\n    var downUntil = curry(walkUntil$1, VDirection.Down, isBelow$1, isAbove$1);\r\n    var positionsUntil = function (direction, root, predicateFn, node) {\r\n      var caretWalker = CaretWalker(root);\r\n      var walkFn;\r\n      var isBelowFn;\r\n      var isAboveFn;\r\n      var caretPosition;\r\n      var result = [];\r\n      var line = 0;\r\n      var getClientRect = function (caretPosition) {\r\n        if (direction === 1) {\r\n          return last$1(caretPosition.getClientRects());\r\n        }\r\n        return last$1(caretPosition.getClientRects());\r\n      };\r\n      if (direction === 1) {\r\n        walkFn = caretWalker.next;\r\n        isBelowFn = isBelow$1;\r\n        isAboveFn = isAbove$1;\r\n        caretPosition = CaretPosition.after(node);\r\n      } else {\r\n        walkFn = caretWalker.prev;\r\n        isBelowFn = isAbove$1;\r\n        isAboveFn = isBelow$1;\r\n        caretPosition = CaretPosition.before(node);\r\n      }\r\n      var targetClientRect = getClientRect(caretPosition);\r\n      do {\r\n        if (!caretPosition.isVisible()) {\r\n          continue;\r\n        }\r\n        var rect = getClientRect(caretPosition);\r\n        if (isAboveFn(rect, targetClientRect)) {\r\n          continue;\r\n        }\r\n        if (result.length > 0 && isBelowFn(rect, last$1(result))) {\r\n          line++;\r\n        }\r\n        var clientRect = clone(rect);\r\n        clientRect.position = caretPosition;\r\n        clientRect.line = line;\r\n        if (predicateFn(clientRect)) {\r\n          return result;\r\n        }\r\n        result.push(clientRect);\r\n      } while (caretPosition = walkFn(caretPosition));\r\n      return result;\r\n    };\r\n    var isAboveLine = function (lineNumber) {\r\n      return function (clientRect) {\r\n        return aboveLineNumber(lineNumber, clientRect);\r\n      };\r\n    };\r\n    var isLine = function (lineNumber) {\r\n      return function (clientRect) {\r\n        return isLineNumber(lineNumber, clientRect);\r\n      };\r\n    };\r\n\r\n    var isContentEditableFalse$3 = isContentEditableFalse$b;\r\n    var findNode = findNode$1;\r\n    var distanceToRectLeft = function (clientRect, clientX) {\r\n      return Math.abs(clientRect.left - clientX);\r\n    };\r\n    var distanceToRectRight = function (clientRect, clientX) {\r\n      return Math.abs(clientRect.right - clientX);\r\n    };\r\n    var isInsideX = function (clientX, clientRect) {\r\n      return clientX >= clientRect.left && clientX <= clientRect.right;\r\n    };\r\n    var isInsideY = function (clientY, clientRect) {\r\n      return clientY >= clientRect.top && clientY <= clientRect.bottom;\r\n    };\r\n    var isNodeClientRect = function (rect) {\r\n      return hasNonNullableKey(rect, 'node');\r\n    };\r\n    var findClosestClientRect = function (clientRects, clientX, allowInside) {\r\n      if (allowInside === void 0) {\r\n        allowInside = always;\r\n      }\r\n      return reduce(clientRects, function (oldClientRect, clientRect) {\r\n        if (isInsideX(clientX, clientRect)) {\r\n          return allowInside(clientRect) ? clientRect : oldClientRect;\r\n        }\r\n        if (isInsideX(clientX, oldClientRect)) {\r\n          return allowInside(oldClientRect) ? oldClientRect : clientRect;\r\n        }\r\n        var oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));\r\n        var newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));\r\n        if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$3(clientRect.node)) {\r\n          return clientRect;\r\n        }\r\n        if (newDistance < oldDistance) {\r\n          return clientRect;\r\n        }\r\n        return oldClientRect;\r\n      });\r\n    };\r\n    var walkUntil = function (direction, root, predicateFn, startNode, includeChildren) {\r\n      var node = findNode(startNode, direction, isEditableCaretCandidate$1, root, !includeChildren);\r\n      do {\r\n        if (!node || predicateFn(node)) {\r\n          return;\r\n        }\r\n      } while (node = findNode(node, direction, isEditableCaretCandidate$1, root));\r\n    };\r\n    var findLineNodeRects = function (root, targetNodeRect, includeChildren) {\r\n      if (includeChildren === void 0) {\r\n        includeChildren = true;\r\n      }\r\n      var clientRects = [];\r\n      var collect = function (checkPosFn, node) {\r\n        var lineRects = filter$4(getClientRects([node]), function (clientRect) {\r\n          return !checkPosFn(clientRect, targetNodeRect);\r\n        });\r\n        clientRects = clientRects.concat(lineRects);\r\n        return lineRects.length === 0;\r\n      };\r\n      clientRects.push(targetNodeRect);\r\n      walkUntil(VDirection.Up, root, curry(collect, isAbove$1), targetNodeRect.node, includeChildren);\r\n      walkUntil(VDirection.Down, root, curry(collect, isBelow$1), targetNodeRect.node, includeChildren);\r\n      return clientRects;\r\n    };\r\n    var getFakeCaretTargets = function (root) {\r\n      return filter$4(from(root.getElementsByTagName('*')), isFakeCaretTarget);\r\n    };\r\n    var caretInfo = function (clientRect, clientX) {\r\n      return {\r\n        node: clientRect.node,\r\n        before: distanceToRectLeft(clientRect, clientX) < distanceToRectRight(clientRect, clientX)\r\n      };\r\n    };\r\n    var closestFakeCaret = function (root, clientX, clientY) {\r\n      var fakeTargetNodeRects = getClientRects(getFakeCaretTargets(root));\r\n      var targetNodeRects = filter$4(fakeTargetNodeRects, curry(isInsideY, clientY));\r\n      var checkInside = function (clientRect) {\r\n        return !isTable$3(clientRect.node) && !isMedia$2(clientRect.node);\r\n      };\r\n      var closestNodeRect = findClosestClientRect(targetNodeRects, clientX, checkInside);\r\n      if (closestNodeRect) {\r\n        var includeChildren = checkInside(closestNodeRect);\r\n        closestNodeRect = findClosestClientRect(findLineNodeRects(root, closestNodeRect, includeChildren), clientX, checkInside);\r\n        if (closestNodeRect && isFakeCaretTarget(closestNodeRect.node)) {\r\n          return caretInfo(closestNodeRect, clientX);\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n\r\n    var moveToRange = function (editor, rng) {\r\n      editor.selection.setRng(rng);\r\n      scrollRangeIntoView(editor, editor.selection.getRng());\r\n    };\r\n    var renderRangeCaretOpt = function (editor, range, scrollIntoView) {\r\n      return Optional.some(renderRangeCaret(editor, range, scrollIntoView));\r\n    };\r\n    var moveHorizontally = function (editor, direction, range, isBefore, isAfter, isElement) {\r\n      var forwards = direction === HDirection.Forwards;\r\n      var caretWalker = CaretWalker(editor.getBody());\r\n      var getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\r\n      var isBeforeFn = forwards ? isBefore : isAfter;\r\n      if (!range.collapsed) {\r\n        var node = getSelectedNode(range);\r\n        if (isElement(node)) {\r\n          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\r\n        }\r\n      }\r\n      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\r\n      if (isBeforeFn(caretPosition)) {\r\n        return selectNode(editor, caretPosition.getNode(!forwards));\r\n      }\r\n      var nextCaretPosition = normalizePosition(forwards, getNextPosFn(caretPosition));\r\n      var rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\r\n      if (!nextCaretPosition) {\r\n        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\r\n      }\r\n      if (isBeforeFn(nextCaretPosition)) {\r\n        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\r\n      }\r\n      var peekCaretPosition = getNextPosFn(nextCaretPosition);\r\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\r\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\r\n          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\r\n        }\r\n      }\r\n      if (rangeIsInContainerBlock) {\r\n        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var moveVertically = function (editor, direction, range, isBefore, isAfter, isElement) {\r\n      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\r\n      var caretClientRect = last$1(caretPosition.getClientRects());\r\n      var forwards = direction === VDirection.Down;\r\n      if (!caretClientRect) {\r\n        return Optional.none();\r\n      }\r\n      var walkerFn = forwards ? downUntil : upUntil;\r\n      var linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);\r\n      var nextLinePositions = filter$4(linePositions, isLine(1));\r\n      var clientX = caretClientRect.left;\r\n      var nextLineRect = findClosestClientRect(nextLinePositions, clientX);\r\n      if (nextLineRect && isElement(nextLineRect.node)) {\r\n        var dist1 = Math.abs(clientX - nextLineRect.left);\r\n        var dist2 = Math.abs(clientX - nextLineRect.right);\r\n        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\r\n      }\r\n      var currentNode;\r\n      if (isBefore(caretPosition)) {\r\n        currentNode = caretPosition.getNode();\r\n      } else if (isAfter(caretPosition)) {\r\n        currentNode = caretPosition.getNode(true);\r\n      } else {\r\n        currentNode = getSelectedNode(range);\r\n      }\r\n      if (currentNode) {\r\n        var caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), currentNode);\r\n        var closestNextLineRect = findClosestClientRect(filter$4(caretPositions, isLine(1)), clientX);\r\n        if (closestNextLineRect) {\r\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\r\n        }\r\n        closestNextLineRect = last$1(filter$4(caretPositions, isLine(0)));\r\n        if (closestNextLineRect) {\r\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\r\n        }\r\n      }\r\n      if (nextLinePositions.length === 0) {\r\n        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(function (pos) {\r\n          return renderRangeCaret(editor, pos.toRange(), false);\r\n        });\r\n      }\r\n      return Optional.none();\r\n    };\r\n    var getLineEndPoint = function (editor, forward) {\r\n      var rng = editor.selection.getRng();\r\n      var body = editor.getBody();\r\n      if (forward) {\r\n        var from = CaretPosition.fromRangeEnd(rng);\r\n        var result = getPositionsUntilNextLine(body, from);\r\n        return last$2(result.positions);\r\n      } else {\r\n        var from = CaretPosition.fromRangeStart(rng);\r\n        var result = getPositionsUntilPreviousLine(body, from);\r\n        return head(result.positions);\r\n      }\r\n    };\r\n    var moveToLineEndPoint$3 = function (editor, forward, isElementPosition) {\r\n      return getLineEndPoint(editor, forward).filter(isElementPosition).exists(function (pos) {\r\n        editor.selection.setRng(pos.toRange());\r\n        return true;\r\n      });\r\n    };\r\n\r\n    var setCaretPosition = function (editor, pos) {\r\n      var rng = editor.dom.createRng();\r\n      rng.setStart(pos.container(), pos.offset());\r\n      rng.setEnd(pos.container(), pos.offset());\r\n      editor.selection.setRng(rng);\r\n    };\r\n    var setSelected = function (state, elm) {\r\n      if (state) {\r\n        elm.setAttribute('data-mce-selected', 'inline-boundary');\r\n      } else {\r\n        elm.removeAttribute('data-mce-selected');\r\n      }\r\n    };\r\n    var renderCaretLocation = function (editor, caret, location) {\r\n      return renderCaret(caret, location).map(function (pos) {\r\n        setCaretPosition(editor, pos);\r\n        return location;\r\n      });\r\n    };\r\n    var findLocation = function (editor, caret, forward) {\r\n      var rootNode = editor.getBody();\r\n      var from = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      var isInlineTarget$1 = curry(isInlineTarget, editor);\r\n      var location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\r\n      return location.bind(function (location) {\r\n        return renderCaretLocation(editor, caret, location);\r\n      });\r\n    };\r\n    var toggleInlines = function (isInlineTarget, dom, elms) {\r\n      var inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), function (e) {\r\n        return e.dom;\r\n      });\r\n      var selectedInlines = filter$4(inlineBoundaries, isInlineTarget);\r\n      var targetInlines = filter$4(elms, isInlineTarget);\r\n      each$k(difference(selectedInlines, targetInlines), curry(setSelected, false));\r\n      each$k(difference(targetInlines, selectedInlines), curry(setSelected, true));\r\n    };\r\n    var safeRemoveCaretContainer = function (editor, caret) {\r\n      if (editor.selection.isCollapsed() && editor.composing !== true && caret.get()) {\r\n        var pos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n        if (CaretPosition.isTextPosition(pos) && isAtZwsp(pos) === false) {\r\n          setCaretPosition(editor, removeAndReposition(caret.get(), pos));\r\n          caret.set(null);\r\n        }\r\n      }\r\n    };\r\n    var renderInsideInlineCaret = function (isInlineTarget, editor, caret, elms) {\r\n      if (editor.selection.isCollapsed()) {\r\n        var inlines = filter$4(elms, isInlineTarget);\r\n        each$k(inlines, function (_inline) {\r\n          var pos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n          readLocation(isInlineTarget, editor.getBody(), pos).bind(function (location) {\r\n            return renderCaretLocation(editor, caret, location);\r\n          });\r\n        });\r\n      }\r\n    };\r\n    var move$2 = function (editor, caret, forward) {\r\n      return isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\r\n    };\r\n    var moveWord = function (forward, editor, _caret) {\r\n      return isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\r\n    };\r\n    var setupSelectedState = function (editor) {\r\n      var caret = Cell(null);\r\n      var isInlineTarget$1 = curry(isInlineTarget, editor);\r\n      editor.on('NodeChange', function (e) {\r\n        if (isInlineBoundariesEnabled(editor) && !(Env.browser.isIE() && e.initial)) {\r\n          toggleInlines(isInlineTarget$1, editor.dom, e.parents);\r\n          safeRemoveCaretContainer(editor, caret);\r\n          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\r\n        }\r\n      });\r\n      return caret;\r\n    };\r\n    var moveNextWord = curry(moveWord, true);\r\n    var movePrevWord = curry(moveWord, false);\r\n    var moveToLineEndPoint$2 = function (editor, forward, caret) {\r\n      if (isInlineBoundariesEnabled(editor)) {\r\n        var linePoint = getLineEndPoint(editor, forward).getOrThunk(function () {\r\n          var rng = editor.selection.getRng();\r\n          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\r\n        });\r\n        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(function (loc) {\r\n          var outsideLoc = outside(loc);\r\n          return renderCaret(caret, outsideLoc).exists(function (pos) {\r\n            setCaretPosition(editor, pos);\r\n            return true;\r\n          });\r\n        });\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    var rangeFromPositions = function (from, to) {\r\n      var range = document.createRange();\r\n      range.setStart(from.container(), from.offset());\r\n      range.setEnd(to.container(), to.offset());\r\n      return range;\r\n    };\r\n    var hasOnlyTwoOrLessPositionsLeft = function (elm) {\r\n      return lift2(firstPositionIn(elm), lastPositionIn(elm), function (firstPos, lastPos) {\r\n        var normalizedFirstPos = normalizePosition(true, firstPos);\r\n        var normalizedLastPos = normalizePosition(false, lastPos);\r\n        return nextPosition(elm, normalizedFirstPos).forall(function (pos) {\r\n          return pos.isEqual(normalizedLastPos);\r\n        });\r\n      }).getOr(true);\r\n    };\r\n    var setCaretLocation = function (editor, caret) {\r\n      return function (location) {\r\n        return renderCaret(caret, location).exists(function (pos) {\r\n          setCaretPosition(editor, pos);\r\n          return true;\r\n        });\r\n      };\r\n    };\r\n    var deleteFromTo = function (editor, caret, from, to) {\r\n      var rootNode = editor.getBody();\r\n      var isInlineTarget$1 = curry(isInlineTarget, editor);\r\n      editor.undoManager.ignore(function () {\r\n        editor.selection.setRng(rangeFromPositions(from, to));\r\n        editor.execCommand('Delete');\r\n        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).map(setCaretLocation(editor, caret));\r\n      });\r\n      editor.nodeChanged();\r\n    };\r\n    var rescope = function (rootNode, node) {\r\n      var parentBlock = getParentBlock$2(node, rootNode);\r\n      return parentBlock ? parentBlock : rootNode;\r\n    };\r\n    var backspaceDeleteCollapsed = function (editor, caret, forward, from) {\r\n      var rootNode = rescope(editor.getBody(), from.container());\r\n      var isInlineTarget$1 = curry(isInlineTarget, editor);\r\n      var fromLocation = readLocation(isInlineTarget$1, rootNode, from);\r\n      return fromLocation.bind(function (location) {\r\n        if (forward) {\r\n          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\r\n        } else {\r\n          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\r\n        }\r\n      }).map(setCaretLocation(editor, caret)).getOrThunk(function () {\r\n        var toPosition = navigate(forward, rootNode, from);\r\n        var toLocation = toPosition.bind(function (pos) {\r\n          return readLocation(isInlineTarget$1, rootNode, pos);\r\n        });\r\n        return lift2(fromLocation, toLocation, function () {\r\n          return findRootInline(isInlineTarget$1, rootNode, from).exists(function (elm) {\r\n            if (hasOnlyTwoOrLessPositionsLeft(elm)) {\r\n              deleteElement$2(editor, forward, SugarElement.fromDom(elm));\r\n              return true;\r\n            } else {\r\n              return false;\r\n            }\r\n          });\r\n        }).orThunk(function () {\r\n          return toLocation.bind(function (_) {\r\n            return toPosition.map(function (to) {\r\n              if (forward) {\r\n                deleteFromTo(editor, caret, from, to);\r\n              } else {\r\n                deleteFromTo(editor, caret, to, from);\r\n              }\r\n              return true;\r\n            });\r\n          });\r\n        }).getOr(false);\r\n      });\r\n    };\r\n    var backspaceDelete$3 = function (editor, caret, forward) {\r\n      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\r\n        var from = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n        return backspaceDeleteCollapsed(editor, caret, forward, from);\r\n      }\r\n      return false;\r\n    };\r\n\r\n    var getParentInlines = function (rootElm, startElm) {\r\n      var parents = parentsAndSelf(startElm, rootElm);\r\n      return findIndex$2(parents, isBlock$2).fold(constant(parents), function (index) {\r\n        return parents.slice(0, index);\r\n      });\r\n    };\r\n    var hasOnlyOneChild = function (elm) {\r\n      return childNodesCount(elm) === 1;\r\n    };\r\n    var deleteLastPosition = function (forward, editor, target, parentInlines) {\r\n      var isFormatElement$1 = curry(isFormatElement, editor);\r\n      var formatNodes = map$3(filter$4(parentInlines, isFormatElement$1), function (elm) {\r\n        return elm.dom;\r\n      });\r\n      if (formatNodes.length === 0) {\r\n        deleteElement$2(editor, forward, target);\r\n      } else {\r\n        var pos = replaceWithCaretFormat(target.dom, formatNodes);\r\n        editor.selection.setRng(pos.toRange());\r\n      }\r\n    };\r\n    var deleteCaret$1 = function (editor, forward) {\r\n      var rootElm = SugarElement.fromDom(editor.getBody());\r\n      var startElm = SugarElement.fromDom(editor.selection.getStart());\r\n      var parentInlines = filter$4(getParentInlines(rootElm, startElm), hasOnlyOneChild);\r\n      return last$2(parentInlines).exists(function (target) {\r\n        var fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\r\n          deleteLastPosition(forward, editor, target, parentInlines);\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      });\r\n    };\r\n    var backspaceDelete$2 = function (editor, forward) {\r\n      return editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : false;\r\n    };\r\n\r\n    var deleteElement = function (editor, forward, element) {\r\n      editor._selectionOverrides.hideFakeCaret();\r\n      deleteElement$2(editor, forward, SugarElement.fromDom(element));\r\n      return true;\r\n    };\r\n    var deleteCaret = function (editor, forward) {\r\n      var isNearMedia = forward ? isBeforeMedia : isAfterMedia;\r\n      var direction = forward ? HDirection.Forwards : HDirection.Backwards;\r\n      var fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\r\n      if (isNearMedia(fromPos)) {\r\n        return deleteElement(editor, forward, fromPos.getNode(!forward));\r\n      } else {\r\n        return Optional.from(normalizePosition(forward, fromPos)).filter(function (pos) {\r\n          return isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos);\r\n        }).exists(function (pos) {\r\n          return deleteElement(editor, forward, pos.getNode(!forward));\r\n        });\r\n      }\r\n    };\r\n    var deleteRange = function (editor, forward) {\r\n      var selectedNode = editor.selection.getNode();\r\n      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : false;\r\n    };\r\n    var backspaceDelete$1 = function (editor, forward) {\r\n      return editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\r\n    };\r\n\r\n    var isEditable = function (target) {\r\n      return closest$3(target, function (elm) {\r\n        return isContentEditableTrue$4(elm.dom) || isContentEditableFalse$b(elm.dom);\r\n      }).exists(function (elm) {\r\n        return isContentEditableTrue$4(elm.dom);\r\n      });\r\n    };\r\n    var parseIndentValue = function (value) {\r\n      var number = parseInt(value, 10);\r\n      return isNaN(number) ? 0 : number;\r\n    };\r\n    var getIndentStyleName = function (useMargin, element) {\r\n      var indentStyleName = useMargin || isTable$2(element) ? 'margin' : 'padding';\r\n      var suffix = get$5(element, 'direction') === 'rtl' ? '-right' : '-left';\r\n      return indentStyleName + suffix;\r\n    };\r\n    var indentElement = function (dom, command, useMargin, value, unit, element) {\r\n      var indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\r\n      if (command === 'outdent') {\r\n        var styleValue = Math.max(0, parseIndentValue(element.style[indentStyleName]) - value);\r\n        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\r\n      } else {\r\n        var styleValue = parseIndentValue(element.style[indentStyleName]) + value + unit;\r\n        dom.setStyle(element, indentStyleName, styleValue);\r\n      }\r\n    };\r\n    var validateBlocks = function (editor, blocks) {\r\n      return forall(blocks, function (block) {\r\n        var indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\r\n        var intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);\r\n        var contentEditable = editor.dom.getContentEditable(block.dom);\r\n        return contentEditable !== 'false' && intentValue > 0;\r\n      });\r\n    };\r\n    var canOutdent = function (editor) {\r\n      var blocks = getBlocksToIndent(editor);\r\n      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\r\n    };\r\n    var isListComponent = function (el) {\r\n      return isList(el) || isListItem(el);\r\n    };\r\n    var parentIsListComponent = function (el) {\r\n      return parent(el).exists(isListComponent);\r\n    };\r\n    var getBlocksToIndent = function (editor) {\r\n      return filter$4(fromDom$1(editor.selection.getSelectedBlocks()), function (el) {\r\n        return !isListComponent(el) && !parentIsListComponent(el) && isEditable(el);\r\n      });\r\n    };\r\n    var handle = function (editor, command) {\r\n      var dom = editor.dom, selection = editor.selection, formatter = editor.formatter;\r\n      var indentation = getIndentation(editor);\r\n      var indentUnit = /[a-z%]+$/i.exec(indentation)[0];\r\n      var indentValue = parseInt(indentation, 10);\r\n      var useMargin = shouldIndentUseMargin(editor);\r\n      var forcedRootBlock = getForcedRootBlock(editor);\r\n      if (!editor.queryCommandState('InsertUnorderedList') && !editor.queryCommandState('InsertOrderedList')) {\r\n        if (forcedRootBlock === '' && !dom.getParent(selection.getNode(), dom.isBlock)) {\r\n          formatter.apply('div');\r\n        }\r\n      }\r\n      each$k(getBlocksToIndent(editor), function (block) {\r\n        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\r\n      });\r\n    };\r\n\r\n    var backspaceDelete = function (editor, _forward) {\r\n      if (editor.selection.isCollapsed() && canOutdent(editor)) {\r\n        var dom = editor.dom;\r\n        var rng = editor.selection.getRng();\r\n        var pos = CaretPosition.fromRangeStart(rng);\r\n        var block = dom.getParent(rng.startContainer, dom.isBlock);\r\n        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {\r\n          handle(editor, 'outdent');\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n\r\n    var nativeCommand = function (editor, command) {\r\n      editor.getDoc().execCommand(command, false, null);\r\n    };\r\n    var deleteCommand = function (editor, caret) {\r\n      if (backspaceDelete(editor)) {\r\n        return;\r\n      } else if (backspaceDelete$5(editor, false)) {\r\n        return;\r\n      } else if (backspaceDelete$6(editor, false)) {\r\n        return;\r\n      } else if (backspaceDelete$3(editor, caret, false)) {\r\n        return;\r\n      } else if (backspaceDelete$8(editor, false)) {\r\n        return;\r\n      } else if (backspaceDelete$9(editor)) {\r\n        return;\r\n      } else if (backspaceDelete$4(editor, false)) {\r\n        return;\r\n      } else if (backspaceDelete$1(editor, false)) {\r\n        return;\r\n      } else if (backspaceDelete$7(editor)) {\r\n        return;\r\n      } else if (backspaceDelete$2(editor, false)) {\r\n        return;\r\n      } else {\r\n        nativeCommand(editor, 'Delete');\r\n        paddEmptyBody(editor);\r\n      }\r\n    };\r\n    var forwardDeleteCommand = function (editor, caret) {\r\n      if (backspaceDelete$5(editor, true)) {\r\n        return;\r\n      } else if (backspaceDelete$6(editor, true)) {\r\n        return;\r\n      } else if (backspaceDelete$3(editor, caret, true)) {\r\n        return;\r\n      } else if (backspaceDelete$8(editor, true)) {\r\n        return;\r\n      } else if (backspaceDelete$9(editor)) {\r\n        return;\r\n      } else if (backspaceDelete$4(editor, true)) {\r\n        return;\r\n      } else if (backspaceDelete$1(editor, true)) {\r\n        return;\r\n      } else if (backspaceDelete$7(editor)) {\r\n        return;\r\n      } else if (backspaceDelete$2(editor, true)) {\r\n        return;\r\n      } else {\r\n        nativeCommand(editor, 'ForwardDelete');\r\n      }\r\n    };\r\n    var setup$f = function (editor, caret) {\r\n      editor.addCommand('delete', function () {\r\n        deleteCommand(editor, caret);\r\n      });\r\n      editor.addCommand('forwardDelete', function () {\r\n        forwardDeleteCommand(editor, caret);\r\n      });\r\n    };\r\n\r\n    var SIGNIFICANT_MOVE = 5;\r\n    var LONGPRESS_DELAY = 400;\r\n    var getTouch = function (event) {\r\n      if (event.touches === undefined || event.touches.length !== 1) {\r\n        return Optional.none();\r\n      }\r\n      return Optional.some(event.touches[0]);\r\n    };\r\n    var isFarEnough = function (touch, data) {\r\n      var distX = Math.abs(touch.clientX - data.x);\r\n      var distY = Math.abs(touch.clientY - data.y);\r\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\r\n    };\r\n    var setup$e = function (editor) {\r\n      var startData = value();\r\n      var longpressFired = Cell(false);\r\n      var debounceLongpress = last(function (e) {\r\n        editor.fire('longpress', __assign(__assign({}, e), { type: 'longpress' }));\r\n        longpressFired.set(true);\r\n      }, LONGPRESS_DELAY);\r\n      editor.on('touchstart', function (e) {\r\n        getTouch(e).each(function (touch) {\r\n          debounceLongpress.cancel();\r\n          var data = {\r\n            x: touch.clientX,\r\n            y: touch.clientY,\r\n            target: e.target\r\n          };\r\n          debounceLongpress.throttle(e);\r\n          longpressFired.set(false);\r\n          startData.set(data);\r\n        });\r\n      }, true);\r\n      editor.on('touchmove', function (e) {\r\n        debounceLongpress.cancel();\r\n        getTouch(e).each(function (touch) {\r\n          startData.on(function (data) {\r\n            if (isFarEnough(touch, data)) {\r\n              startData.clear();\r\n              longpressFired.set(false);\r\n              editor.fire('longpresscancel');\r\n            }\r\n          });\r\n        });\r\n      }, true);\r\n      editor.on('touchend touchcancel', function (e) {\r\n        debounceLongpress.cancel();\r\n        if (e.type === 'touchcancel') {\r\n          return;\r\n        }\r\n        startData.get().filter(function (data) {\r\n          return data.target.isEqualNode(e.target);\r\n        }).each(function () {\r\n          if (longpressFired.get()) {\r\n            e.preventDefault();\r\n          } else {\r\n            editor.fire('tap', __assign(__assign({}, e), { type: 'tap' }));\r\n          }\r\n        });\r\n      }, true);\r\n    };\r\n\r\n    var isBlockElement = function (blockElements, node) {\r\n      return has$2(blockElements, node.nodeName);\r\n    };\r\n    var isValidTarget = function (blockElements, node) {\r\n      if (isText$7(node)) {\r\n        return true;\r\n      } else if (isElement$5(node)) {\r\n        return !isBlockElement(blockElements, node) && !isBookmarkNode$1(node);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var hasBlockParent = function (blockElements, root, node) {\r\n      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), function (elm) {\r\n        return isBlockElement(blockElements, elm.dom);\r\n      });\r\n    };\r\n    var shouldRemoveTextNode = function (blockElements, node) {\r\n      if (isText$7(node)) {\r\n        if (node.nodeValue.length === 0) {\r\n          return true;\r\n        } else if (/^\\s+$/.test(node.nodeValue) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    var addRootBlocks = function (editor) {\r\n      var dom = editor.dom, selection = editor.selection;\r\n      var schema = editor.schema, blockElements = schema.getBlockElements();\r\n      var node = selection.getStart();\r\n      var rootNode = editor.getBody();\r\n      var rootBlockNode, tempNode, wrapped;\r\n      var forcedRootBlock = getForcedRootBlock(editor);\r\n      if (!node || !isElement$5(node) || !forcedRootBlock) {\r\n        return;\r\n      }\r\n      var rootNodeName = rootNode.nodeName.toLowerCase();\r\n      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, node)) {\r\n        return;\r\n      }\r\n      var rng = selection.getRng();\r\n      var startContainer = rng.startContainer;\r\n      var startOffset = rng.startOffset;\r\n      var endContainer = rng.endContainer;\r\n      var endOffset = rng.endOffset;\r\n      var restoreSelection = hasFocus(editor);\r\n      node = rootNode.firstChild;\r\n      while (node) {\r\n        if (isValidTarget(blockElements, node)) {\r\n          if (shouldRemoveTextNode(blockElements, node)) {\r\n            tempNode = node;\r\n            node = node.nextSibling;\r\n            dom.remove(tempNode);\r\n            continue;\r\n          }\r\n          if (!rootBlockNode) {\r\n            rootBlockNode = dom.create(forcedRootBlock, getForcedRootBlockAttrs(editor));\r\n            node.parentNode.insertBefore(rootBlockNode, node);\r\n            wrapped = true;\r\n          }\r\n          tempNode = node;\r\n          node = node.nextSibling;\r\n          rootBlockNode.appendChild(tempNode);\r\n        } else {\r\n          rootBlockNode = null;\r\n          node = node.nextSibling;\r\n        }\r\n      }\r\n      if (wrapped && restoreSelection) {\r\n        rng.setStart(startContainer, startOffset);\r\n        rng.setEnd(endContainer, endOffset);\r\n        selection.setRng(rng);\r\n        editor.nodeChanged();\r\n      }\r\n    };\r\n    var setup$d = function (editor) {\r\n      if (getForcedRootBlock(editor)) {\r\n        editor.on('NodeChange', curry(addRootBlocks, editor));\r\n      }\r\n    };\r\n\r\n    var findBlockCaretContainer = function (editor) {\r\n      return descendant(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(function (elm) {\r\n        return elm.dom;\r\n      }).getOrNull();\r\n    };\r\n    var removeIeControlRect = function (editor) {\r\n      editor.selection.setRng(editor.selection.getRng());\r\n    };\r\n    var showBlockCaretContainer = function (editor, blockCaretContainer) {\r\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\r\n        showCaretContainerBlock(blockCaretContainer);\r\n        removeIeControlRect(editor);\r\n        editor.selection.scrollIntoView(blockCaretContainer);\r\n      }\r\n    };\r\n    var handleBlockContainer = function (editor, e) {\r\n      var blockCaretContainer = findBlockCaretContainer(editor);\r\n      if (!blockCaretContainer) {\r\n        return;\r\n      }\r\n      if (e.type === 'compositionstart') {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        showBlockCaretContainer(editor, blockCaretContainer);\r\n        return;\r\n      }\r\n      if (hasContent(blockCaretContainer)) {\r\n        showBlockCaretContainer(editor, blockCaretContainer);\r\n        editor.undoManager.add();\r\n      }\r\n    };\r\n    var setup$c = function (editor) {\r\n      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\r\n    };\r\n\r\n    var isContentEditableFalse$2 = isContentEditableFalse$b;\r\n    var moveToCeFalseHorizontally = function (direction, editor, range) {\r\n      return moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$2);\r\n    };\r\n    var moveToCeFalseVertically = function (direction, editor, range) {\r\n      var isBefore = function (caretPosition) {\r\n        return isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\r\n      };\r\n      var isAfter = function (caretPosition) {\r\n        return isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\r\n      };\r\n      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$2);\r\n    };\r\n    var createTextBlock = function (editor) {\r\n      var textBlock = editor.dom.create(getForcedRootBlock(editor));\r\n      if (!Env.ie || Env.ie >= 11) {\r\n        textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\r\n      }\r\n      return textBlock;\r\n    };\r\n    var exitPreBlock = function (editor, direction, range) {\r\n      var caretWalker = CaretWalker(editor.getBody());\r\n      var getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\r\n      if (range.collapsed && hasForcedRootBlock(editor)) {\r\n        var pre = editor.dom.getParent(range.startContainer, 'PRE');\r\n        if (!pre) {\r\n          return;\r\n        }\r\n        var caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\r\n        if (!caretPos) {\r\n          var newBlock = createTextBlock(editor);\r\n          if (direction === 1) {\r\n            editor.$(pre).after(newBlock);\r\n          } else {\r\n            editor.$(pre).before(newBlock);\r\n          }\r\n          editor.selection.select(newBlock, true);\r\n          editor.selection.collapse();\r\n        }\r\n      }\r\n    };\r\n    var getHorizontalRange = function (editor, forward) {\r\n      var direction = forward ? HDirection.Forwards : HDirection.Backwards;\r\n      var range = editor.selection.getRng();\r\n      return moveToCeFalseHorizontally(direction, editor, range).orThunk(function () {\r\n        exitPreBlock(editor, direction, range);\r\n        return Optional.none();\r\n      });\r\n    };\r\n    var getVerticalRange = function (editor, down) {\r\n      var direction = down ? 1 : -1;\r\n      var range = editor.selection.getRng();\r\n      return moveToCeFalseVertically(direction, editor, range).orThunk(function () {\r\n        exitPreBlock(editor, direction, range);\r\n        return Optional.none();\r\n      });\r\n    };\r\n    var moveH$2 = function (editor, forward) {\r\n      return getHorizontalRange(editor, forward).exists(function (newRange) {\r\n        moveToRange(editor, newRange);\r\n        return true;\r\n      });\r\n    };\r\n    var moveV$3 = function (editor, down) {\r\n      return getVerticalRange(editor, down).exists(function (newRange) {\r\n        moveToRange(editor, newRange);\r\n        return true;\r\n      });\r\n    };\r\n    var moveToLineEndPoint$1 = function (editor, forward) {\r\n      var isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\r\n      return moveToLineEndPoint$3(editor, forward, isCefPosition);\r\n    };\r\n\r\n    var isTarget = function (node) {\r\n      return contains$3(['figcaption'], name(node));\r\n    };\r\n    var rangeBefore = function (target) {\r\n      var rng = document.createRange();\r\n      rng.setStartBefore(target.dom);\r\n      rng.setEndBefore(target.dom);\r\n      return rng;\r\n    };\r\n    var insertElement = function (root, elm, forward) {\r\n      if (forward) {\r\n        append$1(root, elm);\r\n      } else {\r\n        prepend(root, elm);\r\n      }\r\n    };\r\n    var insertBr = function (root, forward) {\r\n      var br = SugarElement.fromTag('br');\r\n      insertElement(root, br, forward);\r\n      return rangeBefore(br);\r\n    };\r\n    var insertBlock = function (root, forward, blockName, attrs) {\r\n      var block = SugarElement.fromTag(blockName);\r\n      var br = SugarElement.fromTag('br');\r\n      setAll$1(block, attrs);\r\n      append$1(block, br);\r\n      insertElement(root, block, forward);\r\n      return rangeBefore(br);\r\n    };\r\n    var insertEmptyLine = function (root, rootBlockName, attrs, forward) {\r\n      if (rootBlockName === '') {\r\n        return insertBr(root, forward);\r\n      } else {\r\n        return insertBlock(root, forward, rootBlockName, attrs);\r\n      }\r\n    };\r\n    var getClosestTargetBlock = function (pos, root) {\r\n      var isRoot = curry(eq, root);\r\n      return closest$3(SugarElement.fromDom(pos.container()), isBlock$2, isRoot).filter(isTarget);\r\n    };\r\n    var isAtFirstOrLastLine = function (root, forward, pos) {\r\n      return forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\r\n    };\r\n    var moveCaretToNewEmptyLine = function (editor, forward) {\r\n      var root = SugarElement.fromDom(editor.getBody());\r\n      var pos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      var rootBlock = getForcedRootBlock(editor);\r\n      var rootBlockAttrs = getForcedRootBlockAttrs(editor);\r\n      return getClosestTargetBlock(pos, root).exists(function () {\r\n        if (isAtFirstOrLastLine(root, forward, pos)) {\r\n          var rng = insertEmptyLine(root, rootBlock, rootBlockAttrs, forward);\r\n          editor.selection.setRng(rng);\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      });\r\n    };\r\n    var moveV$2 = function (editor, forward) {\r\n      if (editor.selection.isCollapsed()) {\r\n        return moveCaretToNewEmptyLine(editor, forward);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    var defaultPatterns = function (patterns) {\r\n      return map$3(patterns, function (pattern) {\r\n        return __assign({\r\n          shiftKey: false,\r\n          altKey: false,\r\n          ctrlKey: false,\r\n          metaKey: false,\r\n          keyCode: 0,\r\n          action: noop\r\n        }, pattern);\r\n      });\r\n    };\r\n    var matchesEvent = function (pattern, evt) {\r\n      return evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\r\n    };\r\n    var match$1 = function (patterns, evt) {\r\n      return bind(defaultPatterns(patterns), function (pattern) {\r\n        return matchesEvent(pattern, evt) ? [pattern] : [];\r\n      });\r\n    };\r\n    var action = function (f) {\r\n      var x = [];\r\n      for (var _i = 1; _i < arguments.length; _i++) {\r\n        x[_i - 1] = arguments[_i];\r\n      }\r\n      return function () {\r\n        return f.apply(null, x);\r\n      };\r\n    };\r\n    var execute = function (patterns, evt) {\r\n      return find$3(match$1(patterns, evt), function (pattern) {\r\n        return pattern.action();\r\n      });\r\n    };\r\n\r\n    var moveH$1 = function (editor, forward) {\r\n      var direction = forward ? HDirection.Forwards : HDirection.Backwards;\r\n      var range = editor.selection.getRng();\r\n      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(function (newRange) {\r\n        moveToRange(editor, newRange);\r\n        return true;\r\n      });\r\n    };\r\n    var moveV$1 = function (editor, down) {\r\n      var direction = down ? 1 : -1;\r\n      var range = editor.selection.getRng();\r\n      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(function (newRange) {\r\n        moveToRange(editor, newRange);\r\n        return true;\r\n      });\r\n    };\r\n    var moveToLineEndPoint = function (editor, forward) {\r\n      var isNearMedia = forward ? isAfterMedia : isBeforeMedia;\r\n      return moveToLineEndPoint$3(editor, forward, isNearMedia);\r\n    };\r\n\r\n    var deflate = function (rect, delta) {\r\n      return {\r\n        left: rect.left - delta,\r\n        top: rect.top - delta,\r\n        right: rect.right + delta * 2,\r\n        bottom: rect.bottom + delta * 2,\r\n        width: rect.width + delta,\r\n        height: rect.height + delta\r\n      };\r\n    };\r\n    var getCorners = function (getYAxisValue, tds) {\r\n      return bind(tds, function (td) {\r\n        var rect = deflate(clone(td.getBoundingClientRect()), -1);\r\n        return [\r\n          {\r\n            x: rect.left,\r\n            y: getYAxisValue(rect),\r\n            cell: td\r\n          },\r\n          {\r\n            x: rect.right,\r\n            y: getYAxisValue(rect),\r\n            cell: td\r\n          }\r\n        ];\r\n      });\r\n    };\r\n    var findClosestCorner = function (corners, x, y) {\r\n      return foldl(corners, function (acc, newCorner) {\r\n        return acc.fold(function () {\r\n          return Optional.some(newCorner);\r\n        }, function (oldCorner) {\r\n          var oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\r\n          var newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\r\n          return Optional.some(newDist < oldDist ? newCorner : oldCorner);\r\n        });\r\n      }, Optional.none());\r\n    };\r\n    var getClosestCell = function (getYAxisValue, isTargetCorner, table, x, y) {\r\n      var cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(function (e) {\r\n        return e.dom;\r\n      });\r\n      var corners = filter$4(getCorners(getYAxisValue, cells), function (corner) {\r\n        return isTargetCorner(corner, y);\r\n      });\r\n      return findClosestCorner(corners, x, y).map(function (corner) {\r\n        return corner.cell;\r\n      });\r\n    };\r\n    var getBottomValue = function (rect) {\r\n      return rect.bottom;\r\n    };\r\n    var getTopValue = function (rect) {\r\n      return rect.top;\r\n    };\r\n    var isAbove = function (corner, y) {\r\n      return corner.y < y;\r\n    };\r\n    var isBelow = function (corner, y) {\r\n      return corner.y > y;\r\n    };\r\n    var getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\r\n    var getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\r\n    var findClosestPositionInAboveCell = function (table, pos) {\r\n      return head(pos.getClientRects()).bind(function (rect) {\r\n        return getClosestCellAbove(table, rect.left, rect.top);\r\n      }).bind(function (cell) {\r\n        return findClosestHorizontalPosition(getLastLinePositions(cell), pos);\r\n      });\r\n    };\r\n    var findClosestPositionInBelowCell = function (table, pos) {\r\n      return last$2(pos.getClientRects()).bind(function (rect) {\r\n        return getClosestCellBelow(table, rect.left, rect.top);\r\n      }).bind(function (cell) {\r\n        return findClosestHorizontalPosition(getFirstLinePositions(cell), pos);\r\n      });\r\n    };\r\n\r\n    var hasNextBreak = function (getPositionsUntil, scope, lineInfo) {\r\n      return lineInfo.breakAt.exists(function (breakPos) {\r\n        return getPositionsUntil(scope, breakPos).breakAt.isSome();\r\n      });\r\n    };\r\n    var startsWithWrapBreak = function (lineInfo) {\r\n      return lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\r\n    };\r\n    var startsWithBrBreak = function (lineInfo) {\r\n      return lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\r\n    };\r\n    var isAtTableCellLine = function (getPositionsUntil, scope, pos) {\r\n      var lineInfo = getPositionsUntil(scope, pos);\r\n      if (startsWithWrapBreak(lineInfo) || !isBr$5(pos.getNode()) && startsWithBrBreak(lineInfo)) {\r\n        return !hasNextBreak(getPositionsUntil, scope, lineInfo);\r\n      } else {\r\n        return lineInfo.breakAt.isNone();\r\n      }\r\n    };\r\n    var isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\r\n    var isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\r\n    var isCaretAtStartOrEndOfTable = function (forward, rng, table) {\r\n      var caretPos = CaretPosition.fromRangeStart(rng);\r\n      return positionIn(!forward, table).exists(function (pos) {\r\n        return pos.isEqual(caretPos);\r\n      });\r\n    };\r\n    var navigateHorizontally = function (editor, forward, table, _td) {\r\n      var rng = editor.selection.getRng();\r\n      var direction = forward ? 1 : -1;\r\n      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\r\n        showCaret(direction, editor, table, !forward, false).each(function (newRng) {\r\n          moveToRange(editor, newRng);\r\n        });\r\n        return true;\r\n      }\r\n      return false;\r\n    };\r\n    var getClosestAbovePosition = function (root, table, start) {\r\n      return findClosestPositionInAboveCell(table, start).orThunk(function () {\r\n        return head(start.getClientRects()).bind(function (rect) {\r\n          return findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left);\r\n        });\r\n      }).getOr(CaretPosition.before(table));\r\n    };\r\n    var getClosestBelowPosition = function (root, table, start) {\r\n      return findClosestPositionInBelowCell(table, start).orThunk(function () {\r\n        return head(start.getClientRects()).bind(function (rect) {\r\n          return findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left);\r\n        });\r\n      }).getOr(CaretPosition.after(table));\r\n    };\r\n    var getTable = function (previous, pos) {\r\n      var node = pos.getNode(previous);\r\n      return isElement$5(node) && node.nodeName === 'TABLE' ? Optional.some(node) : Optional.none();\r\n    };\r\n    var renderBlock = function (down, editor, table, pos) {\r\n      var forcedRootBlock = getForcedRootBlock(editor);\r\n      if (forcedRootBlock) {\r\n        editor.undoManager.transact(function () {\r\n          var element = SugarElement.fromTag(forcedRootBlock);\r\n          setAll$1(element, getForcedRootBlockAttrs(editor));\r\n          append$1(element, SugarElement.fromTag('br'));\r\n          if (down) {\r\n            after$3(SugarElement.fromDom(table), element);\r\n          } else {\r\n            before$4(SugarElement.fromDom(table), element);\r\n          }\r\n          var rng = editor.dom.createRng();\r\n          rng.setStart(element.dom, 0);\r\n          rng.setEnd(element.dom, 0);\r\n          moveToRange(editor, rng);\r\n        });\r\n      } else {\r\n        moveToRange(editor, pos.toRange());\r\n      }\r\n    };\r\n    var moveCaret = function (editor, down, pos) {\r\n      var table = down ? getTable(true, pos) : getTable(false, pos);\r\n      var last = down === false;\r\n      table.fold(function () {\r\n        return moveToRange(editor, pos.toRange());\r\n      }, function (table) {\r\n        return positionIn(last, editor.getBody()).filter(function (lastPos) {\r\n          return lastPos.isEqual(pos);\r\n        }).fold(function () {\r\n          return moveToRange(editor, pos.toRange());\r\n        }, function (_) {\r\n          return renderBlock(down, editor, table, pos);\r\n        });\r\n      });\r\n    };\r\n    var navigateVertically = function (editor, down, table, td) {\r\n      var rng = editor.selection.getRng();\r\n      var pos = CaretPosition.fromRangeStart(rng);\r\n      var root = editor.getBody();\r\n      if (!down && isAtFirstTableCellLine(td, pos)) {\r\n        var newPos = getClosestAbovePosition(root, table, pos);\r\n        moveCaret(editor, down, newPos);\r\n        return true;\r\n      } else if (down && isAtLastTableCellLine(td, pos)) {\r\n        var newPos = getClosestBelowPosition(root, table, pos);\r\n        moveCaret(editor, down, newPos);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    var move$1 = function (editor, forward, mover) {\r\n      return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(function (td) {\r\n        return Optional.from(editor.dom.getParent(td, 'table')).map(function (table) {\r\n          return mover(editor, forward, table, td);\r\n        });\r\n      }).getOr(false);\r\n    };\r\n    var moveH = function (editor, forward) {\r\n      return move$1(editor, forward, navigateHorizontally);\r\n    };\r\n    var moveV = function (editor, forward) {\r\n      return move$1(editor, forward, navigateVertically);\r\n    };\r\n\r\n    var executeKeydownOverride$3 = function (editor, caret, evt) {\r\n      var os = detect().os;\r\n      execute([\r\n        {\r\n          keyCode: VK.RIGHT,\r\n          action: action(moveH$2, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.LEFT,\r\n          action: action(moveH$2, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.UP,\r\n          action: action(moveV$3, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DOWN,\r\n          action: action(moveV$3, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.RIGHT,\r\n          action: action(moveH, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.LEFT,\r\n          action: action(moveH, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.UP,\r\n          action: action(moveV, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DOWN,\r\n          action: action(moveV, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.RIGHT,\r\n          action: action(moveH$1, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.LEFT,\r\n          action: action(moveH$1, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.UP,\r\n          action: action(moveV$1, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DOWN,\r\n          action: action(moveV$1, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.RIGHT,\r\n          action: action(move$2, editor, caret, true)\r\n        },\r\n        {\r\n          keyCode: VK.LEFT,\r\n          action: action(move$2, editor, caret, false)\r\n        },\r\n        {\r\n          keyCode: VK.RIGHT,\r\n          ctrlKey: !os.isOSX(),\r\n          altKey: os.isOSX(),\r\n          action: action(moveNextWord, editor, caret)\r\n        },\r\n        {\r\n          keyCode: VK.LEFT,\r\n          ctrlKey: !os.isOSX(),\r\n          altKey: os.isOSX(),\r\n          action: action(movePrevWord, editor, caret)\r\n        },\r\n        {\r\n          keyCode: VK.UP,\r\n          action: action(moveV$2, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DOWN,\r\n          action: action(moveV$2, editor, true)\r\n        }\r\n      ], evt).each(function (_) {\r\n        evt.preventDefault();\r\n      });\r\n    };\r\n    var setup$b = function (editor, caret) {\r\n      editor.on('keydown', function (evt) {\r\n        if (evt.isDefaultPrevented() === false) {\r\n          executeKeydownOverride$3(editor, caret, evt);\r\n        }\r\n      });\r\n    };\r\n\r\n    var executeKeydownOverride$2 = function (editor, caret, evt) {\r\n      execute([\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$5, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$5, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$6, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$6, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$3, editor, caret, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$3, editor, caret, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$9, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$9, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$4, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$4, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$1, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$1, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$7, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$7, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$8, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$8, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$2, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$2, editor, true)\r\n        }\r\n      ], evt).each(function (_) {\r\n        evt.preventDefault();\r\n      });\r\n    };\r\n    var executeKeyupOverride = function (editor, evt) {\r\n      execute([\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(paddEmptyElement, editor)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(paddEmptyElement, editor)\r\n        }\r\n      ], evt);\r\n    };\r\n    var setup$a = function (editor, caret) {\r\n      editor.on('keydown', function (evt) {\r\n        if (evt.isDefaultPrevented() === false) {\r\n          executeKeydownOverride$2(editor, caret, evt);\r\n        }\r\n      });\r\n      editor.on('keyup', function (evt) {\r\n        if (evt.isDefaultPrevented() === false) {\r\n          executeKeyupOverride(editor, evt);\r\n        }\r\n      });\r\n    };\r\n\r\n    var firstNonWhiteSpaceNodeSibling = function (node) {\r\n      while (node) {\r\n        if (node.nodeType === 1 || node.nodeType === 3 && node.data && /[\\r\\n\\s]/.test(node.data)) {\r\n          return node;\r\n        }\r\n        node = node.nextSibling;\r\n      }\r\n    };\r\n    var moveToCaretPosition = function (editor, root) {\r\n      var node, lastNode = root;\r\n      var dom = editor.dom;\r\n      var moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\r\n      if (!root) {\r\n        return;\r\n      }\r\n      if (/^(LI|DT|DD)$/.test(root.nodeName)) {\r\n        var firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\r\n        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\r\n          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\r\n        }\r\n      }\r\n      var rng = dom.createRng();\r\n      root.normalize();\r\n      if (root.hasChildNodes()) {\r\n        var walker = new DomTreeWalker(root, root);\r\n        while (node = walker.current()) {\r\n          if (isText$7(node)) {\r\n            rng.setStart(node, 0);\r\n            rng.setEnd(node, 0);\r\n            break;\r\n          }\r\n          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\r\n            rng.setStartBefore(node);\r\n            rng.setEndBefore(node);\r\n            break;\r\n          }\r\n          lastNode = node;\r\n          node = walker.next();\r\n        }\r\n        if (!node) {\r\n          rng.setStart(lastNode, 0);\r\n          rng.setEnd(lastNode, 0);\r\n        }\r\n      } else {\r\n        if (isBr$5(root)) {\r\n          if (root.nextSibling && dom.isBlock(root.nextSibling)) {\r\n            rng.setStartBefore(root);\r\n            rng.setEndBefore(root);\r\n          } else {\r\n            rng.setStartAfter(root);\r\n            rng.setEndAfter(root);\r\n          }\r\n        } else {\r\n          rng.setStart(root, 0);\r\n          rng.setEnd(root, 0);\r\n        }\r\n      }\r\n      editor.selection.setRng(rng);\r\n      scrollRangeIntoView(editor, rng);\r\n    };\r\n    var getEditableRoot$1 = function (dom, node) {\r\n      var root = dom.getRoot();\r\n      var parent, editableRoot;\r\n      parent = node;\r\n      while (parent !== root && dom.getContentEditable(parent) !== 'false') {\r\n        if (dom.getContentEditable(parent) === 'true') {\r\n          editableRoot = parent;\r\n        }\r\n        parent = parent.parentNode;\r\n      }\r\n      return parent !== root ? editableRoot : root;\r\n    };\r\n    var getParentBlock = function (editor) {\r\n      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\r\n    };\r\n    var getParentBlockName = function (editor) {\r\n      return getParentBlock(editor).fold(constant(''), function (parentBlock) {\r\n        return parentBlock.nodeName.toUpperCase();\r\n      });\r\n    };\r\n    var isListItemParentBlock = function (editor) {\r\n      return getParentBlock(editor).filter(function (elm) {\r\n        return isListItem(SugarElement.fromDom(elm));\r\n      }).isSome();\r\n    };\r\n\r\n    var hasFirstChild = function (elm, name) {\r\n      return elm.firstChild && elm.firstChild.nodeName === name;\r\n    };\r\n    var isFirstChild = function (elm) {\r\n      var _a;\r\n      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\r\n    };\r\n    var hasParent = function (elm, parentName) {\r\n      return elm && elm.parentNode && elm.parentNode.nodeName === parentName;\r\n    };\r\n    var isListBlock = function (elm) {\r\n      return elm && /^(OL|UL|LI)$/.test(elm.nodeName);\r\n    };\r\n    var isNestedList = function (elm) {\r\n      return isListBlock(elm) && isListBlock(elm.parentNode);\r\n    };\r\n    var getContainerBlock = function (containerBlock) {\r\n      var containerBlockParent = containerBlock.parentNode;\r\n      if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {\r\n        return containerBlockParent;\r\n      }\r\n      return containerBlock;\r\n    };\r\n    var isFirstOrLastLi = function (containerBlock, parentBlock, first) {\r\n      var node = containerBlock[first ? 'firstChild' : 'lastChild'];\r\n      while (node) {\r\n        if (isElement$5(node)) {\r\n          break;\r\n        }\r\n        node = node[first ? 'nextSibling' : 'previousSibling'];\r\n      }\r\n      return node === parentBlock;\r\n    };\r\n    var insert$3 = function (editor, createNewBlock, containerBlock, parentBlock, newBlockName) {\r\n      var dom = editor.dom;\r\n      var rng = editor.selection.getRng();\r\n      if (containerBlock === editor.getBody()) {\r\n        return;\r\n      }\r\n      if (isNestedList(containerBlock)) {\r\n        newBlockName = 'LI';\r\n      }\r\n      var newBlock = newBlockName ? createNewBlock(newBlockName) : dom.create('BR');\r\n      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\r\n        if (hasParent(containerBlock, 'LI')) {\r\n          var containerBlockParent = getContainerBlock(containerBlock);\r\n          dom.insertAfter(newBlock, containerBlockParent);\r\n          if (isFirstChild(containerBlock)) {\r\n            dom.remove(containerBlockParent);\r\n          } else {\r\n            dom.remove(containerBlock);\r\n          }\r\n        } else {\r\n          dom.replace(newBlock, containerBlock);\r\n        }\r\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\r\n        if (hasParent(containerBlock, 'LI')) {\r\n          dom.insertAfter(newBlock, getContainerBlock(containerBlock));\r\n          newBlock.appendChild(dom.doc.createTextNode(' '));\r\n          newBlock.appendChild(containerBlock);\r\n        } else {\r\n          containerBlock.parentNode.insertBefore(newBlock, containerBlock);\r\n        }\r\n        dom.remove(parentBlock);\r\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\r\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\r\n        dom.remove(parentBlock);\r\n      } else {\r\n        containerBlock = getContainerBlock(containerBlock);\r\n        var tmpRng = rng.cloneRange();\r\n        tmpRng.setStartAfter(parentBlock);\r\n        tmpRng.setEndAfter(containerBlock);\r\n        var fragment = tmpRng.extractContents();\r\n        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\r\n          newBlock = fragment.firstChild;\r\n          dom.insertAfter(fragment, containerBlock);\r\n        } else {\r\n          dom.insertAfter(fragment, containerBlock);\r\n          dom.insertAfter(newBlock, containerBlock);\r\n        }\r\n        dom.remove(parentBlock);\r\n      }\r\n      moveToCaretPosition(editor, newBlock);\r\n    };\r\n\r\n    var trimZwsp = function (fragment) {\r\n      each$k(descendants$1(SugarElement.fromDom(fragment), isText$8), function (text) {\r\n        var rawNode = text.dom;\r\n        rawNode.nodeValue = trim$3(rawNode.nodeValue);\r\n      });\r\n    };\r\n    var isEmptyAnchor = function (dom, elm) {\r\n      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\r\n    };\r\n    var isTableCell = function (node) {\r\n      return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);\r\n    };\r\n    var emptyBlock = function (elm) {\r\n      elm.innerHTML = '<br data-mce-bogus=\"1\">';\r\n    };\r\n    var containerAndSiblingName = function (container, nodeName) {\r\n      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\r\n    };\r\n    var canSplitBlock = function (dom, node) {\r\n      return node && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.getContentEditable(node) !== 'true';\r\n    };\r\n    var trimInlineElementsOnLeftSideOfBlock = function (dom, nonEmptyElementsMap, block) {\r\n      var node = block;\r\n      var firstChilds = [];\r\n      var i;\r\n      if (!node) {\r\n        return;\r\n      }\r\n      while (node = node.firstChild) {\r\n        if (dom.isBlock(node)) {\r\n          return;\r\n        }\r\n        if (isElement$5(node) && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\r\n          firstChilds.push(node);\r\n        }\r\n      }\r\n      i = firstChilds.length;\r\n      while (i--) {\r\n        node = firstChilds[i];\r\n        if (!node.hasChildNodes() || node.firstChild === node.lastChild && node.firstChild.nodeValue === '') {\r\n          dom.remove(node);\r\n        } else {\r\n          if (isEmptyAnchor(dom, node)) {\r\n            dom.remove(node);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var normalizeZwspOffset = function (start, container, offset) {\r\n      if (isText$7(container) === false) {\r\n        return offset;\r\n      } else if (start) {\r\n        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\r\n      } else {\r\n        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\r\n      }\r\n    };\r\n    var includeZwspInRange = function (rng) {\r\n      var newRng = rng.cloneRange();\r\n      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\r\n      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\r\n      return newRng;\r\n    };\r\n    var trimLeadingLineBreaks = function (node) {\r\n      do {\r\n        if (isText$7(node)) {\r\n          node.nodeValue = node.nodeValue.replace(/^[\\r\\n]+/, '');\r\n        }\r\n        node = node.firstChild;\r\n      } while (node);\r\n    };\r\n    var getEditableRoot = function (dom, node) {\r\n      var root = dom.getRoot();\r\n      var parent, editableRoot;\r\n      parent = node;\r\n      while (parent !== root && dom.getContentEditable(parent) !== 'false') {\r\n        if (dom.getContentEditable(parent) === 'true') {\r\n          editableRoot = parent;\r\n        }\r\n        parent = parent.parentNode;\r\n      }\r\n      return parent !== root ? editableRoot : root;\r\n    };\r\n    var applyAttributes = function (editor, node, forcedRootBlockAttrs) {\r\n      var dom = editor.dom;\r\n      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(function (attrStyles) {\r\n        var currentStyles = getAllRaw(SugarElement.fromDom(node));\r\n        var newStyles = __assign(__assign({}, currentStyles), attrStyles);\r\n        dom.setStyles(node, newStyles);\r\n      });\r\n      var attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(function (attrClasses) {\r\n        return attrClasses.split(/\\s+/);\r\n      });\r\n      var currentClassesOpt = Optional.from(node.className).map(function (currentClasses) {\r\n        return filter$4(currentClasses.split(/\\s+/), function (clazz) {\r\n          return clazz !== '';\r\n        });\r\n      });\r\n      lift2(attrClassesOpt, currentClassesOpt, function (attrClasses, currentClasses) {\r\n        var filteredClasses = filter$4(currentClasses, function (clazz) {\r\n          return !contains$3(attrClasses, clazz);\r\n        });\r\n        var newClasses = __spreadArray(__spreadArray([], attrClasses, true), filteredClasses, true);\r\n        dom.setAttrib(node, 'class', newClasses.join(' '));\r\n      });\r\n      var appliedAttrs = [\r\n        'style',\r\n        'class'\r\n      ];\r\n      var remainingAttrs = filter$3(forcedRootBlockAttrs, function (_, attrs) {\r\n        return !contains$3(appliedAttrs, attrs);\r\n      });\r\n      dom.setAttribs(node, remainingAttrs);\r\n    };\r\n    var setForcedBlockAttrs = function (editor, node) {\r\n      var forcedRootBlockName = getForcedRootBlock(editor);\r\n      if (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\r\n        var forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\r\n        applyAttributes(editor, node, forcedRootBlockAttrs);\r\n      }\r\n    };\r\n    var wrapSelfAndSiblingsInDefaultBlock = function (editor, newBlockName, rng, container, offset) {\r\n      var newBlock, parentBlock, startNode, node, next, rootBlockName;\r\n      var blockName = newBlockName || 'P';\r\n      var dom = editor.dom, editableRoot = getEditableRoot(dom, container);\r\n      parentBlock = dom.getParent(container, dom.isBlock);\r\n      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\r\n        parentBlock = parentBlock || editableRoot;\r\n        if (parentBlock === editor.getBody() || isTableCell(parentBlock)) {\r\n          rootBlockName = parentBlock.nodeName.toLowerCase();\r\n        } else {\r\n          rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();\r\n        }\r\n        if (!parentBlock.hasChildNodes()) {\r\n          newBlock = dom.create(blockName);\r\n          setForcedBlockAttrs(editor, newBlock);\r\n          parentBlock.appendChild(newBlock);\r\n          rng.setStart(newBlock, 0);\r\n          rng.setEnd(newBlock, 0);\r\n          return newBlock;\r\n        }\r\n        node = container;\r\n        while (node.parentNode !== parentBlock) {\r\n          node = node.parentNode;\r\n        }\r\n        while (node && !dom.isBlock(node)) {\r\n          startNode = node;\r\n          node = node.previousSibling;\r\n        }\r\n        if (startNode && editor.schema.isValidChild(rootBlockName, blockName.toLowerCase())) {\r\n          newBlock = dom.create(blockName);\r\n          setForcedBlockAttrs(editor, newBlock);\r\n          startNode.parentNode.insertBefore(newBlock, startNode);\r\n          node = startNode;\r\n          while (node && !dom.isBlock(node)) {\r\n            next = node.nextSibling;\r\n            newBlock.appendChild(node);\r\n            node = next;\r\n          }\r\n          rng.setStart(container, offset);\r\n          rng.setEnd(container, offset);\r\n        }\r\n      }\r\n      return container;\r\n    };\r\n    var addBrToBlockIfNeeded = function (dom, block) {\r\n      block.normalize();\r\n      var lastChild = block.lastChild;\r\n      if (!lastChild || /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\r\n        dom.add(block, 'br');\r\n      }\r\n    };\r\n    var insert$2 = function (editor, evt) {\r\n      var tmpRng, container, offset, parentBlock;\r\n      var newBlock, fragment, containerBlock, parentBlockName, newBlockName, isAfterLastNodeInContainer;\r\n      var dom = editor.dom;\r\n      var schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();\r\n      var rng = editor.selection.getRng();\r\n      var createNewBlock = function (name) {\r\n        var node = container, block, clonedNode, caretNode;\r\n        var textInlineElements = schema.getTextInlineElements();\r\n        if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\r\n          block = dom.create(name || newBlockName);\r\n        } else {\r\n          block = parentBlock.cloneNode(false);\r\n        }\r\n        caretNode = block;\r\n        if (shouldKeepStyles(editor) === false) {\r\n          dom.setAttrib(block, 'style', null);\r\n          dom.setAttrib(block, 'class', null);\r\n        } else {\r\n          do {\r\n            if (textInlineElements[node.nodeName]) {\r\n              if (isCaretNode(node) || isBookmarkNode$1(node)) {\r\n                continue;\r\n              }\r\n              clonedNode = node.cloneNode(false);\r\n              dom.setAttrib(clonedNode, 'id', '');\r\n              if (block.hasChildNodes()) {\r\n                clonedNode.appendChild(block.firstChild);\r\n                block.appendChild(clonedNode);\r\n              } else {\r\n                caretNode = clonedNode;\r\n                block.appendChild(clonedNode);\r\n              }\r\n            }\r\n          } while ((node = node.parentNode) && node !== editableRoot);\r\n        }\r\n        setForcedBlockAttrs(editor, block);\r\n        emptyBlock(caretNode);\r\n        return block;\r\n      };\r\n      var isCaretAtStartOrEndOfBlock = function (start) {\r\n        var node, name;\r\n        var normalizedOffset = normalizeZwspOffset(start, container, offset);\r\n        if (isText$7(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.nodeValue.length)) {\r\n          return false;\r\n        }\r\n        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {\r\n          return true;\r\n        }\r\n        if (start && isElement$5(container) && container === parentBlock.firstChild) {\r\n          return true;\r\n        }\r\n        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {\r\n          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\r\n        }\r\n        var walker = new DomTreeWalker(container, parentBlock);\r\n        if (isText$7(container)) {\r\n          if (start && normalizedOffset === 0) {\r\n            walker.prev();\r\n          } else if (!start && normalizedOffset === container.nodeValue.length) {\r\n            walker.next();\r\n          }\r\n        }\r\n        while (node = walker.current()) {\r\n          if (isElement$5(node)) {\r\n            if (!node.getAttribute('data-mce-bogus')) {\r\n              name = node.nodeName.toLowerCase();\r\n              if (nonEmptyElementsMap[name] && name !== 'br') {\r\n                return false;\r\n              }\r\n            }\r\n          } else if (isText$7(node) && !isWhitespaceText(node.nodeValue)) {\r\n            return false;\r\n          }\r\n          if (start) {\r\n            walker.prev();\r\n          } else {\r\n            walker.next();\r\n          }\r\n        }\r\n        return true;\r\n      };\r\n      var insertNewBlockAfter = function () {\r\n        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\r\n          newBlock = createNewBlock(newBlockName);\r\n        } else {\r\n          newBlock = createNewBlock();\r\n        }\r\n        if (shouldEndContainerOnEmptyBlock(editor) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock)) {\r\n          newBlock = dom.split(containerBlock, parentBlock);\r\n        } else {\r\n          dom.insertAfter(newBlock, parentBlock);\r\n        }\r\n        moveToCaretPosition(editor, newBlock);\r\n      };\r\n      normalize$2(dom, rng).each(function (normRng) {\r\n        rng.setStart(normRng.startContainer, normRng.startOffset);\r\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\r\n      });\r\n      container = rng.startContainer;\r\n      offset = rng.startOffset;\r\n      newBlockName = getForcedRootBlock(editor);\r\n      var shiftKey = !!(evt && evt.shiftKey);\r\n      var ctrlKey = !!(evt && evt.ctrlKey);\r\n      if (isElement$5(container) && container.hasChildNodes()) {\r\n        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\r\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\r\n        if (isAfterLastNodeInContainer && isText$7(container)) {\r\n          offset = container.nodeValue.length;\r\n        } else {\r\n          offset = 0;\r\n        }\r\n      }\r\n      var editableRoot = getEditableRoot(dom, container);\r\n      if (!editableRoot) {\r\n        return;\r\n      }\r\n      if (newBlockName && !shiftKey || !newBlockName && shiftKey) {\r\n        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\r\n      }\r\n      parentBlock = dom.getParent(container, dom.isBlock);\r\n      containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\r\n      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\r\n      var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\r\n      if (containerBlockName === 'LI' && !ctrlKey) {\r\n        parentBlock = containerBlock;\r\n        containerBlock = containerBlock.parentNode;\r\n        parentBlockName = containerBlockName;\r\n      }\r\n      if (/^(LI|DT|DD)$/.test(parentBlockName)) {\r\n        if (dom.isEmpty(parentBlock)) {\r\n          insert$3(editor, createNewBlock, containerBlock, parentBlock, newBlockName);\r\n          return;\r\n        }\r\n      }\r\n      if (newBlockName && parentBlock === editor.getBody()) {\r\n        return;\r\n      }\r\n      newBlockName = newBlockName || 'P';\r\n      if (isCaretContainerBlock$1(parentBlock)) {\r\n        newBlock = showCaretContainerBlock(parentBlock);\r\n        if (dom.isEmpty(parentBlock)) {\r\n          emptyBlock(parentBlock);\r\n        }\r\n        setForcedBlockAttrs(editor, newBlock);\r\n        moveToCaretPosition(editor, newBlock);\r\n      } else if (isCaretAtStartOrEndOfBlock()) {\r\n        insertNewBlockAfter();\r\n      } else if (isCaretAtStartOrEndOfBlock(true)) {\r\n        newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);\r\n        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') ? newBlock : parentBlock);\r\n      } else {\r\n        tmpRng = includeZwspInRange(rng).cloneRange();\r\n        tmpRng.setEndAfter(parentBlock);\r\n        fragment = tmpRng.extractContents();\r\n        trimZwsp(fragment);\r\n        trimLeadingLineBreaks(fragment);\r\n        newBlock = fragment.firstChild;\r\n        dom.insertAfter(fragment, parentBlock);\r\n        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\r\n        addBrToBlockIfNeeded(dom, parentBlock);\r\n        if (dom.isEmpty(parentBlock)) {\r\n          emptyBlock(parentBlock);\r\n        }\r\n        newBlock.normalize();\r\n        if (dom.isEmpty(newBlock)) {\r\n          dom.remove(newBlock);\r\n          insertNewBlockAfter();\r\n        } else {\r\n          setForcedBlockAttrs(editor, newBlock);\r\n          moveToCaretPosition(editor, newBlock);\r\n        }\r\n      }\r\n      dom.setAttrib(newBlock, 'id', '');\r\n      editor.fire('NewBlock', { newBlock: newBlock });\r\n    };\r\n\r\n    var hasRightSideContent = function (schema, container, parentBlock) {\r\n      var walker = new DomTreeWalker(container, parentBlock);\r\n      var node;\r\n      var nonEmptyElementsMap = schema.getNonEmptyElements();\r\n      while (node = walker.next()) {\r\n        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {\r\n          return true;\r\n        }\r\n      }\r\n    };\r\n    var moveSelectionToBr = function (editor, brElm, extraBr) {\r\n      var rng = editor.dom.createRng();\r\n      if (!extraBr) {\r\n        rng.setStartAfter(brElm);\r\n        rng.setEndAfter(brElm);\r\n      } else {\r\n        rng.setStartBefore(brElm);\r\n        rng.setEndBefore(brElm);\r\n      }\r\n      editor.selection.setRng(rng);\r\n      scrollRangeIntoView(editor, rng);\r\n    };\r\n    var insertBrAtCaret = function (editor, evt) {\r\n      var selection = editor.selection;\r\n      var dom = editor.dom;\r\n      var rng = selection.getRng();\r\n      var brElm;\r\n      var extraBr;\r\n      normalize$2(dom, rng).each(function (normRng) {\r\n        rng.setStart(normRng.startContainer, normRng.startOffset);\r\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\r\n      });\r\n      var offset = rng.startOffset;\r\n      var container = rng.startContainer;\r\n      if (container.nodeType === 1 && container.hasChildNodes()) {\r\n        var isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\r\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\r\n        if (isAfterLastNodeInContainer && container.nodeType === 3) {\r\n          offset = container.nodeValue.length;\r\n        } else {\r\n          offset = 0;\r\n        }\r\n      }\r\n      var parentBlock = dom.getParent(container, dom.isBlock);\r\n      var containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\r\n      var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\r\n      var isControlKey = !!(evt && evt.ctrlKey);\r\n      if (containerBlockName === 'LI' && !isControlKey) {\r\n        parentBlock = containerBlock;\r\n      }\r\n      if (container && container.nodeType === 3 && offset >= container.nodeValue.length) {\r\n        if (!hasRightSideContent(editor.schema, container, parentBlock)) {\r\n          brElm = dom.create('br');\r\n          rng.insertNode(brElm);\r\n          rng.setStartAfter(brElm);\r\n          rng.setEndAfter(brElm);\r\n          extraBr = true;\r\n        }\r\n      }\r\n      brElm = dom.create('br');\r\n      rangeInsertNode(dom, rng, brElm);\r\n      moveSelectionToBr(editor, brElm, extraBr);\r\n      editor.undoManager.add();\r\n    };\r\n    var insertBrBefore = function (editor, inline) {\r\n      var br = SugarElement.fromTag('br');\r\n      before$4(SugarElement.fromDom(inline), br);\r\n      editor.undoManager.add();\r\n    };\r\n    var insertBrAfter = function (editor, inline) {\r\n      if (!hasBrAfter(editor.getBody(), inline)) {\r\n        after$3(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\r\n      }\r\n      var br = SugarElement.fromTag('br');\r\n      after$3(SugarElement.fromDom(inline), br);\r\n      moveSelectionToBr(editor, br.dom, false);\r\n      editor.undoManager.add();\r\n    };\r\n    var isBeforeBr = function (pos) {\r\n      return isBr$5(pos.getNode());\r\n    };\r\n    var hasBrAfter = function (rootNode, startNode) {\r\n      if (isBeforeBr(CaretPosition.after(startNode))) {\r\n        return true;\r\n      } else {\r\n        return nextPosition(rootNode, CaretPosition.after(startNode)).map(function (pos) {\r\n          return isBr$5(pos.getNode());\r\n        }).getOr(false);\r\n      }\r\n    };\r\n    var isAnchorLink = function (elm) {\r\n      return elm && elm.nodeName === 'A' && 'href' in elm;\r\n    };\r\n    var isInsideAnchor = function (location) {\r\n      return location.fold(never, isAnchorLink, isAnchorLink, never);\r\n    };\r\n    var readInlineAnchorLocation = function (editor) {\r\n      var isInlineTarget$1 = curry(isInlineTarget, editor);\r\n      var position = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\r\n    };\r\n    var insertBrOutsideAnchor = function (editor, location) {\r\n      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\r\n    };\r\n    var insert$1 = function (editor, evt) {\r\n      var anchorLocation = readInlineAnchorLocation(editor);\r\n      if (anchorLocation.isSome()) {\r\n        anchorLocation.each(curry(insertBrOutsideAnchor, editor));\r\n      } else {\r\n        insertBrAtCaret(editor, evt);\r\n      }\r\n    };\r\n\r\n    var matchesSelector = function (editor, selector) {\r\n      return getParentBlock(editor).filter(function (parentBlock) {\r\n        return selector.length > 0 && is$2(SugarElement.fromDom(parentBlock), selector);\r\n      }).isSome();\r\n    };\r\n    var shouldInsertBr = function (editor) {\r\n      return matchesSelector(editor, getBrNewLineSelector(editor));\r\n    };\r\n    var shouldBlockNewLine$1 = function (editor) {\r\n      return matchesSelector(editor, getNoNewLineSelector(editor));\r\n    };\r\n\r\n    var newLineAction = Adt.generate([\r\n      { br: [] },\r\n      { block: [] },\r\n      { none: [] }\r\n    ]);\r\n    var shouldBlockNewLine = function (editor, _shiftKey) {\r\n      return shouldBlockNewLine$1(editor);\r\n    };\r\n    var isBrMode = function (requiredState) {\r\n      return function (editor, _shiftKey) {\r\n        var brMode = getForcedRootBlock(editor) === '';\r\n        return brMode === requiredState;\r\n      };\r\n    };\r\n    var inListBlock = function (requiredState) {\r\n      return function (editor, _shiftKey) {\r\n        return isListItemParentBlock(editor) === requiredState;\r\n      };\r\n    };\r\n    var inBlock = function (blockName, requiredState) {\r\n      return function (editor, _shiftKey) {\r\n        var state = getParentBlockName(editor) === blockName.toUpperCase();\r\n        return state === requiredState;\r\n      };\r\n    };\r\n    var inPreBlock = function (requiredState) {\r\n      return inBlock('pre', requiredState);\r\n    };\r\n    var inSummaryBlock = function () {\r\n      return inBlock('summary', true);\r\n    };\r\n    var shouldPutBrInPre = function (requiredState) {\r\n      return function (editor, _shiftKey) {\r\n        return shouldPutBrInPre$1(editor) === requiredState;\r\n      };\r\n    };\r\n    var inBrContext = function (editor, _shiftKey) {\r\n      return shouldInsertBr(editor);\r\n    };\r\n    var hasShiftKey = function (_editor, shiftKey) {\r\n      return shiftKey;\r\n    };\r\n    var canInsertIntoEditableRoot = function (editor) {\r\n      var forcedRootBlock = getForcedRootBlock(editor);\r\n      var rootEditable = getEditableRoot$1(editor.dom, editor.selection.getStart());\r\n      return rootEditable && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock ? forcedRootBlock : 'P');\r\n    };\r\n    var match = function (predicates, action) {\r\n      return function (editor, shiftKey) {\r\n        var isMatch = foldl(predicates, function (res, p) {\r\n          return res && p(editor, shiftKey);\r\n        }, true);\r\n        return isMatch ? Optional.some(action) : Optional.none();\r\n      };\r\n    };\r\n    var getAction = function (editor, evt) {\r\n      return evaluateUntil([\r\n        match([shouldBlockNewLine], newLineAction.none()),\r\n        match([inSummaryBlock()], newLineAction.br()),\r\n        match([\r\n          inPreBlock(true),\r\n          shouldPutBrInPre(false),\r\n          hasShiftKey\r\n        ], newLineAction.br()),\r\n        match([\r\n          inPreBlock(true),\r\n          shouldPutBrInPre(false)\r\n        ], newLineAction.block()),\r\n        match([\r\n          inPreBlock(true),\r\n          shouldPutBrInPre(true),\r\n          hasShiftKey\r\n        ], newLineAction.block()),\r\n        match([\r\n          inPreBlock(true),\r\n          shouldPutBrInPre(true)\r\n        ], newLineAction.br()),\r\n        match([\r\n          inListBlock(true),\r\n          hasShiftKey\r\n        ], newLineAction.br()),\r\n        match([inListBlock(true)], newLineAction.block()),\r\n        match([\r\n          isBrMode(true),\r\n          hasShiftKey,\r\n          canInsertIntoEditableRoot\r\n        ], newLineAction.block()),\r\n        match([isBrMode(true)], newLineAction.br()),\r\n        match([inBrContext], newLineAction.br()),\r\n        match([\r\n          isBrMode(false),\r\n          hasShiftKey\r\n        ], newLineAction.br()),\r\n        match([canInsertIntoEditableRoot], newLineAction.block())\r\n      ], [\r\n        editor,\r\n        !!(evt && evt.shiftKey)\r\n      ]).getOr(newLineAction.none());\r\n    };\r\n\r\n    var insert = function (editor, evt) {\r\n      getAction(editor, evt).fold(function () {\r\n        insert$1(editor, evt);\r\n      }, function () {\r\n        insert$2(editor, evt);\r\n      }, noop);\r\n    };\r\n\r\n    var handleEnterKeyEvent = function (editor, event) {\r\n      if (event.isDefaultPrevented()) {\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n      endTypingLevelIgnoreLocks(editor.undoManager);\r\n      editor.undoManager.transact(function () {\r\n        if (editor.selection.isCollapsed() === false) {\r\n          editor.execCommand('Delete');\r\n        }\r\n        insert(editor, event);\r\n      });\r\n    };\r\n    var setup$9 = function (editor) {\r\n      editor.on('keydown', function (event) {\r\n        if (event.keyCode === VK.ENTER) {\r\n          handleEnterKeyEvent(editor, event);\r\n        }\r\n      });\r\n    };\r\n\r\n    var executeKeydownOverride$1 = function (editor, caret, evt) {\r\n      execute([\r\n        {\r\n          keyCode: VK.END,\r\n          action: action(moveToLineEndPoint$1, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.HOME,\r\n          action: action(moveToLineEndPoint$1, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.END,\r\n          action: action(moveToLineEndPoint, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.HOME,\r\n          action: action(moveToLineEndPoint, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.END,\r\n          action: action(moveToLineEndPoint$2, editor, true, caret)\r\n        },\r\n        {\r\n          keyCode: VK.HOME,\r\n          action: action(moveToLineEndPoint$2, editor, false, caret)\r\n        }\r\n      ], evt).each(function (_) {\r\n        evt.preventDefault();\r\n      });\r\n    };\r\n    var setup$8 = function (editor, caret) {\r\n      editor.on('keydown', function (evt) {\r\n        if (evt.isDefaultPrevented() === false) {\r\n          executeKeydownOverride$1(editor, caret, evt);\r\n        }\r\n      });\r\n    };\r\n\r\n    var browser = detect().browser;\r\n    var setupIeInput = function (editor) {\r\n      var keypressThrotter = first(function () {\r\n        if (!editor.composing) {\r\n          normalizeNbspsInEditor(editor);\r\n        }\r\n      }, 0);\r\n      if (browser.isIE()) {\r\n        editor.on('keypress', function (_e) {\r\n          keypressThrotter.throttle();\r\n        });\r\n        editor.on('remove', function (_e) {\r\n          keypressThrotter.cancel();\r\n        });\r\n      }\r\n    };\r\n    var setup$7 = function (editor) {\r\n      setupIeInput(editor);\r\n      editor.on('input', function (e) {\r\n        if (e.isComposing === false) {\r\n          normalizeNbspsInEditor(editor);\r\n        }\r\n      });\r\n    };\r\n\r\n    var platform = detect();\r\n    var executeKeyupAction = function (editor, caret, evt) {\r\n      execute([\r\n        {\r\n          keyCode: VK.PAGE_UP,\r\n          action: action(moveToLineEndPoint$2, editor, false, caret)\r\n        },\r\n        {\r\n          keyCode: VK.PAGE_DOWN,\r\n          action: action(moveToLineEndPoint$2, editor, true, caret)\r\n        }\r\n      ], evt);\r\n    };\r\n    var stopImmediatePropagation = function (e) {\r\n      return e.stopImmediatePropagation();\r\n    };\r\n    var isPageUpDown = function (evt) {\r\n      return evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\r\n    };\r\n    var setNodeChangeBlocker = function (blocked, editor, block) {\r\n      if (block && !blocked.get()) {\r\n        editor.on('NodeChange', stopImmediatePropagation, true);\r\n      } else if (!block && blocked.get()) {\r\n        editor.off('NodeChange', stopImmediatePropagation);\r\n      }\r\n      blocked.set(block);\r\n    };\r\n    var setup$6 = function (editor, caret) {\r\n      if (platform.os.isOSX()) {\r\n        return;\r\n      }\r\n      var blocked = Cell(false);\r\n      editor.on('keydown', function (evt) {\r\n        if (isPageUpDown(evt)) {\r\n          setNodeChangeBlocker(blocked, editor, true);\r\n        }\r\n      });\r\n      editor.on('keyup', function (evt) {\r\n        if (evt.isDefaultPrevented() === false) {\r\n          executeKeyupAction(editor, caret, evt);\r\n        }\r\n        if (isPageUpDown(evt) && blocked.get()) {\r\n          setNodeChangeBlocker(blocked, editor, false);\r\n          editor.nodeChanged();\r\n        }\r\n      });\r\n    };\r\n\r\n    var insertTextAtPosition = function (text, pos) {\r\n      var container = pos.container();\r\n      var offset = pos.offset();\r\n      if (isText$7(container)) {\r\n        container.insertData(offset, text);\r\n        return Optional.some(CaretPosition(container, offset + text.length));\r\n      } else {\r\n        return getElementFromPosition(pos).map(function (elm) {\r\n          var textNode = SugarElement.fromText(text);\r\n          if (pos.isAtEnd()) {\r\n            after$3(elm, textNode);\r\n          } else {\r\n            before$4(elm, textNode);\r\n          }\r\n          return CaretPosition(textNode.dom, text.length);\r\n        });\r\n      }\r\n    };\r\n    var insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\r\n    var insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\r\n\r\n    var locationToCaretPosition = function (root) {\r\n      return function (location) {\r\n        return location.fold(function (element) {\r\n          return prevPosition(root.dom, CaretPosition.before(element));\r\n        }, function (element) {\r\n          return firstPositionIn(element);\r\n        }, function (element) {\r\n          return lastPositionIn(element);\r\n        }, function (element) {\r\n          return nextPosition(root.dom, CaretPosition.after(element));\r\n        });\r\n      };\r\n    };\r\n    var insertInlineBoundarySpaceOrNbsp = function (root, pos) {\r\n      return function (checkPos) {\r\n        return needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\r\n      };\r\n    };\r\n    var setSelection = function (editor) {\r\n      return function (pos) {\r\n        editor.selection.setRng(pos.toRange());\r\n        editor.nodeChanged();\r\n        return true;\r\n      };\r\n    };\r\n    var insertSpaceOrNbspAtSelection = function (editor) {\r\n      var pos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      var root = SugarElement.fromDom(editor.getBody());\r\n      if (editor.selection.isCollapsed()) {\r\n        var isInlineTarget$1 = curry(isInlineTarget, editor);\r\n        var caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).bind(insertInlineBoundarySpaceOrNbsp(root, pos)).exists(setSelection(editor));\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    var executeKeydownOverride = function (editor, evt) {\r\n      execute([{\r\n          keyCode: VK.SPACEBAR,\r\n          action: action(insertSpaceOrNbspAtSelection, editor)\r\n        }], evt).each(function (_) {\r\n        evt.preventDefault();\r\n      });\r\n    };\r\n    var setup$5 = function (editor) {\r\n      editor.on('keydown', function (evt) {\r\n        if (evt.isDefaultPrevented() === false) {\r\n          executeKeydownOverride(editor, evt);\r\n        }\r\n      });\r\n    };\r\n\r\n    var registerKeyboardOverrides = function (editor) {\r\n      var caret = setupSelectedState(editor);\r\n      setup$c(editor);\r\n      setup$b(editor, caret);\r\n      setup$a(editor, caret);\r\n      setup$9(editor);\r\n      setup$5(editor);\r\n      setup$7(editor);\r\n      setup$8(editor, caret);\r\n      setup$6(editor, caret);\r\n      return caret;\r\n    };\r\n    var setup$4 = function (editor) {\r\n      if (!isRtc(editor)) {\r\n        return registerKeyboardOverrides(editor);\r\n      } else {\r\n        return Cell(null);\r\n      }\r\n    };\r\n\r\n    var NodeChange = function () {\r\n      function NodeChange(editor) {\r\n        this.lastPath = [];\r\n        this.editor = editor;\r\n        var lastRng;\r\n        var self = this;\r\n        if (!('onselectionchange' in editor.getDoc())) {\r\n          editor.on('NodeChange click mouseup keyup focus', function (e) {\r\n            var nativeRng = editor.selection.getRng();\r\n            var fakeRng = {\r\n              startContainer: nativeRng.startContainer,\r\n              startOffset: nativeRng.startOffset,\r\n              endContainer: nativeRng.endContainer,\r\n              endOffset: nativeRng.endOffset\r\n            };\r\n            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\r\n              editor.fire('SelectionChange');\r\n            }\r\n            lastRng = fakeRng;\r\n          });\r\n        }\r\n        editor.on('contextmenu', function () {\r\n          editor.fire('SelectionChange');\r\n        });\r\n        editor.on('SelectionChange', function () {\r\n          var startElm = editor.selection.getStart(true);\r\n          if (!startElm || !Env.range && editor.selection.isCollapsed()) {\r\n            return;\r\n          }\r\n          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\r\n            editor.nodeChanged({ selectionChange: true });\r\n          }\r\n        });\r\n        editor.on('mouseup', function (e) {\r\n          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\r\n            if (editor.selection.getNode().nodeName === 'IMG') {\r\n              Delay.setEditorTimeout(editor, function () {\r\n                editor.nodeChanged();\r\n              });\r\n            } else {\r\n              editor.nodeChanged();\r\n            }\r\n          }\r\n        });\r\n      }\r\n      NodeChange.prototype.nodeChanged = function (args) {\r\n        var selection = this.editor.selection;\r\n        var node, parents, root;\r\n        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {\r\n          root = this.editor.getBody();\r\n          node = selection.getStart(true) || root;\r\n          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {\r\n            node = root;\r\n          }\r\n          parents = [];\r\n          this.editor.dom.getParent(node, function (node) {\r\n            if (node === root) {\r\n              return true;\r\n            }\r\n            parents.push(node);\r\n          });\r\n          args = args || {};\r\n          args.element = node;\r\n          args.parents = parents;\r\n          this.editor.fire('NodeChange', args);\r\n        }\r\n      };\r\n      NodeChange.prototype.isSameElementPath = function (startElm) {\r\n        var i;\r\n        var currentPath = this.editor.$(startElm).parentsUntil(this.editor.getBody()).add(startElm);\r\n        if (currentPath.length === this.lastPath.length) {\r\n          for (i = currentPath.length; i >= 0; i--) {\r\n            if (currentPath[i] !== this.lastPath[i]) {\r\n              break;\r\n            }\r\n          }\r\n          if (i === -1) {\r\n            this.lastPath = currentPath;\r\n            return true;\r\n          }\r\n        }\r\n        this.lastPath = currentPath;\r\n        return false;\r\n      };\r\n      return NodeChange;\r\n    }();\r\n\r\n    var preventSummaryToggle = function (editor) {\r\n      editor.on('click', function (e) {\r\n        if (editor.dom.getParent(e.target, 'details')) {\r\n          e.preventDefault();\r\n        }\r\n      });\r\n    };\r\n    var filterDetails = function (editor) {\r\n      editor.parser.addNodeFilter('details', function (elms) {\r\n        each$k(elms, function (details) {\r\n          details.attr('data-mce-open', details.attr('open'));\r\n          details.attr('open', 'open');\r\n        });\r\n      });\r\n      editor.serializer.addNodeFilter('details', function (elms) {\r\n        each$k(elms, function (details) {\r\n          var open = details.attr('data-mce-open');\r\n          details.attr('open', isString$1(open) ? open : null);\r\n          details.attr('data-mce-open', null);\r\n        });\r\n      });\r\n    };\r\n    var setup$3 = function (editor) {\r\n      preventSummaryToggle(editor);\r\n      filterDetails(editor);\r\n    };\r\n\r\n    var isTextBlockNode = function (node) {\r\n      return isElement$5(node) && isTextBlock$2(SugarElement.fromDom(node));\r\n    };\r\n    var normalizeSelection = function (editor) {\r\n      var rng = editor.selection.getRng();\r\n      var startPos = CaretPosition.fromRangeStart(rng);\r\n      var endPos = CaretPosition.fromRangeEnd(rng);\r\n      if (CaretPosition.isElementPosition(startPos)) {\r\n        var container = startPos.container();\r\n        if (isTextBlockNode(container)) {\r\n          firstPositionIn(container).each(function (pos) {\r\n            return rng.setStart(pos.container(), pos.offset());\r\n          });\r\n        }\r\n      }\r\n      if (CaretPosition.isElementPosition(endPos)) {\r\n        var container = startPos.container();\r\n        if (isTextBlockNode(container)) {\r\n          lastPositionIn(container).each(function (pos) {\r\n            return rng.setEnd(pos.container(), pos.offset());\r\n          });\r\n        }\r\n      }\r\n      editor.selection.setRng(normalize(rng));\r\n    };\r\n    var setup$2 = function (editor) {\r\n      editor.on('click', function (e) {\r\n        if (e.detail >= 3) {\r\n          normalizeSelection(editor);\r\n        }\r\n      });\r\n    };\r\n\r\n    var getAbsolutePosition = function (elm) {\r\n      var clientRect = elm.getBoundingClientRect();\r\n      var doc = elm.ownerDocument;\r\n      var docElem = doc.documentElement;\r\n      var win = doc.defaultView;\r\n      return {\r\n        top: clientRect.top + win.pageYOffset - docElem.clientTop,\r\n        left: clientRect.left + win.pageXOffset - docElem.clientLeft\r\n      };\r\n    };\r\n    var getBodyPosition = function (editor) {\r\n      return editor.inline ? getAbsolutePosition(editor.getBody()) : {\r\n        left: 0,\r\n        top: 0\r\n      };\r\n    };\r\n    var getScrollPosition = function (editor) {\r\n      var body = editor.getBody();\r\n      return editor.inline ? {\r\n        left: body.scrollLeft,\r\n        top: body.scrollTop\r\n      } : {\r\n        left: 0,\r\n        top: 0\r\n      };\r\n    };\r\n    var getBodyScroll = function (editor) {\r\n      var body = editor.getBody(), docElm = editor.getDoc().documentElement;\r\n      var inlineScroll = {\r\n        left: body.scrollLeft,\r\n        top: body.scrollTop\r\n      };\r\n      var iframeScroll = {\r\n        left: body.scrollLeft || docElm.scrollLeft,\r\n        top: body.scrollTop || docElm.scrollTop\r\n      };\r\n      return editor.inline ? inlineScroll : iframeScroll;\r\n    };\r\n    var getMousePosition = function (editor, event) {\r\n      if (event.target.ownerDocument !== editor.getDoc()) {\r\n        var iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\r\n        var scrollPosition = getBodyScroll(editor);\r\n        return {\r\n          left: event.pageX - iframePosition.left + scrollPosition.left,\r\n          top: event.pageY - iframePosition.top + scrollPosition.top\r\n        };\r\n      }\r\n      return {\r\n        left: event.pageX,\r\n        top: event.pageY\r\n      };\r\n    };\r\n    var calculatePosition = function (bodyPosition, scrollPosition, mousePosition) {\r\n      return {\r\n        pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\r\n        pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\r\n      };\r\n    };\r\n    var calc = function (editor, event) {\r\n      return calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\r\n    };\r\n\r\n    var isContentEditableFalse$1 = isContentEditableFalse$b, isContentEditableTrue$1 = isContentEditableTrue$4;\r\n    var isDraggable = function (rootElm, elm) {\r\n      return isContentEditableFalse$1(elm) && elm !== rootElm;\r\n    };\r\n    var isValidDropTarget = function (editor, targetElement, dragElement) {\r\n      if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\r\n        return false;\r\n      }\r\n      return !isContentEditableFalse$1(targetElement);\r\n    };\r\n    var cloneElement = function (elm) {\r\n      var cloneElm = elm.cloneNode(true);\r\n      cloneElm.removeAttribute('data-mce-selected');\r\n      return cloneElm;\r\n    };\r\n    var createGhost = function (editor, elm, width, height) {\r\n      var dom = editor.dom;\r\n      var clonedElm = elm.cloneNode(true);\r\n      dom.setStyles(clonedElm, {\r\n        width: width,\r\n        height: height\r\n      });\r\n      dom.setAttrib(clonedElm, 'data-mce-selected', null);\r\n      var ghostElm = dom.create('div', {\r\n        'class': 'mce-drag-container',\r\n        'data-mce-bogus': 'all',\r\n        'unselectable': 'on',\r\n        'contenteditable': 'false'\r\n      });\r\n      dom.setStyles(ghostElm, {\r\n        position: 'absolute',\r\n        opacity: 0.5,\r\n        overflow: 'hidden',\r\n        border: 0,\r\n        padding: 0,\r\n        margin: 0,\r\n        width: width,\r\n        height: height\r\n      });\r\n      dom.setStyles(clonedElm, {\r\n        margin: 0,\r\n        boxSizing: 'border-box'\r\n      });\r\n      ghostElm.appendChild(clonedElm);\r\n      return ghostElm;\r\n    };\r\n    var appendGhostToBody = function (ghostElm, bodyElm) {\r\n      if (ghostElm.parentNode !== bodyElm) {\r\n        bodyElm.appendChild(ghostElm);\r\n      }\r\n    };\r\n    var moveGhost = function (ghostElm, position, width, height, maxX, maxY) {\r\n      var overflowX = 0, overflowY = 0;\r\n      ghostElm.style.left = position.pageX + 'px';\r\n      ghostElm.style.top = position.pageY + 'px';\r\n      if (position.pageX + width > maxX) {\r\n        overflowX = position.pageX + width - maxX;\r\n      }\r\n      if (position.pageY + height > maxY) {\r\n        overflowY = position.pageY + height - maxY;\r\n      }\r\n      ghostElm.style.width = width - overflowX + 'px';\r\n      ghostElm.style.height = height - overflowY + 'px';\r\n    };\r\n    var removeElement = function (elm) {\r\n      if (elm && elm.parentNode) {\r\n        elm.parentNode.removeChild(elm);\r\n      }\r\n    };\r\n    var isLeftMouseButtonPressed = function (e) {\r\n      return e.button === 0;\r\n    };\r\n    var applyRelPos = function (state, position) {\r\n      return {\r\n        pageX: position.pageX - state.relX,\r\n        pageY: position.pageY + 5\r\n      };\r\n    };\r\n    var start = function (state, editor) {\r\n      return function (e) {\r\n        if (isLeftMouseButtonPressed(e)) {\r\n          var ceElm = find$3(editor.dom.getParents(e.target), or(isContentEditableFalse$1, isContentEditableTrue$1)).getOr(null);\r\n          if (isDraggable(editor.getBody(), ceElm)) {\r\n            var elmPos = editor.dom.getPos(ceElm);\r\n            var bodyElm = editor.getBody();\r\n            var docElm = editor.getDoc().documentElement;\r\n            state.set({\r\n              element: ceElm,\r\n              dragging: false,\r\n              screenX: e.screenX,\r\n              screenY: e.screenY,\r\n              maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\r\n              maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\r\n              relX: e.pageX - elmPos.x,\r\n              relY: e.pageY - elmPos.y,\r\n              width: ceElm.offsetWidth,\r\n              height: ceElm.offsetHeight,\r\n              ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight)\r\n            });\r\n          }\r\n        }\r\n      };\r\n    };\r\n    var move = function (state, editor) {\r\n      var throttledPlaceCaretAt = Delay.throttle(function (clientX, clientY) {\r\n        editor._selectionOverrides.hideFakeCaret();\r\n        editor.selection.placeCaretAt(clientX, clientY);\r\n      }, 0);\r\n      editor.on('remove', throttledPlaceCaretAt.stop);\r\n      return function (e) {\r\n        return state.on(function (state) {\r\n          var movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\r\n          if (!state.dragging && movement > 10) {\r\n            var args = editor.fire('dragstart', { target: state.element });\r\n            if (args.isDefaultPrevented()) {\r\n              return;\r\n            }\r\n            state.dragging = true;\r\n            editor.focus();\r\n          }\r\n          if (state.dragging) {\r\n            var targetPos = applyRelPos(state, calc(editor, e));\r\n            appendGhostToBody(state.ghost, editor.getBody());\r\n            moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);\r\n            throttledPlaceCaretAt(e.clientX, e.clientY);\r\n          }\r\n        });\r\n      };\r\n    };\r\n    var getRawTarget = function (selection) {\r\n      var rng = selection.getSel().getRangeAt(0);\r\n      var startContainer = rng.startContainer;\r\n      return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;\r\n    };\r\n    var drop = function (state, editor) {\r\n      return function (e) {\r\n        state.on(function (state) {\r\n          if (state.dragging) {\r\n            if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\r\n              var targetClone_1 = cloneElement(state.element);\r\n              var args = editor.fire('drop', {\r\n                clientX: e.clientX,\r\n                clientY: e.clientY\r\n              });\r\n              if (!args.isDefaultPrevented()) {\r\n                editor.undoManager.transact(function () {\r\n                  removeElement(state.element);\r\n                  editor.insertContent(editor.dom.getOuterHTML(targetClone_1));\r\n                  editor._selectionOverrides.hideFakeCaret();\r\n                });\r\n              }\r\n            }\r\n            editor.fire('dragend');\r\n          }\r\n        });\r\n        removeDragState(state);\r\n      };\r\n    };\r\n    var stop = function (state, editor) {\r\n      return function () {\r\n        state.on(function (state) {\r\n          if (state.dragging) {\r\n            editor.fire('dragend');\r\n          }\r\n        });\r\n        removeDragState(state);\r\n      };\r\n    };\r\n    var removeDragState = function (state) {\r\n      state.on(function (state) {\r\n        removeElement(state.ghost);\r\n      });\r\n      state.clear();\r\n    };\r\n    var bindFakeDragEvents = function (editor) {\r\n      var state = value();\r\n      var pageDom = DOMUtils.DOM;\r\n      var rootDocument = document;\r\n      var dragStartHandler = start(state, editor);\r\n      var dragHandler = move(state, editor);\r\n      var dropHandler = drop(state, editor);\r\n      var dragEndHandler = stop(state, editor);\r\n      editor.on('mousedown', dragStartHandler);\r\n      editor.on('mousemove', dragHandler);\r\n      editor.on('mouseup', dropHandler);\r\n      pageDom.bind(rootDocument, 'mousemove', dragHandler);\r\n      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\r\n      editor.on('remove', function () {\r\n        pageDom.unbind(rootDocument, 'mousemove', dragHandler);\r\n        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\r\n      });\r\n      editor.on('keydown', function (e) {\r\n        if (e.keyCode === VK.ESC) {\r\n          dragEndHandler();\r\n        }\r\n      });\r\n    };\r\n    var blockIeDrop = function (editor) {\r\n      editor.on('drop', function (e) {\r\n        var realTarget = typeof e.clientX !== 'undefined' ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : null;\r\n        if (isContentEditableFalse$1(realTarget) || editor.dom.getContentEditableParent(realTarget) === 'false') {\r\n          e.preventDefault();\r\n        }\r\n      });\r\n    };\r\n    var blockUnsupportedFileDrop = function (editor) {\r\n      var preventFileDrop = function (e) {\r\n        if (!e.isDefaultPrevented()) {\r\n          var dataTransfer = e.dataTransfer;\r\n          if (dataTransfer && (contains$3(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\r\n            e.preventDefault();\r\n            if (e.type === 'drop') {\r\n              displayError(editor, 'Dropped file type is not supported');\r\n            }\r\n          }\r\n        }\r\n      };\r\n      var preventFileDropIfUIElement = function (e) {\r\n        if (isUIElement(editor, e.target)) {\r\n          preventFileDrop(e);\r\n        }\r\n      };\r\n      var setup = function () {\r\n        var pageDom = DOMUtils.DOM;\r\n        var dom = editor.dom;\r\n        var doc = document;\r\n        var editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\r\n        var eventNames = [\r\n          'drop',\r\n          'dragover'\r\n        ];\r\n        each$k(eventNames, function (name) {\r\n          pageDom.bind(doc, name, preventFileDropIfUIElement);\r\n          dom.bind(editorRoot, name, preventFileDrop);\r\n        });\r\n        editor.on('remove', function () {\r\n          each$k(eventNames, function (name) {\r\n            pageDom.unbind(doc, name, preventFileDropIfUIElement);\r\n            dom.unbind(editorRoot, name, preventFileDrop);\r\n          });\r\n        });\r\n      };\r\n      editor.on('init', function () {\r\n        Delay.setEditorTimeout(editor, setup, 0);\r\n      });\r\n    };\r\n    var init$2 = function (editor) {\r\n      bindFakeDragEvents(editor);\r\n      blockIeDrop(editor);\r\n      if (shouldBlockUnsupportedDrop(editor)) {\r\n        blockUnsupportedFileDrop(editor);\r\n      }\r\n    };\r\n\r\n    var setup$1 = function (editor) {\r\n      var renderFocusCaret = first(function () {\r\n        if (!editor.removed && editor.getBody().contains(document.activeElement)) {\r\n          var rng = editor.selection.getRng();\r\n          if (rng.collapsed) {\r\n            var caretRange = renderRangeCaret(editor, rng, false);\r\n            editor.selection.setRng(caretRange);\r\n          }\r\n        }\r\n      }, 0);\r\n      editor.on('focus', function () {\r\n        renderFocusCaret.throttle();\r\n      });\r\n      editor.on('blur', function () {\r\n        renderFocusCaret.cancel();\r\n      });\r\n    };\r\n\r\n    var setup = function (editor) {\r\n      editor.on('init', function () {\r\n        editor.on('focusin', function (e) {\r\n          var target = e.target;\r\n          if (isMedia$2(target)) {\r\n            var ceRoot = getContentEditableRoot$1(editor.getBody(), target);\r\n            var node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;\r\n            if (editor.selection.getNode() !== node) {\r\n              selectNode(editor, node).each(function (rng) {\r\n                return editor.selection.setRng(rng);\r\n              });\r\n            }\r\n          }\r\n        });\r\n      });\r\n    };\r\n\r\n    var isContentEditableTrue = isContentEditableTrue$4;\r\n    var isContentEditableFalse = isContentEditableFalse$b;\r\n    var getContentEditableRoot = function (editor, node) {\r\n      return getContentEditableRoot$1(editor.getBody(), node);\r\n    };\r\n    var SelectionOverrides = function (editor) {\r\n      var selection = editor.selection, dom = editor.dom;\r\n      var isBlock = dom.isBlock;\r\n      var rootNode = editor.getBody();\r\n      var fakeCaret = FakeCaret(editor, rootNode, isBlock, function () {\r\n        return hasFocus(editor);\r\n      });\r\n      var realSelectionId = 'sel-' + dom.uniqueId();\r\n      var elementSelectionAttr = 'data-mce-selected';\r\n      var selectedElement;\r\n      var isFakeSelectionElement = function (node) {\r\n        return dom.hasClass(node, 'mce-offscreen-selection');\r\n      };\r\n      var isFakeSelectionTargetElement = function (node) {\r\n        return node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode);\r\n      };\r\n      var isNearFakeSelectionElement = function (pos) {\r\n        return isBeforeContentEditableFalse(pos) || isAfterContentEditableFalse(pos) || isBeforeMedia(pos) || isAfterMedia(pos);\r\n      };\r\n      var getRealSelectionElement = function () {\r\n        var container = dom.get(realSelectionId);\r\n        return container ? container.getElementsByTagName('*')[0] : container;\r\n      };\r\n      var setRange = function (range) {\r\n        if (range) {\r\n          selection.setRng(range);\r\n        }\r\n      };\r\n      var getRange = selection.getRng;\r\n      var showCaret = function (direction, node, before, scrollIntoView) {\r\n        if (scrollIntoView === void 0) {\r\n          scrollIntoView = true;\r\n        }\r\n        var e = editor.fire('ShowCaret', {\r\n          target: node,\r\n          direction: direction,\r\n          before: before\r\n        });\r\n        if (e.isDefaultPrevented()) {\r\n          return null;\r\n        }\r\n        if (scrollIntoView) {\r\n          selection.scrollIntoView(node, direction === -1);\r\n        }\r\n        return fakeCaret.show(before, node);\r\n      };\r\n      var showBlockCaretContainer = function (blockCaretContainer) {\r\n        if (blockCaretContainer.hasAttribute('data-mce-caret')) {\r\n          showCaretContainerBlock(blockCaretContainer);\r\n          setRange(getRange());\r\n          selection.scrollIntoView(blockCaretContainer);\r\n        }\r\n      };\r\n      var registerEvents = function () {\r\n        editor.on('mouseup', function (e) {\r\n          var range = getRange();\r\n          if (range.collapsed && isXYInContentArea(editor, e.clientX, e.clientY)) {\r\n            renderCaretAtRange(editor, range, false).each(setRange);\r\n          }\r\n        });\r\n        editor.on('click', function (e) {\r\n          var contentEditableRoot = getContentEditableRoot(editor, e.target);\r\n          if (contentEditableRoot) {\r\n            if (isContentEditableFalse(contentEditableRoot)) {\r\n              e.preventDefault();\r\n              editor.focus();\r\n            }\r\n            if (isContentEditableTrue(contentEditableRoot)) {\r\n              if (dom.isChildOf(contentEditableRoot, selection.getNode())) {\r\n                removeElementSelection();\r\n              }\r\n            }\r\n          }\r\n        });\r\n        editor.on('blur NewBlock', removeElementSelection);\r\n        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\r\n        var hasNormalCaretPosition = function (elm) {\r\n          var start = elm.firstChild;\r\n          if (isNullable(start)) {\r\n            return false;\r\n          }\r\n          var startPos = CaretPosition.before(start);\r\n          if (isBr$5(startPos.getNode()) && elm.childNodes.length === 1) {\r\n            return !isNearFakeSelectionElement(startPos);\r\n          } else {\r\n            var caretWalker = CaretWalker(elm);\r\n            var newPos = caretWalker.next(startPos);\r\n            return newPos && !isNearFakeSelectionElement(newPos);\r\n          }\r\n        };\r\n        var isInSameBlock = function (node1, node2) {\r\n          var block1 = dom.getParent(node1, isBlock);\r\n          var block2 = dom.getParent(node2, isBlock);\r\n          return block1 === block2;\r\n        };\r\n        var hasBetterMouseTarget = function (targetNode, caretNode) {\r\n          var targetBlock = dom.getParent(targetNode, isBlock);\r\n          var caretBlock = dom.getParent(caretNode, isBlock);\r\n          if (isNullable(targetBlock)) {\r\n            return false;\r\n          }\r\n          if (targetNode !== caretBlock && dom.isChildOf(targetBlock, caretBlock) && isContentEditableFalse(getContentEditableRoot(editor, targetBlock)) === false) {\r\n            return true;\r\n          }\r\n          return !dom.isChildOf(caretBlock, targetBlock) && !isInSameBlock(targetBlock, caretBlock) && hasNormalCaretPosition(targetBlock);\r\n        };\r\n        editor.on('tap', function (e) {\r\n          var targetElm = e.target;\r\n          var contentEditableRoot = getContentEditableRoot(editor, targetElm);\r\n          if (isContentEditableFalse(contentEditableRoot)) {\r\n            e.preventDefault();\r\n            selectNode(editor, contentEditableRoot).each(setElementSelection);\r\n          } else if (isFakeSelectionTargetElement(targetElm)) {\r\n            selectNode(editor, targetElm).each(setElementSelection);\r\n          }\r\n        }, true);\r\n        editor.on('mousedown', function (e) {\r\n          var targetElm = e.target;\r\n          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\r\n            return;\r\n          }\r\n          if (isXYInContentArea(editor, e.clientX, e.clientY) === false) {\r\n            return;\r\n          }\r\n          var contentEditableRoot = getContentEditableRoot(editor, targetElm);\r\n          if (contentEditableRoot) {\r\n            if (isContentEditableFalse(contentEditableRoot)) {\r\n              e.preventDefault();\r\n              selectNode(editor, contentEditableRoot).each(setElementSelection);\r\n            } else {\r\n              removeElementSelection();\r\n              if (!(isContentEditableTrue(contentEditableRoot) && e.shiftKey) && !isXYWithinRange(e.clientX, e.clientY, selection.getRng())) {\r\n                hideFakeCaret();\r\n                selection.placeCaretAt(e.clientX, e.clientY);\r\n              }\r\n            }\r\n          } else if (isFakeSelectionTargetElement(targetElm)) {\r\n            selectNode(editor, targetElm).each(setElementSelection);\r\n          } else if (isFakeCaretTarget(targetElm) === false) {\r\n            removeElementSelection();\r\n            hideFakeCaret();\r\n            var fakeCaretInfo = closestFakeCaret(rootNode, e.clientX, e.clientY);\r\n            if (fakeCaretInfo) {\r\n              if (!hasBetterMouseTarget(targetElm, fakeCaretInfo.node)) {\r\n                e.preventDefault();\r\n                var range = showCaret(1, fakeCaretInfo.node, fakeCaretInfo.before, false);\r\n                setRange(range);\r\n                editor.getBody().focus();\r\n              }\r\n            }\r\n          }\r\n        });\r\n        editor.on('keypress', function (e) {\r\n          if (VK.modifierPressed(e)) {\r\n            return;\r\n          }\r\n          if (isContentEditableFalse(selection.getNode())) {\r\n            e.preventDefault();\r\n          }\r\n        });\r\n        editor.on('GetSelectionRange', function (e) {\r\n          var rng = e.range;\r\n          if (selectedElement) {\r\n            if (!selectedElement.parentNode) {\r\n              selectedElement = null;\r\n              return;\r\n            }\r\n            rng = rng.cloneRange();\r\n            rng.selectNode(selectedElement);\r\n            e.range = rng;\r\n          }\r\n        });\r\n        editor.on('SetSelectionRange', function (e) {\r\n          e.range = normalizeShortEndedElementSelection(e.range);\r\n          var rng = setElementSelection(e.range, e.forward);\r\n          if (rng) {\r\n            e.range = rng;\r\n          }\r\n        });\r\n        var isPasteBin = function (node) {\r\n          return node.id === 'mcepastebin';\r\n        };\r\n        editor.on('AfterSetSelectionRange', function (e) {\r\n          var rng = e.range;\r\n          var parentNode = rng.startContainer.parentNode;\r\n          if (!isRangeInCaretContainer(rng) && !isPasteBin(parentNode)) {\r\n            hideFakeCaret();\r\n          }\r\n          if (!isFakeSelectionElement(parentNode)) {\r\n            removeElementSelection();\r\n          }\r\n        });\r\n        editor.on('copy', function (e) {\r\n          var clipboardData = e.clipboardData;\r\n          if (!e.isDefaultPrevented() && e.clipboardData && !Env.ie) {\r\n            var realSelectionElement = getRealSelectionElement();\r\n            if (realSelectionElement) {\r\n              e.preventDefault();\r\n              clipboardData.clearData();\r\n              clipboardData.setData('text/html', realSelectionElement.outerHTML);\r\n              clipboardData.setData('text/plain', realSelectionElement.outerText || realSelectionElement.innerText);\r\n            }\r\n          }\r\n        });\r\n        init$2(editor);\r\n        setup$1(editor);\r\n        setup(editor);\r\n      };\r\n      var isWithinCaretContainer = function (node) {\r\n        return isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\r\n      };\r\n      var isRangeInCaretContainer = function (rng) {\r\n        return isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\r\n      };\r\n      var normalizeShortEndedElementSelection = function (rng) {\r\n        var shortEndedElements = editor.schema.getShortEndedElements();\r\n        var newRng = dom.createRng();\r\n        var startContainer = rng.startContainer;\r\n        var startOffset = rng.startOffset;\r\n        var endContainer = rng.endContainer;\r\n        var endOffset = rng.endOffset;\r\n        if (has$2(shortEndedElements, startContainer.nodeName.toLowerCase())) {\r\n          if (startOffset === 0) {\r\n            newRng.setStartBefore(startContainer);\r\n          } else {\r\n            newRng.setStartAfter(startContainer);\r\n          }\r\n        } else {\r\n          newRng.setStart(startContainer, startOffset);\r\n        }\r\n        if (has$2(shortEndedElements, endContainer.nodeName.toLowerCase())) {\r\n          if (endOffset === 0) {\r\n            newRng.setEndBefore(endContainer);\r\n          } else {\r\n            newRng.setEndAfter(endContainer);\r\n          }\r\n        } else {\r\n          newRng.setEnd(endContainer, endOffset);\r\n        }\r\n        return newRng;\r\n      };\r\n      var setupOffscreenSelection = function (node, targetClone, origTargetClone) {\r\n        var $ = editor.$;\r\n        var $realSelectionContainer = descendant(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).fold(function () {\r\n          return $([]);\r\n        }, function (elm) {\r\n          return $([elm.dom]);\r\n        });\r\n        if ($realSelectionContainer.length === 0) {\r\n          $realSelectionContainer = $('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>').attr('id', realSelectionId);\r\n          $realSelectionContainer.appendTo(editor.getBody());\r\n        }\r\n        var newRange = dom.createRng();\r\n        if (targetClone === origTargetClone && Env.ie) {\r\n          $realSelectionContainer.empty().append('<p style=\"font-size: 0\" data-mce-bogus=\"all\">\\xA0</p>').append(targetClone);\r\n          newRange.setStartAfter($realSelectionContainer[0].firstChild.firstChild);\r\n          newRange.setEndAfter(targetClone);\r\n        } else {\r\n          $realSelectionContainer.empty().append(nbsp).append(targetClone).append(nbsp);\r\n          newRange.setStart($realSelectionContainer[0].firstChild, 1);\r\n          newRange.setEnd($realSelectionContainer[0].lastChild, 0);\r\n        }\r\n        $realSelectionContainer.css({ top: dom.getPos(node, editor.getBody()).y });\r\n        $realSelectionContainer[0].focus();\r\n        var sel = selection.getSel();\r\n        sel.removeAllRanges();\r\n        sel.addRange(newRange);\r\n        return newRange;\r\n      };\r\n      var selectElement = function (elm) {\r\n        var targetClone = elm.cloneNode(true);\r\n        var e = editor.fire('ObjectSelected', {\r\n          target: elm,\r\n          targetClone: targetClone\r\n        });\r\n        if (e.isDefaultPrevented()) {\r\n          return null;\r\n        }\r\n        var range = setupOffscreenSelection(elm, e.targetClone, targetClone);\r\n        var nodeElm = SugarElement.fromDom(elm);\r\n        each$k(descendants(SugarElement.fromDom(editor.getBody()), '*[data-mce-selected]'), function (elm) {\r\n          if (!eq(nodeElm, elm)) {\r\n            remove$6(elm, elementSelectionAttr);\r\n          }\r\n        });\r\n        if (!dom.getAttrib(elm, elementSelectionAttr)) {\r\n          elm.setAttribute(elementSelectionAttr, '1');\r\n        }\r\n        selectedElement = elm;\r\n        hideFakeCaret();\r\n        return range;\r\n      };\r\n      var setElementSelection = function (range, forward) {\r\n        if (!range) {\r\n          return null;\r\n        }\r\n        if (range.collapsed) {\r\n          if (!isRangeInCaretContainer(range)) {\r\n            var dir = forward ? 1 : -1;\r\n            var caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\r\n            var beforeNode = caretPosition.getNode(!forward);\r\n            if (isFakeCaretTarget(beforeNode)) {\r\n              return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\r\n            }\r\n            var afterNode = caretPosition.getNode(forward);\r\n            if (isFakeCaretTarget(afterNode)) {\r\n              return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n        var startContainer = range.startContainer;\r\n        var startOffset = range.startOffset;\r\n        var endOffset = range.endOffset;\r\n        if (startContainer.nodeType === 3 && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\r\n          startContainer = startContainer.parentNode;\r\n          startOffset = dom.nodeIndex(startContainer);\r\n          startContainer = startContainer.parentNode;\r\n        }\r\n        if (startContainer.nodeType !== 1) {\r\n          return null;\r\n        }\r\n        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\r\n          var node = startContainer.childNodes[startOffset];\r\n          if (isFakeSelectionTargetElement(node)) {\r\n            return selectElement(node);\r\n          }\r\n        }\r\n        return null;\r\n      };\r\n      var removeElementSelection = function () {\r\n        if (selectedElement) {\r\n          selectedElement.removeAttribute(elementSelectionAttr);\r\n        }\r\n        descendant(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$7);\r\n        selectedElement = null;\r\n      };\r\n      var destroy = function () {\r\n        fakeCaret.destroy();\r\n        selectedElement = null;\r\n      };\r\n      var hideFakeCaret = function () {\r\n        fakeCaret.hide();\r\n      };\r\n      if (Env.ceFalse && !isRtc(editor)) {\r\n        registerEvents();\r\n      }\r\n      return {\r\n        showCaret: showCaret,\r\n        showBlockCaretContainer: showBlockCaretContainer,\r\n        hideFakeCaret: hideFakeCaret,\r\n        destroy: destroy\r\n      };\r\n    };\r\n\r\n    var Quirks = function (editor) {\r\n      var each = Tools.each;\r\n      var BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;\r\n      var isGecko = Env.gecko, isIE = Env.ie, isWebKit = Env.webkit;\r\n      var mceInternalUrlPrefix = 'data:text/mce-internal,';\r\n      var mceInternalDataType = isIE ? 'Text' : 'URL';\r\n      var setEditorCommandState = function (cmd, state) {\r\n        try {\r\n          editor.getDoc().execCommand(cmd, false, state);\r\n        } catch (ex) {\r\n        }\r\n      };\r\n      var isDefaultPrevented = function (e) {\r\n        return e.isDefaultPrevented();\r\n      };\r\n      var setMceInternalContent = function (e) {\r\n        var selectionHtml, internalContent;\r\n        if (e.dataTransfer) {\r\n          if (editor.selection.isCollapsed() && e.target.tagName === 'IMG') {\r\n            selection.select(e.target);\r\n          }\r\n          selectionHtml = editor.selection.getContent();\r\n          if (selectionHtml.length > 0) {\r\n            internalContent = mceInternalUrlPrefix + escape(editor.id) + ',' + escape(selectionHtml);\r\n            e.dataTransfer.setData(mceInternalDataType, internalContent);\r\n          }\r\n        }\r\n      };\r\n      var getMceInternalContent = function (e) {\r\n        var internalContent;\r\n        if (e.dataTransfer) {\r\n          internalContent = e.dataTransfer.getData(mceInternalDataType);\r\n          if (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {\r\n            internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(',');\r\n            return {\r\n              id: unescape(internalContent[0]),\r\n              html: unescape(internalContent[1])\r\n            };\r\n          }\r\n        }\r\n        return null;\r\n      };\r\n      var insertClipboardContents = function (content, internal) {\r\n        if (editor.queryCommandSupported('mceInsertClipboardContent')) {\r\n          editor.execCommand('mceInsertClipboardContent', false, {\r\n            content: content,\r\n            internal: internal\r\n          });\r\n        } else {\r\n          editor.execCommand('mceInsertContent', false, content);\r\n        }\r\n      };\r\n      var emptyEditorWhenDeleting = function () {\r\n        var serializeRng = function (rng) {\r\n          var body = dom.create('body');\r\n          var contents = rng.cloneContents();\r\n          body.appendChild(contents);\r\n          return selection.serializer.serialize(body, { format: 'html' });\r\n        };\r\n        var allContentsSelected = function (rng) {\r\n          var selection = serializeRng(rng);\r\n          var allRng = dom.createRng();\r\n          allRng.selectNode(editor.getBody());\r\n          var allSelection = serializeRng(allRng);\r\n          return selection === allSelection;\r\n        };\r\n        editor.on('keydown', function (e) {\r\n          var keyCode = e.keyCode;\r\n          var isCollapsed, body;\r\n          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE)) {\r\n            isCollapsed = editor.selection.isCollapsed();\r\n            body = editor.getBody();\r\n            if (isCollapsed && !dom.isEmpty(body)) {\r\n              return;\r\n            }\r\n            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\r\n              return;\r\n            }\r\n            e.preventDefault();\r\n            editor.setContent('');\r\n            if (body.firstChild && dom.isBlock(body.firstChild)) {\r\n              editor.selection.setCursorLocation(body.firstChild, 0);\r\n            } else {\r\n              editor.selection.setCursorLocation(body, 0);\r\n            }\r\n            editor.nodeChanged();\r\n          }\r\n        });\r\n      };\r\n      var selectAll = function () {\r\n        editor.shortcuts.add('meta+a', null, 'SelectAll');\r\n      };\r\n      var documentElementEditingFocus = function () {\r\n        if (!editor.inline) {\r\n          dom.bind(editor.getDoc(), 'mousedown mouseup', function (e) {\r\n            var rng;\r\n            if (e.target === editor.getDoc().documentElement) {\r\n              rng = selection.getRng();\r\n              editor.getBody().focus();\r\n              if (e.type === 'mousedown') {\r\n                if (isCaretContainer$2(rng.startContainer)) {\r\n                  return;\r\n                }\r\n                selection.placeCaretAt(e.clientX, e.clientY);\r\n              } else {\r\n                selection.setRng(rng);\r\n              }\r\n            }\r\n          });\r\n        }\r\n      };\r\n      var removeHrOnBackspace = function () {\r\n        editor.on('keydown', function (e) {\r\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\r\n            if (!editor.getBody().getElementsByTagName('hr').length) {\r\n              return;\r\n            }\r\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\r\n              var node = selection.getNode();\r\n              var previousSibling = node.previousSibling;\r\n              if (node.nodeName === 'HR') {\r\n                dom.remove(node);\r\n                e.preventDefault();\r\n                return;\r\n              }\r\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\r\n                dom.remove(previousSibling);\r\n                e.preventDefault();\r\n              }\r\n            }\r\n          }\r\n        });\r\n      };\r\n      var focusBody = function () {\r\n        if (!Range.prototype.getClientRects) {\r\n          editor.on('mousedown', function (e) {\r\n            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\r\n              var body_1 = editor.getBody();\r\n              body_1.blur();\r\n              Delay.setEditorTimeout(editor, function () {\r\n                body_1.focus();\r\n              });\r\n            }\r\n          });\r\n        }\r\n      };\r\n      var selectControlElements = function () {\r\n        editor.on('click', function (e) {\r\n          var target = e.target;\r\n          if (/^(IMG|HR)$/.test(target.nodeName) && dom.getContentEditableParent(target) !== 'false') {\r\n            e.preventDefault();\r\n            editor.selection.select(target);\r\n            editor.nodeChanged();\r\n          }\r\n          if (target.nodeName === 'A' && dom.hasClass(target, 'mce-item-anchor')) {\r\n            e.preventDefault();\r\n            selection.select(target);\r\n          }\r\n        });\r\n      };\r\n      var removeStylesWhenDeletingAcrossBlockElements = function () {\r\n        var getAttributeApplyFunction = function () {\r\n          var template = dom.getAttribs(selection.getStart().cloneNode(false));\r\n          return function () {\r\n            var target = selection.getStart();\r\n            if (target !== editor.getBody()) {\r\n              dom.setAttrib(target, 'style', null);\r\n              each(template, function (attr) {\r\n                target.setAttributeNode(attr.cloneNode(true));\r\n              });\r\n            }\r\n          };\r\n        };\r\n        var isSelectionAcrossElements = function () {\r\n          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\r\n        };\r\n        editor.on('keypress', function (e) {\r\n          var applyAttributes;\r\n          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\r\n            applyAttributes = getAttributeApplyFunction();\r\n            editor.getDoc().execCommand('delete', false, null);\r\n            applyAttributes();\r\n            e.preventDefault();\r\n            return false;\r\n          }\r\n        });\r\n        dom.bind(editor.getDoc(), 'cut', function (e) {\r\n          var applyAttributes;\r\n          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\r\n            applyAttributes = getAttributeApplyFunction();\r\n            Delay.setEditorTimeout(editor, function () {\r\n              applyAttributes();\r\n            });\r\n          }\r\n        });\r\n      };\r\n      var disableBackspaceIntoATable = function () {\r\n        editor.on('keydown', function (e) {\r\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\r\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\r\n              var previousSibling = selection.getNode().previousSibling;\r\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\r\n                e.preventDefault();\r\n                return false;\r\n              }\r\n            }\r\n          }\r\n        });\r\n      };\r\n      var removeBlockQuoteOnBackSpace = function () {\r\n        editor.on('keydown', function (e) {\r\n          var rng, parent;\r\n          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\r\n            return;\r\n          }\r\n          rng = selection.getRng();\r\n          var container = rng.startContainer;\r\n          var offset = rng.startOffset;\r\n          var root = dom.getRoot();\r\n          parent = container;\r\n          if (!rng.collapsed || offset !== 0) {\r\n            return;\r\n          }\r\n          while (parent && parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\r\n            parent = parent.parentNode;\r\n          }\r\n          if (parent.tagName === 'BLOCKQUOTE') {\r\n            editor.formatter.toggle('blockquote', null, parent);\r\n            rng = dom.createRng();\r\n            rng.setStart(container, 0);\r\n            rng.setEnd(container, 0);\r\n            selection.setRng(rng);\r\n          }\r\n        });\r\n      };\r\n      var setGeckoEditingOptions = function () {\r\n        var setOpts = function () {\r\n          setEditorCommandState('StyleWithCSS', false);\r\n          setEditorCommandState('enableInlineTableEditing', false);\r\n          if (!getObjectResizing(editor)) {\r\n            setEditorCommandState('enableObjectResizing', false);\r\n          }\r\n        };\r\n        if (!isReadOnly$1(editor)) {\r\n          editor.on('BeforeExecCommand mousedown', setOpts);\r\n        }\r\n      };\r\n      var addBrAfterLastLinks = function () {\r\n        var fixLinks = function () {\r\n          each(dom.select('a'), function (node) {\r\n            var parentNode = node.parentNode;\r\n            var root = dom.getRoot();\r\n            if (parentNode.lastChild === node) {\r\n              while (parentNode && !dom.isBlock(parentNode)) {\r\n                if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {\r\n                  return;\r\n                }\r\n                parentNode = parentNode.parentNode;\r\n              }\r\n              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });\r\n            }\r\n          });\r\n        };\r\n        editor.on('SetContent ExecCommand', function (e) {\r\n          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\r\n            fixLinks();\r\n          }\r\n        });\r\n      };\r\n      var setDefaultBlockType = function () {\r\n        if (getForcedRootBlock(editor)) {\r\n          editor.on('init', function () {\r\n            setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\r\n          });\r\n        }\r\n      };\r\n      var normalizeSelection = function () {\r\n        editor.on('keyup focusin mouseup', function (e) {\r\n          if (!VK.modifierPressed(e)) {\r\n            selection.normalize();\r\n          }\r\n        }, true);\r\n      };\r\n      var showBrokenImageIcon = function () {\r\n        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\r\n      };\r\n      var restoreFocusOnKeyDown = function () {\r\n        if (!editor.inline) {\r\n          editor.on('keydown', function () {\r\n            if (document.activeElement === document.body) {\r\n              editor.getWin().focus();\r\n            }\r\n          });\r\n        }\r\n      };\r\n      var bodyHeight = function () {\r\n        if (!editor.inline) {\r\n          editor.contentStyles.push('body {min-height: 150px}');\r\n          editor.on('click', function (e) {\r\n            var rng;\r\n            if (e.target.nodeName === 'HTML') {\r\n              if (Env.ie > 11) {\r\n                editor.getBody().focus();\r\n                return;\r\n              }\r\n              rng = editor.selection.getRng();\r\n              editor.getBody().focus();\r\n              editor.selection.setRng(rng);\r\n              editor.selection.normalize();\r\n              editor.nodeChanged();\r\n            }\r\n          });\r\n        }\r\n      };\r\n      var blockCmdArrowNavigation = function () {\r\n        if (Env.mac) {\r\n          editor.on('keydown', function (e) {\r\n            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\r\n              e.preventDefault();\r\n              var selection_1 = editor.selection.getSel();\r\n              selection_1.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\r\n            }\r\n          });\r\n        }\r\n      };\r\n      var disableAutoUrlDetect = function () {\r\n        setEditorCommandState('AutoUrlDetect', false);\r\n      };\r\n      var tapLinksAndImages = function () {\r\n        editor.on('click', function (e) {\r\n          var elm = e.target;\r\n          do {\r\n            if (elm.tagName === 'A') {\r\n              e.preventDefault();\r\n              return;\r\n            }\r\n          } while (elm = elm.parentNode);\r\n        });\r\n        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\r\n      };\r\n      var blockFormSubmitInsideEditor = function () {\r\n        editor.on('init', function () {\r\n          editor.dom.bind(editor.getBody(), 'submit', function (e) {\r\n            e.preventDefault();\r\n          });\r\n        });\r\n      };\r\n      var removeAppleInterchangeBrs = function () {\r\n        parser.addNodeFilter('br', function (nodes) {\r\n          var i = nodes.length;\r\n          while (i--) {\r\n            if (nodes[i].attr('class') === 'Apple-interchange-newline') {\r\n              nodes[i].remove();\r\n            }\r\n          }\r\n        });\r\n      };\r\n      var ieInternalDragAndDrop = function () {\r\n        editor.on('dragstart', function (e) {\r\n          setMceInternalContent(e);\r\n        });\r\n        editor.on('drop', function (e) {\r\n          if (!isDefaultPrevented(e)) {\r\n            var internalContent = getMceInternalContent(e);\r\n            if (internalContent && internalContent.id !== editor.id) {\r\n              e.preventDefault();\r\n              var rng = fromPoint(e.x, e.y, editor.getDoc());\r\n              selection.setRng(rng);\r\n              insertClipboardContents(internalContent.html, true);\r\n            }\r\n          }\r\n        });\r\n      };\r\n      var refreshContentEditable = noop;\r\n      var isHidden = function () {\r\n        if (!isGecko || editor.removed) {\r\n          return false;\r\n        }\r\n        var sel = editor.selection.getSel();\r\n        return !sel || !sel.rangeCount || sel.rangeCount === 0;\r\n      };\r\n      var setupRtc = function () {\r\n        if (isWebKit) {\r\n          documentElementEditingFocus();\r\n          selectControlElements();\r\n          blockFormSubmitInsideEditor();\r\n          selectAll();\r\n          if (Env.iOS) {\r\n            restoreFocusOnKeyDown();\r\n            bodyHeight();\r\n            tapLinksAndImages();\r\n          }\r\n        }\r\n        if (isGecko) {\r\n          focusBody();\r\n          setGeckoEditingOptions();\r\n          showBrokenImageIcon();\r\n          blockCmdArrowNavigation();\r\n        }\r\n      };\r\n      var setup = function () {\r\n        removeBlockQuoteOnBackSpace();\r\n        emptyEditorWhenDeleting();\r\n        if (!Env.windowsPhone) {\r\n          normalizeSelection();\r\n        }\r\n        if (isWebKit) {\r\n          documentElementEditingFocus();\r\n          selectControlElements();\r\n          setDefaultBlockType();\r\n          blockFormSubmitInsideEditor();\r\n          disableBackspaceIntoATable();\r\n          removeAppleInterchangeBrs();\r\n          if (Env.iOS) {\r\n            restoreFocusOnKeyDown();\r\n            bodyHeight();\r\n            tapLinksAndImages();\r\n          } else {\r\n            selectAll();\r\n          }\r\n        }\r\n        if (Env.ie >= 11) {\r\n          bodyHeight();\r\n          disableBackspaceIntoATable();\r\n        }\r\n        if (Env.ie) {\r\n          selectAll();\r\n          disableAutoUrlDetect();\r\n          ieInternalDragAndDrop();\r\n        }\r\n        if (isGecko) {\r\n          removeHrOnBackspace();\r\n          focusBody();\r\n          removeStylesWhenDeletingAcrossBlockElements();\r\n          setGeckoEditingOptions();\r\n          addBrAfterLastLinks();\r\n          showBrokenImageIcon();\r\n          blockCmdArrowNavigation();\r\n          disableBackspaceIntoATable();\r\n        }\r\n      };\r\n      if (isRtc(editor)) {\r\n        setupRtc();\r\n      } else {\r\n        setup();\r\n      }\r\n      return {\r\n        refreshContentEditable: refreshContentEditable,\r\n        isHidden: isHidden\r\n      };\r\n    };\r\n\r\n    var DOM$6 = DOMUtils.DOM;\r\n    var appendStyle = function (editor, text) {\r\n      var body = SugarElement.fromDom(editor.getBody());\r\n      var container = getStyleContainer(getRootNode(body));\r\n      var style = SugarElement.fromTag('style');\r\n      set$1(style, 'type', 'text/css');\r\n      append$1(style, SugarElement.fromText(text));\r\n      append$1(container, style);\r\n      editor.on('remove', function () {\r\n        remove$7(style);\r\n      });\r\n    };\r\n    var getRootName = function (editor) {\r\n      return editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\r\n    };\r\n    var removeUndefined = function (obj) {\r\n      return filter$3(obj, function (v) {\r\n        return isUndefined(v) === false;\r\n      });\r\n    };\r\n    var mkSchemaSettings = function (editor) {\r\n      var settings = editor.settings;\r\n      return removeUndefined({\r\n        block_elements: settings.block_elements,\r\n        boolean_attributes: settings.boolean_attributes,\r\n        custom_elements: settings.custom_elements,\r\n        extended_valid_elements: settings.extended_valid_elements,\r\n        invalid_elements: settings.invalid_elements,\r\n        invalid_styles: settings.invalid_styles,\r\n        move_caret_before_on_enter_elements: settings.move_caret_before_on_enter_elements,\r\n        non_empty_elements: settings.non_empty_elements,\r\n        schema: settings.schema,\r\n        self_closing_elements: settings.self_closing_elements,\r\n        short_ended_elements: settings.short_ended_elements,\r\n        special: settings.special,\r\n        text_block_elements: settings.text_block_elements,\r\n        text_inline_elements: settings.text_inline_elements,\r\n        valid_children: settings.valid_children,\r\n        valid_classes: settings.valid_classes,\r\n        valid_elements: settings.valid_elements,\r\n        valid_styles: settings.valid_styles,\r\n        verify_html: settings.verify_html,\r\n        whitespace_elements: settings.whitespace_elements,\r\n        padd_empty_block_inline_children: settings.format_empty_lines\r\n      });\r\n    };\r\n    var mkParserSettings = function (editor) {\r\n      var settings = editor.settings;\r\n      var blobCache = editor.editorUpload.blobCache;\r\n      return removeUndefined({\r\n        allow_conditional_comments: settings.allow_conditional_comments,\r\n        allow_html_data_urls: settings.allow_html_data_urls,\r\n        allow_svg_data_urls: settings.allow_svg_data_urls,\r\n        allow_html_in_named_anchor: settings.allow_html_in_named_anchor,\r\n        allow_script_urls: settings.allow_script_urls,\r\n        allow_unsafe_link_target: settings.allow_unsafe_link_target,\r\n        convert_fonts_to_spans: settings.convert_fonts_to_spans,\r\n        fix_list_elements: settings.fix_list_elements,\r\n        font_size_legacy_values: settings.font_size_legacy_values,\r\n        forced_root_block: settings.forced_root_block,\r\n        forced_root_block_attrs: settings.forced_root_block_attrs,\r\n        padd_empty_with_br: settings.padd_empty_with_br,\r\n        preserve_cdata: settings.preserve_cdata,\r\n        remove_trailing_brs: settings.remove_trailing_brs,\r\n        inline_styles: settings.inline_styles,\r\n        root_name: getRootName(editor),\r\n        validate: true,\r\n        blob_cache: blobCache,\r\n        document: editor.getDoc(),\r\n        images_dataimg_filter: settings.images_dataimg_filter\r\n      });\r\n    };\r\n    var mkSerializerSettings = function (editor) {\r\n      var settings = editor.settings;\r\n      return __assign(__assign(__assign({}, mkParserSettings(editor)), mkSchemaSettings(editor)), removeUndefined({\r\n        url_converter: settings.url_converter,\r\n        url_converter_scope: settings.url_converter_scope,\r\n        element_format: settings.element_format,\r\n        entities: settings.entities,\r\n        entity_encoding: settings.entity_encoding,\r\n        indent: settings.indent,\r\n        indent_after: settings.indent_after,\r\n        indent_before: settings.indent_before\r\n      }));\r\n    };\r\n    var createParser = function (editor) {\r\n      var parser = DomParser(mkParserSettings(editor), editor.schema);\r\n      parser.addAttributeFilter('src,href,style,tabindex', function (nodes, name) {\r\n        var i = nodes.length, node, value;\r\n        var dom = editor.dom;\r\n        var internalName = 'data-mce-' + name;\r\n        while (i--) {\r\n          node = nodes[i];\r\n          value = node.attr(name);\r\n          if (value && !node.attr(internalName)) {\r\n            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\r\n              continue;\r\n            }\r\n            if (name === 'style') {\r\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\r\n              if (!value.length) {\r\n                value = null;\r\n              }\r\n              node.attr(internalName, value);\r\n              node.attr(name, value);\r\n            } else if (name === 'tabindex') {\r\n              node.attr(internalName, value);\r\n              node.attr(name, null);\r\n            } else {\r\n              node.attr(internalName, editor.convertURL(value, name, node.name));\r\n            }\r\n          }\r\n        }\r\n      });\r\n      parser.addNodeFilter('script', function (nodes) {\r\n        var i = nodes.length;\r\n        while (i--) {\r\n          var node = nodes[i];\r\n          var type = node.attr('type') || 'no/type';\r\n          if (type.indexOf('mce-') !== 0) {\r\n            node.attr('type', 'mce-' + type);\r\n          }\r\n        }\r\n      });\r\n      if (editor.settings.preserve_cdata) {\r\n        parser.addNodeFilter('#cdata', function (nodes) {\r\n          var i = nodes.length;\r\n          while (i--) {\r\n            var node = nodes[i];\r\n            node.type = 8;\r\n            node.name = '#comment';\r\n            node.value = '[CDATA[' + editor.dom.encode(node.value) + ']]';\r\n          }\r\n        });\r\n      }\r\n      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function (nodes) {\r\n        var i = nodes.length;\r\n        var nonEmptyElements = editor.schema.getNonEmptyElements();\r\n        while (i--) {\r\n          var node = nodes[i];\r\n          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\r\n            node.append(new AstNode('br', 1)).shortEnded = true;\r\n          }\r\n        }\r\n      });\r\n      return parser;\r\n    };\r\n    var autoFocus = function (editor) {\r\n      if (editor.settings.auto_focus) {\r\n        Delay.setEditorTimeout(editor, function () {\r\n          var focusEditor;\r\n          if (editor.settings.auto_focus === true) {\r\n            focusEditor = editor;\r\n          } else {\r\n            focusEditor = editor.editorManager.get(editor.settings.auto_focus);\r\n          }\r\n          if (!focusEditor.destroyed) {\r\n            focusEditor.focus();\r\n          }\r\n        }, 100);\r\n      }\r\n    };\r\n    var moveSelectionToFirstCaretPosition = function (editor) {\r\n      var root = editor.dom.getRoot();\r\n      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\r\n        firstPositionIn(root).each(function (pos) {\r\n          var node = pos.getNode();\r\n          var caretPos = isTable$3(node) ? firstPositionIn(node).getOr(pos) : pos;\r\n          if (Env.browser.isIE()) {\r\n            storeNative(editor, caretPos.toRange());\r\n          } else {\r\n            editor.selection.setRng(caretPos.toRange());\r\n          }\r\n        });\r\n      }\r\n    };\r\n    var initEditor = function (editor) {\r\n      editor.bindPendingEventDelegates();\r\n      editor.initialized = true;\r\n      fireInit(editor);\r\n      editor.focus(true);\r\n      moveSelectionToFirstCaretPosition(editor);\r\n      editor.nodeChanged({ initial: true });\r\n      editor.execCallback('init_instance_callback', editor);\r\n      autoFocus(editor);\r\n    };\r\n    var getStyleSheetLoader$1 = function (editor) {\r\n      return editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\r\n    };\r\n    var makeStylesheetLoadingPromises = function (editor, css, framedFonts) {\r\n      var promises = [new promiseObj(function (resolve, reject) {\r\n          return getStyleSheetLoader$1(editor).loadAll(css, resolve, reject);\r\n        })];\r\n      if (editor.inline) {\r\n        return promises;\r\n      } else {\r\n        return promises.concat([new promiseObj(function (resolve, reject) {\r\n            return editor.ui.styleSheetLoader.loadAll(framedFonts, resolve, reject);\r\n          })]);\r\n      }\r\n    };\r\n    var loadContentCss = function (editor) {\r\n      var styleSheetLoader = getStyleSheetLoader$1(editor);\r\n      var fontCss = getFontCss(editor);\r\n      var css = editor.contentCSS;\r\n      var removeCss = function () {\r\n        styleSheetLoader.unloadAll(css);\r\n        if (!editor.inline) {\r\n          editor.ui.styleSheetLoader.unloadAll(fontCss);\r\n        }\r\n      };\r\n      var loaded = function () {\r\n        if (editor.removed) {\r\n          removeCss();\r\n        } else {\r\n          editor.on('remove', removeCss);\r\n        }\r\n      };\r\n      if (editor.contentStyles.length > 0) {\r\n        var contentCssText_1 = '';\r\n        Tools.each(editor.contentStyles, function (style) {\r\n          contentCssText_1 += style + '\\r\\n';\r\n        });\r\n        editor.dom.addStyle(contentCssText_1);\r\n      }\r\n      var allStylesheets = promiseObj.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\r\n      if (editor.settings.content_style) {\r\n        appendStyle(editor, editor.settings.content_style);\r\n      }\r\n      return allStylesheets;\r\n    };\r\n    var preInit = function (editor) {\r\n      var settings = editor.settings, doc = editor.getDoc(), body = editor.getBody();\r\n      firePreInit(editor);\r\n      if (!settings.browser_spellcheck && !settings.gecko_spellcheck) {\r\n        doc.body.spellcheck = false;\r\n        DOM$6.setAttrib(body, 'spellcheck', 'false');\r\n      }\r\n      editor.quirks = Quirks(editor);\r\n      firePostRender(editor);\r\n      var directionality = getDirectionality(editor);\r\n      if (directionality !== undefined) {\r\n        body.dir = directionality;\r\n      }\r\n      if (settings.protect) {\r\n        editor.on('BeforeSetContent', function (e) {\r\n          Tools.each(settings.protect, function (pattern) {\r\n            e.content = e.content.replace(pattern, function (str) {\r\n              return '<!--mce:protected ' + escape(str) + '-->';\r\n            });\r\n          });\r\n        });\r\n      }\r\n      editor.on('SetContent', function () {\r\n        editor.addVisual(editor.getBody());\r\n      });\r\n      editor.on('compositionstart compositionend', function (e) {\r\n        editor.composing = e.type === 'compositionstart';\r\n      });\r\n    };\r\n    var loadInitialContent = function (editor) {\r\n      if (!isRtc(editor)) {\r\n        editor.load({\r\n          initial: true,\r\n          format: 'html'\r\n        });\r\n      }\r\n      editor.startContent = editor.getContent({ format: 'raw' });\r\n    };\r\n    var initEditorWithInitialContent = function (editor) {\r\n      if (editor.removed !== true) {\r\n        loadInitialContent(editor);\r\n        initEditor(editor);\r\n      }\r\n    };\r\n    var initContentBody = function (editor, skipWrite) {\r\n      var settings = editor.settings;\r\n      var targetElm = editor.getElement();\r\n      var doc = editor.getDoc();\r\n      if (!settings.inline) {\r\n        editor.getElement().style.visibility = editor.orgVisibility;\r\n      }\r\n      if (!skipWrite && !editor.inline) {\r\n        doc.open();\r\n        doc.write(editor.iframeHTML);\r\n        doc.close();\r\n      }\r\n      if (editor.inline) {\r\n        DOM$6.addClass(targetElm, 'mce-content-body');\r\n        editor.contentDocument = doc = document;\r\n        editor.contentWindow = window;\r\n        editor.bodyElement = targetElm;\r\n        editor.contentAreaContainer = targetElm;\r\n      }\r\n      var body = editor.getBody();\r\n      body.disabled = true;\r\n      editor.readonly = !!settings.readonly;\r\n      if (!editor.readonly) {\r\n        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\r\n          body.style.position = 'relative';\r\n        }\r\n        body.contentEditable = editor.getParam('content_editable_state', true);\r\n      }\r\n      body.disabled = false;\r\n      editor.editorUpload = EditorUpload(editor);\r\n      editor.schema = Schema(mkSchemaSettings(editor));\r\n      editor.dom = DOMUtils(doc, {\r\n        keep_values: true,\r\n        url_converter: editor.convertURL,\r\n        url_converter_scope: editor,\r\n        hex_colors: settings.force_hex_style_colors,\r\n        update_styles: true,\r\n        root_element: editor.inline ? editor.getBody() : null,\r\n        collect: function () {\r\n          return editor.inline;\r\n        },\r\n        schema: editor.schema,\r\n        contentCssCors: shouldUseContentCssCors(editor),\r\n        referrerPolicy: getReferrerPolicy(editor),\r\n        onSetAttrib: function (e) {\r\n          editor.fire('SetAttrib', e);\r\n        }\r\n      });\r\n      editor.parser = createParser(editor);\r\n      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\r\n      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\r\n      editor.annotator = Annotator(editor);\r\n      editor.formatter = Formatter(editor);\r\n      editor.undoManager = UndoManager(editor);\r\n      editor._nodeChangeDispatcher = new NodeChange(editor);\r\n      editor._selectionOverrides = SelectionOverrides(editor);\r\n      setup$e(editor);\r\n      setup$3(editor);\r\n      if (!isRtc(editor)) {\r\n        setup$2(editor);\r\n      }\r\n      var caret = setup$4(editor);\r\n      setup$f(editor, caret);\r\n      setup$d(editor);\r\n      setup$g(editor);\r\n      var setupRtcThunk = setup$i(editor);\r\n      preInit(editor);\r\n      setupRtcThunk.fold(function () {\r\n        loadContentCss(editor).then(function () {\r\n          return initEditorWithInitialContent(editor);\r\n        });\r\n      }, function (setupRtc) {\r\n        editor.setProgressState(true);\r\n        loadContentCss(editor).then(function () {\r\n          setupRtc().then(function (_rtcMode) {\r\n            editor.setProgressState(false);\r\n            initEditorWithInitialContent(editor);\r\n          }, function (err) {\r\n            editor.notificationManager.open({\r\n              type: 'error',\r\n              text: String(err)\r\n            });\r\n            initEditorWithInitialContent(editor);\r\n          });\r\n        });\r\n      });\r\n    };\r\n\r\n    var DOM$5 = DOMUtils.DOM;\r\n    var relaxDomain = function (editor, ifr) {\r\n      if (document.domain !== window.location.hostname && Env.browser.isIE()) {\r\n        var bodyUuid = uuid('mce');\r\n        editor[bodyUuid] = function () {\r\n          initContentBody(editor);\r\n        };\r\n        var domainRelaxUrl = 'javascript:(function(){' + 'document.open();document.domain=\"' + document.domain + '\";' + 'var ed = window.parent.tinymce.get(\"' + editor.id + '\");document.write(ed.iframeHTML);' + 'document.close();ed.' + bodyUuid + '(true);})()';\r\n        DOM$5.setAttrib(ifr, 'src', domainRelaxUrl);\r\n        return true;\r\n      }\r\n      return false;\r\n    };\r\n    var createIframeElement = function (id, title, height, customAttrs) {\r\n      var iframe = SugarElement.fromTag('iframe');\r\n      setAll$1(iframe, customAttrs);\r\n      setAll$1(iframe, {\r\n        id: id + '_ifr',\r\n        frameBorder: '0',\r\n        allowTransparency: 'true',\r\n        title: title\r\n      });\r\n      add$1(iframe, 'tox-edit-area__iframe');\r\n      return iframe;\r\n    };\r\n    var getIframeHtml = function (editor) {\r\n      var iframeHTML = getDocType(editor) + '<html><head>';\r\n      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\r\n        iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\r\n      }\r\n      iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\r\n      var bodyId = getBodyId(editor);\r\n      var bodyClass = getBodyClass(editor);\r\n      var translatedAriaText = editor.translate(getIframeAriaText(editor));\r\n      if (getContentSecurityPolicy(editor)) {\r\n        iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\r\n      }\r\n      iframeHTML += '</head>' + ('<body id=\"' + bodyId + '\" class=\"mce-content-body ' + bodyClass + '\" data-id=\"' + editor.id + '\" aria-label=\"' + translatedAriaText + '\">') + '<br>' + '</body></html>';\r\n      return iframeHTML;\r\n    };\r\n    var createIframe = function (editor, o) {\r\n      var iframeTitle = editor.translate('Rich Text Area');\r\n      var ifr = createIframeElement(editor.id, iframeTitle, o.height, getIframeAttrs(editor)).dom;\r\n      ifr.onload = function () {\r\n        ifr.onload = null;\r\n        editor.fire('load');\r\n      };\r\n      var isDomainRelaxed = relaxDomain(editor, ifr);\r\n      editor.contentAreaContainer = o.iframeContainer;\r\n      editor.iframeElement = ifr;\r\n      editor.iframeHTML = getIframeHtml(editor);\r\n      DOM$5.add(o.iframeContainer, ifr);\r\n      return isDomainRelaxed;\r\n    };\r\n    var init$1 = function (editor, boxInfo) {\r\n      var isDomainRelaxed = createIframe(editor, boxInfo);\r\n      if (boxInfo.editorContainer) {\r\n        DOM$5.get(boxInfo.editorContainer).style.display = editor.orgDisplay;\r\n        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\r\n      }\r\n      editor.getElement().style.display = 'none';\r\n      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\r\n      if (!isDomainRelaxed) {\r\n        initContentBody(editor);\r\n      }\r\n    };\r\n\r\n    var DOM$4 = DOMUtils.DOM;\r\n    var initPlugin = function (editor, initializedPlugins, plugin) {\r\n      var Plugin = PluginManager.get(plugin);\r\n      var pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\r\n      plugin = Tools.trim(plugin);\r\n      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\r\n        Tools.each(PluginManager.dependencies(plugin), function (dep) {\r\n          initPlugin(editor, initializedPlugins, dep);\r\n        });\r\n        if (editor.plugins[plugin]) {\r\n          return;\r\n        }\r\n        try {\r\n          var pluginInstance = new Plugin(editor, pluginUrl, editor.$);\r\n          editor.plugins[plugin] = pluginInstance;\r\n          if (pluginInstance.init) {\r\n            pluginInstance.init(editor, pluginUrl);\r\n            initializedPlugins.push(plugin);\r\n          }\r\n        } catch (e) {\r\n          pluginInitError(editor, plugin, e);\r\n        }\r\n      }\r\n    };\r\n    var trimLegacyPrefix = function (name) {\r\n      return name.replace(/^\\-/, '');\r\n    };\r\n    var initPlugins = function (editor) {\r\n      var initializedPlugins = [];\r\n      Tools.each(getPlugins(editor).split(/[ ,]/), function (name) {\r\n        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\r\n      });\r\n    };\r\n    var initIcons = function (editor) {\r\n      var iconPackName = Tools.trim(getIconPackName(editor));\r\n      var currentIcons = editor.ui.registry.getAll().icons;\r\n      var loadIcons = __assign(__assign({}, IconManager.get('default').icons), IconManager.get(iconPackName).icons);\r\n      each$j(loadIcons, function (svgData, icon) {\r\n        if (!has$2(currentIcons, icon)) {\r\n          editor.ui.registry.addIcon(icon, svgData);\r\n        }\r\n      });\r\n    };\r\n    var initTheme = function (editor) {\r\n      var theme = getTheme(editor);\r\n      if (isString$1(theme)) {\r\n        editor.settings.theme = trimLegacyPrefix(theme);\r\n        var Theme = ThemeManager.get(theme);\r\n        editor.theme = new Theme(editor, ThemeManager.urls[theme]);\r\n        if (editor.theme.init) {\r\n          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''), editor.$);\r\n        }\r\n      } else {\r\n        editor.theme = {};\r\n      }\r\n    };\r\n    var renderFromLoadedTheme = function (editor) {\r\n      return editor.theme.renderUI();\r\n    };\r\n    var renderFromThemeFunc = function (editor) {\r\n      var elm = editor.getElement();\r\n      var theme = getTheme(editor);\r\n      var info = theme(editor, elm);\r\n      if (info.editorContainer.nodeType) {\r\n        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\r\n      }\r\n      if (info.iframeContainer && info.iframeContainer.nodeType) {\r\n        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\r\n      }\r\n      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\r\n      return info;\r\n    };\r\n    var createThemeFalseResult = function (element) {\r\n      return {\r\n        editorContainer: element,\r\n        iframeContainer: element,\r\n        api: {}\r\n      };\r\n    };\r\n    var renderThemeFalseIframe = function (targetElement) {\r\n      var iframeContainer = DOM$4.create('div');\r\n      DOM$4.insertAfter(iframeContainer, targetElement);\r\n      return createThemeFalseResult(iframeContainer);\r\n    };\r\n    var renderThemeFalse = function (editor) {\r\n      var targetElement = editor.getElement();\r\n      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\r\n    };\r\n    var renderThemeUi = function (editor) {\r\n      var elm = editor.getElement();\r\n      editor.orgDisplay = elm.style.display;\r\n      if (isString$1(getTheme(editor))) {\r\n        return renderFromLoadedTheme(editor);\r\n      } else if (isFunction(getTheme(editor))) {\r\n        return renderFromThemeFunc(editor);\r\n      } else {\r\n        return renderThemeFalse(editor);\r\n      }\r\n    };\r\n    var augmentEditorUiApi = function (editor, api) {\r\n      var uiApiFacade = {\r\n        show: Optional.from(api.show).getOr(noop),\r\n        hide: Optional.from(api.hide).getOr(noop),\r\n        disable: Optional.from(api.disable).getOr(noop),\r\n        isDisabled: Optional.from(api.isDisabled).getOr(never),\r\n        enable: function () {\r\n          if (!editor.mode.isReadOnly()) {\r\n            Optional.from(api.enable).map(call);\r\n          }\r\n        }\r\n      };\r\n      editor.ui = __assign(__assign({}, editor.ui), uiApiFacade);\r\n    };\r\n    var init = function (editor) {\r\n      editor.fire('ScriptsLoaded');\r\n      initIcons(editor);\r\n      initTheme(editor);\r\n      initPlugins(editor);\r\n      var renderInfo = renderThemeUi(editor);\r\n      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\r\n      var boxInfo = {\r\n        editorContainer: renderInfo.editorContainer,\r\n        iframeContainer: renderInfo.iframeContainer\r\n      };\r\n      editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;\r\n      appendContentCssFromSettings(editor);\r\n      if (editor.inline) {\r\n        return initContentBody(editor);\r\n      } else {\r\n        return init$1(editor, boxInfo);\r\n      }\r\n    };\r\n\r\n    var DOM$3 = DOMUtils.DOM;\r\n    var hasSkipLoadPrefix = function (name) {\r\n      return name.charAt(0) === '-';\r\n    };\r\n    var loadLanguage = function (scriptLoader, editor) {\r\n      var languageCode = getLanguageCode(editor);\r\n      var languageUrl = getLanguageUrl(editor);\r\n      if (I18n.hasCode(languageCode) === false && languageCode !== 'en') {\r\n        var url_1 = languageUrl !== '' ? languageUrl : editor.editorManager.baseURL + '/langs/' + languageCode + '.js';\r\n        scriptLoader.add(url_1, noop, undefined, function () {\r\n          languageLoadError(editor, url_1, languageCode);\r\n        });\r\n      }\r\n    };\r\n    var loadTheme = function (scriptLoader, editor, suffix, callback) {\r\n      var theme = getTheme(editor);\r\n      if (isString$1(theme)) {\r\n        if (!hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\r\n          var themeUrl = getThemeUrl(editor);\r\n          if (themeUrl) {\r\n            ThemeManager.load(theme, editor.documentBaseURI.toAbsolute(themeUrl));\r\n          } else {\r\n            ThemeManager.load(theme, 'themes/' + theme + '/theme' + suffix + '.js');\r\n          }\r\n        }\r\n        scriptLoader.loadQueue(function () {\r\n          ThemeManager.waitFor(theme, callback);\r\n        });\r\n      } else {\r\n        callback();\r\n      }\r\n    };\r\n    var getIconsUrlMetaFromUrl = function (editor) {\r\n      return Optional.from(getIconsUrl(editor)).filter(function (url) {\r\n        return url.length > 0;\r\n      }).map(function (url) {\r\n        return {\r\n          url: url,\r\n          name: Optional.none()\r\n        };\r\n      });\r\n    };\r\n    var getIconsUrlMetaFromName = function (editor, name, suffix) {\r\n      return Optional.from(name).filter(function (name) {\r\n        return name.length > 0 && !IconManager.has(name);\r\n      }).map(function (name) {\r\n        return {\r\n          url: editor.editorManager.baseURL + '/icons/' + name + '/icons' + suffix + '.js',\r\n          name: Optional.some(name)\r\n        };\r\n      });\r\n    };\r\n    var loadIcons = function (scriptLoader, editor, suffix) {\r\n      var defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\r\n      var customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(function () {\r\n        return getIconsUrlMetaFromName(editor, getIconPackName(editor), '');\r\n      });\r\n      each$k(cat([\r\n        defaultIconsUrl,\r\n        customIconsUrl\r\n      ]), function (urlMeta) {\r\n        scriptLoader.add(urlMeta.url, noop, undefined, function () {\r\n          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\r\n        });\r\n      });\r\n    };\r\n    var loadPlugins = function (editor, suffix) {\r\n      Tools.each(getExternalPlugins$1(editor), function (url, name) {\r\n        PluginManager.load(name, url, noop, undefined, function () {\r\n          pluginLoadError(editor, url, name);\r\n        });\r\n        editor.settings.plugins += ' ' + name;\r\n      });\r\n      Tools.each(getPlugins(editor).split(/[ ,]/), function (plugin) {\r\n        plugin = Tools.trim(plugin);\r\n        if (plugin && !PluginManager.urls[plugin]) {\r\n          if (hasSkipLoadPrefix(plugin)) {\r\n            plugin = plugin.substr(1, plugin.length);\r\n            var dependencies = PluginManager.dependencies(plugin);\r\n            Tools.each(dependencies, function (depPlugin) {\r\n              var defaultSettings = {\r\n                prefix: 'plugins/',\r\n                resource: depPlugin,\r\n                suffix: '/plugin' + suffix + '.js'\r\n              };\r\n              var dep = PluginManager.createUrl(defaultSettings, depPlugin);\r\n              PluginManager.load(dep.resource, dep, noop, undefined, function () {\r\n                pluginLoadError(editor, dep.prefix + dep.resource + dep.suffix, dep.resource);\r\n              });\r\n            });\r\n          } else {\r\n            var url_2 = {\r\n              prefix: 'plugins/',\r\n              resource: plugin,\r\n              suffix: '/plugin' + suffix + '.js'\r\n            };\r\n            PluginManager.load(plugin, url_2, noop, undefined, function () {\r\n              pluginLoadError(editor, url_2.prefix + url_2.resource + url_2.suffix, plugin);\r\n            });\r\n          }\r\n        }\r\n      });\r\n    };\r\n    var loadScripts = function (editor, suffix) {\r\n      var scriptLoader = ScriptLoader.ScriptLoader;\r\n      loadTheme(scriptLoader, editor, suffix, function () {\r\n        loadLanguage(scriptLoader, editor);\r\n        loadIcons(scriptLoader, editor, suffix);\r\n        loadPlugins(editor, suffix);\r\n        scriptLoader.loadQueue(function () {\r\n          if (!editor.removed) {\r\n            init(editor);\r\n          }\r\n        }, editor, function () {\r\n          if (!editor.removed) {\r\n            init(editor);\r\n          }\r\n        });\r\n      });\r\n    };\r\n    var getStyleSheetLoader = function (element, editor) {\r\n      return instance.forElement(element, {\r\n        contentCssCors: hasContentCssCors(editor),\r\n        referrerPolicy: getReferrerPolicy(editor)\r\n      });\r\n    };\r\n    var render = function (editor) {\r\n      var id = editor.id;\r\n      I18n.setCode(getLanguageCode(editor));\r\n      var readyHandler = function () {\r\n        DOM$3.unbind(window, 'ready', readyHandler);\r\n        editor.render();\r\n      };\r\n      if (!EventUtils.Event.domLoaded) {\r\n        DOM$3.bind(window, 'ready', readyHandler);\r\n        return;\r\n      }\r\n      if (!editor.getElement()) {\r\n        return;\r\n      }\r\n      if (!Env.contentEditable) {\r\n        return;\r\n      }\r\n      var element = SugarElement.fromDom(editor.getElement());\r\n      var snapshot = clone$3(element);\r\n      editor.on('remove', function () {\r\n        eachr(element.dom.attributes, function (attr) {\r\n          return remove$6(element, attr.name);\r\n        });\r\n        setAll$1(element, snapshot);\r\n      });\r\n      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\r\n      if (!isInline(editor)) {\r\n        editor.orgVisibility = editor.getElement().style.visibility;\r\n        editor.getElement().style.visibility = 'hidden';\r\n      } else {\r\n        editor.inline = true;\r\n      }\r\n      var form = editor.getElement().form || DOM$3.getParent(id, 'form');\r\n      if (form) {\r\n        editor.formElement = form;\r\n        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\r\n          DOM$3.insertAfter(DOM$3.create('input', {\r\n            type: 'hidden',\r\n            name: id\r\n          }), id);\r\n          editor.hasHiddenInput = true;\r\n        }\r\n        editor.formEventDelegate = function (e) {\r\n          editor.fire(e.type, e);\r\n        };\r\n        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\r\n        editor.on('reset', function () {\r\n          editor.resetContent();\r\n        });\r\n        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\r\n          form._mceOldSubmit = form.submit;\r\n          form.submit = function () {\r\n            editor.editorManager.triggerSave();\r\n            editor.setDirty(false);\r\n            return form._mceOldSubmit(form);\r\n          };\r\n        }\r\n      }\r\n      editor.windowManager = WindowManager(editor);\r\n      editor.notificationManager = NotificationManager(editor);\r\n      if (isEncodingXml(editor)) {\r\n        editor.on('GetContent', function (e) {\r\n          if (e.save) {\r\n            e.content = DOM$3.encode(e.content);\r\n          }\r\n        });\r\n      }\r\n      if (shouldAddFormSubmitTrigger(editor)) {\r\n        editor.on('submit', function () {\r\n          if (editor.initialized) {\r\n            editor.save();\r\n          }\r\n        });\r\n      }\r\n      if (shouldAddUnloadTrigger(editor)) {\r\n        editor._beforeUnload = function () {\r\n          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\r\n            editor.save({\r\n              format: 'raw',\r\n              no_events: true,\r\n              set_dirty: false\r\n            });\r\n          }\r\n        };\r\n        editor.editorManager.on('BeforeUnload', editor._beforeUnload);\r\n      }\r\n      editor.editorManager.add(editor);\r\n      loadScripts(editor, editor.suffix);\r\n    };\r\n\r\n    var addVisual = function (editor, elm) {\r\n      return addVisual$1(editor, elm);\r\n    };\r\n\r\n    var legacyPropNames = {\r\n      'font-size': 'size',\r\n      'font-family': 'face'\r\n    };\r\n    var getSpecifiedFontProp = function (propName, rootElm, elm) {\r\n      var getProperty = function (elm) {\r\n        return getRaw(elm, propName).orThunk(function () {\r\n          if (name(elm) === 'font') {\r\n            return get$9(legacyPropNames, propName).bind(function (legacyPropName) {\r\n              return getOpt(elm, legacyPropName);\r\n            });\r\n          } else {\r\n            return Optional.none();\r\n          }\r\n        });\r\n      };\r\n      var isRoot = function (elm) {\r\n        return eq(SugarElement.fromDom(rootElm), elm);\r\n      };\r\n      return closest$1(SugarElement.fromDom(elm), function (elm) {\r\n        return getProperty(elm);\r\n      }, isRoot);\r\n    };\r\n    var normalizeFontFamily = function (fontFamily) {\r\n      return fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\r\n    };\r\n    var getComputedFontProp = function (propName, elm) {\r\n      return Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\r\n    };\r\n    var getFontProp = function (propName) {\r\n      return function (rootElm, elm) {\r\n        return Optional.from(elm).map(SugarElement.fromDom).filter(isElement$6).bind(function (element) {\r\n          return getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom));\r\n        }).getOr('');\r\n      };\r\n    };\r\n    var getFontSize = getFontProp('font-size');\r\n    var getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\r\n\r\n    var findFirstCaretElement = function (editor) {\r\n      return firstPositionIn(editor.getBody()).map(function (caret) {\r\n        var container = caret.container();\r\n        return isText$7(container) ? container.parentNode : container;\r\n      });\r\n    };\r\n    var getCaretElement = function (editor) {\r\n      return Optional.from(editor.selection.getRng()).bind(function (rng) {\r\n        var root = editor.getBody();\r\n        var atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\r\n        return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\r\n      });\r\n    };\r\n    var bindRange = function (editor, binder) {\r\n      return getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$6).bind(binder);\r\n    };\r\n    var mapRange = function (editor, mapper) {\r\n      return bindRange(editor, compose1(Optional.some, mapper));\r\n    };\r\n\r\n    var fromFontSizeNumber = function (editor, value) {\r\n      if (/^[0-9.]+$/.test(value)) {\r\n        var fontSizeNumber = parseInt(value, 10);\r\n        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\r\n          var fontSizes = getFontStyleValues(editor);\r\n          var fontClasses = getFontSizeClasses(editor);\r\n          if (fontClasses) {\r\n            return fontClasses[fontSizeNumber - 1] || value;\r\n          } else {\r\n            return fontSizes[fontSizeNumber - 1] || value;\r\n          }\r\n        } else {\r\n          return value;\r\n        }\r\n      } else {\r\n        return value;\r\n      }\r\n    };\r\n    var normalizeFontNames = function (font) {\r\n      var fonts = font.split(/\\s*,\\s*/);\r\n      return map$3(fonts, function (font) {\r\n        if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, '\\''))) {\r\n          return '\\'' + font + '\\'';\r\n        } else {\r\n          return font;\r\n        }\r\n      }).join(',');\r\n    };\r\n    var fontNameAction = function (editor, value) {\r\n      var font = fromFontSizeNumber(editor, value);\r\n      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });\r\n      editor.nodeChanged();\r\n    };\r\n    var fontNameQuery = function (editor) {\r\n      return mapRange(editor, function (elm) {\r\n        return getFontFamily(editor.getBody(), elm.dom);\r\n      }).getOr('');\r\n    };\r\n    var fontSizeAction = function (editor, value) {\r\n      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });\r\n      editor.nodeChanged();\r\n    };\r\n    var fontSizeQuery = function (editor) {\r\n      return mapRange(editor, function (elm) {\r\n        return getFontSize(editor.getBody(), elm.dom);\r\n      }).getOr('');\r\n    };\r\n\r\n    var lineHeightQuery = function (editor) {\r\n      return mapRange(editor, function (elm) {\r\n        var root = SugarElement.fromDom(editor.getBody());\r\n        var specifiedStyle = closest$1(elm, function (elm) {\r\n          return getRaw(elm, 'line-height');\r\n        }, curry(eq, root));\r\n        var computedStyle = function () {\r\n          var lineHeight = parseFloat(get$5(elm, 'line-height'));\r\n          var fontSize = parseFloat(get$5(elm, 'font-size'));\r\n          return String(lineHeight / fontSize);\r\n        };\r\n        return specifiedStyle.getOrThunk(computedStyle);\r\n      }).getOr('');\r\n    };\r\n    var lineHeightAction = function (editor, lineHeight) {\r\n      editor.formatter.toggle('lineheight', { value: String(lineHeight) });\r\n      editor.nodeChanged();\r\n    };\r\n\r\n    var processValue = function (value) {\r\n      if (typeof value !== 'string') {\r\n        var details = Tools.extend({\r\n          paste: value.paste,\r\n          data: { paste: value.paste }\r\n        }, value);\r\n        return {\r\n          content: value.content,\r\n          details: details\r\n        };\r\n      }\r\n      return {\r\n        content: value,\r\n        details: {}\r\n      };\r\n    };\r\n    var insertAtCaret = function (editor, value) {\r\n      var result = processValue(value);\r\n      insertContent(editor, result.content, result.details);\r\n    };\r\n\r\n    var each$4 = Tools.each;\r\n    var map = Tools.map, inArray = Tools.inArray;\r\n    var EditorCommands = function () {\r\n      function EditorCommands(editor) {\r\n        this.commands = {\r\n          state: {},\r\n          exec: {},\r\n          value: {}\r\n        };\r\n        this.editor = editor;\r\n        this.setupCommands(editor);\r\n      }\r\n      EditorCommands.prototype.execCommand = function (command, ui, value, args) {\r\n        var func, state = false;\r\n        var self = this;\r\n        if (self.editor.removed) {\r\n          return;\r\n        }\r\n        if (command.toLowerCase() !== 'mcefocus') {\r\n          if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) && (!args || !args.skip_focus)) {\r\n            self.editor.focus();\r\n          } else {\r\n            restore(self.editor);\r\n          }\r\n        }\r\n        args = self.editor.fire('BeforeExecCommand', {\r\n          command: command,\r\n          ui: ui,\r\n          value: value\r\n        });\r\n        if (args.isDefaultPrevented()) {\r\n          return false;\r\n        }\r\n        var customCommand = command.toLowerCase();\r\n        if (func = self.commands.exec[customCommand]) {\r\n          func(customCommand, ui, value);\r\n          self.editor.fire('ExecCommand', {\r\n            command: command,\r\n            ui: ui,\r\n            value: value\r\n          });\r\n          return true;\r\n        }\r\n        each$4(this.editor.plugins, function (p) {\r\n          if (p.execCommand && p.execCommand(command, ui, value)) {\r\n            self.editor.fire('ExecCommand', {\r\n              command: command,\r\n              ui: ui,\r\n              value: value\r\n            });\r\n            state = true;\r\n            return false;\r\n          }\r\n        });\r\n        if (state) {\r\n          return state;\r\n        }\r\n        if (self.editor.theme && self.editor.theme.execCommand && self.editor.theme.execCommand(command, ui, value)) {\r\n          self.editor.fire('ExecCommand', {\r\n            command: command,\r\n            ui: ui,\r\n            value: value\r\n          });\r\n          return true;\r\n        }\r\n        try {\r\n          state = self.editor.getDoc().execCommand(command, ui, value);\r\n        } catch (ex) {\r\n        }\r\n        if (state) {\r\n          self.editor.fire('ExecCommand', {\r\n            command: command,\r\n            ui: ui,\r\n            value: value\r\n          });\r\n          return true;\r\n        }\r\n        return false;\r\n      };\r\n      EditorCommands.prototype.queryCommandState = function (command) {\r\n        var func;\r\n        if (this.editor.quirks.isHidden() || this.editor.removed) {\r\n          return;\r\n        }\r\n        command = command.toLowerCase();\r\n        if (func = this.commands.state[command]) {\r\n          return func(command);\r\n        }\r\n        try {\r\n          return this.editor.getDoc().queryCommandState(command);\r\n        } catch (ex) {\r\n        }\r\n        return false;\r\n      };\r\n      EditorCommands.prototype.queryCommandValue = function (command) {\r\n        var func;\r\n        if (this.editor.quirks.isHidden() || this.editor.removed) {\r\n          return;\r\n        }\r\n        command = command.toLowerCase();\r\n        if (func = this.commands.value[command]) {\r\n          return func(command);\r\n        }\r\n        try {\r\n          return this.editor.getDoc().queryCommandValue(command);\r\n        } catch (ex) {\r\n        }\r\n      };\r\n      EditorCommands.prototype.addCommands = function (commandList, type) {\r\n        if (type === void 0) {\r\n          type = 'exec';\r\n        }\r\n        var self = this;\r\n        each$4(commandList, function (callback, command) {\r\n          each$4(command.toLowerCase().split(','), function (command) {\r\n            self.commands[type][command] = callback;\r\n          });\r\n        });\r\n      };\r\n      EditorCommands.prototype.addCommand = function (command, callback, scope) {\r\n        var _this = this;\r\n        command = command.toLowerCase();\r\n        this.commands.exec[command] = function (command, ui, value, args) {\r\n          return callback.call(scope || _this.editor, ui, value, args);\r\n        };\r\n      };\r\n      EditorCommands.prototype.queryCommandSupported = function (command) {\r\n        command = command.toLowerCase();\r\n        if (this.commands.exec[command]) {\r\n          return true;\r\n        }\r\n        try {\r\n          return this.editor.getDoc().queryCommandSupported(command);\r\n        } catch (ex) {\r\n        }\r\n        return false;\r\n      };\r\n      EditorCommands.prototype.addQueryStateHandler = function (command, callback, scope) {\r\n        var _this = this;\r\n        command = command.toLowerCase();\r\n        this.commands.state[command] = function () {\r\n          return callback.call(scope || _this.editor);\r\n        };\r\n      };\r\n      EditorCommands.prototype.addQueryValueHandler = function (command, callback, scope) {\r\n        var _this = this;\r\n        command = command.toLowerCase();\r\n        this.commands.value[command] = function () {\r\n          return callback.call(scope || _this.editor);\r\n        };\r\n      };\r\n      EditorCommands.prototype.hasCustomCommand = function (command) {\r\n        command = command.toLowerCase();\r\n        return !!this.commands.exec[command];\r\n      };\r\n      EditorCommands.prototype.execNativeCommand = function (command, ui, value) {\r\n        if (ui === undefined) {\r\n          ui = false;\r\n        }\r\n        if (value === undefined) {\r\n          value = null;\r\n        }\r\n        return this.editor.getDoc().execCommand(command, ui, value);\r\n      };\r\n      EditorCommands.prototype.isFormatMatch = function (name) {\r\n        return this.editor.formatter.match(name);\r\n      };\r\n      EditorCommands.prototype.toggleFormat = function (name, value) {\r\n        this.editor.formatter.toggle(name, value);\r\n        this.editor.nodeChanged();\r\n      };\r\n      EditorCommands.prototype.storeSelection = function (type) {\r\n        this.selectionBookmark = this.editor.selection.getBookmark(type);\r\n      };\r\n      EditorCommands.prototype.restoreSelection = function () {\r\n        this.editor.selection.moveToBookmark(this.selectionBookmark);\r\n      };\r\n      EditorCommands.prototype.setupCommands = function (editor) {\r\n        var self = this;\r\n        this.addCommands({\r\n          'mceResetDesignMode,mceBeginUndoLevel': noop,\r\n          'mceEndUndoLevel,mceAddUndoLevel': function () {\r\n            editor.undoManager.add();\r\n          },\r\n          'mceFocus': function (_command, _ui, value) {\r\n            focus(editor, value);\r\n          },\r\n          'Cut,Copy,Paste': function (command) {\r\n            var doc = editor.getDoc();\r\n            var failed;\r\n            try {\r\n              self.execNativeCommand(command);\r\n            } catch (ex) {\r\n              failed = true;\r\n            }\r\n            if (command === 'paste' && !doc.queryCommandEnabled(command)) {\r\n              failed = true;\r\n            }\r\n            if (failed || !doc.queryCommandSupported(command)) {\r\n              var msg = editor.translate('Your browser doesn\\'t support direct access to the clipboard. ' + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\r\n              if (Env.mac) {\r\n                msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\r\n              }\r\n              editor.notificationManager.open({\r\n                text: msg,\r\n                type: 'error'\r\n              });\r\n            }\r\n          },\r\n          'unlink': function () {\r\n            if (editor.selection.isCollapsed()) {\r\n              var elm = editor.dom.getParent(editor.selection.getStart(), 'a');\r\n              if (elm) {\r\n                editor.dom.remove(elm, true);\r\n              }\r\n              return;\r\n            }\r\n            editor.formatter.remove('link');\r\n          },\r\n          'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone': function (command) {\r\n            var align = command.substring(7);\r\n            if (align === 'full') {\r\n              align = 'justify';\r\n            }\r\n            each$4('left,center,right,justify'.split(','), function (name) {\r\n              if (align !== name) {\r\n                editor.formatter.remove('align' + name);\r\n              }\r\n            });\r\n            if (align !== 'none') {\r\n              self.toggleFormat('align' + align);\r\n            }\r\n          },\r\n          'InsertUnorderedList,InsertOrderedList': function (command) {\r\n            var listParent;\r\n            self.execNativeCommand(command);\r\n            var listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\r\n            if (listElm) {\r\n              listParent = listElm.parentNode;\r\n              if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\r\n                self.storeSelection();\r\n                editor.dom.split(listParent, listElm);\r\n                self.restoreSelection();\r\n              }\r\n            }\r\n          },\r\n          'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function (command) {\r\n            self.toggleFormat(command);\r\n          },\r\n          'ForeColor,HiliteColor': function (command, ui, value) {\r\n            self.toggleFormat(command, { value: value });\r\n          },\r\n          'FontName': function (command, ui, value) {\r\n            fontNameAction(editor, value);\r\n          },\r\n          'FontSize': function (command, ui, value) {\r\n            fontSizeAction(editor, value);\r\n          },\r\n          'LineHeight': function (command, ui, value) {\r\n            lineHeightAction(editor, value);\r\n          },\r\n          'Lang': function (command, ui, lang) {\r\n            self.toggleFormat(command, {\r\n              value: lang.code,\r\n              customValue: lang.customCode\r\n            });\r\n          },\r\n          'RemoveFormat': function (command) {\r\n            editor.formatter.remove(command);\r\n          },\r\n          'mceBlockQuote': function () {\r\n            self.toggleFormat('blockquote');\r\n          },\r\n          'FormatBlock': function (command, ui, value) {\r\n            return self.toggleFormat(value || 'p');\r\n          },\r\n          'mceCleanup': function () {\r\n            var bookmark = editor.selection.getBookmark();\r\n            editor.setContent(editor.getContent());\r\n            editor.selection.moveToBookmark(bookmark);\r\n          },\r\n          'mceRemoveNode': function (command, ui, value) {\r\n            var node = value || editor.selection.getNode();\r\n            if (node !== editor.getBody()) {\r\n              self.storeSelection();\r\n              editor.dom.remove(node, true);\r\n              self.restoreSelection();\r\n            }\r\n          },\r\n          'mceSelectNodeDepth': function (command, ui, value) {\r\n            var counter = 0;\r\n            editor.dom.getParent(editor.selection.getNode(), function (node) {\r\n              if (node.nodeType === 1 && counter++ === value) {\r\n                editor.selection.select(node);\r\n                return false;\r\n              }\r\n            }, editor.getBody());\r\n          },\r\n          'mceSelectNode': function (command, ui, value) {\r\n            editor.selection.select(value);\r\n          },\r\n          'mceInsertContent': function (command, ui, value) {\r\n            insertAtCaret(editor, value);\r\n          },\r\n          'mceInsertRawHTML': function (command, ui, value) {\r\n            editor.selection.setContent('tiny_mce_marker');\r\n            var content = editor.getContent();\r\n            editor.setContent(content.replace(/tiny_mce_marker/g, function () {\r\n              return value;\r\n            }));\r\n          },\r\n          'mceInsertNewLine': function (command, ui, value) {\r\n            insert(editor, value);\r\n          },\r\n          'mceToggleFormat': function (command, ui, value) {\r\n            self.toggleFormat(value);\r\n          },\r\n          'mceSetContent': function (command, ui, value) {\r\n            editor.setContent(value);\r\n          },\r\n          'Indent,Outdent': function (command) {\r\n            handle(editor, command);\r\n          },\r\n          'mceRepaint': noop,\r\n          'InsertHorizontalRule': function () {\r\n            editor.execCommand('mceInsertContent', false, '<hr />');\r\n          },\r\n          'mceToggleVisualAid': function () {\r\n            editor.hasVisual = !editor.hasVisual;\r\n            editor.addVisual();\r\n          },\r\n          'mceReplaceContent': function (command, ui, value) {\r\n            editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({ format: 'text' })));\r\n          },\r\n          'mceInsertLink': function (command, ui, value) {\r\n            if (typeof value === 'string') {\r\n              value = { href: value };\r\n            }\r\n            var anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\r\n            value.href = value.href.replace(/ /g, '%20');\r\n            if (!anchor || !value.href) {\r\n              editor.formatter.remove('link');\r\n            }\r\n            if (value.href) {\r\n              editor.formatter.apply('link', value, anchor);\r\n            }\r\n          },\r\n          'selectAll': function () {\r\n            var editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$4);\r\n            if (editingHost) {\r\n              var rng = editor.dom.createRng();\r\n              rng.selectNodeContents(editingHost);\r\n              editor.selection.setRng(rng);\r\n            }\r\n          },\r\n          'mceNewDocument': function () {\r\n            editor.setContent('');\r\n          },\r\n          'InsertLineBreak': function (command, ui, value) {\r\n            insert$1(editor, value);\r\n            return true;\r\n          }\r\n        });\r\n        var alignStates = function (name) {\r\n          return function () {\r\n            var selection = editor.selection;\r\n            var nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\r\n            var matches = map(nodes, function (node) {\r\n              return !!editor.formatter.matchNode(node, name);\r\n            });\r\n            return inArray(matches, true) !== -1;\r\n          };\r\n        };\r\n        self.addCommands({\r\n          'JustifyLeft': alignStates('alignleft'),\r\n          'JustifyCenter': alignStates('aligncenter'),\r\n          'JustifyRight': alignStates('alignright'),\r\n          'JustifyFull': alignStates('alignjustify'),\r\n          'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function (command) {\r\n            return self.isFormatMatch(command);\r\n          },\r\n          'mceBlockQuote': function () {\r\n            return self.isFormatMatch('blockquote');\r\n          },\r\n          'Outdent': function () {\r\n            return canOutdent(editor);\r\n          },\r\n          'InsertUnorderedList,InsertOrderedList': function (command) {\r\n            var list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');\r\n            return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');\r\n          }\r\n        }, 'state');\r\n        self.addCommands({\r\n          Undo: function () {\r\n            editor.undoManager.undo();\r\n          },\r\n          Redo: function () {\r\n            editor.undoManager.redo();\r\n          }\r\n        });\r\n        self.addQueryValueHandler('FontName', function () {\r\n          return fontNameQuery(editor);\r\n        }, this);\r\n        self.addQueryValueHandler('FontSize', function () {\r\n          return fontSizeQuery(editor);\r\n        }, this);\r\n        self.addQueryValueHandler('LineHeight', function () {\r\n          return lineHeightQuery(editor);\r\n        }, this);\r\n      };\r\n      return EditorCommands;\r\n    }();\r\n\r\n    var internalContentEditableAttr = 'data-mce-contenteditable';\r\n    var toggleClass = function (elm, cls, state) {\r\n      if (has(elm, cls) && state === false) {\r\n        remove$3(elm, cls);\r\n      } else if (state) {\r\n        add$1(elm, cls);\r\n      }\r\n    };\r\n    var setEditorCommandState = function (editor, cmd, state) {\r\n      try {\r\n        editor.getDoc().execCommand(cmd, false, String(state));\r\n      } catch (ex) {\r\n      }\r\n    };\r\n    var setContentEditable = function (elm, state) {\r\n      elm.dom.contentEditable = state ? 'true' : 'false';\r\n    };\r\n    var switchOffContentEditableTrue = function (elm) {\r\n      each$k(descendants(elm, '*[contenteditable=\"true\"]'), function (elm) {\r\n        set$1(elm, internalContentEditableAttr, 'true');\r\n        setContentEditable(elm, false);\r\n      });\r\n    };\r\n    var switchOnContentEditableTrue = function (elm) {\r\n      each$k(descendants(elm, '*[' + internalContentEditableAttr + '=\"true\"]'), function (elm) {\r\n        remove$6(elm, internalContentEditableAttr);\r\n        setContentEditable(elm, true);\r\n      });\r\n    };\r\n    var removeFakeSelection = function (editor) {\r\n      Optional.from(editor.selection.getNode()).each(function (elm) {\r\n        elm.removeAttribute('data-mce-selected');\r\n      });\r\n    };\r\n    var restoreFakeSelection = function (editor) {\r\n      editor.selection.setRng(editor.selection.getRng());\r\n    };\r\n    var toggleReadOnly = function (editor, state) {\r\n      var body = SugarElement.fromDom(editor.getBody());\r\n      toggleClass(body, 'mce-content-readonly', state);\r\n      if (state) {\r\n        editor.selection.controlSelection.hideResizeRect();\r\n        editor._selectionOverrides.hideFakeCaret();\r\n        removeFakeSelection(editor);\r\n        editor.readonly = true;\r\n        setContentEditable(body, false);\r\n        switchOffContentEditableTrue(body);\r\n      } else {\r\n        editor.readonly = false;\r\n        setContentEditable(body, true);\r\n        switchOnContentEditableTrue(body);\r\n        setEditorCommandState(editor, 'StyleWithCSS', false);\r\n        setEditorCommandState(editor, 'enableInlineTableEditing', false);\r\n        setEditorCommandState(editor, 'enableObjectResizing', false);\r\n        if (hasEditorOrUiFocus(editor)) {\r\n          editor.focus();\r\n        }\r\n        restoreFakeSelection(editor);\r\n        editor.nodeChanged();\r\n      }\r\n    };\r\n    var isReadOnly = function (editor) {\r\n      return editor.readonly;\r\n    };\r\n    var registerFilters = function (editor) {\r\n      editor.parser.addAttributeFilter('contenteditable', function (nodes) {\r\n        if (isReadOnly(editor)) {\r\n          each$k(nodes, function (node) {\r\n            node.attr(internalContentEditableAttr, node.attr('contenteditable'));\r\n            node.attr('contenteditable', 'false');\r\n          });\r\n        }\r\n      });\r\n      editor.serializer.addAttributeFilter(internalContentEditableAttr, function (nodes) {\r\n        if (isReadOnly(editor)) {\r\n          each$k(nodes, function (node) {\r\n            node.attr('contenteditable', node.attr(internalContentEditableAttr));\r\n          });\r\n        }\r\n      });\r\n      editor.serializer.addTempAttr(internalContentEditableAttr);\r\n    };\r\n    var registerReadOnlyContentFilters = function (editor) {\r\n      if (editor.serializer) {\r\n        registerFilters(editor);\r\n      } else {\r\n        editor.on('PreInit', function () {\r\n          registerFilters(editor);\r\n        });\r\n      }\r\n    };\r\n    var isClickEvent = function (e) {\r\n      return e.type === 'click';\r\n    };\r\n    var getAnchorHrefOpt = function (editor, elm) {\r\n      var isRoot = function (elm) {\r\n        return eq(elm, SugarElement.fromDom(editor.getBody()));\r\n      };\r\n      return closest$2(elm, 'a', isRoot).bind(function (a) {\r\n        return getOpt(a, 'href');\r\n      });\r\n    };\r\n    var processReadonlyEvents = function (editor, e) {\r\n      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\r\n        var elm = SugarElement.fromDom(e.target);\r\n        getAnchorHrefOpt(editor, elm).each(function (href) {\r\n          e.preventDefault();\r\n          if (/^#/.test(href)) {\r\n            var targetEl = editor.dom.select(href + ',[name=\"' + removeLeading(href, '#') + '\"]');\r\n            if (targetEl.length) {\r\n              editor.selection.scrollIntoView(targetEl[0], true);\r\n            }\r\n          } else {\r\n            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\r\n          }\r\n        });\r\n      }\r\n    };\r\n    var registerReadOnlySelectionBlockers = function (editor) {\r\n      editor.on('ShowCaret', function (e) {\r\n        if (isReadOnly(editor)) {\r\n          e.preventDefault();\r\n        }\r\n      });\r\n      editor.on('ObjectSelected', function (e) {\r\n        if (isReadOnly(editor)) {\r\n          e.preventDefault();\r\n        }\r\n      });\r\n    };\r\n\r\n    var nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\r\n    var EventDispatcher = function () {\r\n      function EventDispatcher(settings) {\r\n        this.bindings = {};\r\n        this.settings = settings || {};\r\n        this.scope = this.settings.scope || this;\r\n        this.toggleEvent = this.settings.toggleEvent || never;\r\n      }\r\n      EventDispatcher.isNative = function (name) {\r\n        return !!nativeEvents[name.toLowerCase()];\r\n      };\r\n      EventDispatcher.prototype.fire = function (name, args) {\r\n        var lcName = name.toLowerCase();\r\n        var event = normalize$3(lcName, args || {}, this.scope);\r\n        if (this.settings.beforeFire) {\r\n          this.settings.beforeFire(event);\r\n        }\r\n        var handlers = this.bindings[lcName];\r\n        if (handlers) {\r\n          for (var i = 0, l = handlers.length; i < l; i++) {\r\n            var callback = handlers[i];\r\n            if (callback.removed) {\r\n              continue;\r\n            }\r\n            if (callback.once) {\r\n              this.off(lcName, callback.func);\r\n            }\r\n            if (event.isImmediatePropagationStopped()) {\r\n              return event;\r\n            }\r\n            if (callback.func.call(this.scope, event) === false) {\r\n              event.preventDefault();\r\n              return event;\r\n            }\r\n          }\r\n        }\r\n        return event;\r\n      };\r\n      EventDispatcher.prototype.on = function (name, callback, prepend, extra) {\r\n        if (callback === false) {\r\n          callback = never;\r\n        }\r\n        if (callback) {\r\n          var wrappedCallback = {\r\n            func: callback,\r\n            removed: false\r\n          };\r\n          if (extra) {\r\n            Tools.extend(wrappedCallback, extra);\r\n          }\r\n          var names = name.toLowerCase().split(' ');\r\n          var i = names.length;\r\n          while (i--) {\r\n            var currentName = names[i];\r\n            var handlers = this.bindings[currentName];\r\n            if (!handlers) {\r\n              handlers = [];\r\n              this.toggleEvent(currentName, true);\r\n            }\r\n            if (prepend) {\r\n              handlers = __spreadArray([wrappedCallback], handlers, true);\r\n            } else {\r\n              handlers = __spreadArray(__spreadArray([], handlers, true), [wrappedCallback], false);\r\n            }\r\n            this.bindings[currentName] = handlers;\r\n          }\r\n        }\r\n        return this;\r\n      };\r\n      EventDispatcher.prototype.off = function (name, callback) {\r\n        var _this = this;\r\n        if (name) {\r\n          var names = name.toLowerCase().split(' ');\r\n          var i = names.length;\r\n          while (i--) {\r\n            var currentName = names[i];\r\n            var handlers = this.bindings[currentName];\r\n            if (!currentName) {\r\n              each$j(this.bindings, function (_value, bindingName) {\r\n                _this.toggleEvent(bindingName, false);\r\n                delete _this.bindings[bindingName];\r\n              });\r\n              return this;\r\n            }\r\n            if (handlers) {\r\n              if (!callback) {\r\n                handlers.length = 0;\r\n              } else {\r\n                var filteredHandlers = partition(handlers, function (handler) {\r\n                  return handler.func === callback;\r\n                });\r\n                handlers = filteredHandlers.fail;\r\n                this.bindings[currentName] = handlers;\r\n                each$k(filteredHandlers.pass, function (handler) {\r\n                  handler.removed = true;\r\n                });\r\n              }\r\n              if (!handlers.length) {\r\n                this.toggleEvent(name, false);\r\n                delete this.bindings[currentName];\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          each$j(this.bindings, function (_value, name) {\r\n            _this.toggleEvent(name, false);\r\n          });\r\n          this.bindings = {};\r\n        }\r\n        return this;\r\n      };\r\n      EventDispatcher.prototype.once = function (name, callback, prepend) {\r\n        return this.on(name, callback, prepend, { once: true });\r\n      };\r\n      EventDispatcher.prototype.has = function (name) {\r\n        name = name.toLowerCase();\r\n        return !(!this.bindings[name] || this.bindings[name].length === 0);\r\n      };\r\n      return EventDispatcher;\r\n    }();\r\n\r\n    var getEventDispatcher = function (obj) {\r\n      if (!obj._eventDispatcher) {\r\n        obj._eventDispatcher = new EventDispatcher({\r\n          scope: obj,\r\n          toggleEvent: function (name, state) {\r\n            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\r\n              obj.toggleNativeEvent(name, state);\r\n            }\r\n          }\r\n        });\r\n      }\r\n      return obj._eventDispatcher;\r\n    };\r\n    var Observable = {\r\n      fire: function (name, args, bubble) {\r\n        var self = this;\r\n        if (self.removed && name !== 'remove' && name !== 'detach') {\r\n          return args;\r\n        }\r\n        var dispatcherArgs = getEventDispatcher(self).fire(name, args);\r\n        if (bubble !== false && self.parent) {\r\n          var parent_1 = self.parent();\r\n          while (parent_1 && !dispatcherArgs.isPropagationStopped()) {\r\n            parent_1.fire(name, dispatcherArgs, false);\r\n            parent_1 = parent_1.parent();\r\n          }\r\n        }\r\n        return dispatcherArgs;\r\n      },\r\n      on: function (name, callback, prepend) {\r\n        return getEventDispatcher(this).on(name, callback, prepend);\r\n      },\r\n      off: function (name, callback) {\r\n        return getEventDispatcher(this).off(name, callback);\r\n      },\r\n      once: function (name, callback) {\r\n        return getEventDispatcher(this).once(name, callback);\r\n      },\r\n      hasEventListeners: function (name) {\r\n        return getEventDispatcher(this).has(name);\r\n      }\r\n    };\r\n\r\n    var DOM$2 = DOMUtils.DOM;\r\n    var customEventRootDelegates;\r\n    var getEventTarget = function (editor, eventName) {\r\n      if (eventName === 'selectionchange') {\r\n        return editor.getDoc();\r\n      }\r\n      if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {\r\n        return editor.getDoc().documentElement;\r\n      }\r\n      var eventRoot = getEventRoot(editor);\r\n      if (eventRoot) {\r\n        if (!editor.eventRoot) {\r\n          editor.eventRoot = DOM$2.select(eventRoot)[0];\r\n        }\r\n        return editor.eventRoot;\r\n      }\r\n      return editor.getBody();\r\n    };\r\n    var isListening = function (editor) {\r\n      return !editor.hidden && !isReadOnly(editor);\r\n    };\r\n    var fireEvent = function (editor, eventName, e) {\r\n      if (isListening(editor)) {\r\n        editor.fire(eventName, e);\r\n      } else if (isReadOnly(editor)) {\r\n        processReadonlyEvents(editor, e);\r\n      }\r\n    };\r\n    var bindEventDelegate = function (editor, eventName) {\r\n      var delegate;\r\n      if (!editor.delegates) {\r\n        editor.delegates = {};\r\n      }\r\n      if (editor.delegates[eventName] || editor.removed) {\r\n        return;\r\n      }\r\n      var eventRootElm = getEventTarget(editor, eventName);\r\n      if (getEventRoot(editor)) {\r\n        if (!customEventRootDelegates) {\r\n          customEventRootDelegates = {};\r\n          editor.editorManager.on('removeEditor', function () {\r\n            if (!editor.editorManager.activeEditor) {\r\n              if (customEventRootDelegates) {\r\n                each$j(customEventRootDelegates, function (_value, name) {\r\n                  editor.dom.unbind(getEventTarget(editor, name));\r\n                });\r\n                customEventRootDelegates = null;\r\n              }\r\n            }\r\n          });\r\n        }\r\n        if (customEventRootDelegates[eventName]) {\r\n          return;\r\n        }\r\n        delegate = function (e) {\r\n          var target = e.target;\r\n          var editors = editor.editorManager.get();\r\n          var i = editors.length;\r\n          while (i--) {\r\n            var body = editors[i].getBody();\r\n            if (body === target || DOM$2.isChildOf(target, body)) {\r\n              fireEvent(editors[i], eventName, e);\r\n            }\r\n          }\r\n        };\r\n        customEventRootDelegates[eventName] = delegate;\r\n        DOM$2.bind(eventRootElm, eventName, delegate);\r\n      } else {\r\n        delegate = function (e) {\r\n          fireEvent(editor, eventName, e);\r\n        };\r\n        DOM$2.bind(eventRootElm, eventName, delegate);\r\n        editor.delegates[eventName] = delegate;\r\n      }\r\n    };\r\n    var EditorObservable = __assign(__assign({}, Observable), {\r\n      bindPendingEventDelegates: function () {\r\n        var self = this;\r\n        Tools.each(self._pendingNativeEvents, function (name) {\r\n          bindEventDelegate(self, name);\r\n        });\r\n      },\r\n      toggleNativeEvent: function (name, state) {\r\n        var self = this;\r\n        if (name === 'focus' || name === 'blur') {\r\n          return;\r\n        }\r\n        if (self.removed) {\r\n          return;\r\n        }\r\n        if (state) {\r\n          if (self.initialized) {\r\n            bindEventDelegate(self, name);\r\n          } else {\r\n            if (!self._pendingNativeEvents) {\r\n              self._pendingNativeEvents = [name];\r\n            } else {\r\n              self._pendingNativeEvents.push(name);\r\n            }\r\n          }\r\n        } else if (self.initialized) {\r\n          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\r\n          delete self.delegates[name];\r\n        }\r\n      },\r\n      unbindAllNativeEvents: function () {\r\n        var self = this;\r\n        var body = self.getBody();\r\n        var dom = self.dom;\r\n        if (self.delegates) {\r\n          each$j(self.delegates, function (value, name) {\r\n            self.dom.unbind(getEventTarget(self, name), name, value);\r\n          });\r\n          delete self.delegates;\r\n        }\r\n        if (!self.inline && body && dom) {\r\n          body.onload = null;\r\n          dom.unbind(self.getWin());\r\n          dom.unbind(self.getDoc());\r\n        }\r\n        if (dom) {\r\n          dom.unbind(body);\r\n          dom.unbind(self.getContainer());\r\n        }\r\n      }\r\n    });\r\n\r\n    var defaultModes = [\r\n      'design',\r\n      'readonly'\r\n    ];\r\n    var switchToMode = function (editor, activeMode, availableModes, mode) {\r\n      var oldMode = availableModes[activeMode.get()];\r\n      var newMode = availableModes[mode];\r\n      try {\r\n        newMode.activate();\r\n      } catch (e) {\r\n        console.error('problem while activating editor mode ' + mode + ':', e);\r\n        return;\r\n      }\r\n      oldMode.deactivate();\r\n      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\r\n        toggleReadOnly(editor, newMode.editorReadOnly);\r\n      }\r\n      activeMode.set(mode);\r\n      fireSwitchMode(editor, mode);\r\n    };\r\n    var setMode = function (editor, availableModes, activeMode, mode) {\r\n      if (mode === activeMode.get()) {\r\n        return;\r\n      } else if (!has$2(availableModes, mode)) {\r\n        throw new Error('Editor mode \\'' + mode + '\\' is invalid');\r\n      }\r\n      if (editor.initialized) {\r\n        switchToMode(editor, activeMode, availableModes, mode);\r\n      } else {\r\n        editor.on('init', function () {\r\n          return switchToMode(editor, activeMode, availableModes, mode);\r\n        });\r\n      }\r\n    };\r\n    var registerMode = function (availableModes, mode, api) {\r\n      var _a;\r\n      if (contains$3(defaultModes, mode)) {\r\n        throw new Error('Cannot override default mode ' + mode);\r\n      }\r\n      return __assign(__assign({}, availableModes), (_a = {}, _a[mode] = __assign(__assign({}, api), {\r\n        deactivate: function () {\r\n          try {\r\n            api.deactivate();\r\n          } catch (e) {\r\n            console.error('problem while deactivating editor mode ' + mode + ':', e);\r\n          }\r\n        }\r\n      }), _a));\r\n    };\r\n\r\n    var create$4 = function (editor) {\r\n      var activeMode = Cell('design');\r\n      var availableModes = Cell({\r\n        design: {\r\n          activate: noop,\r\n          deactivate: noop,\r\n          editorReadOnly: false\r\n        },\r\n        readonly: {\r\n          activate: noop,\r\n          deactivate: noop,\r\n          editorReadOnly: true\r\n        }\r\n      });\r\n      registerReadOnlyContentFilters(editor);\r\n      registerReadOnlySelectionBlockers(editor);\r\n      return {\r\n        isReadOnly: function () {\r\n          return isReadOnly(editor);\r\n        },\r\n        set: function (mode) {\r\n          return setMode(editor, availableModes.get(), activeMode, mode);\r\n        },\r\n        get: function () {\r\n          return activeMode.get();\r\n        },\r\n        register: function (mode, api) {\r\n          availableModes.set(registerMode(availableModes.get(), mode, api));\r\n        }\r\n      };\r\n    };\r\n\r\n    var each$3 = Tools.each, explode$1 = Tools.explode;\r\n    var keyCodeLookup = {\r\n      f1: 112,\r\n      f2: 113,\r\n      f3: 114,\r\n      f4: 115,\r\n      f5: 116,\r\n      f6: 117,\r\n      f7: 118,\r\n      f8: 119,\r\n      f9: 120,\r\n      f10: 121,\r\n      f11: 122,\r\n      f12: 123\r\n    };\r\n    var modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\r\n    var parseShortcut = function (pattern) {\r\n      var key;\r\n      var shortcut = {};\r\n      each$3(explode$1(pattern.toLowerCase(), '+'), function (value) {\r\n        if (value in modifierNames) {\r\n          shortcut[value] = true;\r\n        } else {\r\n          if (/^[0-9]{2,}$/.test(value)) {\r\n            shortcut.keyCode = parseInt(value, 10);\r\n          } else {\r\n            shortcut.charCode = value.charCodeAt(0);\r\n            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\r\n          }\r\n        }\r\n      });\r\n      var id = [shortcut.keyCode];\r\n      for (key in modifierNames) {\r\n        if (shortcut[key]) {\r\n          id.push(key);\r\n        } else {\r\n          shortcut[key] = false;\r\n        }\r\n      }\r\n      shortcut.id = id.join(',');\r\n      if (shortcut.access) {\r\n        shortcut.alt = true;\r\n        if (Env.mac) {\r\n          shortcut.ctrl = true;\r\n        } else {\r\n          shortcut.shift = true;\r\n        }\r\n      }\r\n      if (shortcut.meta) {\r\n        if (Env.mac) {\r\n          shortcut.meta = true;\r\n        } else {\r\n          shortcut.ctrl = true;\r\n          shortcut.meta = false;\r\n        }\r\n      }\r\n      return shortcut;\r\n    };\r\n    var Shortcuts = function () {\r\n      function Shortcuts(editor) {\r\n        this.shortcuts = {};\r\n        this.pendingPatterns = [];\r\n        this.editor = editor;\r\n        var self = this;\r\n        editor.on('keyup keypress keydown', function (e) {\r\n          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\r\n            each$3(self.shortcuts, function (shortcut) {\r\n              if (self.matchShortcut(e, shortcut)) {\r\n                self.pendingPatterns = shortcut.subpatterns.slice(0);\r\n                if (e.type === 'keydown') {\r\n                  self.executeShortcutAction(shortcut);\r\n                }\r\n                return true;\r\n              }\r\n            });\r\n            if (self.matchShortcut(e, self.pendingPatterns[0])) {\r\n              if (self.pendingPatterns.length === 1) {\r\n                if (e.type === 'keydown') {\r\n                  self.executeShortcutAction(self.pendingPatterns[0]);\r\n                }\r\n              }\r\n              self.pendingPatterns.shift();\r\n            }\r\n          }\r\n        });\r\n      }\r\n      Shortcuts.prototype.add = function (pattern, desc, cmdFunc, scope) {\r\n        var self = this;\r\n        var func = self.normalizeCommandFunc(cmdFunc);\r\n        each$3(explode$1(Tools.trim(pattern)), function (pattern) {\r\n          var shortcut = self.createShortcut(pattern, desc, func, scope);\r\n          self.shortcuts[shortcut.id] = shortcut;\r\n        });\r\n        return true;\r\n      };\r\n      Shortcuts.prototype.remove = function (pattern) {\r\n        var shortcut = this.createShortcut(pattern);\r\n        if (this.shortcuts[shortcut.id]) {\r\n          delete this.shortcuts[shortcut.id];\r\n          return true;\r\n        }\r\n        return false;\r\n      };\r\n      Shortcuts.prototype.normalizeCommandFunc = function (cmdFunc) {\r\n        var self = this;\r\n        var cmd = cmdFunc;\r\n        if (typeof cmd === 'string') {\r\n          return function () {\r\n            self.editor.execCommand(cmd, false, null);\r\n          };\r\n        } else if (Tools.isArray(cmd)) {\r\n          return function () {\r\n            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\r\n          };\r\n        } else {\r\n          return cmd;\r\n        }\r\n      };\r\n      Shortcuts.prototype.createShortcut = function (pattern, desc, cmdFunc, scope) {\r\n        var shortcuts = Tools.map(explode$1(pattern, '>'), parseShortcut);\r\n        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\r\n          func: cmdFunc,\r\n          scope: scope || this.editor\r\n        });\r\n        return Tools.extend(shortcuts[0], {\r\n          desc: this.editor.translate(desc),\r\n          subpatterns: shortcuts.slice(1)\r\n        });\r\n      };\r\n      Shortcuts.prototype.hasModifier = function (e) {\r\n        return e.altKey || e.ctrlKey || e.metaKey;\r\n      };\r\n      Shortcuts.prototype.isFunctionKey = function (e) {\r\n        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\r\n      };\r\n      Shortcuts.prototype.matchShortcut = function (e, shortcut) {\r\n        if (!shortcut) {\r\n          return false;\r\n        }\r\n        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\r\n          return false;\r\n        }\r\n        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\r\n          return false;\r\n        }\r\n        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\r\n          e.preventDefault();\r\n          return true;\r\n        }\r\n        return false;\r\n      };\r\n      Shortcuts.prototype.executeShortcutAction = function (shortcut) {\r\n        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\r\n      };\r\n      return Shortcuts;\r\n    }();\r\n\r\n    var create$3 = function () {\r\n      var buttons = {};\r\n      var menuItems = {};\r\n      var popups = {};\r\n      var icons = {};\r\n      var contextMenus = {};\r\n      var contextToolbars = {};\r\n      var sidebars = {};\r\n      var add = function (collection, type) {\r\n        return function (name, spec) {\r\n          return collection[name.toLowerCase()] = __assign(__assign({}, spec), { type: type });\r\n        };\r\n      };\r\n      var addIcon = function (name, svgData) {\r\n        return icons[name.toLowerCase()] = svgData;\r\n      };\r\n      return {\r\n        addButton: add(buttons, 'button'),\r\n        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\r\n        addToggleButton: add(buttons, 'togglebutton'),\r\n        addMenuButton: add(buttons, 'menubutton'),\r\n        addSplitButton: add(buttons, 'splitbutton'),\r\n        addMenuItem: add(menuItems, 'menuitem'),\r\n        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\r\n        addToggleMenuItem: add(menuItems, 'togglemenuitem'),\r\n        addAutocompleter: add(popups, 'autocompleter'),\r\n        addContextMenu: add(contextMenus, 'contextmenu'),\r\n        addContextToolbar: add(contextToolbars, 'contexttoolbar'),\r\n        addContextForm: add(contextToolbars, 'contextform'),\r\n        addSidebar: add(sidebars, 'sidebar'),\r\n        addIcon: addIcon,\r\n        getAll: function () {\r\n          return {\r\n            buttons: buttons,\r\n            menuItems: menuItems,\r\n            icons: icons,\r\n            popups: popups,\r\n            contextMenus: contextMenus,\r\n            contextToolbars: contextToolbars,\r\n            sidebars: sidebars\r\n          };\r\n        }\r\n      };\r\n    };\r\n\r\n    var registry = function () {\r\n      var bridge = create$3();\r\n      return {\r\n        addAutocompleter: bridge.addAutocompleter,\r\n        addButton: bridge.addButton,\r\n        addContextForm: bridge.addContextForm,\r\n        addContextMenu: bridge.addContextMenu,\r\n        addContextToolbar: bridge.addContextToolbar,\r\n        addIcon: bridge.addIcon,\r\n        addMenuButton: bridge.addMenuButton,\r\n        addMenuItem: bridge.addMenuItem,\r\n        addNestedMenuItem: bridge.addNestedMenuItem,\r\n        addSidebar: bridge.addSidebar,\r\n        addSplitButton: bridge.addSplitButton,\r\n        addToggleButton: bridge.addToggleButton,\r\n        addGroupToolbarButton: bridge.addGroupToolbarButton,\r\n        addToggleMenuItem: bridge.addToggleMenuItem,\r\n        getAll: bridge.getAll\r\n      };\r\n    };\r\n\r\n    var DOM$1 = DOMUtils.DOM;\r\n    var extend$3 = Tools.extend, each$2 = Tools.each;\r\n    var resolve = Tools.resolve;\r\n    var ie = Env.ie;\r\n    var Editor = function () {\r\n      function Editor(id, settings, editorManager) {\r\n        var _this = this;\r\n        this.plugins = {};\r\n        this.contentCSS = [];\r\n        this.contentStyles = [];\r\n        this.loadedCSS = {};\r\n        this.isNotDirty = false;\r\n        this.editorManager = editorManager;\r\n        this.documentBaseUrl = editorManager.documentBaseURL;\r\n        extend$3(this, EditorObservable);\r\n        this.settings = getEditorSettings(this, id, this.documentBaseUrl, editorManager.defaultSettings, settings);\r\n        if (this.settings.suffix) {\r\n          editorManager.suffix = this.settings.suffix;\r\n        }\r\n        this.suffix = editorManager.suffix;\r\n        if (this.settings.base_url) {\r\n          editorManager._setBaseUrl(this.settings.base_url);\r\n        }\r\n        this.baseUri = editorManager.baseURI;\r\n        if (this.settings.referrer_policy) {\r\n          ScriptLoader.ScriptLoader._setReferrerPolicy(this.settings.referrer_policy);\r\n          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(this.settings.referrer_policy);\r\n        }\r\n        AddOnManager.languageLoad = this.settings.language_load;\r\n        AddOnManager.baseURL = editorManager.baseURL;\r\n        this.id = id;\r\n        this.setDirty(false);\r\n        this.documentBaseURI = new URI(this.settings.document_base_url, { base_uri: this.baseUri });\r\n        this.baseURI = this.baseUri;\r\n        this.inline = !!this.settings.inline;\r\n        this.shortcuts = new Shortcuts(this);\r\n        this.editorCommands = new EditorCommands(this);\r\n        if (this.settings.cache_suffix) {\r\n          Env.cacheSuffix = this.settings.cache_suffix.replace(/^[\\?\\&]+/, '');\r\n        }\r\n        this.ui = {\r\n          registry: registry(),\r\n          styleSheetLoader: undefined,\r\n          show: noop,\r\n          hide: noop,\r\n          enable: noop,\r\n          disable: noop,\r\n          isDisabled: never\r\n        };\r\n        var self = this;\r\n        var modeInstance = create$4(self);\r\n        this.mode = modeInstance;\r\n        this.setMode = modeInstance.set;\r\n        editorManager.fire('SetupEditor', { editor: this });\r\n        this.execCallback('setup', this);\r\n        this.$ = DomQuery.overrideDefaults(function () {\r\n          return {\r\n            context: _this.inline ? _this.getBody() : _this.getDoc(),\r\n            element: _this.getBody()\r\n          };\r\n        });\r\n      }\r\n      Editor.prototype.render = function () {\r\n        render(this);\r\n      };\r\n      Editor.prototype.focus = function (skipFocus) {\r\n        this.execCommand('mceFocus', false, skipFocus);\r\n      };\r\n      Editor.prototype.hasFocus = function () {\r\n        return hasFocus(this);\r\n      };\r\n      Editor.prototype.execCallback = function (name) {\r\n        var x = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n          x[_i - 1] = arguments[_i];\r\n        }\r\n        var self = this;\r\n        var callback = self.settings[name], scope;\r\n        if (!callback) {\r\n          return;\r\n        }\r\n        if (self.callbackLookup && (scope = self.callbackLookup[name])) {\r\n          callback = scope.func;\r\n          scope = scope.scope;\r\n        }\r\n        if (typeof callback === 'string') {\r\n          scope = callback.replace(/\\.\\w+$/, '');\r\n          scope = scope ? resolve(scope) : 0;\r\n          callback = resolve(callback);\r\n          self.callbackLookup = self.callbackLookup || {};\r\n          self.callbackLookup[name] = {\r\n            func: callback,\r\n            scope: scope\r\n          };\r\n        }\r\n        return callback.apply(scope || self, x);\r\n      };\r\n      Editor.prototype.translate = function (text) {\r\n        return I18n.translate(text);\r\n      };\r\n      Editor.prototype.getParam = function (name, defaultVal, type) {\r\n        return getParam(this, name, defaultVal, type);\r\n      };\r\n      Editor.prototype.hasPlugin = function (name, loaded) {\r\n        var hasPlugin = contains$3(getPlugins(this).split(/[ ,]/), name);\r\n        if (hasPlugin) {\r\n          return loaded ? PluginManager.get(name) !== undefined : true;\r\n        } else {\r\n          return false;\r\n        }\r\n      };\r\n      Editor.prototype.nodeChanged = function (args) {\r\n        this._nodeChangeDispatcher.nodeChanged(args);\r\n      };\r\n      Editor.prototype.addCommand = function (name, callback, scope) {\r\n        this.editorCommands.addCommand(name, callback, scope);\r\n      };\r\n      Editor.prototype.addQueryStateHandler = function (name, callback, scope) {\r\n        this.editorCommands.addQueryStateHandler(name, callback, scope);\r\n      };\r\n      Editor.prototype.addQueryValueHandler = function (name, callback, scope) {\r\n        this.editorCommands.addQueryValueHandler(name, callback, scope);\r\n      };\r\n      Editor.prototype.addShortcut = function (pattern, desc, cmdFunc, scope) {\r\n        this.shortcuts.add(pattern, desc, cmdFunc, scope);\r\n      };\r\n      Editor.prototype.execCommand = function (cmd, ui, value, args) {\r\n        return this.editorCommands.execCommand(cmd, ui, value, args);\r\n      };\r\n      Editor.prototype.queryCommandState = function (cmd) {\r\n        return this.editorCommands.queryCommandState(cmd);\r\n      };\r\n      Editor.prototype.queryCommandValue = function (cmd) {\r\n        return this.editorCommands.queryCommandValue(cmd);\r\n      };\r\n      Editor.prototype.queryCommandSupported = function (cmd) {\r\n        return this.editorCommands.queryCommandSupported(cmd);\r\n      };\r\n      Editor.prototype.show = function () {\r\n        var self = this;\r\n        if (self.hidden) {\r\n          self.hidden = false;\r\n          if (self.inline) {\r\n            self.getBody().contentEditable = 'true';\r\n          } else {\r\n            DOM$1.show(self.getContainer());\r\n            DOM$1.hide(self.id);\r\n          }\r\n          self.load();\r\n          self.fire('show');\r\n        }\r\n      };\r\n      Editor.prototype.hide = function () {\r\n        var self = this, doc = self.getDoc();\r\n        if (!self.hidden) {\r\n          if (ie && doc && !self.inline) {\r\n            doc.execCommand('SelectAll');\r\n          }\r\n          self.save();\r\n          if (self.inline) {\r\n            self.getBody().contentEditable = 'false';\r\n            if (self === self.editorManager.focusedEditor) {\r\n              self.editorManager.focusedEditor = null;\r\n            }\r\n          } else {\r\n            DOM$1.hide(self.getContainer());\r\n            DOM$1.setStyle(self.id, 'display', self.orgDisplay);\r\n          }\r\n          self.hidden = true;\r\n          self.fire('hide');\r\n        }\r\n      };\r\n      Editor.prototype.isHidden = function () {\r\n        return !!this.hidden;\r\n      };\r\n      Editor.prototype.setProgressState = function (state, time) {\r\n        this.fire('ProgressState', {\r\n          state: state,\r\n          time: time\r\n        });\r\n      };\r\n      Editor.prototype.load = function (args) {\r\n        var self = this;\r\n        var elm = self.getElement(), html;\r\n        if (self.removed) {\r\n          return '';\r\n        }\r\n        if (elm) {\r\n          args = args || {};\r\n          args.load = true;\r\n          var value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\r\n          html = self.setContent(value, args);\r\n          args.element = elm;\r\n          if (!args.no_events) {\r\n            self.fire('LoadContent', args);\r\n          }\r\n          args.element = elm = null;\r\n          return html;\r\n        }\r\n      };\r\n      Editor.prototype.save = function (args) {\r\n        var self = this;\r\n        var elm = self.getElement(), html, form;\r\n        if (!elm || !self.initialized || self.removed) {\r\n          return;\r\n        }\r\n        args = args || {};\r\n        args.save = true;\r\n        args.element = elm;\r\n        html = args.content = self.getContent(args);\r\n        if (!args.no_events) {\r\n          self.fire('SaveContent', args);\r\n        }\r\n        if (args.format === 'raw') {\r\n          self.fire('RawSaveContent', args);\r\n        }\r\n        html = args.content;\r\n        if (!isTextareaOrInput(elm)) {\r\n          if (args.is_removing || !self.inline) {\r\n            elm.innerHTML = html;\r\n          }\r\n          if (form = DOM$1.getParent(self.id, 'form')) {\r\n            each$2(form.elements, function (elm) {\r\n              if (elm.name === self.id) {\r\n                elm.value = html;\r\n                return false;\r\n              }\r\n            });\r\n          }\r\n        } else {\r\n          elm.value = html;\r\n        }\r\n        args.element = elm = null;\r\n        if (args.set_dirty !== false) {\r\n          self.setDirty(false);\r\n        }\r\n        return html;\r\n      };\r\n      Editor.prototype.setContent = function (content, args) {\r\n        return setContent(this, content, args);\r\n      };\r\n      Editor.prototype.getContent = function (args) {\r\n        return getContent(this, args);\r\n      };\r\n      Editor.prototype.insertContent = function (content, args) {\r\n        if (args) {\r\n          content = extend$3({ content: content }, args);\r\n        }\r\n        this.execCommand('mceInsertContent', false, content);\r\n      };\r\n      Editor.prototype.resetContent = function (initialContent) {\r\n        if (initialContent === undefined) {\r\n          setContent(this, this.startContent, { format: 'raw' });\r\n        } else {\r\n          setContent(this, initialContent);\r\n        }\r\n        this.undoManager.reset();\r\n        this.setDirty(false);\r\n        this.nodeChanged();\r\n      };\r\n      Editor.prototype.isDirty = function () {\r\n        return !this.isNotDirty;\r\n      };\r\n      Editor.prototype.setDirty = function (state) {\r\n        var oldState = !this.isNotDirty;\r\n        this.isNotDirty = !state;\r\n        if (state && state !== oldState) {\r\n          this.fire('dirty');\r\n        }\r\n      };\r\n      Editor.prototype.getContainer = function () {\r\n        var self = this;\r\n        if (!self.container) {\r\n          self.container = DOM$1.get(self.editorContainer || self.id + '_parent');\r\n        }\r\n        return self.container;\r\n      };\r\n      Editor.prototype.getContentAreaContainer = function () {\r\n        return this.contentAreaContainer;\r\n      };\r\n      Editor.prototype.getElement = function () {\r\n        if (!this.targetElm) {\r\n          this.targetElm = DOM$1.get(this.id);\r\n        }\r\n        return this.targetElm;\r\n      };\r\n      Editor.prototype.getWin = function () {\r\n        var self = this;\r\n        var elm;\r\n        if (!self.contentWindow) {\r\n          elm = self.iframeElement;\r\n          if (elm) {\r\n            self.contentWindow = elm.contentWindow;\r\n          }\r\n        }\r\n        return self.contentWindow;\r\n      };\r\n      Editor.prototype.getDoc = function () {\r\n        var self = this;\r\n        var win;\r\n        if (!self.contentDocument) {\r\n          win = self.getWin();\r\n          if (win) {\r\n            self.contentDocument = win.document;\r\n          }\r\n        }\r\n        return self.contentDocument;\r\n      };\r\n      Editor.prototype.getBody = function () {\r\n        var doc = this.getDoc();\r\n        return this.bodyElement || (doc ? doc.body : null);\r\n      };\r\n      Editor.prototype.convertURL = function (url, name, elm) {\r\n        var self = this, settings = self.settings;\r\n        if (settings.urlconverter_callback) {\r\n          return self.execCallback('urlconverter_callback', url, elm, true, name);\r\n        }\r\n        if (!settings.convert_urls || elm && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\r\n          return url;\r\n        }\r\n        if (settings.relative_urls) {\r\n          return self.documentBaseURI.toRelative(url);\r\n        }\r\n        url = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);\r\n        return url;\r\n      };\r\n      Editor.prototype.addVisual = function (elm) {\r\n        addVisual(this, elm);\r\n      };\r\n      Editor.prototype.remove = function () {\r\n        remove(this);\r\n      };\r\n      Editor.prototype.destroy = function (automatic) {\r\n        destroy(this, automatic);\r\n      };\r\n      Editor.prototype.uploadImages = function (callback) {\r\n        return this.editorUpload.uploadImages(callback);\r\n      };\r\n      Editor.prototype._scanForImages = function () {\r\n        return this.editorUpload.scanForImages();\r\n      };\r\n      Editor.prototype.addButton = function () {\r\n        throw new Error('editor.addButton has been removed in tinymce 5x, use editor.ui.registry.addButton or editor.ui.registry.addToggleButton or editor.ui.registry.addSplitButton instead');\r\n      };\r\n      Editor.prototype.addSidebar = function () {\r\n        throw new Error('editor.addSidebar has been removed in tinymce 5x, use editor.ui.registry.addSidebar instead');\r\n      };\r\n      Editor.prototype.addMenuItem = function () {\r\n        throw new Error('editor.addMenuItem has been removed in tinymce 5x, use editor.ui.registry.addMenuItem instead');\r\n      };\r\n      Editor.prototype.addContextToolbar = function () {\r\n        throw new Error('editor.addContextToolbar has been removed in tinymce 5x, use editor.ui.registry.addContextToolbar instead');\r\n      };\r\n      return Editor;\r\n    }();\r\n\r\n    var DOM = DOMUtils.DOM;\r\n    var explode = Tools.explode, each$1 = Tools.each, extend$2 = Tools.extend;\r\n    var instanceCounter = 0, boundGlobalEvents = false;\r\n    var beforeUnloadDelegate;\r\n    var legacyEditors = [];\r\n    var editors = [];\r\n    var isValidLegacyKey = function (id) {\r\n      return id !== 'length';\r\n    };\r\n    var globalEventDelegate = function (e) {\r\n      var type = e.type;\r\n      each$1(EditorManager.get(), function (editor) {\r\n        switch (type) {\r\n        case 'scroll':\r\n          editor.fire('ScrollWindow', e);\r\n          break;\r\n        case 'resize':\r\n          editor.fire('ResizeWindow', e);\r\n          break;\r\n        }\r\n      });\r\n    };\r\n    var toggleGlobalEvents = function (state) {\r\n      if (state !== boundGlobalEvents) {\r\n        if (state) {\r\n          DomQuery(window).on('resize scroll', globalEventDelegate);\r\n        } else {\r\n          DomQuery(window).off('resize scroll', globalEventDelegate);\r\n        }\r\n        boundGlobalEvents = state;\r\n      }\r\n    };\r\n    var removeEditorFromList = function (targetEditor) {\r\n      var oldEditors = editors;\r\n      delete legacyEditors[targetEditor.id];\r\n      for (var i = 0; i < legacyEditors.length; i++) {\r\n        if (legacyEditors[i] === targetEditor) {\r\n          legacyEditors.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n      editors = filter$4(editors, function (editor) {\r\n        return targetEditor !== editor;\r\n      });\r\n      if (EditorManager.activeEditor === targetEditor) {\r\n        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\r\n      }\r\n      if (EditorManager.focusedEditor === targetEditor) {\r\n        EditorManager.focusedEditor = null;\r\n      }\r\n      return oldEditors.length !== editors.length;\r\n    };\r\n    var purgeDestroyedEditor = function (editor) {\r\n      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\r\n        removeEditorFromList(editor);\r\n        editor.unbindAllNativeEvents();\r\n        editor.destroy(true);\r\n        editor.removed = true;\r\n        editor = null;\r\n      }\r\n      return editor;\r\n    };\r\n    var isQuirksMode = document.compatMode !== 'CSS1Compat';\r\n    var EditorManager = __assign(__assign({}, Observable), {\r\n      baseURI: null,\r\n      baseURL: null,\r\n      defaultSettings: {},\r\n      documentBaseURL: null,\r\n      suffix: null,\r\n      $: DomQuery,\r\n      majorVersion: '5',\r\n      minorVersion: '10.8',\r\n      releaseDate: '2023-10-19',\r\n      editors: legacyEditors,\r\n      i18n: I18n,\r\n      activeEditor: null,\r\n      focusedEditor: null,\r\n      settings: {},\r\n      setup: function () {\r\n        var self = this;\r\n        var baseURL, documentBaseURL, suffix = '';\r\n        documentBaseURL = URI.getDocumentBaseUrl(document.location);\r\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\r\n          documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\r\n          if (!/[\\/\\\\]$/.test(documentBaseURL)) {\r\n            documentBaseURL += '/';\r\n          }\r\n        }\r\n        var preInit = window.tinymce || window.tinyMCEPreInit;\r\n        if (preInit) {\r\n          baseURL = preInit.base || preInit.baseURL;\r\n          suffix = preInit.suffix;\r\n        } else {\r\n          var scripts = document.getElementsByTagName('script');\r\n          for (var i = 0; i < scripts.length; i++) {\r\n            var src = scripts[i].src || '';\r\n            if (src === '') {\r\n              continue;\r\n            }\r\n            var srcScript = src.substring(src.lastIndexOf('/'));\r\n            if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\r\n              if (srcScript.indexOf('.min') !== -1) {\r\n                suffix = '.min';\r\n              }\r\n              baseURL = src.substring(0, src.lastIndexOf('/'));\r\n              break;\r\n            }\r\n          }\r\n          if (!baseURL && document.currentScript) {\r\n            var src = document.currentScript.src;\r\n            if (src.indexOf('.min') !== -1) {\r\n              suffix = '.min';\r\n            }\r\n            baseURL = src.substring(0, src.lastIndexOf('/'));\r\n          }\r\n        }\r\n        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\r\n        self.documentBaseURL = documentBaseURL;\r\n        self.baseURI = new URI(self.baseURL);\r\n        self.suffix = suffix;\r\n        setup$l(self);\r\n      },\r\n      overrideDefaults: function (defaultSettings) {\r\n        var baseUrl = defaultSettings.base_url;\r\n        if (baseUrl) {\r\n          this._setBaseUrl(baseUrl);\r\n        }\r\n        var suffix = defaultSettings.suffix;\r\n        if (defaultSettings.suffix) {\r\n          this.suffix = suffix;\r\n        }\r\n        this.defaultSettings = defaultSettings;\r\n        var pluginBaseUrls = defaultSettings.plugin_base_urls;\r\n        if (pluginBaseUrls !== undefined) {\r\n          each$j(pluginBaseUrls, function (pluginBaseUrl, pluginName) {\r\n            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\r\n          });\r\n        }\r\n      },\r\n      init: function (settings) {\r\n        var self = this;\r\n        var result;\r\n        var invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\r\n        var isInvalidInlineTarget = function (settings, elm) {\r\n          return settings.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\r\n        };\r\n        var createId = function (elm) {\r\n          var id = elm.id;\r\n          if (!id) {\r\n            id = get$9(elm, 'name').filter(function (name) {\r\n              return !DOM.get(name);\r\n            }).getOrThunk(DOM.uniqueId);\r\n            elm.setAttribute('id', id);\r\n          }\r\n          return id;\r\n        };\r\n        var execCallback = function (name) {\r\n          var callback = settings[name];\r\n          if (!callback) {\r\n            return;\r\n          }\r\n          return callback.apply(self, []);\r\n        };\r\n        var hasClass = function (elm, className) {\r\n          return className.constructor === RegExp ? className.test(elm.className) : DOM.hasClass(elm, className);\r\n        };\r\n        var findTargets = function (settings) {\r\n          var targets = [];\r\n          if (Env.browser.isIE() && Env.browser.version.major < 11) {\r\n            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/');\r\n            return [];\r\n          } else if (isQuirksMode) {\r\n            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\r\n            return [];\r\n          }\r\n          if (settings.types) {\r\n            each$1(settings.types, function (type) {\r\n              targets = targets.concat(DOM.select(type.selector));\r\n            });\r\n            return targets;\r\n          } else if (settings.selector) {\r\n            return DOM.select(settings.selector);\r\n          } else if (settings.target) {\r\n            return [settings.target];\r\n          }\r\n          switch (settings.mode) {\r\n          case 'exact':\r\n            var l = settings.elements || '';\r\n            if (l.length > 0) {\r\n              each$1(explode(l), function (id) {\r\n                var elm = DOM.get(id);\r\n                if (elm) {\r\n                  targets.push(elm);\r\n                } else {\r\n                  each$1(document.forms, function (f) {\r\n                    each$1(f.elements, function (e) {\r\n                      if (e.name === id) {\r\n                        id = 'mce_editor_' + instanceCounter++;\r\n                        DOM.setAttrib(e, 'id', id);\r\n                        targets.push(e);\r\n                      }\r\n                    });\r\n                  });\r\n                }\r\n              });\r\n            }\r\n            break;\r\n          case 'textareas':\r\n          case 'specific_textareas':\r\n            each$1(DOM.select('textarea'), function (elm) {\r\n              if (settings.editor_deselector && hasClass(elm, settings.editor_deselector)) {\r\n                return;\r\n              }\r\n              if (!settings.editor_selector || hasClass(elm, settings.editor_selector)) {\r\n                targets.push(elm);\r\n              }\r\n            });\r\n            break;\r\n          }\r\n          return targets;\r\n        };\r\n        var provideResults = function (editors) {\r\n          result = editors;\r\n        };\r\n        var initEditors = function () {\r\n          var initCount = 0;\r\n          var editors = [];\r\n          var targets;\r\n          var createEditor = function (id, settings, targetElm) {\r\n            var editor = new Editor(id, settings, self);\r\n            editors.push(editor);\r\n            editor.on('init', function () {\r\n              if (++initCount === targets.length) {\r\n                provideResults(editors);\r\n              }\r\n            });\r\n            editor.targetElm = editor.targetElm || targetElm;\r\n            editor.render();\r\n          };\r\n          DOM.unbind(window, 'ready', initEditors);\r\n          execCallback('onpageload');\r\n          targets = DomQuery.unique(findTargets(settings));\r\n          if (settings.types) {\r\n            each$1(settings.types, function (type) {\r\n              Tools.each(targets, function (elm) {\r\n                if (DOM.is(elm, type.selector)) {\r\n                  createEditor(createId(elm), extend$2({}, settings, type), elm);\r\n                  return false;\r\n                }\r\n                return true;\r\n              });\r\n            });\r\n            return;\r\n          }\r\n          Tools.each(targets, function (elm) {\r\n            purgeDestroyedEditor(self.get(elm.id));\r\n          });\r\n          targets = Tools.grep(targets, function (elm) {\r\n            return !self.get(elm.id);\r\n          });\r\n          if (targets.length === 0) {\r\n            provideResults([]);\r\n          } else {\r\n            each$1(targets, function (elm) {\r\n              if (isInvalidInlineTarget(settings, elm)) {\r\n                initError('Could not initialize inline editor on invalid inline target element', elm);\r\n              } else {\r\n                createEditor(createId(elm), settings, elm);\r\n              }\r\n            });\r\n          }\r\n        };\r\n        self.settings = settings;\r\n        DOM.bind(window, 'ready', initEditors);\r\n        return new promiseObj(function (resolve) {\r\n          if (result) {\r\n            resolve(result);\r\n          } else {\r\n            provideResults = function (editors) {\r\n              resolve(editors);\r\n            };\r\n          }\r\n        });\r\n      },\r\n      get: function (id) {\r\n        if (arguments.length === 0) {\r\n          return editors.slice(0);\r\n        } else if (isString$1(id)) {\r\n          return find$3(editors, function (editor) {\r\n            return editor.id === id;\r\n          }).getOr(null);\r\n        } else if (isNumber(id)) {\r\n          return editors[id] ? editors[id] : null;\r\n        } else {\r\n          return null;\r\n        }\r\n      },\r\n      add: function (editor) {\r\n        var self = this;\r\n        var existingEditor = legacyEditors[editor.id];\r\n        if (existingEditor === editor) {\r\n          return editor;\r\n        }\r\n        if (self.get(editor.id) === null) {\r\n          if (isValidLegacyKey(editor.id)) {\r\n            legacyEditors[editor.id] = editor;\r\n          }\r\n          legacyEditors.push(editor);\r\n          editors.push(editor);\r\n        }\r\n        toggleGlobalEvents(true);\r\n        self.activeEditor = editor;\r\n        self.fire('AddEditor', { editor: editor });\r\n        if (!beforeUnloadDelegate) {\r\n          beforeUnloadDelegate = function (e) {\r\n            var event = self.fire('BeforeUnload');\r\n            if (event.returnValue) {\r\n              e.preventDefault();\r\n              e.returnValue = event.returnValue;\r\n              return event.returnValue;\r\n            }\r\n          };\r\n          window.addEventListener('beforeunload', beforeUnloadDelegate);\r\n        }\r\n        return editor;\r\n      },\r\n      createEditor: function (id, settings) {\r\n        return this.add(new Editor(id, settings, this));\r\n      },\r\n      remove: function (selector) {\r\n        var self = this;\r\n        var i, editor;\r\n        if (!selector) {\r\n          for (i = editors.length - 1; i >= 0; i--) {\r\n            self.remove(editors[i]);\r\n          }\r\n          return;\r\n        }\r\n        if (isString$1(selector)) {\r\n          each$1(DOM.select(selector), function (elm) {\r\n            editor = self.get(elm.id);\r\n            if (editor) {\r\n              self.remove(editor);\r\n            }\r\n          });\r\n          return;\r\n        }\r\n        editor = selector;\r\n        if (isNull(self.get(editor.id))) {\r\n          return null;\r\n        }\r\n        if (removeEditorFromList(editor)) {\r\n          self.fire('RemoveEditor', { editor: editor });\r\n        }\r\n        if (editors.length === 0) {\r\n          window.removeEventListener('beforeunload', beforeUnloadDelegate);\r\n        }\r\n        editor.remove();\r\n        toggleGlobalEvents(editors.length > 0);\r\n        return editor;\r\n      },\r\n      execCommand: function (cmd, ui, value) {\r\n        var self = this, editor = self.get(value);\r\n        switch (cmd) {\r\n        case 'mceAddEditor':\r\n          if (!self.get(value)) {\r\n            new Editor(value, self.settings, self).render();\r\n          }\r\n          return true;\r\n        case 'mceRemoveEditor':\r\n          if (editor) {\r\n            editor.remove();\r\n          }\r\n          return true;\r\n        case 'mceToggleEditor':\r\n          if (!editor) {\r\n            self.execCommand('mceAddEditor', false, value);\r\n            return true;\r\n          }\r\n          if (editor.isHidden()) {\r\n            editor.show();\r\n          } else {\r\n            editor.hide();\r\n          }\r\n          return true;\r\n        }\r\n        if (self.activeEditor) {\r\n          return self.activeEditor.execCommand(cmd, ui, value);\r\n        }\r\n        return false;\r\n      },\r\n      triggerSave: function () {\r\n        each$1(editors, function (editor) {\r\n          editor.save();\r\n        });\r\n      },\r\n      addI18n: function (code, items) {\r\n        I18n.add(code, items);\r\n      },\r\n      translate: function (text) {\r\n        return I18n.translate(text);\r\n      },\r\n      setActive: function (editor) {\r\n        var activeEditor = this.activeEditor;\r\n        if (this.activeEditor !== editor) {\r\n          if (activeEditor) {\r\n            activeEditor.fire('deactivate', { relatedTarget: editor });\r\n          }\r\n          editor.fire('activate', { relatedTarget: activeEditor });\r\n        }\r\n        this.activeEditor = editor;\r\n      },\r\n      _setBaseUrl: function (baseUrl) {\r\n        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\r\n        this.baseURI = new URI(this.baseURL);\r\n      }\r\n    });\r\n    EditorManager.setup();\r\n\r\n    var min$1 = Math.min, max$1 = Math.max, round$1 = Math.round;\r\n    var relativePosition = function (rect, targetRect, rel) {\r\n      var x = targetRect.x;\r\n      var y = targetRect.y;\r\n      var w = rect.w;\r\n      var h = rect.h;\r\n      var targetW = targetRect.w;\r\n      var targetH = targetRect.h;\r\n      var relChars = (rel || '').split('');\r\n      if (relChars[0] === 'b') {\r\n        y += targetH;\r\n      }\r\n      if (relChars[1] === 'r') {\r\n        x += targetW;\r\n      }\r\n      if (relChars[0] === 'c') {\r\n        y += round$1(targetH / 2);\r\n      }\r\n      if (relChars[1] === 'c') {\r\n        x += round$1(targetW / 2);\r\n      }\r\n      if (relChars[3] === 'b') {\r\n        y -= h;\r\n      }\r\n      if (relChars[4] === 'r') {\r\n        x -= w;\r\n      }\r\n      if (relChars[3] === 'c') {\r\n        y -= round$1(h / 2);\r\n      }\r\n      if (relChars[4] === 'c') {\r\n        x -= round$1(w / 2);\r\n      }\r\n      return create$2(x, y, w, h);\r\n    };\r\n    var findBestRelativePosition = function (rect, targetRect, constrainRect, rels) {\r\n      var pos, i;\r\n      for (i = 0; i < rels.length; i++) {\r\n        pos = relativePosition(rect, targetRect, rels[i]);\r\n        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\r\n          return rels[i];\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    var inflate = function (rect, w, h) {\r\n      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\r\n    };\r\n    var intersect = function (rect, cropRect) {\r\n      var x1 = max$1(rect.x, cropRect.x);\r\n      var y1 = max$1(rect.y, cropRect.y);\r\n      var x2 = min$1(rect.x + rect.w, cropRect.x + cropRect.w);\r\n      var y2 = min$1(rect.y + rect.h, cropRect.y + cropRect.h);\r\n      if (x2 - x1 < 0 || y2 - y1 < 0) {\r\n        return null;\r\n      }\r\n      return create$2(x1, y1, x2 - x1, y2 - y1);\r\n    };\r\n    var clamp = function (rect, clampRect, fixedSize) {\r\n      var x1 = rect.x;\r\n      var y1 = rect.y;\r\n      var x2 = rect.x + rect.w;\r\n      var y2 = rect.y + rect.h;\r\n      var cx2 = clampRect.x + clampRect.w;\r\n      var cy2 = clampRect.y + clampRect.h;\r\n      var underflowX1 = max$1(0, clampRect.x - x1);\r\n      var underflowY1 = max$1(0, clampRect.y - y1);\r\n      var overflowX2 = max$1(0, x2 - cx2);\r\n      var overflowY2 = max$1(0, y2 - cy2);\r\n      x1 += underflowX1;\r\n      y1 += underflowY1;\r\n      if (fixedSize) {\r\n        x2 += underflowX1;\r\n        y2 += underflowY1;\r\n        x1 -= overflowX2;\r\n        y1 -= overflowY2;\r\n      }\r\n      x2 -= overflowX2;\r\n      y2 -= overflowY2;\r\n      return create$2(x1, y1, x2 - x1, y2 - y1);\r\n    };\r\n    var create$2 = function (x, y, w, h) {\r\n      return {\r\n        x: x,\r\n        y: y,\r\n        w: w,\r\n        h: h\r\n      };\r\n    };\r\n    var fromClientRect = function (clientRect) {\r\n      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\r\n    };\r\n    var Rect = {\r\n      inflate: inflate,\r\n      relativePosition: relativePosition,\r\n      findBestRelativePosition: findBestRelativePosition,\r\n      intersect: intersect,\r\n      clamp: clamp,\r\n      create: create$2,\r\n      fromClientRect: fromClientRect\r\n    };\r\n\r\n    var awaiter = function (resolveCb, rejectCb, timeout) {\r\n      if (timeout === void 0) {\r\n        timeout = 1000;\r\n      }\r\n      var done = false;\r\n      var timer = null;\r\n      var complete = function (completer) {\r\n        return function () {\r\n          var args = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n          }\r\n          if (!done) {\r\n            done = true;\r\n            if (timer !== null) {\r\n              clearTimeout(timer);\r\n              timer = null;\r\n            }\r\n            completer.apply(null, args);\r\n          }\r\n        };\r\n      };\r\n      var resolve = complete(resolveCb);\r\n      var reject = complete(rejectCb);\r\n      var start = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n        }\r\n        if (!done && timer === null) {\r\n          timer = setTimeout(function () {\r\n            return reject.apply(null, args);\r\n          }, timeout);\r\n        }\r\n      };\r\n      return {\r\n        start: start,\r\n        resolve: resolve,\r\n        reject: reject\r\n      };\r\n    };\r\n    var create$1 = function () {\r\n      var tasks = {};\r\n      var resultFns = {};\r\n      var load = function (id, url) {\r\n        var loadErrMsg = 'Script at URL \"' + url + '\" failed to load';\r\n        var runErrMsg = 'Script at URL \"' + url + '\" did not call `tinymce.Resource.add(\\'' + id + '\\', data)` within 1 second';\r\n        if (tasks[id] !== undefined) {\r\n          return tasks[id];\r\n        } else {\r\n          var task = new promiseObj(function (resolve, reject) {\r\n            var waiter = awaiter(resolve, reject);\r\n            resultFns[id] = waiter.resolve;\r\n            ScriptLoader.ScriptLoader.loadScript(url, function () {\r\n              return waiter.start(runErrMsg);\r\n            }, function () {\r\n              return waiter.reject(loadErrMsg);\r\n            });\r\n          });\r\n          tasks[id] = task;\r\n          return task;\r\n        }\r\n      };\r\n      var add = function (id, data) {\r\n        if (resultFns[id] !== undefined) {\r\n          resultFns[id](data);\r\n          delete resultFns[id];\r\n        }\r\n        tasks[id] = promiseObj.resolve(data);\r\n      };\r\n      return {\r\n        load: load,\r\n        add: add\r\n      };\r\n    };\r\n    var Resource = create$1();\r\n\r\n    var each = Tools.each, extend$1 = Tools.extend;\r\n    var extendClass, initializing;\r\n    var Class = function () {\r\n    };\r\n    Class.extend = extendClass = function (props) {\r\n      var self = this;\r\n      var _super = self.prototype;\r\n      var Class = function () {\r\n        var i, mixins, mixin;\r\n        var self = this;\r\n        if (!initializing) {\r\n          if (self.init) {\r\n            self.init.apply(self, arguments);\r\n          }\r\n          mixins = self.Mixins;\r\n          if (mixins) {\r\n            i = mixins.length;\r\n            while (i--) {\r\n              mixin = mixins[i];\r\n              if (mixin.init) {\r\n                mixin.init.apply(self, arguments);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n      var dummy = function () {\r\n        return this;\r\n      };\r\n      var createMethod = function (name, fn) {\r\n        return function () {\r\n          var self = this;\r\n          var tmp = self._super;\r\n          self._super = _super[name];\r\n          var ret = fn.apply(self, arguments);\r\n          self._super = tmp;\r\n          return ret;\r\n        };\r\n      };\r\n      initializing = true;\r\n      var prototype = new self();\r\n      initializing = false;\r\n      if (props.Mixins) {\r\n        each(props.Mixins, function (mixin) {\r\n          for (var name_1 in mixin) {\r\n            if (name_1 !== 'init') {\r\n              props[name_1] = mixin[name_1];\r\n            }\r\n          }\r\n        });\r\n        if (_super.Mixins) {\r\n          props.Mixins = _super.Mixins.concat(props.Mixins);\r\n        }\r\n      }\r\n      if (props.Methods) {\r\n        each(props.Methods.split(','), function (name) {\r\n          props[name] = dummy;\r\n        });\r\n      }\r\n      if (props.Properties) {\r\n        each(props.Properties.split(','), function (name) {\r\n          var fieldName = '_' + name;\r\n          props[name] = function (value) {\r\n            var self = this;\r\n            if (value !== undefined) {\r\n              self[fieldName] = value;\r\n              return self;\r\n            }\r\n            return self[fieldName];\r\n          };\r\n        });\r\n      }\r\n      if (props.Statics) {\r\n        each(props.Statics, function (func, name) {\r\n          Class[name] = func;\r\n        });\r\n      }\r\n      if (props.Defaults && _super.Defaults) {\r\n        props.Defaults = extend$1({}, _super.Defaults, props.Defaults);\r\n      }\r\n      each$j(props, function (member, name) {\r\n        if (typeof member === 'function' && _super[name]) {\r\n          prototype[name] = createMethod(name, member);\r\n        } else {\r\n          prototype[name] = member;\r\n        }\r\n      });\r\n      Class.prototype = prototype;\r\n      Class.constructor = Class;\r\n      Class.extend = extendClass;\r\n      return Class;\r\n    };\r\n\r\n    var min = Math.min, max = Math.max, round = Math.round;\r\n    var Color = function (value) {\r\n      var self = {};\r\n      var r = 0, g = 0, b = 0;\r\n      var rgb2hsv = function (r, g, b) {\r\n        var h, s, v;\r\n        h = 0;\r\n        s = 0;\r\n        v = 0;\r\n        r = r / 255;\r\n        g = g / 255;\r\n        b = b / 255;\r\n        var minRGB = min(r, min(g, b));\r\n        var maxRGB = max(r, max(g, b));\r\n        if (minRGB === maxRGB) {\r\n          v = minRGB;\r\n          return {\r\n            h: 0,\r\n            s: 0,\r\n            v: v * 100\r\n          };\r\n        }\r\n        var d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;\r\n        h = r === minRGB ? 3 : b === minRGB ? 1 : 5;\r\n        h = 60 * (h - d / (maxRGB - minRGB));\r\n        s = (maxRGB - minRGB) / maxRGB;\r\n        v = maxRGB;\r\n        return {\r\n          h: round(h),\r\n          s: round(s * 100),\r\n          v: round(v * 100)\r\n        };\r\n      };\r\n      var hsvToRgb = function (hue, saturation, brightness) {\r\n        hue = (parseInt(hue, 10) || 0) % 360;\r\n        saturation = parseInt(saturation, 10) / 100;\r\n        brightness = parseInt(brightness, 10) / 100;\r\n        saturation = max(0, min(saturation, 1));\r\n        brightness = max(0, min(brightness, 1));\r\n        if (saturation === 0) {\r\n          r = g = b = round(255 * brightness);\r\n          return;\r\n        }\r\n        var side = hue / 60;\r\n        var chroma = brightness * saturation;\r\n        var x = chroma * (1 - Math.abs(side % 2 - 1));\r\n        var match = brightness - chroma;\r\n        switch (Math.floor(side)) {\r\n        case 0:\r\n          r = chroma;\r\n          g = x;\r\n          b = 0;\r\n          break;\r\n        case 1:\r\n          r = x;\r\n          g = chroma;\r\n          b = 0;\r\n          break;\r\n        case 2:\r\n          r = 0;\r\n          g = chroma;\r\n          b = x;\r\n          break;\r\n        case 3:\r\n          r = 0;\r\n          g = x;\r\n          b = chroma;\r\n          break;\r\n        case 4:\r\n          r = x;\r\n          g = 0;\r\n          b = chroma;\r\n          break;\r\n        case 5:\r\n          r = chroma;\r\n          g = 0;\r\n          b = x;\r\n          break;\r\n        default:\r\n          r = g = b = 0;\r\n        }\r\n        r = round(255 * (r + match));\r\n        g = round(255 * (g + match));\r\n        b = round(255 * (b + match));\r\n      };\r\n      var toHex = function () {\r\n        var hex = function (val) {\r\n          val = parseInt(val, 10).toString(16);\r\n          return val.length > 1 ? val : '0' + val;\r\n        };\r\n        return '#' + hex(r) + hex(g) + hex(b);\r\n      };\r\n      var toRgb = function () {\r\n        return {\r\n          r: r,\r\n          g: g,\r\n          b: b\r\n        };\r\n      };\r\n      var toHsv = function () {\r\n        return rgb2hsv(r, g, b);\r\n      };\r\n      var parse = function (value) {\r\n        var matches;\r\n        if (typeof value === 'object') {\r\n          if ('r' in value) {\r\n            r = value.r;\r\n            g = value.g;\r\n            b = value.b;\r\n          } else if ('v' in value) {\r\n            hsvToRgb(value.h, value.s, value.v);\r\n          }\r\n        } else {\r\n          if (matches = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)[^\\)]*\\)/gi.exec(value)) {\r\n            r = parseInt(matches[1], 10);\r\n            g = parseInt(matches[2], 10);\r\n            b = parseInt(matches[3], 10);\r\n          } else if (matches = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value)) {\r\n            r = parseInt(matches[1], 16);\r\n            g = parseInt(matches[2], 16);\r\n            b = parseInt(matches[3], 16);\r\n          } else if (matches = /#([0-F])([0-F])([0-F])/gi.exec(value)) {\r\n            r = parseInt(matches[1] + matches[1], 16);\r\n            g = parseInt(matches[2] + matches[2], 16);\r\n            b = parseInt(matches[3] + matches[3], 16);\r\n          }\r\n        }\r\n        r = r < 0 ? 0 : r > 255 ? 255 : r;\r\n        g = g < 0 ? 0 : g > 255 ? 255 : g;\r\n        b = b < 0 ? 0 : b > 255 ? 255 : b;\r\n        return self;\r\n      };\r\n      if (value) {\r\n        parse(value);\r\n      }\r\n      self.toRgb = toRgb;\r\n      self.toHsv = toHsv;\r\n      self.toHex = toHex;\r\n      self.parse = parse;\r\n      return self;\r\n    };\r\n\r\n    var serialize = function (obj) {\r\n      var data = JSON.stringify(obj);\r\n      if (!isString$1(data)) {\r\n        return data;\r\n      }\r\n      return data.replace(/[\\u0080-\\uFFFF]/g, function (match) {\r\n        var hexCode = match.charCodeAt(0).toString(16);\r\n        return '\\\\u' + '0000'.substring(hexCode.length) + hexCode;\r\n      });\r\n    };\r\n    var JSONUtils = {\r\n      serialize: serialize,\r\n      parse: function (text) {\r\n        try {\r\n          return JSON.parse(text);\r\n        } catch (ex) {\r\n        }\r\n      }\r\n    };\r\n\r\n    var JSONP = {\r\n      callbacks: {},\r\n      count: 0,\r\n      send: function (settings) {\r\n        var self = this, dom = DOMUtils.DOM, count = settings.count !== undefined ? settings.count : self.count;\r\n        var id = 'tinymce_jsonp_' + count;\r\n        self.callbacks[count] = function (json) {\r\n          dom.remove(id);\r\n          delete self.callbacks[count];\r\n          settings.callback(json);\r\n        };\r\n        dom.add(dom.doc.body, 'script', {\r\n          id: id,\r\n          src: settings.url,\r\n          type: 'text/javascript'\r\n        });\r\n        self.count++;\r\n      }\r\n    };\r\n\r\n    var XHR = __assign(__assign({}, Observable), {\r\n      send: function (settings) {\r\n        var xhr, count = 0;\r\n        var ready = function () {\r\n          if (!settings.async || xhr.readyState === 4 || count++ > 10000) {\r\n            if (settings.success && count < 10000 && xhr.status === 200) {\r\n              settings.success.call(settings.success_scope, '' + xhr.responseText, xhr, settings);\r\n            } else if (settings.error) {\r\n              settings.error.call(settings.error_scope, count > 10000 ? 'TIMED_OUT' : 'GENERAL', xhr, settings);\r\n            }\r\n            xhr = null;\r\n          } else {\r\n            Delay.setTimeout(ready, 10);\r\n          }\r\n        };\r\n        settings.scope = settings.scope || this;\r\n        settings.success_scope = settings.success_scope || settings.scope;\r\n        settings.error_scope = settings.error_scope || settings.scope;\r\n        settings.async = settings.async !== false;\r\n        settings.data = settings.data || '';\r\n        XHR.fire('beforeInitialize', { settings: settings });\r\n        xhr = new XMLHttpRequest();\r\n        if (xhr.overrideMimeType) {\r\n          xhr.overrideMimeType(settings.content_type);\r\n        }\r\n        xhr.open(settings.type || (settings.data ? 'POST' : 'GET'), settings.url, settings.async);\r\n        if (settings.crossDomain) {\r\n          xhr.withCredentials = true;\r\n        }\r\n        if (settings.content_type) {\r\n          xhr.setRequestHeader('Content-Type', settings.content_type);\r\n        }\r\n        if (settings.requestheaders) {\r\n          Tools.each(settings.requestheaders, function (header) {\r\n            xhr.setRequestHeader(header.key, header.value);\r\n          });\r\n        }\r\n        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\r\n        xhr = XHR.fire('beforeSend', {\r\n          xhr: xhr,\r\n          settings: settings\r\n        }).xhr;\r\n        xhr.send(settings.data);\r\n        if (!settings.async) {\r\n          return ready();\r\n        }\r\n        Delay.setTimeout(ready, 10);\r\n      }\r\n    });\r\n\r\n    var extend = Tools.extend;\r\n    var JSONRequest = function () {\r\n      function JSONRequest(settings) {\r\n        this.settings = extend({}, settings);\r\n        this.count = 0;\r\n      }\r\n      JSONRequest.sendRPC = function (o) {\r\n        return new JSONRequest().send(o);\r\n      };\r\n      JSONRequest.prototype.send = function (args) {\r\n        var ecb = args.error, scb = args.success;\r\n        var xhrArgs = extend(this.settings, args);\r\n        xhrArgs.success = function (c, x) {\r\n          c = JSONUtils.parse(c);\r\n          if (typeof c === 'undefined') {\r\n            c = { error: 'JSON Parse error.' };\r\n          }\r\n          if (c.error) {\r\n            ecb.call(xhrArgs.error_scope || xhrArgs.scope, c.error, x);\r\n          } else {\r\n            scb.call(xhrArgs.success_scope || xhrArgs.scope, c.result);\r\n          }\r\n        };\r\n        xhrArgs.error = function (ty, x) {\r\n          if (ecb) {\r\n            ecb.call(xhrArgs.error_scope || xhrArgs.scope, ty, x);\r\n          }\r\n        };\r\n        xhrArgs.data = JSONUtils.serialize({\r\n          id: args.id || 'c' + this.count++,\r\n          method: args.method,\r\n          params: args.params\r\n        });\r\n        xhrArgs.content_type = 'application/json';\r\n        XHR.send(xhrArgs);\r\n      };\r\n      return JSONRequest;\r\n    }();\r\n\r\n    var create = function () {\r\n      return function () {\r\n        var data = {};\r\n        var keys = [];\r\n        var storage = {\r\n          getItem: function (key) {\r\n            var item = data[key];\r\n            return item ? item : null;\r\n          },\r\n          setItem: function (key, value) {\r\n            keys.push(key);\r\n            data[key] = String(value);\r\n          },\r\n          key: function (index) {\r\n            return keys[index];\r\n          },\r\n          removeItem: function (key) {\r\n            keys = keys.filter(function (k) {\r\n              return k === key;\r\n            });\r\n            delete data[key];\r\n          },\r\n          clear: function () {\r\n            keys = [];\r\n            data = {};\r\n          },\r\n          length: 0\r\n        };\r\n        Object.defineProperty(storage, 'length', {\r\n          get: function () {\r\n            return keys.length;\r\n          },\r\n          configurable: false,\r\n          enumerable: false\r\n        });\r\n        return storage;\r\n      }();\r\n    };\r\n\r\n    var localStorage;\r\n    try {\r\n      var test = '__storage_test__';\r\n      localStorage = window.localStorage;\r\n      localStorage.setItem(test, test);\r\n      localStorage.removeItem(test);\r\n    } catch (e) {\r\n      localStorage = create();\r\n    }\r\n    var LocalStorage = localStorage;\r\n\r\n    var publicApi = {\r\n      geom: { Rect: Rect },\r\n      util: {\r\n        Promise: promiseObj,\r\n        Delay: Delay,\r\n        Tools: Tools,\r\n        VK: VK,\r\n        URI: URI,\r\n        Class: Class,\r\n        EventDispatcher: EventDispatcher,\r\n        Observable: Observable,\r\n        I18n: I18n,\r\n        XHR: XHR,\r\n        JSON: JSONUtils,\r\n        JSONRequest: JSONRequest,\r\n        JSONP: JSONP,\r\n        LocalStorage: LocalStorage,\r\n        Color: Color,\r\n        ImageUploader: ImageUploader\r\n      },\r\n      dom: {\r\n        EventUtils: EventUtils,\r\n        Sizzle: Sizzle,\r\n        DomQuery: DomQuery,\r\n        TreeWalker: DomTreeWalker,\r\n        TextSeeker: TextSeeker,\r\n        DOMUtils: DOMUtils,\r\n        ScriptLoader: ScriptLoader,\r\n        RangeUtils: RangeUtils,\r\n        Serializer: DomSerializer,\r\n        StyleSheetLoader: StyleSheetLoader,\r\n        ControlSelection: ControlSelection,\r\n        BookmarkManager: BookmarkManager,\r\n        Selection: EditorSelection,\r\n        Event: EventUtils.Event\r\n      },\r\n      html: {\r\n        Styles: Styles,\r\n        Entities: Entities,\r\n        Node: AstNode,\r\n        Schema: Schema,\r\n        SaxParser: SaxParser,\r\n        DomParser: DomParser,\r\n        Writer: Writer,\r\n        Serializer: HtmlSerializer\r\n      },\r\n      Env: Env,\r\n      AddOnManager: AddOnManager,\r\n      Annotator: Annotator,\r\n      Formatter: Formatter,\r\n      UndoManager: UndoManager,\r\n      EditorCommands: EditorCommands,\r\n      WindowManager: WindowManager,\r\n      NotificationManager: NotificationManager,\r\n      EditorObservable: EditorObservable,\r\n      Shortcuts: Shortcuts,\r\n      Editor: Editor,\r\n      FocusManager: FocusManager,\r\n      EditorManager: EditorManager,\r\n      DOM: DOMUtils.DOM,\r\n      ScriptLoader: ScriptLoader.ScriptLoader,\r\n      PluginManager: PluginManager,\r\n      ThemeManager: ThemeManager,\r\n      IconManager: IconManager,\r\n      Resource: Resource,\r\n      trim: Tools.trim,\r\n      isArray: Tools.isArray,\r\n      is: Tools.is,\r\n      toArray: Tools.toArray,\r\n      makeMap: Tools.makeMap,\r\n      each: Tools.each,\r\n      map: Tools.map,\r\n      grep: Tools.grep,\r\n      inArray: Tools.inArray,\r\n      extend: Tools.extend,\r\n      create: Tools.create,\r\n      walk: Tools.walk,\r\n      createNS: Tools.createNS,\r\n      resolve: Tools.resolve,\r\n      explode: Tools.explode,\r\n      _addCacheSuffix: Tools._addCacheSuffix,\r\n      isOpera: Env.opera,\r\n      isWebKit: Env.webkit,\r\n      isIE: Env.ie,\r\n      isGecko: Env.gecko,\r\n      isMac: Env.mac\r\n    };\r\n    var tinymce = Tools.extend(EditorManager, publicApi);\r\n\r\n    var exportToModuleLoaders = function (tinymce) {\r\n      if (true) {\r\n        try {\r\n          module.exports = tinymce;\r\n        } catch (_) {\r\n        }\r\n      }\r\n    };\r\n    var exportToWindowGlobal = function (tinymce) {\r\n      window.tinymce = tinymce;\r\n      window.tinyMCE = tinymce;\r\n    };\r\n    exportToWindowGlobal(tinymce);\r\n    exportToModuleLoaders(tinymce);\r\n\r\n}());\r\n\n\n//# sourceURL=webpack://test/./node_modules/tinymce/tinymce.js?\n}");

/***/ }),

/***/ "./src/script.js":
/*!***********************!*\
  !*** ./src/script.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tinymce_tinymce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tinymce/tinymce */ \"./node_modules/tinymce/tinymce.js\");\n/* harmony import */ var tinymce_tinymce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tinymce_tinymce__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tinymce_themes_silver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tinymce/themes/silver */ \"./node_modules/tinymce/themes/silver/index.js\");\n/* harmony import */ var tinymce_themes_silver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tinymce_themes_silver__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var tinymce_icons_default__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tinymce/icons/default */ \"./node_modules/tinymce/icons/default/index.js\");\n/* harmony import */ var tinymce_icons_default__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(tinymce_icons_default__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var tinymce_plugins_lists__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tinymce/plugins/lists */ \"./node_modules/tinymce/plugins/lists/index.js\");\n/* harmony import */ var tinymce_plugins_lists__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(tinymce_plugins_lists__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style.css */ \"./style.css\");\n\r\n\r\n\r\n\r\n\r\n\r\n(tinymce_tinymce__WEBPACK_IMPORTED_MODULE_0___default().baseURL) = \"./tinymce\";\r\n\r\nlet templates = [\"template 1\", \"template 2\", \"template 3\"];\r\nlet selectedTemplateIndex = 0;\r\n\r\nconst templatesList = document.getElementById(\"templatesList\");\r\nconst addTemplateBtn = document.getElementById(\"addTemplateBtn\");\r\nconst removeTemplateBtn = document.getElementById(\"removeTemplateBtn\");\r\nconst editTemplateInput = document.getElementById(\"editTemplateInput\");\r\n\r\nfunction renderTemplatesList() {\r\n  templatesList.innerHTML = \"\";\r\n  templates.forEach((t, i) => {\r\n    const li = document.createElement(\"li\");\r\n    li.textContent = t;\r\n    li.dataset.index = i;\r\n    if (i === selectedTemplateIndex) li.classList.add(\"selected\");\r\n    templatesList.appendChild(li);\r\n  });\r\n}\r\n\r\nrenderTemplatesList();\r\n\r\ntemplatesList.addEventListener(\"click\", (e) => {\r\n  if (e.target.tagName !== \"LI\") return;\r\n  selectedTemplateIndex = +e.target.dataset.index;\r\n  renderTemplatesList();\r\n  editTemplateInput.value = templates[selectedTemplateIndex];\r\n});\r\n\r\naddTemplateBtn.addEventListener(\"click\", () => {\r\n  templates.push(\"template\");\r\n  selectedTemplateIndex = templates.length - 1;\r\n  renderTemplatesList();\r\n  editTemplateInput.value = templates[selectedTemplateIndex];\r\n  updateAllDropdowns(editor);\r\n});\r\n\r\nremoveTemplateBtn.addEventListener(\"click\", () => {\r\n  if (templates.length === 0) return;\r\n  templates.splice(selectedTemplateIndex, 1);\r\n  if (selectedTemplateIndex >= templates.length) {\r\n    selectedTemplateIndex = templates.length - 1;\r\n  }\r\n  renderTemplatesList();\r\n  editTemplateInput.value =\r\n    selectedTemplateIndex >= 0 ? templates[selectedTemplateIndex] : \"\";\r\n  updateAllDropdowns(editor);\r\n});\r\n\r\nfunction applyEdit() {\r\n  if (selectedTemplateIndex < 0) return;\r\n  templates[selectedTemplateIndex] = editTemplateInput.value;\r\n  renderTemplatesList();\r\n  updateAllDropdowns(editor);\r\n}\r\n\r\neditTemplateInput.addEventListener(\"blur\", applyEdit);\r\neditTemplateInput.addEventListener(\"keydown\", (e) => {\r\n  if (e.key === \"Enter\") {\r\n    e.preventDefault();\r\n    applyEdit();\r\n    editTemplateInput.blur();\r\n  }\r\n});\r\n\r\nfunction createDropdownHTML(index) {\r\n  if (index < 0 || index >= templates.length) {\r\n    return `<span style=\"color:red;font-weight:bold;\">ERROR</span>`;\r\n  }\r\n  return `<select class=\"template-dropdown\" data-template-index=\"${index}\">${templates\r\n    .map(\r\n      (tpl, i) =>\r\n        `<option value=\"${i}\" ${i === index ? \"selected\" : \"\"}>${tpl}</option>`\r\n    )\r\n    .join(\"\")}</select>`;\r\n}\r\n\r\nfunction updateAllDropdowns(editor) {\r\n  if (!editor) return;\r\n\r\n  const body = editor.getBody();\r\n  if (!body) return;\r\n\r\n  const selects = body.querySelectorAll(\"select.template-dropdown\");\r\n\r\n  selects.forEach((select) => {\r\n    const currentValue = select.value;\r\n    const currentIndex = parseInt(currentValue, 10);\r\n\r\n    if (\r\n      isNaN(currentIndex) ||\r\n      currentIndex < 0 ||\r\n      currentIndex >= templates.length\r\n    ) {\r\n      const errorSpan = editor.dom.create(\r\n        \"span\",\r\n        {\r\n          style: \"color:red;font-weight:bold;\",\r\n        },\r\n        \"ERROR\"\r\n      );\r\n\r\n      select.replaceWith(errorSpan);\r\n      return;\r\n    }\r\n\r\n    while (select.firstChild) {\r\n      select.removeChild(select.firstChild);\r\n    }\r\n\r\n    templates.forEach((tpl, i) => {\r\n      const option = editor.dom.create(\"option\", { value: i }, tpl);\r\n      if (i.toString() === currentValue) {\r\n        option.selected = true;\r\n      }\r\n      select.appendChild(option);\r\n    });\r\n\r\n    select.onchange = (e) => {\r\n      const target = e.target;\r\n      if (target && target instanceof HTMLSelectElement) {\r\n        target.dataset.templateIndex = target.value;\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nlet editor;\r\n\r\ntinymce_tinymce__WEBPACK_IMPORTED_MODULE_0___default().init({\r\n  selector: \"#editor\",\r\n  setup: (ed) => {\r\n    editor = ed;\r\n\r\n    document.getElementById(\"insertBtn\").addEventListener(\"click\", () => {\r\n      const dropdownHTML = createDropdownHTML(selectedTemplateIndex);\r\n      editor.insertContent(dropdownHTML);\r\n\r\n      setTimeout(() => {\r\n        updateAllDropdowns(editor);\r\n      }, 100);\r\n    });\r\n\r\n    ed.on(\"init\", () => updateAllDropdowns(editor));\r\n  },\r\n});\r\n\n\n//# sourceURL=webpack://test/./src/script.js?\n}");

/***/ }),

/***/ "./style.css":
/*!*******************!*\
  !*** ./style.css ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !./node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!./node_modules/css-loader/dist/cjs.js!./style.css */ \"./node_modules/css-loader/dist/cjs.js!./style.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://test/./style.css?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/script.js");
/******/ 	
/******/ })()
;